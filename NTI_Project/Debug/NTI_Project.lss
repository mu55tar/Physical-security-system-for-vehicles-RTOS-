
NTI_Project.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00009924  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000126  00800060  00009924  000099b8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000068c  00800186  00800186  00009ade  2**0
                  ALLOC
  3 .stab         0000c3fc  00000000  00000000  00009ae0  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000070cb  00000000  00000000  00015edc  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 000001c0  00000000  00000000  0001cfa7  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 0000020e  00000000  00000000  0001d167  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   0000268b  00000000  00000000  0001d375  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000014d1  00000000  00000000  0001fa00  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000012ab  00000000  00000000  00020ed1  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  000001e0  00000000  00000000  0002217c  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    000002fb  00000000  00000000  0002235c  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00000a0a  00000000  00000000  00022657  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000050  00000000  00000000  00023061  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 99 22 	jmp	0x4532	; 0x4532 <__vector_6>
      1c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 08 08 	jmp	0x1010	; 0x1010 <__vector_13>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 28 0d 	jmp	0x1a50	; 0x1a50 <__vector_16>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d4 e0       	ldi	r29, 0x04	; 4
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	11 e0       	ldi	r17, 0x01	; 1
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e4 e2       	ldi	r30, 0x24	; 36
      68:	f9 e9       	ldi	r31, 0x99	; 153
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a6 38       	cpi	r26, 0x86	; 134
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	18 e0       	ldi	r17, 0x08	; 8
      78:	a6 e8       	ldi	r26, 0x86	; 134
      7a:	b1 e0       	ldi	r27, 0x01	; 1
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a2 31       	cpi	r26, 0x12	; 18
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 52 4a 	call	0x94a4	; 0x94a4 <main>
      8a:	0c 94 90 4c 	jmp	0x9920	; 0x9920 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <__fixunssfsi>:
      92:	ef 92       	push	r14
      94:	ff 92       	push	r15
      96:	0f 93       	push	r16
      98:	1f 93       	push	r17
      9a:	7b 01       	movw	r14, r22
      9c:	8c 01       	movw	r16, r24
      9e:	20 e0       	ldi	r18, 0x00	; 0
      a0:	30 e0       	ldi	r19, 0x00	; 0
      a2:	40 e0       	ldi	r20, 0x00	; 0
      a4:	5f e4       	ldi	r21, 0x4F	; 79
      a6:	0e 94 25 04 	call	0x84a	; 0x84a <__gesf2>
      aa:	88 23       	and	r24, r24
      ac:	8c f0       	brlt	.+34     	; 0xd0 <__fixunssfsi+0x3e>
      ae:	c8 01       	movw	r24, r16
      b0:	b7 01       	movw	r22, r14
      b2:	20 e0       	ldi	r18, 0x00	; 0
      b4:	30 e0       	ldi	r19, 0x00	; 0
      b6:	40 e0       	ldi	r20, 0x00	; 0
      b8:	5f e4       	ldi	r21, 0x4F	; 79
      ba:	0e 94 c1 01 	call	0x382	; 0x382 <__subsf3>
      be:	0e 94 e3 04 	call	0x9c6	; 0x9c6 <__fixsfsi>
      c2:	9b 01       	movw	r18, r22
      c4:	ac 01       	movw	r20, r24
      c6:	20 50       	subi	r18, 0x00	; 0
      c8:	30 40       	sbci	r19, 0x00	; 0
      ca:	40 40       	sbci	r20, 0x00	; 0
      cc:	50 48       	sbci	r21, 0x80	; 128
      ce:	06 c0       	rjmp	.+12     	; 0xdc <__fixunssfsi+0x4a>
      d0:	c8 01       	movw	r24, r16
      d2:	b7 01       	movw	r22, r14
      d4:	0e 94 e3 04 	call	0x9c6	; 0x9c6 <__fixsfsi>
      d8:	9b 01       	movw	r18, r22
      da:	ac 01       	movw	r20, r24
      dc:	b9 01       	movw	r22, r18
      de:	ca 01       	movw	r24, r20
      e0:	1f 91       	pop	r17
      e2:	0f 91       	pop	r16
      e4:	ff 90       	pop	r15
      e6:	ef 90       	pop	r14
      e8:	08 95       	ret

000000ea <_fpadd_parts>:
      ea:	a0 e0       	ldi	r26, 0x00	; 0
      ec:	b0 e0       	ldi	r27, 0x00	; 0
      ee:	eb e7       	ldi	r30, 0x7B	; 123
      f0:	f0 e0       	ldi	r31, 0x00	; 0
      f2:	0c 94 49 4c 	jmp	0x9892	; 0x9892 <__prologue_saves__>
      f6:	dc 01       	movw	r26, r24
      f8:	2b 01       	movw	r4, r22
      fa:	fa 01       	movw	r30, r20
      fc:	9c 91       	ld	r25, X
      fe:	92 30       	cpi	r25, 0x02	; 2
     100:	08 f4       	brcc	.+2      	; 0x104 <_fpadd_parts+0x1a>
     102:	39 c1       	rjmp	.+626    	; 0x376 <_fpadd_parts+0x28c>
     104:	eb 01       	movw	r28, r22
     106:	88 81       	ld	r24, Y
     108:	82 30       	cpi	r24, 0x02	; 2
     10a:	08 f4       	brcc	.+2      	; 0x10e <_fpadd_parts+0x24>
     10c:	33 c1       	rjmp	.+614    	; 0x374 <_fpadd_parts+0x28a>
     10e:	94 30       	cpi	r25, 0x04	; 4
     110:	69 f4       	brne	.+26     	; 0x12c <_fpadd_parts+0x42>
     112:	84 30       	cpi	r24, 0x04	; 4
     114:	09 f0       	breq	.+2      	; 0x118 <_fpadd_parts+0x2e>
     116:	2f c1       	rjmp	.+606    	; 0x376 <_fpadd_parts+0x28c>
     118:	11 96       	adiw	r26, 0x01	; 1
     11a:	9c 91       	ld	r25, X
     11c:	11 97       	sbiw	r26, 0x01	; 1
     11e:	89 81       	ldd	r24, Y+1	; 0x01
     120:	98 17       	cp	r25, r24
     122:	09 f4       	brne	.+2      	; 0x126 <_fpadd_parts+0x3c>
     124:	28 c1       	rjmp	.+592    	; 0x376 <_fpadd_parts+0x28c>
     126:	ad e7       	ldi	r26, 0x7D	; 125
     128:	b0 e0       	ldi	r27, 0x00	; 0
     12a:	25 c1       	rjmp	.+586    	; 0x376 <_fpadd_parts+0x28c>
     12c:	84 30       	cpi	r24, 0x04	; 4
     12e:	09 f4       	brne	.+2      	; 0x132 <_fpadd_parts+0x48>
     130:	21 c1       	rjmp	.+578    	; 0x374 <_fpadd_parts+0x28a>
     132:	82 30       	cpi	r24, 0x02	; 2
     134:	a9 f4       	brne	.+42     	; 0x160 <_fpadd_parts+0x76>
     136:	92 30       	cpi	r25, 0x02	; 2
     138:	09 f0       	breq	.+2      	; 0x13c <_fpadd_parts+0x52>
     13a:	1d c1       	rjmp	.+570    	; 0x376 <_fpadd_parts+0x28c>
     13c:	9a 01       	movw	r18, r20
     13e:	ad 01       	movw	r20, r26
     140:	88 e0       	ldi	r24, 0x08	; 8
     142:	ea 01       	movw	r28, r20
     144:	09 90       	ld	r0, Y+
     146:	ae 01       	movw	r20, r28
     148:	e9 01       	movw	r28, r18
     14a:	09 92       	st	Y+, r0
     14c:	9e 01       	movw	r18, r28
     14e:	81 50       	subi	r24, 0x01	; 1
     150:	c1 f7       	brne	.-16     	; 0x142 <_fpadd_parts+0x58>
     152:	e2 01       	movw	r28, r4
     154:	89 81       	ldd	r24, Y+1	; 0x01
     156:	11 96       	adiw	r26, 0x01	; 1
     158:	9c 91       	ld	r25, X
     15a:	89 23       	and	r24, r25
     15c:	81 83       	std	Z+1, r24	; 0x01
     15e:	08 c1       	rjmp	.+528    	; 0x370 <_fpadd_parts+0x286>
     160:	92 30       	cpi	r25, 0x02	; 2
     162:	09 f4       	brne	.+2      	; 0x166 <_fpadd_parts+0x7c>
     164:	07 c1       	rjmp	.+526    	; 0x374 <_fpadd_parts+0x28a>
     166:	12 96       	adiw	r26, 0x02	; 2
     168:	2d 90       	ld	r2, X+
     16a:	3c 90       	ld	r3, X
     16c:	13 97       	sbiw	r26, 0x03	; 3
     16e:	eb 01       	movw	r28, r22
     170:	8a 81       	ldd	r24, Y+2	; 0x02
     172:	9b 81       	ldd	r25, Y+3	; 0x03
     174:	14 96       	adiw	r26, 0x04	; 4
     176:	ad 90       	ld	r10, X+
     178:	bd 90       	ld	r11, X+
     17a:	cd 90       	ld	r12, X+
     17c:	dc 90       	ld	r13, X
     17e:	17 97       	sbiw	r26, 0x07	; 7
     180:	ec 80       	ldd	r14, Y+4	; 0x04
     182:	fd 80       	ldd	r15, Y+5	; 0x05
     184:	0e 81       	ldd	r16, Y+6	; 0x06
     186:	1f 81       	ldd	r17, Y+7	; 0x07
     188:	91 01       	movw	r18, r2
     18a:	28 1b       	sub	r18, r24
     18c:	39 0b       	sbc	r19, r25
     18e:	b9 01       	movw	r22, r18
     190:	37 ff       	sbrs	r19, 7
     192:	04 c0       	rjmp	.+8      	; 0x19c <_fpadd_parts+0xb2>
     194:	66 27       	eor	r22, r22
     196:	77 27       	eor	r23, r23
     198:	62 1b       	sub	r22, r18
     19a:	73 0b       	sbc	r23, r19
     19c:	60 32       	cpi	r22, 0x20	; 32
     19e:	71 05       	cpc	r23, r1
     1a0:	0c f0       	brlt	.+2      	; 0x1a4 <_fpadd_parts+0xba>
     1a2:	61 c0       	rjmp	.+194    	; 0x266 <_fpadd_parts+0x17c>
     1a4:	12 16       	cp	r1, r18
     1a6:	13 06       	cpc	r1, r19
     1a8:	6c f5       	brge	.+90     	; 0x204 <_fpadd_parts+0x11a>
     1aa:	37 01       	movw	r6, r14
     1ac:	48 01       	movw	r8, r16
     1ae:	06 2e       	mov	r0, r22
     1b0:	04 c0       	rjmp	.+8      	; 0x1ba <_fpadd_parts+0xd0>
     1b2:	96 94       	lsr	r9
     1b4:	87 94       	ror	r8
     1b6:	77 94       	ror	r7
     1b8:	67 94       	ror	r6
     1ba:	0a 94       	dec	r0
     1bc:	d2 f7       	brpl	.-12     	; 0x1b2 <_fpadd_parts+0xc8>
     1be:	21 e0       	ldi	r18, 0x01	; 1
     1c0:	30 e0       	ldi	r19, 0x00	; 0
     1c2:	40 e0       	ldi	r20, 0x00	; 0
     1c4:	50 e0       	ldi	r21, 0x00	; 0
     1c6:	04 c0       	rjmp	.+8      	; 0x1d0 <_fpadd_parts+0xe6>
     1c8:	22 0f       	add	r18, r18
     1ca:	33 1f       	adc	r19, r19
     1cc:	44 1f       	adc	r20, r20
     1ce:	55 1f       	adc	r21, r21
     1d0:	6a 95       	dec	r22
     1d2:	d2 f7       	brpl	.-12     	; 0x1c8 <_fpadd_parts+0xde>
     1d4:	21 50       	subi	r18, 0x01	; 1
     1d6:	30 40       	sbci	r19, 0x00	; 0
     1d8:	40 40       	sbci	r20, 0x00	; 0
     1da:	50 40       	sbci	r21, 0x00	; 0
     1dc:	2e 21       	and	r18, r14
     1de:	3f 21       	and	r19, r15
     1e0:	40 23       	and	r20, r16
     1e2:	51 23       	and	r21, r17
     1e4:	21 15       	cp	r18, r1
     1e6:	31 05       	cpc	r19, r1
     1e8:	41 05       	cpc	r20, r1
     1ea:	51 05       	cpc	r21, r1
     1ec:	21 f0       	breq	.+8      	; 0x1f6 <_fpadd_parts+0x10c>
     1ee:	21 e0       	ldi	r18, 0x01	; 1
     1f0:	30 e0       	ldi	r19, 0x00	; 0
     1f2:	40 e0       	ldi	r20, 0x00	; 0
     1f4:	50 e0       	ldi	r21, 0x00	; 0
     1f6:	79 01       	movw	r14, r18
     1f8:	8a 01       	movw	r16, r20
     1fa:	e6 28       	or	r14, r6
     1fc:	f7 28       	or	r15, r7
     1fe:	08 29       	or	r16, r8
     200:	19 29       	or	r17, r9
     202:	3c c0       	rjmp	.+120    	; 0x27c <_fpadd_parts+0x192>
     204:	23 2b       	or	r18, r19
     206:	d1 f1       	breq	.+116    	; 0x27c <_fpadd_parts+0x192>
     208:	26 0e       	add	r2, r22
     20a:	37 1e       	adc	r3, r23
     20c:	35 01       	movw	r6, r10
     20e:	46 01       	movw	r8, r12
     210:	06 2e       	mov	r0, r22
     212:	04 c0       	rjmp	.+8      	; 0x21c <_fpadd_parts+0x132>
     214:	96 94       	lsr	r9
     216:	87 94       	ror	r8
     218:	77 94       	ror	r7
     21a:	67 94       	ror	r6
     21c:	0a 94       	dec	r0
     21e:	d2 f7       	brpl	.-12     	; 0x214 <_fpadd_parts+0x12a>
     220:	21 e0       	ldi	r18, 0x01	; 1
     222:	30 e0       	ldi	r19, 0x00	; 0
     224:	40 e0       	ldi	r20, 0x00	; 0
     226:	50 e0       	ldi	r21, 0x00	; 0
     228:	04 c0       	rjmp	.+8      	; 0x232 <_fpadd_parts+0x148>
     22a:	22 0f       	add	r18, r18
     22c:	33 1f       	adc	r19, r19
     22e:	44 1f       	adc	r20, r20
     230:	55 1f       	adc	r21, r21
     232:	6a 95       	dec	r22
     234:	d2 f7       	brpl	.-12     	; 0x22a <_fpadd_parts+0x140>
     236:	21 50       	subi	r18, 0x01	; 1
     238:	30 40       	sbci	r19, 0x00	; 0
     23a:	40 40       	sbci	r20, 0x00	; 0
     23c:	50 40       	sbci	r21, 0x00	; 0
     23e:	2a 21       	and	r18, r10
     240:	3b 21       	and	r19, r11
     242:	4c 21       	and	r20, r12
     244:	5d 21       	and	r21, r13
     246:	21 15       	cp	r18, r1
     248:	31 05       	cpc	r19, r1
     24a:	41 05       	cpc	r20, r1
     24c:	51 05       	cpc	r21, r1
     24e:	21 f0       	breq	.+8      	; 0x258 <_fpadd_parts+0x16e>
     250:	21 e0       	ldi	r18, 0x01	; 1
     252:	30 e0       	ldi	r19, 0x00	; 0
     254:	40 e0       	ldi	r20, 0x00	; 0
     256:	50 e0       	ldi	r21, 0x00	; 0
     258:	59 01       	movw	r10, r18
     25a:	6a 01       	movw	r12, r20
     25c:	a6 28       	or	r10, r6
     25e:	b7 28       	or	r11, r7
     260:	c8 28       	or	r12, r8
     262:	d9 28       	or	r13, r9
     264:	0b c0       	rjmp	.+22     	; 0x27c <_fpadd_parts+0x192>
     266:	82 15       	cp	r24, r2
     268:	93 05       	cpc	r25, r3
     26a:	2c f0       	brlt	.+10     	; 0x276 <_fpadd_parts+0x18c>
     26c:	1c 01       	movw	r2, r24
     26e:	aa 24       	eor	r10, r10
     270:	bb 24       	eor	r11, r11
     272:	65 01       	movw	r12, r10
     274:	03 c0       	rjmp	.+6      	; 0x27c <_fpadd_parts+0x192>
     276:	ee 24       	eor	r14, r14
     278:	ff 24       	eor	r15, r15
     27a:	87 01       	movw	r16, r14
     27c:	11 96       	adiw	r26, 0x01	; 1
     27e:	9c 91       	ld	r25, X
     280:	d2 01       	movw	r26, r4
     282:	11 96       	adiw	r26, 0x01	; 1
     284:	8c 91       	ld	r24, X
     286:	98 17       	cp	r25, r24
     288:	09 f4       	brne	.+2      	; 0x28c <_fpadd_parts+0x1a2>
     28a:	45 c0       	rjmp	.+138    	; 0x316 <_fpadd_parts+0x22c>
     28c:	99 23       	and	r25, r25
     28e:	39 f0       	breq	.+14     	; 0x29e <_fpadd_parts+0x1b4>
     290:	a8 01       	movw	r20, r16
     292:	97 01       	movw	r18, r14
     294:	2a 19       	sub	r18, r10
     296:	3b 09       	sbc	r19, r11
     298:	4c 09       	sbc	r20, r12
     29a:	5d 09       	sbc	r21, r13
     29c:	06 c0       	rjmp	.+12     	; 0x2aa <_fpadd_parts+0x1c0>
     29e:	a6 01       	movw	r20, r12
     2a0:	95 01       	movw	r18, r10
     2a2:	2e 19       	sub	r18, r14
     2a4:	3f 09       	sbc	r19, r15
     2a6:	40 0b       	sbc	r20, r16
     2a8:	51 0b       	sbc	r21, r17
     2aa:	57 fd       	sbrc	r21, 7
     2ac:	08 c0       	rjmp	.+16     	; 0x2be <_fpadd_parts+0x1d4>
     2ae:	11 82       	std	Z+1, r1	; 0x01
     2b0:	33 82       	std	Z+3, r3	; 0x03
     2b2:	22 82       	std	Z+2, r2	; 0x02
     2b4:	24 83       	std	Z+4, r18	; 0x04
     2b6:	35 83       	std	Z+5, r19	; 0x05
     2b8:	46 83       	std	Z+6, r20	; 0x06
     2ba:	57 83       	std	Z+7, r21	; 0x07
     2bc:	1d c0       	rjmp	.+58     	; 0x2f8 <_fpadd_parts+0x20e>
     2be:	81 e0       	ldi	r24, 0x01	; 1
     2c0:	81 83       	std	Z+1, r24	; 0x01
     2c2:	33 82       	std	Z+3, r3	; 0x03
     2c4:	22 82       	std	Z+2, r2	; 0x02
     2c6:	88 27       	eor	r24, r24
     2c8:	99 27       	eor	r25, r25
     2ca:	dc 01       	movw	r26, r24
     2cc:	82 1b       	sub	r24, r18
     2ce:	93 0b       	sbc	r25, r19
     2d0:	a4 0b       	sbc	r26, r20
     2d2:	b5 0b       	sbc	r27, r21
     2d4:	84 83       	std	Z+4, r24	; 0x04
     2d6:	95 83       	std	Z+5, r25	; 0x05
     2d8:	a6 83       	std	Z+6, r26	; 0x06
     2da:	b7 83       	std	Z+7, r27	; 0x07
     2dc:	0d c0       	rjmp	.+26     	; 0x2f8 <_fpadd_parts+0x20e>
     2de:	22 0f       	add	r18, r18
     2e0:	33 1f       	adc	r19, r19
     2e2:	44 1f       	adc	r20, r20
     2e4:	55 1f       	adc	r21, r21
     2e6:	24 83       	std	Z+4, r18	; 0x04
     2e8:	35 83       	std	Z+5, r19	; 0x05
     2ea:	46 83       	std	Z+6, r20	; 0x06
     2ec:	57 83       	std	Z+7, r21	; 0x07
     2ee:	82 81       	ldd	r24, Z+2	; 0x02
     2f0:	93 81       	ldd	r25, Z+3	; 0x03
     2f2:	01 97       	sbiw	r24, 0x01	; 1
     2f4:	93 83       	std	Z+3, r25	; 0x03
     2f6:	82 83       	std	Z+2, r24	; 0x02
     2f8:	24 81       	ldd	r18, Z+4	; 0x04
     2fa:	35 81       	ldd	r19, Z+5	; 0x05
     2fc:	46 81       	ldd	r20, Z+6	; 0x06
     2fe:	57 81       	ldd	r21, Z+7	; 0x07
     300:	da 01       	movw	r26, r20
     302:	c9 01       	movw	r24, r18
     304:	01 97       	sbiw	r24, 0x01	; 1
     306:	a1 09       	sbc	r26, r1
     308:	b1 09       	sbc	r27, r1
     30a:	8f 5f       	subi	r24, 0xFF	; 255
     30c:	9f 4f       	sbci	r25, 0xFF	; 255
     30e:	af 4f       	sbci	r26, 0xFF	; 255
     310:	bf 43       	sbci	r27, 0x3F	; 63
     312:	28 f3       	brcs	.-54     	; 0x2de <_fpadd_parts+0x1f4>
     314:	0b c0       	rjmp	.+22     	; 0x32c <_fpadd_parts+0x242>
     316:	91 83       	std	Z+1, r25	; 0x01
     318:	33 82       	std	Z+3, r3	; 0x03
     31a:	22 82       	std	Z+2, r2	; 0x02
     31c:	ea 0c       	add	r14, r10
     31e:	fb 1c       	adc	r15, r11
     320:	0c 1d       	adc	r16, r12
     322:	1d 1d       	adc	r17, r13
     324:	e4 82       	std	Z+4, r14	; 0x04
     326:	f5 82       	std	Z+5, r15	; 0x05
     328:	06 83       	std	Z+6, r16	; 0x06
     32a:	17 83       	std	Z+7, r17	; 0x07
     32c:	83 e0       	ldi	r24, 0x03	; 3
     32e:	80 83       	st	Z, r24
     330:	24 81       	ldd	r18, Z+4	; 0x04
     332:	35 81       	ldd	r19, Z+5	; 0x05
     334:	46 81       	ldd	r20, Z+6	; 0x06
     336:	57 81       	ldd	r21, Z+7	; 0x07
     338:	57 ff       	sbrs	r21, 7
     33a:	1a c0       	rjmp	.+52     	; 0x370 <_fpadd_parts+0x286>
     33c:	c9 01       	movw	r24, r18
     33e:	aa 27       	eor	r26, r26
     340:	97 fd       	sbrc	r25, 7
     342:	a0 95       	com	r26
     344:	ba 2f       	mov	r27, r26
     346:	81 70       	andi	r24, 0x01	; 1
     348:	90 70       	andi	r25, 0x00	; 0
     34a:	a0 70       	andi	r26, 0x00	; 0
     34c:	b0 70       	andi	r27, 0x00	; 0
     34e:	56 95       	lsr	r21
     350:	47 95       	ror	r20
     352:	37 95       	ror	r19
     354:	27 95       	ror	r18
     356:	82 2b       	or	r24, r18
     358:	93 2b       	or	r25, r19
     35a:	a4 2b       	or	r26, r20
     35c:	b5 2b       	or	r27, r21
     35e:	84 83       	std	Z+4, r24	; 0x04
     360:	95 83       	std	Z+5, r25	; 0x05
     362:	a6 83       	std	Z+6, r26	; 0x06
     364:	b7 83       	std	Z+7, r27	; 0x07
     366:	82 81       	ldd	r24, Z+2	; 0x02
     368:	93 81       	ldd	r25, Z+3	; 0x03
     36a:	01 96       	adiw	r24, 0x01	; 1
     36c:	93 83       	std	Z+3, r25	; 0x03
     36e:	82 83       	std	Z+2, r24	; 0x02
     370:	df 01       	movw	r26, r30
     372:	01 c0       	rjmp	.+2      	; 0x376 <_fpadd_parts+0x28c>
     374:	d2 01       	movw	r26, r4
     376:	cd 01       	movw	r24, r26
     378:	cd b7       	in	r28, 0x3d	; 61
     37a:	de b7       	in	r29, 0x3e	; 62
     37c:	e2 e1       	ldi	r30, 0x12	; 18
     37e:	0c 94 65 4c 	jmp	0x98ca	; 0x98ca <__epilogue_restores__>

00000382 <__subsf3>:
     382:	a0 e2       	ldi	r26, 0x20	; 32
     384:	b0 e0       	ldi	r27, 0x00	; 0
     386:	e7 ec       	ldi	r30, 0xC7	; 199
     388:	f1 e0       	ldi	r31, 0x01	; 1
     38a:	0c 94 55 4c 	jmp	0x98aa	; 0x98aa <__prologue_saves__+0x18>
     38e:	69 83       	std	Y+1, r22	; 0x01
     390:	7a 83       	std	Y+2, r23	; 0x02
     392:	8b 83       	std	Y+3, r24	; 0x03
     394:	9c 83       	std	Y+4, r25	; 0x04
     396:	2d 83       	std	Y+5, r18	; 0x05
     398:	3e 83       	std	Y+6, r19	; 0x06
     39a:	4f 83       	std	Y+7, r20	; 0x07
     39c:	58 87       	std	Y+8, r21	; 0x08
     39e:	e9 e0       	ldi	r30, 0x09	; 9
     3a0:	ee 2e       	mov	r14, r30
     3a2:	f1 2c       	mov	r15, r1
     3a4:	ec 0e       	add	r14, r28
     3a6:	fd 1e       	adc	r15, r29
     3a8:	ce 01       	movw	r24, r28
     3aa:	01 96       	adiw	r24, 0x01	; 1
     3ac:	b7 01       	movw	r22, r14
     3ae:	0e 94 5b 06 	call	0xcb6	; 0xcb6 <__unpack_f>
     3b2:	8e 01       	movw	r16, r28
     3b4:	0f 5e       	subi	r16, 0xEF	; 239
     3b6:	1f 4f       	sbci	r17, 0xFF	; 255
     3b8:	ce 01       	movw	r24, r28
     3ba:	05 96       	adiw	r24, 0x05	; 5
     3bc:	b8 01       	movw	r22, r16
     3be:	0e 94 5b 06 	call	0xcb6	; 0xcb6 <__unpack_f>
     3c2:	8a 89       	ldd	r24, Y+18	; 0x12
     3c4:	91 e0       	ldi	r25, 0x01	; 1
     3c6:	89 27       	eor	r24, r25
     3c8:	8a 8b       	std	Y+18, r24	; 0x12
     3ca:	c7 01       	movw	r24, r14
     3cc:	b8 01       	movw	r22, r16
     3ce:	ae 01       	movw	r20, r28
     3d0:	47 5e       	subi	r20, 0xE7	; 231
     3d2:	5f 4f       	sbci	r21, 0xFF	; 255
     3d4:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     3d8:	0e 94 86 05 	call	0xb0c	; 0xb0c <__pack_f>
     3dc:	a0 96       	adiw	r28, 0x20	; 32
     3de:	e6 e0       	ldi	r30, 0x06	; 6
     3e0:	0c 94 71 4c 	jmp	0x98e2	; 0x98e2 <__epilogue_restores__+0x18>

000003e4 <__addsf3>:
     3e4:	a0 e2       	ldi	r26, 0x20	; 32
     3e6:	b0 e0       	ldi	r27, 0x00	; 0
     3e8:	e8 ef       	ldi	r30, 0xF8	; 248
     3ea:	f1 e0       	ldi	r31, 0x01	; 1
     3ec:	0c 94 55 4c 	jmp	0x98aa	; 0x98aa <__prologue_saves__+0x18>
     3f0:	69 83       	std	Y+1, r22	; 0x01
     3f2:	7a 83       	std	Y+2, r23	; 0x02
     3f4:	8b 83       	std	Y+3, r24	; 0x03
     3f6:	9c 83       	std	Y+4, r25	; 0x04
     3f8:	2d 83       	std	Y+5, r18	; 0x05
     3fa:	3e 83       	std	Y+6, r19	; 0x06
     3fc:	4f 83       	std	Y+7, r20	; 0x07
     3fe:	58 87       	std	Y+8, r21	; 0x08
     400:	f9 e0       	ldi	r31, 0x09	; 9
     402:	ef 2e       	mov	r14, r31
     404:	f1 2c       	mov	r15, r1
     406:	ec 0e       	add	r14, r28
     408:	fd 1e       	adc	r15, r29
     40a:	ce 01       	movw	r24, r28
     40c:	01 96       	adiw	r24, 0x01	; 1
     40e:	b7 01       	movw	r22, r14
     410:	0e 94 5b 06 	call	0xcb6	; 0xcb6 <__unpack_f>
     414:	8e 01       	movw	r16, r28
     416:	0f 5e       	subi	r16, 0xEF	; 239
     418:	1f 4f       	sbci	r17, 0xFF	; 255
     41a:	ce 01       	movw	r24, r28
     41c:	05 96       	adiw	r24, 0x05	; 5
     41e:	b8 01       	movw	r22, r16
     420:	0e 94 5b 06 	call	0xcb6	; 0xcb6 <__unpack_f>
     424:	c7 01       	movw	r24, r14
     426:	b8 01       	movw	r22, r16
     428:	ae 01       	movw	r20, r28
     42a:	47 5e       	subi	r20, 0xE7	; 231
     42c:	5f 4f       	sbci	r21, 0xFF	; 255
     42e:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     432:	0e 94 86 05 	call	0xb0c	; 0xb0c <__pack_f>
     436:	a0 96       	adiw	r28, 0x20	; 32
     438:	e6 e0       	ldi	r30, 0x06	; 6
     43a:	0c 94 71 4c 	jmp	0x98e2	; 0x98e2 <__epilogue_restores__+0x18>

0000043e <__mulsf3>:
     43e:	a0 e2       	ldi	r26, 0x20	; 32
     440:	b0 e0       	ldi	r27, 0x00	; 0
     442:	e5 e2       	ldi	r30, 0x25	; 37
     444:	f2 e0       	ldi	r31, 0x02	; 2
     446:	0c 94 49 4c 	jmp	0x9892	; 0x9892 <__prologue_saves__>
     44a:	69 83       	std	Y+1, r22	; 0x01
     44c:	7a 83       	std	Y+2, r23	; 0x02
     44e:	8b 83       	std	Y+3, r24	; 0x03
     450:	9c 83       	std	Y+4, r25	; 0x04
     452:	2d 83       	std	Y+5, r18	; 0x05
     454:	3e 83       	std	Y+6, r19	; 0x06
     456:	4f 83       	std	Y+7, r20	; 0x07
     458:	58 87       	std	Y+8, r21	; 0x08
     45a:	ce 01       	movw	r24, r28
     45c:	01 96       	adiw	r24, 0x01	; 1
     45e:	be 01       	movw	r22, r28
     460:	67 5f       	subi	r22, 0xF7	; 247
     462:	7f 4f       	sbci	r23, 0xFF	; 255
     464:	0e 94 5b 06 	call	0xcb6	; 0xcb6 <__unpack_f>
     468:	ce 01       	movw	r24, r28
     46a:	05 96       	adiw	r24, 0x05	; 5
     46c:	be 01       	movw	r22, r28
     46e:	6f 5e       	subi	r22, 0xEF	; 239
     470:	7f 4f       	sbci	r23, 0xFF	; 255
     472:	0e 94 5b 06 	call	0xcb6	; 0xcb6 <__unpack_f>
     476:	99 85       	ldd	r25, Y+9	; 0x09
     478:	92 30       	cpi	r25, 0x02	; 2
     47a:	88 f0       	brcs	.+34     	; 0x49e <__stack+0x3f>
     47c:	89 89       	ldd	r24, Y+17	; 0x11
     47e:	82 30       	cpi	r24, 0x02	; 2
     480:	c8 f0       	brcs	.+50     	; 0x4b4 <__stack+0x55>
     482:	94 30       	cpi	r25, 0x04	; 4
     484:	19 f4       	brne	.+6      	; 0x48c <__stack+0x2d>
     486:	82 30       	cpi	r24, 0x02	; 2
     488:	51 f4       	brne	.+20     	; 0x49e <__stack+0x3f>
     48a:	04 c0       	rjmp	.+8      	; 0x494 <__stack+0x35>
     48c:	84 30       	cpi	r24, 0x04	; 4
     48e:	29 f4       	brne	.+10     	; 0x49a <__stack+0x3b>
     490:	92 30       	cpi	r25, 0x02	; 2
     492:	81 f4       	brne	.+32     	; 0x4b4 <__stack+0x55>
     494:	8d e7       	ldi	r24, 0x7D	; 125
     496:	90 e0       	ldi	r25, 0x00	; 0
     498:	c6 c0       	rjmp	.+396    	; 0x626 <__stack+0x1c7>
     49a:	92 30       	cpi	r25, 0x02	; 2
     49c:	49 f4       	brne	.+18     	; 0x4b0 <__stack+0x51>
     49e:	20 e0       	ldi	r18, 0x00	; 0
     4a0:	9a 85       	ldd	r25, Y+10	; 0x0a
     4a2:	8a 89       	ldd	r24, Y+18	; 0x12
     4a4:	98 13       	cpse	r25, r24
     4a6:	21 e0       	ldi	r18, 0x01	; 1
     4a8:	2a 87       	std	Y+10, r18	; 0x0a
     4aa:	ce 01       	movw	r24, r28
     4ac:	09 96       	adiw	r24, 0x09	; 9
     4ae:	bb c0       	rjmp	.+374    	; 0x626 <__stack+0x1c7>
     4b0:	82 30       	cpi	r24, 0x02	; 2
     4b2:	49 f4       	brne	.+18     	; 0x4c6 <__stack+0x67>
     4b4:	20 e0       	ldi	r18, 0x00	; 0
     4b6:	9a 85       	ldd	r25, Y+10	; 0x0a
     4b8:	8a 89       	ldd	r24, Y+18	; 0x12
     4ba:	98 13       	cpse	r25, r24
     4bc:	21 e0       	ldi	r18, 0x01	; 1
     4be:	2a 8b       	std	Y+18, r18	; 0x12
     4c0:	ce 01       	movw	r24, r28
     4c2:	41 96       	adiw	r24, 0x11	; 17
     4c4:	b0 c0       	rjmp	.+352    	; 0x626 <__stack+0x1c7>
     4c6:	2d 84       	ldd	r2, Y+13	; 0x0d
     4c8:	3e 84       	ldd	r3, Y+14	; 0x0e
     4ca:	4f 84       	ldd	r4, Y+15	; 0x0f
     4cc:	58 88       	ldd	r5, Y+16	; 0x10
     4ce:	6d 88       	ldd	r6, Y+21	; 0x15
     4d0:	7e 88       	ldd	r7, Y+22	; 0x16
     4d2:	8f 88       	ldd	r8, Y+23	; 0x17
     4d4:	98 8c       	ldd	r9, Y+24	; 0x18
     4d6:	ee 24       	eor	r14, r14
     4d8:	ff 24       	eor	r15, r15
     4da:	87 01       	movw	r16, r14
     4dc:	aa 24       	eor	r10, r10
     4de:	bb 24       	eor	r11, r11
     4e0:	65 01       	movw	r12, r10
     4e2:	40 e0       	ldi	r20, 0x00	; 0
     4e4:	50 e0       	ldi	r21, 0x00	; 0
     4e6:	60 e0       	ldi	r22, 0x00	; 0
     4e8:	70 e0       	ldi	r23, 0x00	; 0
     4ea:	e0 e0       	ldi	r30, 0x00	; 0
     4ec:	f0 e0       	ldi	r31, 0x00	; 0
     4ee:	c1 01       	movw	r24, r2
     4f0:	81 70       	andi	r24, 0x01	; 1
     4f2:	90 70       	andi	r25, 0x00	; 0
     4f4:	89 2b       	or	r24, r25
     4f6:	e9 f0       	breq	.+58     	; 0x532 <__stack+0xd3>
     4f8:	e6 0c       	add	r14, r6
     4fa:	f7 1c       	adc	r15, r7
     4fc:	08 1d       	adc	r16, r8
     4fe:	19 1d       	adc	r17, r9
     500:	9a 01       	movw	r18, r20
     502:	ab 01       	movw	r20, r22
     504:	2a 0d       	add	r18, r10
     506:	3b 1d       	adc	r19, r11
     508:	4c 1d       	adc	r20, r12
     50a:	5d 1d       	adc	r21, r13
     50c:	80 e0       	ldi	r24, 0x00	; 0
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	a0 e0       	ldi	r26, 0x00	; 0
     512:	b0 e0       	ldi	r27, 0x00	; 0
     514:	e6 14       	cp	r14, r6
     516:	f7 04       	cpc	r15, r7
     518:	08 05       	cpc	r16, r8
     51a:	19 05       	cpc	r17, r9
     51c:	20 f4       	brcc	.+8      	; 0x526 <__stack+0xc7>
     51e:	81 e0       	ldi	r24, 0x01	; 1
     520:	90 e0       	ldi	r25, 0x00	; 0
     522:	a0 e0       	ldi	r26, 0x00	; 0
     524:	b0 e0       	ldi	r27, 0x00	; 0
     526:	ba 01       	movw	r22, r20
     528:	a9 01       	movw	r20, r18
     52a:	48 0f       	add	r20, r24
     52c:	59 1f       	adc	r21, r25
     52e:	6a 1f       	adc	r22, r26
     530:	7b 1f       	adc	r23, r27
     532:	aa 0c       	add	r10, r10
     534:	bb 1c       	adc	r11, r11
     536:	cc 1c       	adc	r12, r12
     538:	dd 1c       	adc	r13, r13
     53a:	97 fe       	sbrs	r9, 7
     53c:	08 c0       	rjmp	.+16     	; 0x54e <__stack+0xef>
     53e:	81 e0       	ldi	r24, 0x01	; 1
     540:	90 e0       	ldi	r25, 0x00	; 0
     542:	a0 e0       	ldi	r26, 0x00	; 0
     544:	b0 e0       	ldi	r27, 0x00	; 0
     546:	a8 2a       	or	r10, r24
     548:	b9 2a       	or	r11, r25
     54a:	ca 2a       	or	r12, r26
     54c:	db 2a       	or	r13, r27
     54e:	31 96       	adiw	r30, 0x01	; 1
     550:	e0 32       	cpi	r30, 0x20	; 32
     552:	f1 05       	cpc	r31, r1
     554:	49 f0       	breq	.+18     	; 0x568 <__stack+0x109>
     556:	66 0c       	add	r6, r6
     558:	77 1c       	adc	r7, r7
     55a:	88 1c       	adc	r8, r8
     55c:	99 1c       	adc	r9, r9
     55e:	56 94       	lsr	r5
     560:	47 94       	ror	r4
     562:	37 94       	ror	r3
     564:	27 94       	ror	r2
     566:	c3 cf       	rjmp	.-122    	; 0x4ee <__stack+0x8f>
     568:	fa 85       	ldd	r31, Y+10	; 0x0a
     56a:	ea 89       	ldd	r30, Y+18	; 0x12
     56c:	2b 89       	ldd	r18, Y+19	; 0x13
     56e:	3c 89       	ldd	r19, Y+20	; 0x14
     570:	8b 85       	ldd	r24, Y+11	; 0x0b
     572:	9c 85       	ldd	r25, Y+12	; 0x0c
     574:	28 0f       	add	r18, r24
     576:	39 1f       	adc	r19, r25
     578:	2e 5f       	subi	r18, 0xFE	; 254
     57a:	3f 4f       	sbci	r19, 0xFF	; 255
     57c:	17 c0       	rjmp	.+46     	; 0x5ac <__stack+0x14d>
     57e:	ca 01       	movw	r24, r20
     580:	81 70       	andi	r24, 0x01	; 1
     582:	90 70       	andi	r25, 0x00	; 0
     584:	89 2b       	or	r24, r25
     586:	61 f0       	breq	.+24     	; 0x5a0 <__stack+0x141>
     588:	16 95       	lsr	r17
     58a:	07 95       	ror	r16
     58c:	f7 94       	ror	r15
     58e:	e7 94       	ror	r14
     590:	80 e0       	ldi	r24, 0x00	; 0
     592:	90 e0       	ldi	r25, 0x00	; 0
     594:	a0 e0       	ldi	r26, 0x00	; 0
     596:	b0 e8       	ldi	r27, 0x80	; 128
     598:	e8 2a       	or	r14, r24
     59a:	f9 2a       	or	r15, r25
     59c:	0a 2b       	or	r16, r26
     59e:	1b 2b       	or	r17, r27
     5a0:	76 95       	lsr	r23
     5a2:	67 95       	ror	r22
     5a4:	57 95       	ror	r21
     5a6:	47 95       	ror	r20
     5a8:	2f 5f       	subi	r18, 0xFF	; 255
     5aa:	3f 4f       	sbci	r19, 0xFF	; 255
     5ac:	77 fd       	sbrc	r23, 7
     5ae:	e7 cf       	rjmp	.-50     	; 0x57e <__stack+0x11f>
     5b0:	0c c0       	rjmp	.+24     	; 0x5ca <__stack+0x16b>
     5b2:	44 0f       	add	r20, r20
     5b4:	55 1f       	adc	r21, r21
     5b6:	66 1f       	adc	r22, r22
     5b8:	77 1f       	adc	r23, r23
     5ba:	17 fd       	sbrc	r17, 7
     5bc:	41 60       	ori	r20, 0x01	; 1
     5be:	ee 0c       	add	r14, r14
     5c0:	ff 1c       	adc	r15, r15
     5c2:	00 1f       	adc	r16, r16
     5c4:	11 1f       	adc	r17, r17
     5c6:	21 50       	subi	r18, 0x01	; 1
     5c8:	30 40       	sbci	r19, 0x00	; 0
     5ca:	40 30       	cpi	r20, 0x00	; 0
     5cc:	90 e0       	ldi	r25, 0x00	; 0
     5ce:	59 07       	cpc	r21, r25
     5d0:	90 e0       	ldi	r25, 0x00	; 0
     5d2:	69 07       	cpc	r22, r25
     5d4:	90 e4       	ldi	r25, 0x40	; 64
     5d6:	79 07       	cpc	r23, r25
     5d8:	60 f3       	brcs	.-40     	; 0x5b2 <__stack+0x153>
     5da:	2b 8f       	std	Y+27, r18	; 0x1b
     5dc:	3c 8f       	std	Y+28, r19	; 0x1c
     5de:	db 01       	movw	r26, r22
     5e0:	ca 01       	movw	r24, r20
     5e2:	8f 77       	andi	r24, 0x7F	; 127
     5e4:	90 70       	andi	r25, 0x00	; 0
     5e6:	a0 70       	andi	r26, 0x00	; 0
     5e8:	b0 70       	andi	r27, 0x00	; 0
     5ea:	80 34       	cpi	r24, 0x40	; 64
     5ec:	91 05       	cpc	r25, r1
     5ee:	a1 05       	cpc	r26, r1
     5f0:	b1 05       	cpc	r27, r1
     5f2:	61 f4       	brne	.+24     	; 0x60c <__stack+0x1ad>
     5f4:	47 fd       	sbrc	r20, 7
     5f6:	0a c0       	rjmp	.+20     	; 0x60c <__stack+0x1ad>
     5f8:	e1 14       	cp	r14, r1
     5fa:	f1 04       	cpc	r15, r1
     5fc:	01 05       	cpc	r16, r1
     5fe:	11 05       	cpc	r17, r1
     600:	29 f0       	breq	.+10     	; 0x60c <__stack+0x1ad>
     602:	40 5c       	subi	r20, 0xC0	; 192
     604:	5f 4f       	sbci	r21, 0xFF	; 255
     606:	6f 4f       	sbci	r22, 0xFF	; 255
     608:	7f 4f       	sbci	r23, 0xFF	; 255
     60a:	40 78       	andi	r20, 0x80	; 128
     60c:	1a 8e       	std	Y+26, r1	; 0x1a
     60e:	fe 17       	cp	r31, r30
     610:	11 f0       	breq	.+4      	; 0x616 <__stack+0x1b7>
     612:	81 e0       	ldi	r24, 0x01	; 1
     614:	8a 8f       	std	Y+26, r24	; 0x1a
     616:	4d 8f       	std	Y+29, r20	; 0x1d
     618:	5e 8f       	std	Y+30, r21	; 0x1e
     61a:	6f 8f       	std	Y+31, r22	; 0x1f
     61c:	78 a3       	std	Y+32, r23	; 0x20
     61e:	83 e0       	ldi	r24, 0x03	; 3
     620:	89 8f       	std	Y+25, r24	; 0x19
     622:	ce 01       	movw	r24, r28
     624:	49 96       	adiw	r24, 0x19	; 25
     626:	0e 94 86 05 	call	0xb0c	; 0xb0c <__pack_f>
     62a:	a0 96       	adiw	r28, 0x20	; 32
     62c:	e2 e1       	ldi	r30, 0x12	; 18
     62e:	0c 94 65 4c 	jmp	0x98ca	; 0x98ca <__epilogue_restores__>

00000632 <__divsf3>:
     632:	a8 e1       	ldi	r26, 0x18	; 24
     634:	b0 e0       	ldi	r27, 0x00	; 0
     636:	ef e1       	ldi	r30, 0x1F	; 31
     638:	f3 e0       	ldi	r31, 0x03	; 3
     63a:	0c 94 51 4c 	jmp	0x98a2	; 0x98a2 <__prologue_saves__+0x10>
     63e:	69 83       	std	Y+1, r22	; 0x01
     640:	7a 83       	std	Y+2, r23	; 0x02
     642:	8b 83       	std	Y+3, r24	; 0x03
     644:	9c 83       	std	Y+4, r25	; 0x04
     646:	2d 83       	std	Y+5, r18	; 0x05
     648:	3e 83       	std	Y+6, r19	; 0x06
     64a:	4f 83       	std	Y+7, r20	; 0x07
     64c:	58 87       	std	Y+8, r21	; 0x08
     64e:	b9 e0       	ldi	r27, 0x09	; 9
     650:	eb 2e       	mov	r14, r27
     652:	f1 2c       	mov	r15, r1
     654:	ec 0e       	add	r14, r28
     656:	fd 1e       	adc	r15, r29
     658:	ce 01       	movw	r24, r28
     65a:	01 96       	adiw	r24, 0x01	; 1
     65c:	b7 01       	movw	r22, r14
     65e:	0e 94 5b 06 	call	0xcb6	; 0xcb6 <__unpack_f>
     662:	8e 01       	movw	r16, r28
     664:	0f 5e       	subi	r16, 0xEF	; 239
     666:	1f 4f       	sbci	r17, 0xFF	; 255
     668:	ce 01       	movw	r24, r28
     66a:	05 96       	adiw	r24, 0x05	; 5
     66c:	b8 01       	movw	r22, r16
     66e:	0e 94 5b 06 	call	0xcb6	; 0xcb6 <__unpack_f>
     672:	29 85       	ldd	r18, Y+9	; 0x09
     674:	22 30       	cpi	r18, 0x02	; 2
     676:	08 f4       	brcc	.+2      	; 0x67a <__divsf3+0x48>
     678:	7e c0       	rjmp	.+252    	; 0x776 <__divsf3+0x144>
     67a:	39 89       	ldd	r19, Y+17	; 0x11
     67c:	32 30       	cpi	r19, 0x02	; 2
     67e:	10 f4       	brcc	.+4      	; 0x684 <__divsf3+0x52>
     680:	b8 01       	movw	r22, r16
     682:	7c c0       	rjmp	.+248    	; 0x77c <__divsf3+0x14a>
     684:	8a 85       	ldd	r24, Y+10	; 0x0a
     686:	9a 89       	ldd	r25, Y+18	; 0x12
     688:	89 27       	eor	r24, r25
     68a:	8a 87       	std	Y+10, r24	; 0x0a
     68c:	24 30       	cpi	r18, 0x04	; 4
     68e:	11 f0       	breq	.+4      	; 0x694 <__divsf3+0x62>
     690:	22 30       	cpi	r18, 0x02	; 2
     692:	31 f4       	brne	.+12     	; 0x6a0 <__divsf3+0x6e>
     694:	23 17       	cp	r18, r19
     696:	09 f0       	breq	.+2      	; 0x69a <__divsf3+0x68>
     698:	6e c0       	rjmp	.+220    	; 0x776 <__divsf3+0x144>
     69a:	6d e7       	ldi	r22, 0x7D	; 125
     69c:	70 e0       	ldi	r23, 0x00	; 0
     69e:	6e c0       	rjmp	.+220    	; 0x77c <__divsf3+0x14a>
     6a0:	34 30       	cpi	r19, 0x04	; 4
     6a2:	39 f4       	brne	.+14     	; 0x6b2 <__divsf3+0x80>
     6a4:	1d 86       	std	Y+13, r1	; 0x0d
     6a6:	1e 86       	std	Y+14, r1	; 0x0e
     6a8:	1f 86       	std	Y+15, r1	; 0x0f
     6aa:	18 8a       	std	Y+16, r1	; 0x10
     6ac:	1c 86       	std	Y+12, r1	; 0x0c
     6ae:	1b 86       	std	Y+11, r1	; 0x0b
     6b0:	04 c0       	rjmp	.+8      	; 0x6ba <__divsf3+0x88>
     6b2:	32 30       	cpi	r19, 0x02	; 2
     6b4:	21 f4       	brne	.+8      	; 0x6be <__divsf3+0x8c>
     6b6:	84 e0       	ldi	r24, 0x04	; 4
     6b8:	89 87       	std	Y+9, r24	; 0x09
     6ba:	b7 01       	movw	r22, r14
     6bc:	5f c0       	rjmp	.+190    	; 0x77c <__divsf3+0x14a>
     6be:	2b 85       	ldd	r18, Y+11	; 0x0b
     6c0:	3c 85       	ldd	r19, Y+12	; 0x0c
     6c2:	8b 89       	ldd	r24, Y+19	; 0x13
     6c4:	9c 89       	ldd	r25, Y+20	; 0x14
     6c6:	28 1b       	sub	r18, r24
     6c8:	39 0b       	sbc	r19, r25
     6ca:	3c 87       	std	Y+12, r19	; 0x0c
     6cc:	2b 87       	std	Y+11, r18	; 0x0b
     6ce:	ed 84       	ldd	r14, Y+13	; 0x0d
     6d0:	fe 84       	ldd	r15, Y+14	; 0x0e
     6d2:	0f 85       	ldd	r16, Y+15	; 0x0f
     6d4:	18 89       	ldd	r17, Y+16	; 0x10
     6d6:	ad 88       	ldd	r10, Y+21	; 0x15
     6d8:	be 88       	ldd	r11, Y+22	; 0x16
     6da:	cf 88       	ldd	r12, Y+23	; 0x17
     6dc:	d8 8c       	ldd	r13, Y+24	; 0x18
     6de:	ea 14       	cp	r14, r10
     6e0:	fb 04       	cpc	r15, r11
     6e2:	0c 05       	cpc	r16, r12
     6e4:	1d 05       	cpc	r17, r13
     6e6:	40 f4       	brcc	.+16     	; 0x6f8 <__divsf3+0xc6>
     6e8:	ee 0c       	add	r14, r14
     6ea:	ff 1c       	adc	r15, r15
     6ec:	00 1f       	adc	r16, r16
     6ee:	11 1f       	adc	r17, r17
     6f0:	21 50       	subi	r18, 0x01	; 1
     6f2:	30 40       	sbci	r19, 0x00	; 0
     6f4:	3c 87       	std	Y+12, r19	; 0x0c
     6f6:	2b 87       	std	Y+11, r18	; 0x0b
     6f8:	20 e0       	ldi	r18, 0x00	; 0
     6fa:	30 e0       	ldi	r19, 0x00	; 0
     6fc:	40 e0       	ldi	r20, 0x00	; 0
     6fe:	50 e0       	ldi	r21, 0x00	; 0
     700:	80 e0       	ldi	r24, 0x00	; 0
     702:	90 e0       	ldi	r25, 0x00	; 0
     704:	a0 e0       	ldi	r26, 0x00	; 0
     706:	b0 e4       	ldi	r27, 0x40	; 64
     708:	60 e0       	ldi	r22, 0x00	; 0
     70a:	70 e0       	ldi	r23, 0x00	; 0
     70c:	ea 14       	cp	r14, r10
     70e:	fb 04       	cpc	r15, r11
     710:	0c 05       	cpc	r16, r12
     712:	1d 05       	cpc	r17, r13
     714:	40 f0       	brcs	.+16     	; 0x726 <__divsf3+0xf4>
     716:	28 2b       	or	r18, r24
     718:	39 2b       	or	r19, r25
     71a:	4a 2b       	or	r20, r26
     71c:	5b 2b       	or	r21, r27
     71e:	ea 18       	sub	r14, r10
     720:	fb 08       	sbc	r15, r11
     722:	0c 09       	sbc	r16, r12
     724:	1d 09       	sbc	r17, r13
     726:	b6 95       	lsr	r27
     728:	a7 95       	ror	r26
     72a:	97 95       	ror	r25
     72c:	87 95       	ror	r24
     72e:	ee 0c       	add	r14, r14
     730:	ff 1c       	adc	r15, r15
     732:	00 1f       	adc	r16, r16
     734:	11 1f       	adc	r17, r17
     736:	6f 5f       	subi	r22, 0xFF	; 255
     738:	7f 4f       	sbci	r23, 0xFF	; 255
     73a:	6f 31       	cpi	r22, 0x1F	; 31
     73c:	71 05       	cpc	r23, r1
     73e:	31 f7       	brne	.-52     	; 0x70c <__divsf3+0xda>
     740:	da 01       	movw	r26, r20
     742:	c9 01       	movw	r24, r18
     744:	8f 77       	andi	r24, 0x7F	; 127
     746:	90 70       	andi	r25, 0x00	; 0
     748:	a0 70       	andi	r26, 0x00	; 0
     74a:	b0 70       	andi	r27, 0x00	; 0
     74c:	80 34       	cpi	r24, 0x40	; 64
     74e:	91 05       	cpc	r25, r1
     750:	a1 05       	cpc	r26, r1
     752:	b1 05       	cpc	r27, r1
     754:	61 f4       	brne	.+24     	; 0x76e <__divsf3+0x13c>
     756:	27 fd       	sbrc	r18, 7
     758:	0a c0       	rjmp	.+20     	; 0x76e <__divsf3+0x13c>
     75a:	e1 14       	cp	r14, r1
     75c:	f1 04       	cpc	r15, r1
     75e:	01 05       	cpc	r16, r1
     760:	11 05       	cpc	r17, r1
     762:	29 f0       	breq	.+10     	; 0x76e <__divsf3+0x13c>
     764:	20 5c       	subi	r18, 0xC0	; 192
     766:	3f 4f       	sbci	r19, 0xFF	; 255
     768:	4f 4f       	sbci	r20, 0xFF	; 255
     76a:	5f 4f       	sbci	r21, 0xFF	; 255
     76c:	20 78       	andi	r18, 0x80	; 128
     76e:	2d 87       	std	Y+13, r18	; 0x0d
     770:	3e 87       	std	Y+14, r19	; 0x0e
     772:	4f 87       	std	Y+15, r20	; 0x0f
     774:	58 8b       	std	Y+16, r21	; 0x10
     776:	be 01       	movw	r22, r28
     778:	67 5f       	subi	r22, 0xF7	; 247
     77a:	7f 4f       	sbci	r23, 0xFF	; 255
     77c:	cb 01       	movw	r24, r22
     77e:	0e 94 86 05 	call	0xb0c	; 0xb0c <__pack_f>
     782:	68 96       	adiw	r28, 0x18	; 24
     784:	ea e0       	ldi	r30, 0x0A	; 10
     786:	0c 94 6d 4c 	jmp	0x98da	; 0x98da <__epilogue_restores__+0x10>

0000078a <__nesf2>:
     78a:	a8 e1       	ldi	r26, 0x18	; 24
     78c:	b0 e0       	ldi	r27, 0x00	; 0
     78e:	eb ec       	ldi	r30, 0xCB	; 203
     790:	f3 e0       	ldi	r31, 0x03	; 3
     792:	0c 94 55 4c 	jmp	0x98aa	; 0x98aa <__prologue_saves__+0x18>
     796:	69 83       	std	Y+1, r22	; 0x01
     798:	7a 83       	std	Y+2, r23	; 0x02
     79a:	8b 83       	std	Y+3, r24	; 0x03
     79c:	9c 83       	std	Y+4, r25	; 0x04
     79e:	2d 83       	std	Y+5, r18	; 0x05
     7a0:	3e 83       	std	Y+6, r19	; 0x06
     7a2:	4f 83       	std	Y+7, r20	; 0x07
     7a4:	58 87       	std	Y+8, r21	; 0x08
     7a6:	89 e0       	ldi	r24, 0x09	; 9
     7a8:	e8 2e       	mov	r14, r24
     7aa:	f1 2c       	mov	r15, r1
     7ac:	ec 0e       	add	r14, r28
     7ae:	fd 1e       	adc	r15, r29
     7b0:	ce 01       	movw	r24, r28
     7b2:	01 96       	adiw	r24, 0x01	; 1
     7b4:	b7 01       	movw	r22, r14
     7b6:	0e 94 5b 06 	call	0xcb6	; 0xcb6 <__unpack_f>
     7ba:	8e 01       	movw	r16, r28
     7bc:	0f 5e       	subi	r16, 0xEF	; 239
     7be:	1f 4f       	sbci	r17, 0xFF	; 255
     7c0:	ce 01       	movw	r24, r28
     7c2:	05 96       	adiw	r24, 0x05	; 5
     7c4:	b8 01       	movw	r22, r16
     7c6:	0e 94 5b 06 	call	0xcb6	; 0xcb6 <__unpack_f>
     7ca:	89 85       	ldd	r24, Y+9	; 0x09
     7cc:	82 30       	cpi	r24, 0x02	; 2
     7ce:	40 f0       	brcs	.+16     	; 0x7e0 <__nesf2+0x56>
     7d0:	89 89       	ldd	r24, Y+17	; 0x11
     7d2:	82 30       	cpi	r24, 0x02	; 2
     7d4:	28 f0       	brcs	.+10     	; 0x7e0 <__nesf2+0x56>
     7d6:	c7 01       	movw	r24, r14
     7d8:	b8 01       	movw	r22, r16
     7da:	0e 94 d3 06 	call	0xda6	; 0xda6 <__fpcmp_parts_f>
     7de:	01 c0       	rjmp	.+2      	; 0x7e2 <__nesf2+0x58>
     7e0:	81 e0       	ldi	r24, 0x01	; 1
     7e2:	68 96       	adiw	r28, 0x18	; 24
     7e4:	e6 e0       	ldi	r30, 0x06	; 6
     7e6:	0c 94 71 4c 	jmp	0x98e2	; 0x98e2 <__epilogue_restores__+0x18>

000007ea <__gtsf2>:
     7ea:	a8 e1       	ldi	r26, 0x18	; 24
     7ec:	b0 e0       	ldi	r27, 0x00	; 0
     7ee:	eb ef       	ldi	r30, 0xFB	; 251
     7f0:	f3 e0       	ldi	r31, 0x03	; 3
     7f2:	0c 94 55 4c 	jmp	0x98aa	; 0x98aa <__prologue_saves__+0x18>
     7f6:	69 83       	std	Y+1, r22	; 0x01
     7f8:	7a 83       	std	Y+2, r23	; 0x02
     7fa:	8b 83       	std	Y+3, r24	; 0x03
     7fc:	9c 83       	std	Y+4, r25	; 0x04
     7fe:	2d 83       	std	Y+5, r18	; 0x05
     800:	3e 83       	std	Y+6, r19	; 0x06
     802:	4f 83       	std	Y+7, r20	; 0x07
     804:	58 87       	std	Y+8, r21	; 0x08
     806:	89 e0       	ldi	r24, 0x09	; 9
     808:	e8 2e       	mov	r14, r24
     80a:	f1 2c       	mov	r15, r1
     80c:	ec 0e       	add	r14, r28
     80e:	fd 1e       	adc	r15, r29
     810:	ce 01       	movw	r24, r28
     812:	01 96       	adiw	r24, 0x01	; 1
     814:	b7 01       	movw	r22, r14
     816:	0e 94 5b 06 	call	0xcb6	; 0xcb6 <__unpack_f>
     81a:	8e 01       	movw	r16, r28
     81c:	0f 5e       	subi	r16, 0xEF	; 239
     81e:	1f 4f       	sbci	r17, 0xFF	; 255
     820:	ce 01       	movw	r24, r28
     822:	05 96       	adiw	r24, 0x05	; 5
     824:	b8 01       	movw	r22, r16
     826:	0e 94 5b 06 	call	0xcb6	; 0xcb6 <__unpack_f>
     82a:	89 85       	ldd	r24, Y+9	; 0x09
     82c:	82 30       	cpi	r24, 0x02	; 2
     82e:	40 f0       	brcs	.+16     	; 0x840 <__gtsf2+0x56>
     830:	89 89       	ldd	r24, Y+17	; 0x11
     832:	82 30       	cpi	r24, 0x02	; 2
     834:	28 f0       	brcs	.+10     	; 0x840 <__gtsf2+0x56>
     836:	c7 01       	movw	r24, r14
     838:	b8 01       	movw	r22, r16
     83a:	0e 94 d3 06 	call	0xda6	; 0xda6 <__fpcmp_parts_f>
     83e:	01 c0       	rjmp	.+2      	; 0x842 <__gtsf2+0x58>
     840:	8f ef       	ldi	r24, 0xFF	; 255
     842:	68 96       	adiw	r28, 0x18	; 24
     844:	e6 e0       	ldi	r30, 0x06	; 6
     846:	0c 94 71 4c 	jmp	0x98e2	; 0x98e2 <__epilogue_restores__+0x18>

0000084a <__gesf2>:
     84a:	a8 e1       	ldi	r26, 0x18	; 24
     84c:	b0 e0       	ldi	r27, 0x00	; 0
     84e:	eb e2       	ldi	r30, 0x2B	; 43
     850:	f4 e0       	ldi	r31, 0x04	; 4
     852:	0c 94 55 4c 	jmp	0x98aa	; 0x98aa <__prologue_saves__+0x18>
     856:	69 83       	std	Y+1, r22	; 0x01
     858:	7a 83       	std	Y+2, r23	; 0x02
     85a:	8b 83       	std	Y+3, r24	; 0x03
     85c:	9c 83       	std	Y+4, r25	; 0x04
     85e:	2d 83       	std	Y+5, r18	; 0x05
     860:	3e 83       	std	Y+6, r19	; 0x06
     862:	4f 83       	std	Y+7, r20	; 0x07
     864:	58 87       	std	Y+8, r21	; 0x08
     866:	89 e0       	ldi	r24, 0x09	; 9
     868:	e8 2e       	mov	r14, r24
     86a:	f1 2c       	mov	r15, r1
     86c:	ec 0e       	add	r14, r28
     86e:	fd 1e       	adc	r15, r29
     870:	ce 01       	movw	r24, r28
     872:	01 96       	adiw	r24, 0x01	; 1
     874:	b7 01       	movw	r22, r14
     876:	0e 94 5b 06 	call	0xcb6	; 0xcb6 <__unpack_f>
     87a:	8e 01       	movw	r16, r28
     87c:	0f 5e       	subi	r16, 0xEF	; 239
     87e:	1f 4f       	sbci	r17, 0xFF	; 255
     880:	ce 01       	movw	r24, r28
     882:	05 96       	adiw	r24, 0x05	; 5
     884:	b8 01       	movw	r22, r16
     886:	0e 94 5b 06 	call	0xcb6	; 0xcb6 <__unpack_f>
     88a:	89 85       	ldd	r24, Y+9	; 0x09
     88c:	82 30       	cpi	r24, 0x02	; 2
     88e:	40 f0       	brcs	.+16     	; 0x8a0 <__gesf2+0x56>
     890:	89 89       	ldd	r24, Y+17	; 0x11
     892:	82 30       	cpi	r24, 0x02	; 2
     894:	28 f0       	brcs	.+10     	; 0x8a0 <__gesf2+0x56>
     896:	c7 01       	movw	r24, r14
     898:	b8 01       	movw	r22, r16
     89a:	0e 94 d3 06 	call	0xda6	; 0xda6 <__fpcmp_parts_f>
     89e:	01 c0       	rjmp	.+2      	; 0x8a2 <__gesf2+0x58>
     8a0:	8f ef       	ldi	r24, 0xFF	; 255
     8a2:	68 96       	adiw	r28, 0x18	; 24
     8a4:	e6 e0       	ldi	r30, 0x06	; 6
     8a6:	0c 94 71 4c 	jmp	0x98e2	; 0x98e2 <__epilogue_restores__+0x18>

000008aa <__ltsf2>:
     8aa:	a8 e1       	ldi	r26, 0x18	; 24
     8ac:	b0 e0       	ldi	r27, 0x00	; 0
     8ae:	eb e5       	ldi	r30, 0x5B	; 91
     8b0:	f4 e0       	ldi	r31, 0x04	; 4
     8b2:	0c 94 55 4c 	jmp	0x98aa	; 0x98aa <__prologue_saves__+0x18>
     8b6:	69 83       	std	Y+1, r22	; 0x01
     8b8:	7a 83       	std	Y+2, r23	; 0x02
     8ba:	8b 83       	std	Y+3, r24	; 0x03
     8bc:	9c 83       	std	Y+4, r25	; 0x04
     8be:	2d 83       	std	Y+5, r18	; 0x05
     8c0:	3e 83       	std	Y+6, r19	; 0x06
     8c2:	4f 83       	std	Y+7, r20	; 0x07
     8c4:	58 87       	std	Y+8, r21	; 0x08
     8c6:	89 e0       	ldi	r24, 0x09	; 9
     8c8:	e8 2e       	mov	r14, r24
     8ca:	f1 2c       	mov	r15, r1
     8cc:	ec 0e       	add	r14, r28
     8ce:	fd 1e       	adc	r15, r29
     8d0:	ce 01       	movw	r24, r28
     8d2:	01 96       	adiw	r24, 0x01	; 1
     8d4:	b7 01       	movw	r22, r14
     8d6:	0e 94 5b 06 	call	0xcb6	; 0xcb6 <__unpack_f>
     8da:	8e 01       	movw	r16, r28
     8dc:	0f 5e       	subi	r16, 0xEF	; 239
     8de:	1f 4f       	sbci	r17, 0xFF	; 255
     8e0:	ce 01       	movw	r24, r28
     8e2:	05 96       	adiw	r24, 0x05	; 5
     8e4:	b8 01       	movw	r22, r16
     8e6:	0e 94 5b 06 	call	0xcb6	; 0xcb6 <__unpack_f>
     8ea:	89 85       	ldd	r24, Y+9	; 0x09
     8ec:	82 30       	cpi	r24, 0x02	; 2
     8ee:	40 f0       	brcs	.+16     	; 0x900 <__ltsf2+0x56>
     8f0:	89 89       	ldd	r24, Y+17	; 0x11
     8f2:	82 30       	cpi	r24, 0x02	; 2
     8f4:	28 f0       	brcs	.+10     	; 0x900 <__ltsf2+0x56>
     8f6:	c7 01       	movw	r24, r14
     8f8:	b8 01       	movw	r22, r16
     8fa:	0e 94 d3 06 	call	0xda6	; 0xda6 <__fpcmp_parts_f>
     8fe:	01 c0       	rjmp	.+2      	; 0x902 <__ltsf2+0x58>
     900:	81 e0       	ldi	r24, 0x01	; 1
     902:	68 96       	adiw	r28, 0x18	; 24
     904:	e6 e0       	ldi	r30, 0x06	; 6
     906:	0c 94 71 4c 	jmp	0x98e2	; 0x98e2 <__epilogue_restores__+0x18>

0000090a <__floatsisf>:
     90a:	a8 e0       	ldi	r26, 0x08	; 8
     90c:	b0 e0       	ldi	r27, 0x00	; 0
     90e:	eb e8       	ldi	r30, 0x8B	; 139
     910:	f4 e0       	ldi	r31, 0x04	; 4
     912:	0c 94 52 4c 	jmp	0x98a4	; 0x98a4 <__prologue_saves__+0x12>
     916:	9b 01       	movw	r18, r22
     918:	ac 01       	movw	r20, r24
     91a:	83 e0       	ldi	r24, 0x03	; 3
     91c:	89 83       	std	Y+1, r24	; 0x01
     91e:	da 01       	movw	r26, r20
     920:	c9 01       	movw	r24, r18
     922:	88 27       	eor	r24, r24
     924:	b7 fd       	sbrc	r27, 7
     926:	83 95       	inc	r24
     928:	99 27       	eor	r25, r25
     92a:	aa 27       	eor	r26, r26
     92c:	bb 27       	eor	r27, r27
     92e:	b8 2e       	mov	r11, r24
     930:	21 15       	cp	r18, r1
     932:	31 05       	cpc	r19, r1
     934:	41 05       	cpc	r20, r1
     936:	51 05       	cpc	r21, r1
     938:	19 f4       	brne	.+6      	; 0x940 <__floatsisf+0x36>
     93a:	82 e0       	ldi	r24, 0x02	; 2
     93c:	89 83       	std	Y+1, r24	; 0x01
     93e:	3a c0       	rjmp	.+116    	; 0x9b4 <__floatsisf+0xaa>
     940:	88 23       	and	r24, r24
     942:	a9 f0       	breq	.+42     	; 0x96e <__floatsisf+0x64>
     944:	20 30       	cpi	r18, 0x00	; 0
     946:	80 e0       	ldi	r24, 0x00	; 0
     948:	38 07       	cpc	r19, r24
     94a:	80 e0       	ldi	r24, 0x00	; 0
     94c:	48 07       	cpc	r20, r24
     94e:	80 e8       	ldi	r24, 0x80	; 128
     950:	58 07       	cpc	r21, r24
     952:	29 f4       	brne	.+10     	; 0x95e <__floatsisf+0x54>
     954:	60 e0       	ldi	r22, 0x00	; 0
     956:	70 e0       	ldi	r23, 0x00	; 0
     958:	80 e0       	ldi	r24, 0x00	; 0
     95a:	9f ec       	ldi	r25, 0xCF	; 207
     95c:	30 c0       	rjmp	.+96     	; 0x9be <__floatsisf+0xb4>
     95e:	ee 24       	eor	r14, r14
     960:	ff 24       	eor	r15, r15
     962:	87 01       	movw	r16, r14
     964:	e2 1a       	sub	r14, r18
     966:	f3 0a       	sbc	r15, r19
     968:	04 0b       	sbc	r16, r20
     96a:	15 0b       	sbc	r17, r21
     96c:	02 c0       	rjmp	.+4      	; 0x972 <__floatsisf+0x68>
     96e:	79 01       	movw	r14, r18
     970:	8a 01       	movw	r16, r20
     972:	8e e1       	ldi	r24, 0x1E	; 30
     974:	c8 2e       	mov	r12, r24
     976:	d1 2c       	mov	r13, r1
     978:	dc 82       	std	Y+4, r13	; 0x04
     97a:	cb 82       	std	Y+3, r12	; 0x03
     97c:	ed 82       	std	Y+5, r14	; 0x05
     97e:	fe 82       	std	Y+6, r15	; 0x06
     980:	0f 83       	std	Y+7, r16	; 0x07
     982:	18 87       	std	Y+8, r17	; 0x08
     984:	c8 01       	movw	r24, r16
     986:	b7 01       	movw	r22, r14
     988:	0e 94 37 05 	call	0xa6e	; 0xa6e <__clzsi2>
     98c:	01 97       	sbiw	r24, 0x01	; 1
     98e:	18 16       	cp	r1, r24
     990:	19 06       	cpc	r1, r25
     992:	84 f4       	brge	.+32     	; 0x9b4 <__floatsisf+0xaa>
     994:	08 2e       	mov	r0, r24
     996:	04 c0       	rjmp	.+8      	; 0x9a0 <__floatsisf+0x96>
     998:	ee 0c       	add	r14, r14
     99a:	ff 1c       	adc	r15, r15
     99c:	00 1f       	adc	r16, r16
     99e:	11 1f       	adc	r17, r17
     9a0:	0a 94       	dec	r0
     9a2:	d2 f7       	brpl	.-12     	; 0x998 <__floatsisf+0x8e>
     9a4:	ed 82       	std	Y+5, r14	; 0x05
     9a6:	fe 82       	std	Y+6, r15	; 0x06
     9a8:	0f 83       	std	Y+7, r16	; 0x07
     9aa:	18 87       	std	Y+8, r17	; 0x08
     9ac:	c8 1a       	sub	r12, r24
     9ae:	d9 0a       	sbc	r13, r25
     9b0:	dc 82       	std	Y+4, r13	; 0x04
     9b2:	cb 82       	std	Y+3, r12	; 0x03
     9b4:	ba 82       	std	Y+2, r11	; 0x02
     9b6:	ce 01       	movw	r24, r28
     9b8:	01 96       	adiw	r24, 0x01	; 1
     9ba:	0e 94 86 05 	call	0xb0c	; 0xb0c <__pack_f>
     9be:	28 96       	adiw	r28, 0x08	; 8
     9c0:	e9 e0       	ldi	r30, 0x09	; 9
     9c2:	0c 94 6e 4c 	jmp	0x98dc	; 0x98dc <__epilogue_restores__+0x12>

000009c6 <__fixsfsi>:
     9c6:	ac e0       	ldi	r26, 0x0C	; 12
     9c8:	b0 e0       	ldi	r27, 0x00	; 0
     9ca:	e9 ee       	ldi	r30, 0xE9	; 233
     9cc:	f4 e0       	ldi	r31, 0x04	; 4
     9ce:	0c 94 59 4c 	jmp	0x98b2	; 0x98b2 <__prologue_saves__+0x20>
     9d2:	69 83       	std	Y+1, r22	; 0x01
     9d4:	7a 83       	std	Y+2, r23	; 0x02
     9d6:	8b 83       	std	Y+3, r24	; 0x03
     9d8:	9c 83       	std	Y+4, r25	; 0x04
     9da:	ce 01       	movw	r24, r28
     9dc:	01 96       	adiw	r24, 0x01	; 1
     9de:	be 01       	movw	r22, r28
     9e0:	6b 5f       	subi	r22, 0xFB	; 251
     9e2:	7f 4f       	sbci	r23, 0xFF	; 255
     9e4:	0e 94 5b 06 	call	0xcb6	; 0xcb6 <__unpack_f>
     9e8:	8d 81       	ldd	r24, Y+5	; 0x05
     9ea:	82 30       	cpi	r24, 0x02	; 2
     9ec:	61 f1       	breq	.+88     	; 0xa46 <__fixsfsi+0x80>
     9ee:	82 30       	cpi	r24, 0x02	; 2
     9f0:	50 f1       	brcs	.+84     	; 0xa46 <__fixsfsi+0x80>
     9f2:	84 30       	cpi	r24, 0x04	; 4
     9f4:	21 f4       	brne	.+8      	; 0x9fe <__fixsfsi+0x38>
     9f6:	8e 81       	ldd	r24, Y+6	; 0x06
     9f8:	88 23       	and	r24, r24
     9fa:	51 f1       	breq	.+84     	; 0xa50 <__fixsfsi+0x8a>
     9fc:	2e c0       	rjmp	.+92     	; 0xa5a <__fixsfsi+0x94>
     9fe:	2f 81       	ldd	r18, Y+7	; 0x07
     a00:	38 85       	ldd	r19, Y+8	; 0x08
     a02:	37 fd       	sbrc	r19, 7
     a04:	20 c0       	rjmp	.+64     	; 0xa46 <__fixsfsi+0x80>
     a06:	6e 81       	ldd	r22, Y+6	; 0x06
     a08:	2f 31       	cpi	r18, 0x1F	; 31
     a0a:	31 05       	cpc	r19, r1
     a0c:	1c f0       	brlt	.+6      	; 0xa14 <__fixsfsi+0x4e>
     a0e:	66 23       	and	r22, r22
     a10:	f9 f0       	breq	.+62     	; 0xa50 <__fixsfsi+0x8a>
     a12:	23 c0       	rjmp	.+70     	; 0xa5a <__fixsfsi+0x94>
     a14:	8e e1       	ldi	r24, 0x1E	; 30
     a16:	90 e0       	ldi	r25, 0x00	; 0
     a18:	82 1b       	sub	r24, r18
     a1a:	93 0b       	sbc	r25, r19
     a1c:	29 85       	ldd	r18, Y+9	; 0x09
     a1e:	3a 85       	ldd	r19, Y+10	; 0x0a
     a20:	4b 85       	ldd	r20, Y+11	; 0x0b
     a22:	5c 85       	ldd	r21, Y+12	; 0x0c
     a24:	04 c0       	rjmp	.+8      	; 0xa2e <__fixsfsi+0x68>
     a26:	56 95       	lsr	r21
     a28:	47 95       	ror	r20
     a2a:	37 95       	ror	r19
     a2c:	27 95       	ror	r18
     a2e:	8a 95       	dec	r24
     a30:	d2 f7       	brpl	.-12     	; 0xa26 <__fixsfsi+0x60>
     a32:	66 23       	and	r22, r22
     a34:	b1 f0       	breq	.+44     	; 0xa62 <__fixsfsi+0x9c>
     a36:	50 95       	com	r21
     a38:	40 95       	com	r20
     a3a:	30 95       	com	r19
     a3c:	21 95       	neg	r18
     a3e:	3f 4f       	sbci	r19, 0xFF	; 255
     a40:	4f 4f       	sbci	r20, 0xFF	; 255
     a42:	5f 4f       	sbci	r21, 0xFF	; 255
     a44:	0e c0       	rjmp	.+28     	; 0xa62 <__fixsfsi+0x9c>
     a46:	20 e0       	ldi	r18, 0x00	; 0
     a48:	30 e0       	ldi	r19, 0x00	; 0
     a4a:	40 e0       	ldi	r20, 0x00	; 0
     a4c:	50 e0       	ldi	r21, 0x00	; 0
     a4e:	09 c0       	rjmp	.+18     	; 0xa62 <__fixsfsi+0x9c>
     a50:	2f ef       	ldi	r18, 0xFF	; 255
     a52:	3f ef       	ldi	r19, 0xFF	; 255
     a54:	4f ef       	ldi	r20, 0xFF	; 255
     a56:	5f e7       	ldi	r21, 0x7F	; 127
     a58:	04 c0       	rjmp	.+8      	; 0xa62 <__fixsfsi+0x9c>
     a5a:	20 e0       	ldi	r18, 0x00	; 0
     a5c:	30 e0       	ldi	r19, 0x00	; 0
     a5e:	40 e0       	ldi	r20, 0x00	; 0
     a60:	50 e8       	ldi	r21, 0x80	; 128
     a62:	b9 01       	movw	r22, r18
     a64:	ca 01       	movw	r24, r20
     a66:	2c 96       	adiw	r28, 0x0c	; 12
     a68:	e2 e0       	ldi	r30, 0x02	; 2
     a6a:	0c 94 75 4c 	jmp	0x98ea	; 0x98ea <__epilogue_restores__+0x20>

00000a6e <__clzsi2>:
     a6e:	ef 92       	push	r14
     a70:	ff 92       	push	r15
     a72:	0f 93       	push	r16
     a74:	1f 93       	push	r17
     a76:	7b 01       	movw	r14, r22
     a78:	8c 01       	movw	r16, r24
     a7a:	80 e0       	ldi	r24, 0x00	; 0
     a7c:	e8 16       	cp	r14, r24
     a7e:	80 e0       	ldi	r24, 0x00	; 0
     a80:	f8 06       	cpc	r15, r24
     a82:	81 e0       	ldi	r24, 0x01	; 1
     a84:	08 07       	cpc	r16, r24
     a86:	80 e0       	ldi	r24, 0x00	; 0
     a88:	18 07       	cpc	r17, r24
     a8a:	88 f4       	brcc	.+34     	; 0xaae <__clzsi2+0x40>
     a8c:	8f ef       	ldi	r24, 0xFF	; 255
     a8e:	e8 16       	cp	r14, r24
     a90:	f1 04       	cpc	r15, r1
     a92:	01 05       	cpc	r16, r1
     a94:	11 05       	cpc	r17, r1
     a96:	31 f0       	breq	.+12     	; 0xaa4 <__clzsi2+0x36>
     a98:	28 f0       	brcs	.+10     	; 0xaa4 <__clzsi2+0x36>
     a9a:	88 e0       	ldi	r24, 0x08	; 8
     a9c:	90 e0       	ldi	r25, 0x00	; 0
     a9e:	a0 e0       	ldi	r26, 0x00	; 0
     aa0:	b0 e0       	ldi	r27, 0x00	; 0
     aa2:	17 c0       	rjmp	.+46     	; 0xad2 <__clzsi2+0x64>
     aa4:	80 e0       	ldi	r24, 0x00	; 0
     aa6:	90 e0       	ldi	r25, 0x00	; 0
     aa8:	a0 e0       	ldi	r26, 0x00	; 0
     aaa:	b0 e0       	ldi	r27, 0x00	; 0
     aac:	12 c0       	rjmp	.+36     	; 0xad2 <__clzsi2+0x64>
     aae:	80 e0       	ldi	r24, 0x00	; 0
     ab0:	e8 16       	cp	r14, r24
     ab2:	80 e0       	ldi	r24, 0x00	; 0
     ab4:	f8 06       	cpc	r15, r24
     ab6:	80 e0       	ldi	r24, 0x00	; 0
     ab8:	08 07       	cpc	r16, r24
     aba:	81 e0       	ldi	r24, 0x01	; 1
     abc:	18 07       	cpc	r17, r24
     abe:	28 f0       	brcs	.+10     	; 0xaca <__clzsi2+0x5c>
     ac0:	88 e1       	ldi	r24, 0x18	; 24
     ac2:	90 e0       	ldi	r25, 0x00	; 0
     ac4:	a0 e0       	ldi	r26, 0x00	; 0
     ac6:	b0 e0       	ldi	r27, 0x00	; 0
     ac8:	04 c0       	rjmp	.+8      	; 0xad2 <__clzsi2+0x64>
     aca:	80 e1       	ldi	r24, 0x10	; 16
     acc:	90 e0       	ldi	r25, 0x00	; 0
     ace:	a0 e0       	ldi	r26, 0x00	; 0
     ad0:	b0 e0       	ldi	r27, 0x00	; 0
     ad2:	20 e2       	ldi	r18, 0x20	; 32
     ad4:	30 e0       	ldi	r19, 0x00	; 0
     ad6:	40 e0       	ldi	r20, 0x00	; 0
     ad8:	50 e0       	ldi	r21, 0x00	; 0
     ada:	28 1b       	sub	r18, r24
     adc:	39 0b       	sbc	r19, r25
     ade:	4a 0b       	sbc	r20, r26
     ae0:	5b 0b       	sbc	r21, r27
     ae2:	04 c0       	rjmp	.+8      	; 0xaec <__clzsi2+0x7e>
     ae4:	16 95       	lsr	r17
     ae6:	07 95       	ror	r16
     ae8:	f7 94       	ror	r15
     aea:	e7 94       	ror	r14
     aec:	8a 95       	dec	r24
     aee:	d2 f7       	brpl	.-12     	; 0xae4 <__clzsi2+0x76>
     af0:	f7 01       	movw	r30, r14
     af2:	eb 57       	subi	r30, 0x7B	; 123
     af4:	ff 4f       	sbci	r31, 0xFF	; 255
     af6:	80 81       	ld	r24, Z
     af8:	28 1b       	sub	r18, r24
     afa:	31 09       	sbc	r19, r1
     afc:	41 09       	sbc	r20, r1
     afe:	51 09       	sbc	r21, r1
     b00:	c9 01       	movw	r24, r18
     b02:	1f 91       	pop	r17
     b04:	0f 91       	pop	r16
     b06:	ff 90       	pop	r15
     b08:	ef 90       	pop	r14
     b0a:	08 95       	ret

00000b0c <__pack_f>:
     b0c:	df 92       	push	r13
     b0e:	ef 92       	push	r14
     b10:	ff 92       	push	r15
     b12:	0f 93       	push	r16
     b14:	1f 93       	push	r17
     b16:	fc 01       	movw	r30, r24
     b18:	e4 80       	ldd	r14, Z+4	; 0x04
     b1a:	f5 80       	ldd	r15, Z+5	; 0x05
     b1c:	06 81       	ldd	r16, Z+6	; 0x06
     b1e:	17 81       	ldd	r17, Z+7	; 0x07
     b20:	d1 80       	ldd	r13, Z+1	; 0x01
     b22:	80 81       	ld	r24, Z
     b24:	82 30       	cpi	r24, 0x02	; 2
     b26:	48 f4       	brcc	.+18     	; 0xb3a <__pack_f+0x2e>
     b28:	80 e0       	ldi	r24, 0x00	; 0
     b2a:	90 e0       	ldi	r25, 0x00	; 0
     b2c:	a0 e1       	ldi	r26, 0x10	; 16
     b2e:	b0 e0       	ldi	r27, 0x00	; 0
     b30:	e8 2a       	or	r14, r24
     b32:	f9 2a       	or	r15, r25
     b34:	0a 2b       	or	r16, r26
     b36:	1b 2b       	or	r17, r27
     b38:	a5 c0       	rjmp	.+330    	; 0xc84 <__pack_f+0x178>
     b3a:	84 30       	cpi	r24, 0x04	; 4
     b3c:	09 f4       	brne	.+2      	; 0xb40 <__pack_f+0x34>
     b3e:	9f c0       	rjmp	.+318    	; 0xc7e <__pack_f+0x172>
     b40:	82 30       	cpi	r24, 0x02	; 2
     b42:	21 f4       	brne	.+8      	; 0xb4c <__pack_f+0x40>
     b44:	ee 24       	eor	r14, r14
     b46:	ff 24       	eor	r15, r15
     b48:	87 01       	movw	r16, r14
     b4a:	05 c0       	rjmp	.+10     	; 0xb56 <__pack_f+0x4a>
     b4c:	e1 14       	cp	r14, r1
     b4e:	f1 04       	cpc	r15, r1
     b50:	01 05       	cpc	r16, r1
     b52:	11 05       	cpc	r17, r1
     b54:	19 f4       	brne	.+6      	; 0xb5c <__pack_f+0x50>
     b56:	e0 e0       	ldi	r30, 0x00	; 0
     b58:	f0 e0       	ldi	r31, 0x00	; 0
     b5a:	96 c0       	rjmp	.+300    	; 0xc88 <__pack_f+0x17c>
     b5c:	62 81       	ldd	r22, Z+2	; 0x02
     b5e:	73 81       	ldd	r23, Z+3	; 0x03
     b60:	9f ef       	ldi	r25, 0xFF	; 255
     b62:	62 38       	cpi	r22, 0x82	; 130
     b64:	79 07       	cpc	r23, r25
     b66:	0c f0       	brlt	.+2      	; 0xb6a <__pack_f+0x5e>
     b68:	5b c0       	rjmp	.+182    	; 0xc20 <__pack_f+0x114>
     b6a:	22 e8       	ldi	r18, 0x82	; 130
     b6c:	3f ef       	ldi	r19, 0xFF	; 255
     b6e:	26 1b       	sub	r18, r22
     b70:	37 0b       	sbc	r19, r23
     b72:	2a 31       	cpi	r18, 0x1A	; 26
     b74:	31 05       	cpc	r19, r1
     b76:	2c f0       	brlt	.+10     	; 0xb82 <__pack_f+0x76>
     b78:	20 e0       	ldi	r18, 0x00	; 0
     b7a:	30 e0       	ldi	r19, 0x00	; 0
     b7c:	40 e0       	ldi	r20, 0x00	; 0
     b7e:	50 e0       	ldi	r21, 0x00	; 0
     b80:	2a c0       	rjmp	.+84     	; 0xbd6 <__pack_f+0xca>
     b82:	b8 01       	movw	r22, r16
     b84:	a7 01       	movw	r20, r14
     b86:	02 2e       	mov	r0, r18
     b88:	04 c0       	rjmp	.+8      	; 0xb92 <__pack_f+0x86>
     b8a:	76 95       	lsr	r23
     b8c:	67 95       	ror	r22
     b8e:	57 95       	ror	r21
     b90:	47 95       	ror	r20
     b92:	0a 94       	dec	r0
     b94:	d2 f7       	brpl	.-12     	; 0xb8a <__pack_f+0x7e>
     b96:	81 e0       	ldi	r24, 0x01	; 1
     b98:	90 e0       	ldi	r25, 0x00	; 0
     b9a:	a0 e0       	ldi	r26, 0x00	; 0
     b9c:	b0 e0       	ldi	r27, 0x00	; 0
     b9e:	04 c0       	rjmp	.+8      	; 0xba8 <__pack_f+0x9c>
     ba0:	88 0f       	add	r24, r24
     ba2:	99 1f       	adc	r25, r25
     ba4:	aa 1f       	adc	r26, r26
     ba6:	bb 1f       	adc	r27, r27
     ba8:	2a 95       	dec	r18
     baa:	d2 f7       	brpl	.-12     	; 0xba0 <__pack_f+0x94>
     bac:	01 97       	sbiw	r24, 0x01	; 1
     bae:	a1 09       	sbc	r26, r1
     bb0:	b1 09       	sbc	r27, r1
     bb2:	8e 21       	and	r24, r14
     bb4:	9f 21       	and	r25, r15
     bb6:	a0 23       	and	r26, r16
     bb8:	b1 23       	and	r27, r17
     bba:	00 97       	sbiw	r24, 0x00	; 0
     bbc:	a1 05       	cpc	r26, r1
     bbe:	b1 05       	cpc	r27, r1
     bc0:	21 f0       	breq	.+8      	; 0xbca <__pack_f+0xbe>
     bc2:	81 e0       	ldi	r24, 0x01	; 1
     bc4:	90 e0       	ldi	r25, 0x00	; 0
     bc6:	a0 e0       	ldi	r26, 0x00	; 0
     bc8:	b0 e0       	ldi	r27, 0x00	; 0
     bca:	9a 01       	movw	r18, r20
     bcc:	ab 01       	movw	r20, r22
     bce:	28 2b       	or	r18, r24
     bd0:	39 2b       	or	r19, r25
     bd2:	4a 2b       	or	r20, r26
     bd4:	5b 2b       	or	r21, r27
     bd6:	da 01       	movw	r26, r20
     bd8:	c9 01       	movw	r24, r18
     bda:	8f 77       	andi	r24, 0x7F	; 127
     bdc:	90 70       	andi	r25, 0x00	; 0
     bde:	a0 70       	andi	r26, 0x00	; 0
     be0:	b0 70       	andi	r27, 0x00	; 0
     be2:	80 34       	cpi	r24, 0x40	; 64
     be4:	91 05       	cpc	r25, r1
     be6:	a1 05       	cpc	r26, r1
     be8:	b1 05       	cpc	r27, r1
     bea:	39 f4       	brne	.+14     	; 0xbfa <__pack_f+0xee>
     bec:	27 ff       	sbrs	r18, 7
     bee:	09 c0       	rjmp	.+18     	; 0xc02 <__pack_f+0xf6>
     bf0:	20 5c       	subi	r18, 0xC0	; 192
     bf2:	3f 4f       	sbci	r19, 0xFF	; 255
     bf4:	4f 4f       	sbci	r20, 0xFF	; 255
     bf6:	5f 4f       	sbci	r21, 0xFF	; 255
     bf8:	04 c0       	rjmp	.+8      	; 0xc02 <__pack_f+0xf6>
     bfa:	21 5c       	subi	r18, 0xC1	; 193
     bfc:	3f 4f       	sbci	r19, 0xFF	; 255
     bfe:	4f 4f       	sbci	r20, 0xFF	; 255
     c00:	5f 4f       	sbci	r21, 0xFF	; 255
     c02:	e0 e0       	ldi	r30, 0x00	; 0
     c04:	f0 e0       	ldi	r31, 0x00	; 0
     c06:	20 30       	cpi	r18, 0x00	; 0
     c08:	a0 e0       	ldi	r26, 0x00	; 0
     c0a:	3a 07       	cpc	r19, r26
     c0c:	a0 e0       	ldi	r26, 0x00	; 0
     c0e:	4a 07       	cpc	r20, r26
     c10:	a0 e4       	ldi	r26, 0x40	; 64
     c12:	5a 07       	cpc	r21, r26
     c14:	10 f0       	brcs	.+4      	; 0xc1a <__pack_f+0x10e>
     c16:	e1 e0       	ldi	r30, 0x01	; 1
     c18:	f0 e0       	ldi	r31, 0x00	; 0
     c1a:	79 01       	movw	r14, r18
     c1c:	8a 01       	movw	r16, r20
     c1e:	27 c0       	rjmp	.+78     	; 0xc6e <__pack_f+0x162>
     c20:	60 38       	cpi	r22, 0x80	; 128
     c22:	71 05       	cpc	r23, r1
     c24:	64 f5       	brge	.+88     	; 0xc7e <__pack_f+0x172>
     c26:	fb 01       	movw	r30, r22
     c28:	e1 58       	subi	r30, 0x81	; 129
     c2a:	ff 4f       	sbci	r31, 0xFF	; 255
     c2c:	d8 01       	movw	r26, r16
     c2e:	c7 01       	movw	r24, r14
     c30:	8f 77       	andi	r24, 0x7F	; 127
     c32:	90 70       	andi	r25, 0x00	; 0
     c34:	a0 70       	andi	r26, 0x00	; 0
     c36:	b0 70       	andi	r27, 0x00	; 0
     c38:	80 34       	cpi	r24, 0x40	; 64
     c3a:	91 05       	cpc	r25, r1
     c3c:	a1 05       	cpc	r26, r1
     c3e:	b1 05       	cpc	r27, r1
     c40:	39 f4       	brne	.+14     	; 0xc50 <__pack_f+0x144>
     c42:	e7 fe       	sbrs	r14, 7
     c44:	0d c0       	rjmp	.+26     	; 0xc60 <__pack_f+0x154>
     c46:	80 e4       	ldi	r24, 0x40	; 64
     c48:	90 e0       	ldi	r25, 0x00	; 0
     c4a:	a0 e0       	ldi	r26, 0x00	; 0
     c4c:	b0 e0       	ldi	r27, 0x00	; 0
     c4e:	04 c0       	rjmp	.+8      	; 0xc58 <__pack_f+0x14c>
     c50:	8f e3       	ldi	r24, 0x3F	; 63
     c52:	90 e0       	ldi	r25, 0x00	; 0
     c54:	a0 e0       	ldi	r26, 0x00	; 0
     c56:	b0 e0       	ldi	r27, 0x00	; 0
     c58:	e8 0e       	add	r14, r24
     c5a:	f9 1e       	adc	r15, r25
     c5c:	0a 1f       	adc	r16, r26
     c5e:	1b 1f       	adc	r17, r27
     c60:	17 ff       	sbrs	r17, 7
     c62:	05 c0       	rjmp	.+10     	; 0xc6e <__pack_f+0x162>
     c64:	16 95       	lsr	r17
     c66:	07 95       	ror	r16
     c68:	f7 94       	ror	r15
     c6a:	e7 94       	ror	r14
     c6c:	31 96       	adiw	r30, 0x01	; 1
     c6e:	87 e0       	ldi	r24, 0x07	; 7
     c70:	16 95       	lsr	r17
     c72:	07 95       	ror	r16
     c74:	f7 94       	ror	r15
     c76:	e7 94       	ror	r14
     c78:	8a 95       	dec	r24
     c7a:	d1 f7       	brne	.-12     	; 0xc70 <__pack_f+0x164>
     c7c:	05 c0       	rjmp	.+10     	; 0xc88 <__pack_f+0x17c>
     c7e:	ee 24       	eor	r14, r14
     c80:	ff 24       	eor	r15, r15
     c82:	87 01       	movw	r16, r14
     c84:	ef ef       	ldi	r30, 0xFF	; 255
     c86:	f0 e0       	ldi	r31, 0x00	; 0
     c88:	6e 2f       	mov	r22, r30
     c8a:	67 95       	ror	r22
     c8c:	66 27       	eor	r22, r22
     c8e:	67 95       	ror	r22
     c90:	90 2f       	mov	r25, r16
     c92:	9f 77       	andi	r25, 0x7F	; 127
     c94:	d7 94       	ror	r13
     c96:	dd 24       	eor	r13, r13
     c98:	d7 94       	ror	r13
     c9a:	8e 2f       	mov	r24, r30
     c9c:	86 95       	lsr	r24
     c9e:	49 2f       	mov	r20, r25
     ca0:	46 2b       	or	r20, r22
     ca2:	58 2f       	mov	r21, r24
     ca4:	5d 29       	or	r21, r13
     ca6:	b7 01       	movw	r22, r14
     ca8:	ca 01       	movw	r24, r20
     caa:	1f 91       	pop	r17
     cac:	0f 91       	pop	r16
     cae:	ff 90       	pop	r15
     cb0:	ef 90       	pop	r14
     cb2:	df 90       	pop	r13
     cb4:	08 95       	ret

00000cb6 <__unpack_f>:
     cb6:	fc 01       	movw	r30, r24
     cb8:	db 01       	movw	r26, r22
     cba:	40 81       	ld	r20, Z
     cbc:	51 81       	ldd	r21, Z+1	; 0x01
     cbe:	22 81       	ldd	r18, Z+2	; 0x02
     cc0:	62 2f       	mov	r22, r18
     cc2:	6f 77       	andi	r22, 0x7F	; 127
     cc4:	70 e0       	ldi	r23, 0x00	; 0
     cc6:	22 1f       	adc	r18, r18
     cc8:	22 27       	eor	r18, r18
     cca:	22 1f       	adc	r18, r18
     ccc:	93 81       	ldd	r25, Z+3	; 0x03
     cce:	89 2f       	mov	r24, r25
     cd0:	88 0f       	add	r24, r24
     cd2:	82 2b       	or	r24, r18
     cd4:	28 2f       	mov	r18, r24
     cd6:	30 e0       	ldi	r19, 0x00	; 0
     cd8:	99 1f       	adc	r25, r25
     cda:	99 27       	eor	r25, r25
     cdc:	99 1f       	adc	r25, r25
     cde:	11 96       	adiw	r26, 0x01	; 1
     ce0:	9c 93       	st	X, r25
     ce2:	11 97       	sbiw	r26, 0x01	; 1
     ce4:	21 15       	cp	r18, r1
     ce6:	31 05       	cpc	r19, r1
     ce8:	a9 f5       	brne	.+106    	; 0xd54 <__unpack_f+0x9e>
     cea:	41 15       	cp	r20, r1
     cec:	51 05       	cpc	r21, r1
     cee:	61 05       	cpc	r22, r1
     cf0:	71 05       	cpc	r23, r1
     cf2:	11 f4       	brne	.+4      	; 0xcf8 <__unpack_f+0x42>
     cf4:	82 e0       	ldi	r24, 0x02	; 2
     cf6:	37 c0       	rjmp	.+110    	; 0xd66 <__unpack_f+0xb0>
     cf8:	82 e8       	ldi	r24, 0x82	; 130
     cfa:	9f ef       	ldi	r25, 0xFF	; 255
     cfc:	13 96       	adiw	r26, 0x03	; 3
     cfe:	9c 93       	st	X, r25
     d00:	8e 93       	st	-X, r24
     d02:	12 97       	sbiw	r26, 0x02	; 2
     d04:	9a 01       	movw	r18, r20
     d06:	ab 01       	movw	r20, r22
     d08:	67 e0       	ldi	r22, 0x07	; 7
     d0a:	22 0f       	add	r18, r18
     d0c:	33 1f       	adc	r19, r19
     d0e:	44 1f       	adc	r20, r20
     d10:	55 1f       	adc	r21, r21
     d12:	6a 95       	dec	r22
     d14:	d1 f7       	brne	.-12     	; 0xd0a <__unpack_f+0x54>
     d16:	83 e0       	ldi	r24, 0x03	; 3
     d18:	8c 93       	st	X, r24
     d1a:	0d c0       	rjmp	.+26     	; 0xd36 <__unpack_f+0x80>
     d1c:	22 0f       	add	r18, r18
     d1e:	33 1f       	adc	r19, r19
     d20:	44 1f       	adc	r20, r20
     d22:	55 1f       	adc	r21, r21
     d24:	12 96       	adiw	r26, 0x02	; 2
     d26:	8d 91       	ld	r24, X+
     d28:	9c 91       	ld	r25, X
     d2a:	13 97       	sbiw	r26, 0x03	; 3
     d2c:	01 97       	sbiw	r24, 0x01	; 1
     d2e:	13 96       	adiw	r26, 0x03	; 3
     d30:	9c 93       	st	X, r25
     d32:	8e 93       	st	-X, r24
     d34:	12 97       	sbiw	r26, 0x02	; 2
     d36:	20 30       	cpi	r18, 0x00	; 0
     d38:	80 e0       	ldi	r24, 0x00	; 0
     d3a:	38 07       	cpc	r19, r24
     d3c:	80 e0       	ldi	r24, 0x00	; 0
     d3e:	48 07       	cpc	r20, r24
     d40:	80 e4       	ldi	r24, 0x40	; 64
     d42:	58 07       	cpc	r21, r24
     d44:	58 f3       	brcs	.-42     	; 0xd1c <__unpack_f+0x66>
     d46:	14 96       	adiw	r26, 0x04	; 4
     d48:	2d 93       	st	X+, r18
     d4a:	3d 93       	st	X+, r19
     d4c:	4d 93       	st	X+, r20
     d4e:	5c 93       	st	X, r21
     d50:	17 97       	sbiw	r26, 0x07	; 7
     d52:	08 95       	ret
     d54:	2f 3f       	cpi	r18, 0xFF	; 255
     d56:	31 05       	cpc	r19, r1
     d58:	79 f4       	brne	.+30     	; 0xd78 <__unpack_f+0xc2>
     d5a:	41 15       	cp	r20, r1
     d5c:	51 05       	cpc	r21, r1
     d5e:	61 05       	cpc	r22, r1
     d60:	71 05       	cpc	r23, r1
     d62:	19 f4       	brne	.+6      	; 0xd6a <__unpack_f+0xb4>
     d64:	84 e0       	ldi	r24, 0x04	; 4
     d66:	8c 93       	st	X, r24
     d68:	08 95       	ret
     d6a:	64 ff       	sbrs	r22, 4
     d6c:	03 c0       	rjmp	.+6      	; 0xd74 <__unpack_f+0xbe>
     d6e:	81 e0       	ldi	r24, 0x01	; 1
     d70:	8c 93       	st	X, r24
     d72:	12 c0       	rjmp	.+36     	; 0xd98 <__unpack_f+0xe2>
     d74:	1c 92       	st	X, r1
     d76:	10 c0       	rjmp	.+32     	; 0xd98 <__unpack_f+0xe2>
     d78:	2f 57       	subi	r18, 0x7F	; 127
     d7a:	30 40       	sbci	r19, 0x00	; 0
     d7c:	13 96       	adiw	r26, 0x03	; 3
     d7e:	3c 93       	st	X, r19
     d80:	2e 93       	st	-X, r18
     d82:	12 97       	sbiw	r26, 0x02	; 2
     d84:	83 e0       	ldi	r24, 0x03	; 3
     d86:	8c 93       	st	X, r24
     d88:	87 e0       	ldi	r24, 0x07	; 7
     d8a:	44 0f       	add	r20, r20
     d8c:	55 1f       	adc	r21, r21
     d8e:	66 1f       	adc	r22, r22
     d90:	77 1f       	adc	r23, r23
     d92:	8a 95       	dec	r24
     d94:	d1 f7       	brne	.-12     	; 0xd8a <__unpack_f+0xd4>
     d96:	70 64       	ori	r23, 0x40	; 64
     d98:	14 96       	adiw	r26, 0x04	; 4
     d9a:	4d 93       	st	X+, r20
     d9c:	5d 93       	st	X+, r21
     d9e:	6d 93       	st	X+, r22
     da0:	7c 93       	st	X, r23
     da2:	17 97       	sbiw	r26, 0x07	; 7
     da4:	08 95       	ret

00000da6 <__fpcmp_parts_f>:
     da6:	1f 93       	push	r17
     da8:	dc 01       	movw	r26, r24
     daa:	fb 01       	movw	r30, r22
     dac:	9c 91       	ld	r25, X
     dae:	92 30       	cpi	r25, 0x02	; 2
     db0:	08 f4       	brcc	.+2      	; 0xdb4 <__fpcmp_parts_f+0xe>
     db2:	47 c0       	rjmp	.+142    	; 0xe42 <__fpcmp_parts_f+0x9c>
     db4:	80 81       	ld	r24, Z
     db6:	82 30       	cpi	r24, 0x02	; 2
     db8:	08 f4       	brcc	.+2      	; 0xdbc <__fpcmp_parts_f+0x16>
     dba:	43 c0       	rjmp	.+134    	; 0xe42 <__fpcmp_parts_f+0x9c>
     dbc:	94 30       	cpi	r25, 0x04	; 4
     dbe:	51 f4       	brne	.+20     	; 0xdd4 <__fpcmp_parts_f+0x2e>
     dc0:	11 96       	adiw	r26, 0x01	; 1
     dc2:	1c 91       	ld	r17, X
     dc4:	84 30       	cpi	r24, 0x04	; 4
     dc6:	99 f5       	brne	.+102    	; 0xe2e <__fpcmp_parts_f+0x88>
     dc8:	81 81       	ldd	r24, Z+1	; 0x01
     dca:	68 2f       	mov	r22, r24
     dcc:	70 e0       	ldi	r23, 0x00	; 0
     dce:	61 1b       	sub	r22, r17
     dd0:	71 09       	sbc	r23, r1
     dd2:	3f c0       	rjmp	.+126    	; 0xe52 <__fpcmp_parts_f+0xac>
     dd4:	84 30       	cpi	r24, 0x04	; 4
     dd6:	21 f0       	breq	.+8      	; 0xde0 <__fpcmp_parts_f+0x3a>
     dd8:	92 30       	cpi	r25, 0x02	; 2
     dda:	31 f4       	brne	.+12     	; 0xde8 <__fpcmp_parts_f+0x42>
     ddc:	82 30       	cpi	r24, 0x02	; 2
     dde:	b9 f1       	breq	.+110    	; 0xe4e <__fpcmp_parts_f+0xa8>
     de0:	81 81       	ldd	r24, Z+1	; 0x01
     de2:	88 23       	and	r24, r24
     de4:	89 f1       	breq	.+98     	; 0xe48 <__fpcmp_parts_f+0xa2>
     de6:	2d c0       	rjmp	.+90     	; 0xe42 <__fpcmp_parts_f+0x9c>
     de8:	11 96       	adiw	r26, 0x01	; 1
     dea:	1c 91       	ld	r17, X
     dec:	11 97       	sbiw	r26, 0x01	; 1
     dee:	82 30       	cpi	r24, 0x02	; 2
     df0:	f1 f0       	breq	.+60     	; 0xe2e <__fpcmp_parts_f+0x88>
     df2:	81 81       	ldd	r24, Z+1	; 0x01
     df4:	18 17       	cp	r17, r24
     df6:	d9 f4       	brne	.+54     	; 0xe2e <__fpcmp_parts_f+0x88>
     df8:	12 96       	adiw	r26, 0x02	; 2
     dfa:	2d 91       	ld	r18, X+
     dfc:	3c 91       	ld	r19, X
     dfe:	13 97       	sbiw	r26, 0x03	; 3
     e00:	82 81       	ldd	r24, Z+2	; 0x02
     e02:	93 81       	ldd	r25, Z+3	; 0x03
     e04:	82 17       	cp	r24, r18
     e06:	93 07       	cpc	r25, r19
     e08:	94 f0       	brlt	.+36     	; 0xe2e <__fpcmp_parts_f+0x88>
     e0a:	28 17       	cp	r18, r24
     e0c:	39 07       	cpc	r19, r25
     e0e:	bc f0       	brlt	.+46     	; 0xe3e <__fpcmp_parts_f+0x98>
     e10:	14 96       	adiw	r26, 0x04	; 4
     e12:	8d 91       	ld	r24, X+
     e14:	9d 91       	ld	r25, X+
     e16:	0d 90       	ld	r0, X+
     e18:	bc 91       	ld	r27, X
     e1a:	a0 2d       	mov	r26, r0
     e1c:	24 81       	ldd	r18, Z+4	; 0x04
     e1e:	35 81       	ldd	r19, Z+5	; 0x05
     e20:	46 81       	ldd	r20, Z+6	; 0x06
     e22:	57 81       	ldd	r21, Z+7	; 0x07
     e24:	28 17       	cp	r18, r24
     e26:	39 07       	cpc	r19, r25
     e28:	4a 07       	cpc	r20, r26
     e2a:	5b 07       	cpc	r21, r27
     e2c:	18 f4       	brcc	.+6      	; 0xe34 <__fpcmp_parts_f+0x8e>
     e2e:	11 23       	and	r17, r17
     e30:	41 f0       	breq	.+16     	; 0xe42 <__fpcmp_parts_f+0x9c>
     e32:	0a c0       	rjmp	.+20     	; 0xe48 <__fpcmp_parts_f+0xa2>
     e34:	82 17       	cp	r24, r18
     e36:	93 07       	cpc	r25, r19
     e38:	a4 07       	cpc	r26, r20
     e3a:	b5 07       	cpc	r27, r21
     e3c:	40 f4       	brcc	.+16     	; 0xe4e <__fpcmp_parts_f+0xa8>
     e3e:	11 23       	and	r17, r17
     e40:	19 f0       	breq	.+6      	; 0xe48 <__fpcmp_parts_f+0xa2>
     e42:	61 e0       	ldi	r22, 0x01	; 1
     e44:	70 e0       	ldi	r23, 0x00	; 0
     e46:	05 c0       	rjmp	.+10     	; 0xe52 <__fpcmp_parts_f+0xac>
     e48:	6f ef       	ldi	r22, 0xFF	; 255
     e4a:	7f ef       	ldi	r23, 0xFF	; 255
     e4c:	02 c0       	rjmp	.+4      	; 0xe52 <__fpcmp_parts_f+0xac>
     e4e:	60 e0       	ldi	r22, 0x00	; 0
     e50:	70 e0       	ldi	r23, 0x00	; 0
     e52:	cb 01       	movw	r24, r22
     e54:	1f 91       	pop	r17
     e56:	08 95       	ret

00000e58 <MUSART_VidInit>:

void (*MUSART_CallBack)(void);

/*USART Initialization*/
void MUSART_VidInit(void)
{
     e58:	df 93       	push	r29
     e5a:	cf 93       	push	r28
     e5c:	0f 92       	push	r0
     e5e:	cd b7       	in	r28, 0x3d	; 61
     e60:	de b7       	in	r29, 0x3e	; 62
	u8 LOC_u8Copy_UCSRC=0;
     e62:	19 82       	std	Y+1, r1	; 0x01
	/*Select USART Mode*/
#if USART_SET_MODE==USART_ASYNCHRONOUS_MODE
	CLR_BIT(LOC_u8Copy_UCSRC,6);
     e64:	89 81       	ldd	r24, Y+1	; 0x01
     e66:	8f 7b       	andi	r24, 0xBF	; 191
     e68:	89 83       	std	Y+1, r24	; 0x01
#else
#error"USART Mode Is not valid..."
#endif
	/*Parity Mode*/
#if USART_SET_PARITY_MODE==USART_DISABLED_PARITY
	CLR_BIT(LOC_u8Copy_UCSRC,5);
     e6a:	89 81       	ldd	r24, Y+1	; 0x01
     e6c:	8f 7d       	andi	r24, 0xDF	; 223
     e6e:	89 83       	std	Y+1, r24	; 0x01
	CLR_BIT(LOC_u8Copy_UCSRC,4);
     e70:	89 81       	ldd	r24, Y+1	; 0x01
     e72:	8f 7e       	andi	r24, 0xEF	; 239
     e74:	89 83       	std	Y+1, r24	; 0x01
#else
#error"USART Parity Mode Is not valid..."
#endif
	/*Select Stop Bit*/
#if USART_SET_STOP_BIT==USART_STOP_ONE_BIT
	CLR_BIT(LOC_u8Copy_UCSRC,3);
     e76:	89 81       	ldd	r24, Y+1	; 0x01
     e78:	87 7f       	andi	r24, 0xF7	; 247
     e7a:	89 83       	std	Y+1, r24	; 0x01
#elif USART_SET_CHR_SIZE==USART_CHR_SIZE_7
	SET_BIT(LOC_u8Copy_UCSRC,2);
	CLR_BIT(LOC_u8Copy_UCSRC,1);
	CLR_BIT(UCSRB,2);
#elif USART_SET_CHR_SIZE==USART_CHR_SIZE_8
	SET_BIT(LOC_u8Copy_UCSRC,2);
     e7c:	89 81       	ldd	r24, Y+1	; 0x01
     e7e:	84 60       	ori	r24, 0x04	; 4
     e80:	89 83       	std	Y+1, r24	; 0x01
	SET_BIT(LOC_u8Copy_UCSRC,1);
     e82:	89 81       	ldd	r24, Y+1	; 0x01
     e84:	82 60       	ori	r24, 0x02	; 2
     e86:	89 83       	std	Y+1, r24	; 0x01
	CLR_BIT(UCSRB,2);
     e88:	aa e2       	ldi	r26, 0x2A	; 42
     e8a:	b0 e0       	ldi	r27, 0x00	; 0
     e8c:	ea e2       	ldi	r30, 0x2A	; 42
     e8e:	f0 e0       	ldi	r31, 0x00	; 0
     e90:	80 81       	ld	r24, Z
     e92:	8b 7f       	andi	r24, 0xFB	; 251
     e94:	8c 93       	st	X, r24
	SET_BIT(UCSRB,2);
#else
#error"USART CHR SIZE Is not valid..."
#endif
	/*Set LOC_u8Copy_UCSRC Value in UCSRC Register and select UCSRC Register*/
	SET_BIT(LOC_u8Copy_UCSRC,7);
     e96:	89 81       	ldd	r24, Y+1	; 0x01
     e98:	80 68       	ori	r24, 0x80	; 128
     e9a:	89 83       	std	Y+1, r24	; 0x01
	UCSRC=LOC_u8Copy_UCSRC;
     e9c:	e0 e4       	ldi	r30, 0x40	; 64
     e9e:	f0 e0       	ldi	r31, 0x00	; 0
     ea0:	89 81       	ldd	r24, Y+1	; 0x01
     ea2:	80 83       	st	Z, r24
	/*Set BuadRate -->9600*/
	UBRRL=103;
     ea4:	e9 e2       	ldi	r30, 0x29	; 41
     ea6:	f0 e0       	ldi	r31, 0x00	; 0
     ea8:	87 e6       	ldi	r24, 0x67	; 103
     eaa:	80 83       	st	Z, r24
	/*Enable To TX and RX*/
	SET_BIT(UCSRB,4);
     eac:	aa e2       	ldi	r26, 0x2A	; 42
     eae:	b0 e0       	ldi	r27, 0x00	; 0
     eb0:	ea e2       	ldi	r30, 0x2A	; 42
     eb2:	f0 e0       	ldi	r31, 0x00	; 0
     eb4:	80 81       	ld	r24, Z
     eb6:	80 61       	ori	r24, 0x10	; 16
     eb8:	8c 93       	st	X, r24
	SET_BIT(UCSRB,3);
     eba:	aa e2       	ldi	r26, 0x2A	; 42
     ebc:	b0 e0       	ldi	r27, 0x00	; 0
     ebe:	ea e2       	ldi	r30, 0x2A	; 42
     ec0:	f0 e0       	ldi	r31, 0x00	; 0
     ec2:	80 81       	ld	r24, Z
     ec4:	88 60       	ori	r24, 0x08	; 8
     ec6:	8c 93       	st	X, r24
}
     ec8:	0f 90       	pop	r0
     eca:	cf 91       	pop	r28
     ecc:	df 91       	pop	r29
     ece:	08 95       	ret

00000ed0 <MUSART_VidSendChar>:
/*USART Send Data*/
void MUSART_VidSendChar(u8 Copy_u8Data)
{
     ed0:	df 93       	push	r29
     ed2:	cf 93       	push	r28
     ed4:	0f 92       	push	r0
     ed6:	cd b7       	in	r28, 0x3d	; 61
     ed8:	de b7       	in	r29, 0x3e	; 62
     eda:	89 83       	std	Y+1, r24	; 0x01
	/*Wait until Register Empty Flag is set*/
	while(GET_BIT(UCSRA,5)==0);
     edc:	eb e2       	ldi	r30, 0x2B	; 43
     ede:	f0 e0       	ldi	r31, 0x00	; 0
     ee0:	80 81       	ld	r24, Z
     ee2:	82 95       	swap	r24
     ee4:	86 95       	lsr	r24
     ee6:	87 70       	andi	r24, 0x07	; 7
     ee8:	88 2f       	mov	r24, r24
     eea:	90 e0       	ldi	r25, 0x00	; 0
     eec:	81 70       	andi	r24, 0x01	; 1
     eee:	90 70       	andi	r25, 0x00	; 0
     ef0:	00 97       	sbiw	r24, 0x00	; 0
     ef2:	a1 f3       	breq	.-24     	; 0xedc <MUSART_VidSendChar+0xc>
	UDR=Copy_u8Data;
     ef4:	ec e2       	ldi	r30, 0x2C	; 44
     ef6:	f0 e0       	ldi	r31, 0x00	; 0
     ef8:	89 81       	ldd	r24, Y+1	; 0x01
     efa:	80 83       	st	Z, r24
}
     efc:	0f 90       	pop	r0
     efe:	cf 91       	pop	r28
     f00:	df 91       	pop	r29
     f02:	08 95       	ret

00000f04 <MUSART_u8ReceiveData>:
/*USART Receive Data*/
u8 MUSART_u8ReceiveData(void)
{
     f04:	df 93       	push	r29
     f06:	cf 93       	push	r28
     f08:	cd b7       	in	r28, 0x3d	; 61
     f0a:	de b7       	in	r29, 0x3e	; 62
	/*Wait until Receive Complete Flag is set*/
	while(GET_BIT(UCSRA,7)==0);
     f0c:	eb e2       	ldi	r30, 0x2B	; 43
     f0e:	f0 e0       	ldi	r31, 0x00	; 0
     f10:	80 81       	ld	r24, Z
     f12:	88 23       	and	r24, r24
     f14:	dc f7       	brge	.-10     	; 0xf0c <MUSART_u8ReceiveData+0x8>
	return UDR;
     f16:	ec e2       	ldi	r30, 0x2C	; 44
     f18:	f0 e0       	ldi	r31, 0x00	; 0
     f1a:	80 81       	ld	r24, Z
}
     f1c:	cf 91       	pop	r28
     f1e:	df 91       	pop	r29
     f20:	08 95       	ret

00000f22 <MUSART_VidSendString>:
void MUSART_VidSendString(u8 *Copy_u8Data)
{
     f22:	df 93       	push	r29
     f24:	cf 93       	push	r28
     f26:	00 d0       	rcall	.+0      	; 0xf28 <MUSART_VidSendString+0x6>
     f28:	0f 92       	push	r0
     f2a:	cd b7       	in	r28, 0x3d	; 61
     f2c:	de b7       	in	r29, 0x3e	; 62
     f2e:	9b 83       	std	Y+3, r25	; 0x03
     f30:	8a 83       	std	Y+2, r24	; 0x02
	u8 LOC_CharCount=0;
     f32:	19 82       	std	Y+1, r1	; 0x01
     f34:	0e c0       	rjmp	.+28     	; 0xf52 <MUSART_VidSendString+0x30>
	while(Copy_u8Data[LOC_CharCount]!=NULL)
	{
		MUSART_VidSendChar(Copy_u8Data[LOC_CharCount]);
     f36:	89 81       	ldd	r24, Y+1	; 0x01
     f38:	28 2f       	mov	r18, r24
     f3a:	30 e0       	ldi	r19, 0x00	; 0
     f3c:	8a 81       	ldd	r24, Y+2	; 0x02
     f3e:	9b 81       	ldd	r25, Y+3	; 0x03
     f40:	fc 01       	movw	r30, r24
     f42:	e2 0f       	add	r30, r18
     f44:	f3 1f       	adc	r31, r19
     f46:	80 81       	ld	r24, Z
     f48:	0e 94 68 07 	call	0xed0	; 0xed0 <MUSART_VidSendChar>
		LOC_CharCount++;
     f4c:	89 81       	ldd	r24, Y+1	; 0x01
     f4e:	8f 5f       	subi	r24, 0xFF	; 255
     f50:	89 83       	std	Y+1, r24	; 0x01
	return UDR;
}
void MUSART_VidSendString(u8 *Copy_u8Data)
{
	u8 LOC_CharCount=0;
	while(Copy_u8Data[LOC_CharCount]!=NULL)
     f52:	89 81       	ldd	r24, Y+1	; 0x01
     f54:	28 2f       	mov	r18, r24
     f56:	30 e0       	ldi	r19, 0x00	; 0
     f58:	8a 81       	ldd	r24, Y+2	; 0x02
     f5a:	9b 81       	ldd	r25, Y+3	; 0x03
     f5c:	fc 01       	movw	r30, r24
     f5e:	e2 0f       	add	r30, r18
     f60:	f3 1f       	adc	r31, r19
     f62:	80 81       	ld	r24, Z
     f64:	88 23       	and	r24, r24
     f66:	39 f7       	brne	.-50     	; 0xf36 <MUSART_VidSendString+0x14>
	{
		MUSART_VidSendChar(Copy_u8Data[LOC_CharCount]);
		LOC_CharCount++;
	}
}
     f68:	0f 90       	pop	r0
     f6a:	0f 90       	pop	r0
     f6c:	0f 90       	pop	r0
     f6e:	cf 91       	pop	r28
     f70:	df 91       	pop	r29
     f72:	08 95       	ret

00000f74 <MUSART_VidReceiveString>:
void MUSART_VidReceiveString(u8 *Copy_u8Data)
{
     f74:	0f 93       	push	r16
     f76:	1f 93       	push	r17
     f78:	df 93       	push	r29
     f7a:	cf 93       	push	r28
     f7c:	00 d0       	rcall	.+0      	; 0xf7e <MUSART_VidReceiveString+0xa>
     f7e:	0f 92       	push	r0
     f80:	cd b7       	in	r28, 0x3d	; 61
     f82:	de b7       	in	r29, 0x3e	; 62
     f84:	9b 83       	std	Y+3, r25	; 0x03
     f86:	8a 83       	std	Y+2, r24	; 0x02
	u8 LOC_CharCount=0;
     f88:	19 82       	std	Y+1, r1	; 0x01
	while(1)
	{
		Copy_u8Data[LOC_CharCount]=MUSART_u8ReceiveData();
     f8a:	89 81       	ldd	r24, Y+1	; 0x01
     f8c:	28 2f       	mov	r18, r24
     f8e:	30 e0       	ldi	r19, 0x00	; 0
     f90:	8a 81       	ldd	r24, Y+2	; 0x02
     f92:	9b 81       	ldd	r25, Y+3	; 0x03
     f94:	8c 01       	movw	r16, r24
     f96:	02 0f       	add	r16, r18
     f98:	13 1f       	adc	r17, r19
     f9a:	0e 94 82 07 	call	0xf04	; 0xf04 <MUSART_u8ReceiveData>
     f9e:	f8 01       	movw	r30, r16
     fa0:	80 83       	st	Z, r24
		if(Copy_u8Data[LOC_CharCount]=='\t')
     fa2:	89 81       	ldd	r24, Y+1	; 0x01
     fa4:	28 2f       	mov	r18, r24
     fa6:	30 e0       	ldi	r19, 0x00	; 0
     fa8:	8a 81       	ldd	r24, Y+2	; 0x02
     faa:	9b 81       	ldd	r25, Y+3	; 0x03
     fac:	fc 01       	movw	r30, r24
     fae:	e2 0f       	add	r30, r18
     fb0:	f3 1f       	adc	r31, r19
     fb2:	80 81       	ld	r24, Z
     fb4:	89 30       	cpi	r24, 0x09	; 9
     fb6:	21 f0       	breq	.+8      	; 0xfc0 <MUSART_VidReceiveString+0x4c>
		{
			break;
		}
		LOC_CharCount++;
     fb8:	89 81       	ldd	r24, Y+1	; 0x01
     fba:	8f 5f       	subi	r24, 0xFF	; 255
     fbc:	89 83       	std	Y+1, r24	; 0x01
     fbe:	e5 cf       	rjmp	.-54     	; 0xf8a <MUSART_VidReceiveString+0x16>
	}

}
     fc0:	0f 90       	pop	r0
     fc2:	0f 90       	pop	r0
     fc4:	0f 90       	pop	r0
     fc6:	cf 91       	pop	r28
     fc8:	df 91       	pop	r29
     fca:	1f 91       	pop	r17
     fcc:	0f 91       	pop	r16
     fce:	08 95       	ret

00000fd0 <MUSART_VidUSART_Receive_Interrupt_Enable>:
void MUSART_VidUSART_Receive_Interrupt_Enable(void)
{
     fd0:	df 93       	push	r29
     fd2:	cf 93       	push	r28
     fd4:	cd b7       	in	r28, 0x3d	; 61
     fd6:	de b7       	in	r29, 0x3e	; 62
	SET_BIT(UCSRB,7);
     fd8:	aa e2       	ldi	r26, 0x2A	; 42
     fda:	b0 e0       	ldi	r27, 0x00	; 0
     fdc:	ea e2       	ldi	r30, 0x2A	; 42
     fde:	f0 e0       	ldi	r31, 0x00	; 0
     fe0:	80 81       	ld	r24, Z
     fe2:	80 68       	ori	r24, 0x80	; 128
     fe4:	8c 93       	st	X, r24
}
     fe6:	cf 91       	pop	r28
     fe8:	df 91       	pop	r29
     fea:	08 95       	ret

00000fec <MUSART_VidSetCallBack>:
void MUSART_VidSetCallBack(void (*Copy_pFun)(void))
{
     fec:	df 93       	push	r29
     fee:	cf 93       	push	r28
     ff0:	00 d0       	rcall	.+0      	; 0xff2 <MUSART_VidSetCallBack+0x6>
     ff2:	cd b7       	in	r28, 0x3d	; 61
     ff4:	de b7       	in	r29, 0x3e	; 62
     ff6:	9a 83       	std	Y+2, r25	; 0x02
     ff8:	89 83       	std	Y+1, r24	; 0x01
	MUSART_CallBack=Copy_pFun;
     ffa:	89 81       	ldd	r24, Y+1	; 0x01
     ffc:	9a 81       	ldd	r25, Y+2	; 0x02
     ffe:	90 93 01 08 	sts	0x0801, r25
    1002:	80 93 00 08 	sts	0x0800, r24
}
    1006:	0f 90       	pop	r0
    1008:	0f 90       	pop	r0
    100a:	cf 91       	pop	r28
    100c:	df 91       	pop	r29
    100e:	08 95       	ret

00001010 <__vector_13>:
void __vector_13(void)
{
    1010:	1f 92       	push	r1
    1012:	0f 92       	push	r0
    1014:	0f b6       	in	r0, 0x3f	; 63
    1016:	0f 92       	push	r0
    1018:	11 24       	eor	r1, r1
    101a:	2f 93       	push	r18
    101c:	3f 93       	push	r19
    101e:	4f 93       	push	r20
    1020:	5f 93       	push	r21
    1022:	6f 93       	push	r22
    1024:	7f 93       	push	r23
    1026:	8f 93       	push	r24
    1028:	9f 93       	push	r25
    102a:	af 93       	push	r26
    102c:	bf 93       	push	r27
    102e:	ef 93       	push	r30
    1030:	ff 93       	push	r31
    1032:	df 93       	push	r29
    1034:	cf 93       	push	r28
    1036:	cd b7       	in	r28, 0x3d	; 61
    1038:	de b7       	in	r29, 0x3e	; 62
	MUSART_CallBack();
    103a:	e0 91 00 08 	lds	r30, 0x0800
    103e:	f0 91 01 08 	lds	r31, 0x0801
    1042:	09 95       	icall
}
    1044:	cf 91       	pop	r28
    1046:	df 91       	pop	r29
    1048:	ff 91       	pop	r31
    104a:	ef 91       	pop	r30
    104c:	bf 91       	pop	r27
    104e:	af 91       	pop	r26
    1050:	9f 91       	pop	r25
    1052:	8f 91       	pop	r24
    1054:	7f 91       	pop	r23
    1056:	6f 91       	pop	r22
    1058:	5f 91       	pop	r21
    105a:	4f 91       	pop	r20
    105c:	3f 91       	pop	r19
    105e:	2f 91       	pop	r18
    1060:	0f 90       	pop	r0
    1062:	0f be       	out	0x3f, r0	; 63
    1064:	0f 90       	pop	r0
    1066:	1f 90       	pop	r1
    1068:	18 95       	reti

0000106a <MUSART_u8CompareString>:



u8 MUSART_u8CompareString(u8 *Copy_aReceivedData , u8 *Copy_aData)
{
    106a:	df 93       	push	r29
    106c:	cf 93       	push	r28
    106e:	00 d0       	rcall	.+0      	; 0x1070 <MUSART_u8CompareString+0x6>
    1070:	00 d0       	rcall	.+0      	; 0x1072 <MUSART_u8CompareString+0x8>
    1072:	00 d0       	rcall	.+0      	; 0x1074 <MUSART_u8CompareString+0xa>
    1074:	cd b7       	in	r28, 0x3d	; 61
    1076:	de b7       	in	r29, 0x3e	; 62
    1078:	9c 83       	std	Y+4, r25	; 0x04
    107a:	8b 83       	std	Y+3, r24	; 0x03
    107c:	7e 83       	std	Y+6, r23	; 0x06
    107e:	6d 83       	std	Y+5, r22	; 0x05
	u8 i=0;
    1080:	1a 82       	std	Y+2, r1	; 0x02
	u8 flag=0;
    1082:	19 82       	std	Y+1, r1	; 0x01
    1084:	1b c0       	rjmp	.+54     	; 0x10bc <MUSART_u8CompareString+0x52>
	while((Copy_aData[i]!='\0'))
	{
		if(Copy_aReceivedData[i]==Copy_aData[i])
    1086:	8a 81       	ldd	r24, Y+2	; 0x02
    1088:	28 2f       	mov	r18, r24
    108a:	30 e0       	ldi	r19, 0x00	; 0
    108c:	8b 81       	ldd	r24, Y+3	; 0x03
    108e:	9c 81       	ldd	r25, Y+4	; 0x04
    1090:	fc 01       	movw	r30, r24
    1092:	e2 0f       	add	r30, r18
    1094:	f3 1f       	adc	r31, r19
    1096:	40 81       	ld	r20, Z
    1098:	8a 81       	ldd	r24, Y+2	; 0x02
    109a:	28 2f       	mov	r18, r24
    109c:	30 e0       	ldi	r19, 0x00	; 0
    109e:	8d 81       	ldd	r24, Y+5	; 0x05
    10a0:	9e 81       	ldd	r25, Y+6	; 0x06
    10a2:	fc 01       	movw	r30, r24
    10a4:	e2 0f       	add	r30, r18
    10a6:	f3 1f       	adc	r31, r19
    10a8:	80 81       	ld	r24, Z
    10aa:	48 17       	cp	r20, r24
    10ac:	19 f4       	brne	.+6      	; 0x10b4 <MUSART_u8CompareString+0x4a>
		{
			flag=1;
    10ae:	81 e0       	ldi	r24, 0x01	; 1
    10b0:	89 83       	std	Y+1, r24	; 0x01
    10b2:	01 c0       	rjmp	.+2      	; 0x10b6 <MUSART_u8CompareString+0x4c>
		}else{
			flag=0;
    10b4:	19 82       	std	Y+1, r1	; 0x01
		}
		i++;
    10b6:	8a 81       	ldd	r24, Y+2	; 0x02
    10b8:	8f 5f       	subi	r24, 0xFF	; 255
    10ba:	8a 83       	std	Y+2, r24	; 0x02

u8 MUSART_u8CompareString(u8 *Copy_aReceivedData , u8 *Copy_aData)
{
	u8 i=0;
	u8 flag=0;
	while((Copy_aData[i]!='\0'))
    10bc:	8a 81       	ldd	r24, Y+2	; 0x02
    10be:	28 2f       	mov	r18, r24
    10c0:	30 e0       	ldi	r19, 0x00	; 0
    10c2:	8d 81       	ldd	r24, Y+5	; 0x05
    10c4:	9e 81       	ldd	r25, Y+6	; 0x06
    10c6:	fc 01       	movw	r30, r24
    10c8:	e2 0f       	add	r30, r18
    10ca:	f3 1f       	adc	r31, r19
    10cc:	80 81       	ld	r24, Z
    10ce:	88 23       	and	r24, r24
    10d0:	d1 f6       	brne	.-76     	; 0x1086 <MUSART_u8CompareString+0x1c>
		}else{
			flag=0;
		}
		i++;
	}
	return flag ;
    10d2:	89 81       	ldd	r24, Y+1	; 0x01
}
    10d4:	26 96       	adiw	r28, 0x06	; 6
    10d6:	0f b6       	in	r0, 0x3f	; 63
    10d8:	f8 94       	cli
    10da:	de bf       	out	0x3e, r29	; 62
    10dc:	0f be       	out	0x3f, r0	; 63
    10de:	cd bf       	out	0x3d, r28	; 61
    10e0:	cf 91       	pop	r28
    10e2:	df 91       	pop	r29
    10e4:	08 95       	ret

000010e6 <MGIE_VidEnable>:

#include"MGIE_Private.h"

/*GIE Enable Function*/
void MGIE_VidEnable(void)
{
    10e6:	df 93       	push	r29
    10e8:	cf 93       	push	r28
    10ea:	cd b7       	in	r28, 0x3d	; 61
    10ec:	de b7       	in	r29, 0x3e	; 62
	SET_BIT(SREG,7);
    10ee:	af e5       	ldi	r26, 0x5F	; 95
    10f0:	b0 e0       	ldi	r27, 0x00	; 0
    10f2:	ef e5       	ldi	r30, 0x5F	; 95
    10f4:	f0 e0       	ldi	r31, 0x00	; 0
    10f6:	80 81       	ld	r24, Z
    10f8:	80 68       	ori	r24, 0x80	; 128
    10fa:	8c 93       	st	X, r24
}
    10fc:	cf 91       	pop	r28
    10fe:	df 91       	pop	r29
    1100:	08 95       	ret

00001102 <MGIE_VidDisable>:
/*GIE Disable Function*/
void MGIE_VidDisable(void)
{
    1102:	df 93       	push	r29
    1104:	cf 93       	push	r28
    1106:	cd b7       	in	r28, 0x3d	; 61
    1108:	de b7       	in	r29, 0x3e	; 62
	CLR_BIT(SREG,7);
    110a:	af e5       	ldi	r26, 0x5F	; 95
    110c:	b0 e0       	ldi	r27, 0x00	; 0
    110e:	ef e5       	ldi	r30, 0x5F	; 95
    1110:	f0 e0       	ldi	r31, 0x00	; 0
    1112:	80 81       	ld	r24, Z
    1114:	8f 77       	andi	r24, 0x7F	; 127
    1116:	8c 93       	st	X, r24
}
    1118:	cf 91       	pop	r28
    111a:	df 91       	pop	r29
    111c:	08 95       	ret

0000111e <MDIO_Error_State_SetPinDirection>:
#include"MDIO_Private.h"
#include"MDIO_Interface.h"

/*Set Pin Direction Function */
Error_State MDIO_Error_State_SetPinDirection(u8 Copy_u8PinNumber,u8  Copy_u8PortNumber,u8 Copy_u8PinDirection)
{
    111e:	df 93       	push	r29
    1120:	cf 93       	push	r28
    1122:	00 d0       	rcall	.+0      	; 0x1124 <MDIO_Error_State_SetPinDirection+0x6>
    1124:	00 d0       	rcall	.+0      	; 0x1126 <MDIO_Error_State_SetPinDirection+0x8>
    1126:	00 d0       	rcall	.+0      	; 0x1128 <MDIO_Error_State_SetPinDirection+0xa>
    1128:	cd b7       	in	r28, 0x3d	; 61
    112a:	de b7       	in	r29, 0x3e	; 62
    112c:	8a 83       	std	Y+2, r24	; 0x02
    112e:	6b 83       	std	Y+3, r22	; 0x03
    1130:	4c 83       	std	Y+4, r20	; 0x04
	Error_State LOC_Error_State_ReturnState=OK;
    1132:	81 e0       	ldi	r24, 0x01	; 1
    1134:	89 83       	std	Y+1, r24	; 0x01
	if((Copy_u8PinNumber>=0)&&(Copy_u8PinNumber<8))
    1136:	8a 81       	ldd	r24, Y+2	; 0x02
    1138:	88 30       	cpi	r24, 0x08	; 8
    113a:	08 f0       	brcs	.+2      	; 0x113e <MDIO_Error_State_SetPinDirection+0x20>
    113c:	e8 c0       	rjmp	.+464    	; 0x130e <MDIO_Error_State_SetPinDirection+0x1f0>
	{
		switch(Copy_u8PortNumber)
    113e:	8b 81       	ldd	r24, Y+3	; 0x03
    1140:	28 2f       	mov	r18, r24
    1142:	30 e0       	ldi	r19, 0x00	; 0
    1144:	3e 83       	std	Y+6, r19	; 0x06
    1146:	2d 83       	std	Y+5, r18	; 0x05
    1148:	8d 81       	ldd	r24, Y+5	; 0x05
    114a:	9e 81       	ldd	r25, Y+6	; 0x06
    114c:	81 30       	cpi	r24, 0x01	; 1
    114e:	91 05       	cpc	r25, r1
    1150:	09 f4       	brne	.+2      	; 0x1154 <MDIO_Error_State_SetPinDirection+0x36>
    1152:	48 c0       	rjmp	.+144    	; 0x11e4 <MDIO_Error_State_SetPinDirection+0xc6>
    1154:	2d 81       	ldd	r18, Y+5	; 0x05
    1156:	3e 81       	ldd	r19, Y+6	; 0x06
    1158:	22 30       	cpi	r18, 0x02	; 2
    115a:	31 05       	cpc	r19, r1
    115c:	2c f4       	brge	.+10     	; 0x1168 <MDIO_Error_State_SetPinDirection+0x4a>
    115e:	8d 81       	ldd	r24, Y+5	; 0x05
    1160:	9e 81       	ldd	r25, Y+6	; 0x06
    1162:	00 97       	sbiw	r24, 0x00	; 0
    1164:	71 f0       	breq	.+28     	; 0x1182 <MDIO_Error_State_SetPinDirection+0x64>
    1166:	d1 c0       	rjmp	.+418    	; 0x130a <MDIO_Error_State_SetPinDirection+0x1ec>
    1168:	2d 81       	ldd	r18, Y+5	; 0x05
    116a:	3e 81       	ldd	r19, Y+6	; 0x06
    116c:	22 30       	cpi	r18, 0x02	; 2
    116e:	31 05       	cpc	r19, r1
    1170:	09 f4       	brne	.+2      	; 0x1174 <MDIO_Error_State_SetPinDirection+0x56>
    1172:	69 c0       	rjmp	.+210    	; 0x1246 <MDIO_Error_State_SetPinDirection+0x128>
    1174:	8d 81       	ldd	r24, Y+5	; 0x05
    1176:	9e 81       	ldd	r25, Y+6	; 0x06
    1178:	83 30       	cpi	r24, 0x03	; 3
    117a:	91 05       	cpc	r25, r1
    117c:	09 f4       	brne	.+2      	; 0x1180 <MDIO_Error_State_SetPinDirection+0x62>
    117e:	94 c0       	rjmp	.+296    	; 0x12a8 <MDIO_Error_State_SetPinDirection+0x18a>
    1180:	c4 c0       	rjmp	.+392    	; 0x130a <MDIO_Error_State_SetPinDirection+0x1ec>
		{
		case MDIO_PORTA:
			if(Copy_u8PinDirection==PIN_OUTPUT)
    1182:	8c 81       	ldd	r24, Y+4	; 0x04
    1184:	81 30       	cpi	r24, 0x01	; 1
    1186:	a1 f4       	brne	.+40     	; 0x11b0 <MDIO_Error_State_SetPinDirection+0x92>
			{
				SET_BIT(DDRA,Copy_u8PinNumber);
    1188:	aa e3       	ldi	r26, 0x3A	; 58
    118a:	b0 e0       	ldi	r27, 0x00	; 0
    118c:	ea e3       	ldi	r30, 0x3A	; 58
    118e:	f0 e0       	ldi	r31, 0x00	; 0
    1190:	80 81       	ld	r24, Z
    1192:	48 2f       	mov	r20, r24
    1194:	8a 81       	ldd	r24, Y+2	; 0x02
    1196:	28 2f       	mov	r18, r24
    1198:	30 e0       	ldi	r19, 0x00	; 0
    119a:	81 e0       	ldi	r24, 0x01	; 1
    119c:	90 e0       	ldi	r25, 0x00	; 0
    119e:	02 2e       	mov	r0, r18
    11a0:	02 c0       	rjmp	.+4      	; 0x11a6 <MDIO_Error_State_SetPinDirection+0x88>
    11a2:	88 0f       	add	r24, r24
    11a4:	99 1f       	adc	r25, r25
    11a6:	0a 94       	dec	r0
    11a8:	e2 f7       	brpl	.-8      	; 0x11a2 <MDIO_Error_State_SetPinDirection+0x84>
    11aa:	84 2b       	or	r24, r20
    11ac:	8c 93       	st	X, r24
    11ae:	b0 c0       	rjmp	.+352    	; 0x1310 <MDIO_Error_State_SetPinDirection+0x1f2>
			}
			else if(Copy_u8PinDirection==PIN_INPUT)
    11b0:	8c 81       	ldd	r24, Y+4	; 0x04
    11b2:	88 23       	and	r24, r24
    11b4:	a9 f4       	brne	.+42     	; 0x11e0 <MDIO_Error_State_SetPinDirection+0xc2>
			{
				CLR_BIT(DDRA,Copy_u8PinNumber);
    11b6:	aa e3       	ldi	r26, 0x3A	; 58
    11b8:	b0 e0       	ldi	r27, 0x00	; 0
    11ba:	ea e3       	ldi	r30, 0x3A	; 58
    11bc:	f0 e0       	ldi	r31, 0x00	; 0
    11be:	80 81       	ld	r24, Z
    11c0:	48 2f       	mov	r20, r24
    11c2:	8a 81       	ldd	r24, Y+2	; 0x02
    11c4:	28 2f       	mov	r18, r24
    11c6:	30 e0       	ldi	r19, 0x00	; 0
    11c8:	81 e0       	ldi	r24, 0x01	; 1
    11ca:	90 e0       	ldi	r25, 0x00	; 0
    11cc:	02 2e       	mov	r0, r18
    11ce:	02 c0       	rjmp	.+4      	; 0x11d4 <MDIO_Error_State_SetPinDirection+0xb6>
    11d0:	88 0f       	add	r24, r24
    11d2:	99 1f       	adc	r25, r25
    11d4:	0a 94       	dec	r0
    11d6:	e2 f7       	brpl	.-8      	; 0x11d0 <MDIO_Error_State_SetPinDirection+0xb2>
    11d8:	80 95       	com	r24
    11da:	84 23       	and	r24, r20
    11dc:	8c 93       	st	X, r24
    11de:	98 c0       	rjmp	.+304    	; 0x1310 <MDIO_Error_State_SetPinDirection+0x1f2>
			}
			else
			{
				LOC_Error_State_ReturnState=NOK;
    11e0:	19 82       	std	Y+1, r1	; 0x01
    11e2:	96 c0       	rjmp	.+300    	; 0x1310 <MDIO_Error_State_SetPinDirection+0x1f2>
			}
			break;
		case MDIO_PORTB:
			if(Copy_u8PinDirection==PIN_OUTPUT)
    11e4:	8c 81       	ldd	r24, Y+4	; 0x04
    11e6:	81 30       	cpi	r24, 0x01	; 1
    11e8:	a1 f4       	brne	.+40     	; 0x1212 <MDIO_Error_State_SetPinDirection+0xf4>
			{
				SET_BIT(DDRB,Copy_u8PinNumber);
    11ea:	a7 e3       	ldi	r26, 0x37	; 55
    11ec:	b0 e0       	ldi	r27, 0x00	; 0
    11ee:	e7 e3       	ldi	r30, 0x37	; 55
    11f0:	f0 e0       	ldi	r31, 0x00	; 0
    11f2:	80 81       	ld	r24, Z
    11f4:	48 2f       	mov	r20, r24
    11f6:	8a 81       	ldd	r24, Y+2	; 0x02
    11f8:	28 2f       	mov	r18, r24
    11fa:	30 e0       	ldi	r19, 0x00	; 0
    11fc:	81 e0       	ldi	r24, 0x01	; 1
    11fe:	90 e0       	ldi	r25, 0x00	; 0
    1200:	02 2e       	mov	r0, r18
    1202:	02 c0       	rjmp	.+4      	; 0x1208 <MDIO_Error_State_SetPinDirection+0xea>
    1204:	88 0f       	add	r24, r24
    1206:	99 1f       	adc	r25, r25
    1208:	0a 94       	dec	r0
    120a:	e2 f7       	brpl	.-8      	; 0x1204 <MDIO_Error_State_SetPinDirection+0xe6>
    120c:	84 2b       	or	r24, r20
    120e:	8c 93       	st	X, r24
    1210:	7f c0       	rjmp	.+254    	; 0x1310 <MDIO_Error_State_SetPinDirection+0x1f2>
			}
			else if(Copy_u8PinDirection==PIN_INPUT)
    1212:	8c 81       	ldd	r24, Y+4	; 0x04
    1214:	88 23       	and	r24, r24
    1216:	a9 f4       	brne	.+42     	; 0x1242 <MDIO_Error_State_SetPinDirection+0x124>
			{
				CLR_BIT(DDRB,Copy_u8PinNumber);
    1218:	a7 e3       	ldi	r26, 0x37	; 55
    121a:	b0 e0       	ldi	r27, 0x00	; 0
    121c:	e7 e3       	ldi	r30, 0x37	; 55
    121e:	f0 e0       	ldi	r31, 0x00	; 0
    1220:	80 81       	ld	r24, Z
    1222:	48 2f       	mov	r20, r24
    1224:	8a 81       	ldd	r24, Y+2	; 0x02
    1226:	28 2f       	mov	r18, r24
    1228:	30 e0       	ldi	r19, 0x00	; 0
    122a:	81 e0       	ldi	r24, 0x01	; 1
    122c:	90 e0       	ldi	r25, 0x00	; 0
    122e:	02 2e       	mov	r0, r18
    1230:	02 c0       	rjmp	.+4      	; 0x1236 <MDIO_Error_State_SetPinDirection+0x118>
    1232:	88 0f       	add	r24, r24
    1234:	99 1f       	adc	r25, r25
    1236:	0a 94       	dec	r0
    1238:	e2 f7       	brpl	.-8      	; 0x1232 <MDIO_Error_State_SetPinDirection+0x114>
    123a:	80 95       	com	r24
    123c:	84 23       	and	r24, r20
    123e:	8c 93       	st	X, r24
    1240:	67 c0       	rjmp	.+206    	; 0x1310 <MDIO_Error_State_SetPinDirection+0x1f2>
			}
			else
			{
				LOC_Error_State_ReturnState=NOK;
    1242:	19 82       	std	Y+1, r1	; 0x01
    1244:	65 c0       	rjmp	.+202    	; 0x1310 <MDIO_Error_State_SetPinDirection+0x1f2>
			}
			break;
		case MDIO_PORTC:
			if(Copy_u8PinDirection==PIN_OUTPUT)
    1246:	8c 81       	ldd	r24, Y+4	; 0x04
    1248:	81 30       	cpi	r24, 0x01	; 1
    124a:	a1 f4       	brne	.+40     	; 0x1274 <MDIO_Error_State_SetPinDirection+0x156>
			{
				SET_BIT(DDRC,Copy_u8PinNumber);
    124c:	a4 e3       	ldi	r26, 0x34	; 52
    124e:	b0 e0       	ldi	r27, 0x00	; 0
    1250:	e4 e3       	ldi	r30, 0x34	; 52
    1252:	f0 e0       	ldi	r31, 0x00	; 0
    1254:	80 81       	ld	r24, Z
    1256:	48 2f       	mov	r20, r24
    1258:	8a 81       	ldd	r24, Y+2	; 0x02
    125a:	28 2f       	mov	r18, r24
    125c:	30 e0       	ldi	r19, 0x00	; 0
    125e:	81 e0       	ldi	r24, 0x01	; 1
    1260:	90 e0       	ldi	r25, 0x00	; 0
    1262:	02 2e       	mov	r0, r18
    1264:	02 c0       	rjmp	.+4      	; 0x126a <MDIO_Error_State_SetPinDirection+0x14c>
    1266:	88 0f       	add	r24, r24
    1268:	99 1f       	adc	r25, r25
    126a:	0a 94       	dec	r0
    126c:	e2 f7       	brpl	.-8      	; 0x1266 <MDIO_Error_State_SetPinDirection+0x148>
    126e:	84 2b       	or	r24, r20
    1270:	8c 93       	st	X, r24
    1272:	4e c0       	rjmp	.+156    	; 0x1310 <MDIO_Error_State_SetPinDirection+0x1f2>
			}
			else if(Copy_u8PinDirection==PIN_INPUT)
    1274:	8c 81       	ldd	r24, Y+4	; 0x04
    1276:	88 23       	and	r24, r24
    1278:	a9 f4       	brne	.+42     	; 0x12a4 <MDIO_Error_State_SetPinDirection+0x186>
			{
				CLR_BIT(DDRC,Copy_u8PinNumber);
    127a:	a4 e3       	ldi	r26, 0x34	; 52
    127c:	b0 e0       	ldi	r27, 0x00	; 0
    127e:	e4 e3       	ldi	r30, 0x34	; 52
    1280:	f0 e0       	ldi	r31, 0x00	; 0
    1282:	80 81       	ld	r24, Z
    1284:	48 2f       	mov	r20, r24
    1286:	8a 81       	ldd	r24, Y+2	; 0x02
    1288:	28 2f       	mov	r18, r24
    128a:	30 e0       	ldi	r19, 0x00	; 0
    128c:	81 e0       	ldi	r24, 0x01	; 1
    128e:	90 e0       	ldi	r25, 0x00	; 0
    1290:	02 2e       	mov	r0, r18
    1292:	02 c0       	rjmp	.+4      	; 0x1298 <MDIO_Error_State_SetPinDirection+0x17a>
    1294:	88 0f       	add	r24, r24
    1296:	99 1f       	adc	r25, r25
    1298:	0a 94       	dec	r0
    129a:	e2 f7       	brpl	.-8      	; 0x1294 <MDIO_Error_State_SetPinDirection+0x176>
    129c:	80 95       	com	r24
    129e:	84 23       	and	r24, r20
    12a0:	8c 93       	st	X, r24
    12a2:	36 c0       	rjmp	.+108    	; 0x1310 <MDIO_Error_State_SetPinDirection+0x1f2>
			}
			else
			{
				LOC_Error_State_ReturnState=NOK;
    12a4:	19 82       	std	Y+1, r1	; 0x01
    12a6:	34 c0       	rjmp	.+104    	; 0x1310 <MDIO_Error_State_SetPinDirection+0x1f2>
			}
			break;	
		case MDIO_PORTD:
			if(Copy_u8PinDirection==PIN_OUTPUT)
    12a8:	8c 81       	ldd	r24, Y+4	; 0x04
    12aa:	81 30       	cpi	r24, 0x01	; 1
    12ac:	a1 f4       	brne	.+40     	; 0x12d6 <MDIO_Error_State_SetPinDirection+0x1b8>
			{
				SET_BIT(DDRD,Copy_u8PinNumber);
    12ae:	a1 e3       	ldi	r26, 0x31	; 49
    12b0:	b0 e0       	ldi	r27, 0x00	; 0
    12b2:	e1 e3       	ldi	r30, 0x31	; 49
    12b4:	f0 e0       	ldi	r31, 0x00	; 0
    12b6:	80 81       	ld	r24, Z
    12b8:	48 2f       	mov	r20, r24
    12ba:	8a 81       	ldd	r24, Y+2	; 0x02
    12bc:	28 2f       	mov	r18, r24
    12be:	30 e0       	ldi	r19, 0x00	; 0
    12c0:	81 e0       	ldi	r24, 0x01	; 1
    12c2:	90 e0       	ldi	r25, 0x00	; 0
    12c4:	02 2e       	mov	r0, r18
    12c6:	02 c0       	rjmp	.+4      	; 0x12cc <MDIO_Error_State_SetPinDirection+0x1ae>
    12c8:	88 0f       	add	r24, r24
    12ca:	99 1f       	adc	r25, r25
    12cc:	0a 94       	dec	r0
    12ce:	e2 f7       	brpl	.-8      	; 0x12c8 <MDIO_Error_State_SetPinDirection+0x1aa>
    12d0:	84 2b       	or	r24, r20
    12d2:	8c 93       	st	X, r24
    12d4:	1d c0       	rjmp	.+58     	; 0x1310 <MDIO_Error_State_SetPinDirection+0x1f2>
			}
			else if(Copy_u8PinDirection==PIN_INPUT)
    12d6:	8c 81       	ldd	r24, Y+4	; 0x04
    12d8:	88 23       	and	r24, r24
    12da:	a9 f4       	brne	.+42     	; 0x1306 <MDIO_Error_State_SetPinDirection+0x1e8>
			{
				CLR_BIT(DDRD,Copy_u8PinNumber);
    12dc:	a1 e3       	ldi	r26, 0x31	; 49
    12de:	b0 e0       	ldi	r27, 0x00	; 0
    12e0:	e1 e3       	ldi	r30, 0x31	; 49
    12e2:	f0 e0       	ldi	r31, 0x00	; 0
    12e4:	80 81       	ld	r24, Z
    12e6:	48 2f       	mov	r20, r24
    12e8:	8a 81       	ldd	r24, Y+2	; 0x02
    12ea:	28 2f       	mov	r18, r24
    12ec:	30 e0       	ldi	r19, 0x00	; 0
    12ee:	81 e0       	ldi	r24, 0x01	; 1
    12f0:	90 e0       	ldi	r25, 0x00	; 0
    12f2:	02 2e       	mov	r0, r18
    12f4:	02 c0       	rjmp	.+4      	; 0x12fa <MDIO_Error_State_SetPinDirection+0x1dc>
    12f6:	88 0f       	add	r24, r24
    12f8:	99 1f       	adc	r25, r25
    12fa:	0a 94       	dec	r0
    12fc:	e2 f7       	brpl	.-8      	; 0x12f6 <MDIO_Error_State_SetPinDirection+0x1d8>
    12fe:	80 95       	com	r24
    1300:	84 23       	and	r24, r20
    1302:	8c 93       	st	X, r24
    1304:	05 c0       	rjmp	.+10     	; 0x1310 <MDIO_Error_State_SetPinDirection+0x1f2>
			}
			else
			{
				LOC_Error_State_ReturnState=NOK;
    1306:	19 82       	std	Y+1, r1	; 0x01
    1308:	03 c0       	rjmp	.+6      	; 0x1310 <MDIO_Error_State_SetPinDirection+0x1f2>
			}
			break;
		default:
			LOC_Error_State_ReturnState=NOK;
    130a:	19 82       	std	Y+1, r1	; 0x01
    130c:	01 c0       	rjmp	.+2      	; 0x1310 <MDIO_Error_State_SetPinDirection+0x1f2>
			break;
		}
	}
	else
	{
		LOC_Error_State_ReturnState=NOK;
    130e:	19 82       	std	Y+1, r1	; 0x01
	}

	return LOC_Error_State_ReturnState;
    1310:	89 81       	ldd	r24, Y+1	; 0x01
}
    1312:	26 96       	adiw	r28, 0x06	; 6
    1314:	0f b6       	in	r0, 0x3f	; 63
    1316:	f8 94       	cli
    1318:	de bf       	out	0x3e, r29	; 62
    131a:	0f be       	out	0x3f, r0	; 63
    131c:	cd bf       	out	0x3d, r28	; 61
    131e:	cf 91       	pop	r28
    1320:	df 91       	pop	r29
    1322:	08 95       	ret

00001324 <MDIO_Error_State_SetPortDirection>:
/*Set Port Direction Function */
Error_State MDIO_Error_State_SetPortDirection(u8 Copy_u8PortNumber,u8 Copy_u8PortDirection)
{
    1324:	df 93       	push	r29
    1326:	cf 93       	push	r28
    1328:	00 d0       	rcall	.+0      	; 0x132a <MDIO_Error_State_SetPortDirection+0x6>
    132a:	00 d0       	rcall	.+0      	; 0x132c <MDIO_Error_State_SetPortDirection+0x8>
    132c:	0f 92       	push	r0
    132e:	cd b7       	in	r28, 0x3d	; 61
    1330:	de b7       	in	r29, 0x3e	; 62
    1332:	8a 83       	std	Y+2, r24	; 0x02
    1334:	6b 83       	std	Y+3, r22	; 0x03
	Error_State LOC_Error_State_ReturnState=OK;
    1336:	81 e0       	ldi	r24, 0x01	; 1
    1338:	89 83       	std	Y+1, r24	; 0x01
	if((Copy_u8PortDirection==PORT_OUTPUT)||(Copy_u8PortDirection==PORT_INPUT))
    133a:	8b 81       	ldd	r24, Y+3	; 0x03
    133c:	8f 3f       	cpi	r24, 0xFF	; 255
    133e:	19 f0       	breq	.+6      	; 0x1346 <MDIO_Error_State_SetPortDirection+0x22>
    1340:	8b 81       	ldd	r24, Y+3	; 0x03
    1342:	88 23       	and	r24, r24
    1344:	a9 f5       	brne	.+106    	; 0x13b0 <MDIO_Error_State_SetPortDirection+0x8c>
	{
		switch(Copy_u8PortNumber)
    1346:	8a 81       	ldd	r24, Y+2	; 0x02
    1348:	28 2f       	mov	r18, r24
    134a:	30 e0       	ldi	r19, 0x00	; 0
    134c:	3d 83       	std	Y+5, r19	; 0x05
    134e:	2c 83       	std	Y+4, r18	; 0x04
    1350:	8c 81       	ldd	r24, Y+4	; 0x04
    1352:	9d 81       	ldd	r25, Y+5	; 0x05
    1354:	81 30       	cpi	r24, 0x01	; 1
    1356:	91 05       	cpc	r25, r1
    1358:	d1 f0       	breq	.+52     	; 0x138e <MDIO_Error_State_SetPortDirection+0x6a>
    135a:	2c 81       	ldd	r18, Y+4	; 0x04
    135c:	3d 81       	ldd	r19, Y+5	; 0x05
    135e:	22 30       	cpi	r18, 0x02	; 2
    1360:	31 05       	cpc	r19, r1
    1362:	2c f4       	brge	.+10     	; 0x136e <MDIO_Error_State_SetPortDirection+0x4a>
    1364:	8c 81       	ldd	r24, Y+4	; 0x04
    1366:	9d 81       	ldd	r25, Y+5	; 0x05
    1368:	00 97       	sbiw	r24, 0x00	; 0
    136a:	61 f0       	breq	.+24     	; 0x1384 <MDIO_Error_State_SetPortDirection+0x60>
    136c:	1f c0       	rjmp	.+62     	; 0x13ac <MDIO_Error_State_SetPortDirection+0x88>
    136e:	2c 81       	ldd	r18, Y+4	; 0x04
    1370:	3d 81       	ldd	r19, Y+5	; 0x05
    1372:	22 30       	cpi	r18, 0x02	; 2
    1374:	31 05       	cpc	r19, r1
    1376:	81 f0       	breq	.+32     	; 0x1398 <MDIO_Error_State_SetPortDirection+0x74>
    1378:	8c 81       	ldd	r24, Y+4	; 0x04
    137a:	9d 81       	ldd	r25, Y+5	; 0x05
    137c:	83 30       	cpi	r24, 0x03	; 3
    137e:	91 05       	cpc	r25, r1
    1380:	81 f0       	breq	.+32     	; 0x13a2 <MDIO_Error_State_SetPortDirection+0x7e>
    1382:	14 c0       	rjmp	.+40     	; 0x13ac <MDIO_Error_State_SetPortDirection+0x88>
		{
		case MDIO_PORTA:
			DDRA=Copy_u8PortDirection;
    1384:	ea e3       	ldi	r30, 0x3A	; 58
    1386:	f0 e0       	ldi	r31, 0x00	; 0
    1388:	8b 81       	ldd	r24, Y+3	; 0x03
    138a:	80 83       	st	Z, r24
    138c:	12 c0       	rjmp	.+36     	; 0x13b2 <MDIO_Error_State_SetPortDirection+0x8e>
			break;
		case MDIO_PORTB:
			DDRB=Copy_u8PortDirection;
    138e:	e7 e3       	ldi	r30, 0x37	; 55
    1390:	f0 e0       	ldi	r31, 0x00	; 0
    1392:	8b 81       	ldd	r24, Y+3	; 0x03
    1394:	80 83       	st	Z, r24
    1396:	0d c0       	rjmp	.+26     	; 0x13b2 <MDIO_Error_State_SetPortDirection+0x8e>
			break;
		case MDIO_PORTC:
			DDRC=Copy_u8PortDirection;
    1398:	e4 e3       	ldi	r30, 0x34	; 52
    139a:	f0 e0       	ldi	r31, 0x00	; 0
    139c:	8b 81       	ldd	r24, Y+3	; 0x03
    139e:	80 83       	st	Z, r24
    13a0:	08 c0       	rjmp	.+16     	; 0x13b2 <MDIO_Error_State_SetPortDirection+0x8e>
			break;
		case MDIO_PORTD:
			DDRD=Copy_u8PortDirection;
    13a2:	e1 e3       	ldi	r30, 0x31	; 49
    13a4:	f0 e0       	ldi	r31, 0x00	; 0
    13a6:	8b 81       	ldd	r24, Y+3	; 0x03
    13a8:	80 83       	st	Z, r24
    13aa:	03 c0       	rjmp	.+6      	; 0x13b2 <MDIO_Error_State_SetPortDirection+0x8e>
			break;
		default:
			LOC_Error_State_ReturnState=NOK;
    13ac:	19 82       	std	Y+1, r1	; 0x01
    13ae:	01 c0       	rjmp	.+2      	; 0x13b2 <MDIO_Error_State_SetPortDirection+0x8e>
			break;
		}
	}
	else
	{
		LOC_Error_State_ReturnState=NOK;
    13b0:	19 82       	std	Y+1, r1	; 0x01
	}
	return LOC_Error_State_ReturnState;
    13b2:	89 81       	ldd	r24, Y+1	; 0x01
}
    13b4:	0f 90       	pop	r0
    13b6:	0f 90       	pop	r0
    13b8:	0f 90       	pop	r0
    13ba:	0f 90       	pop	r0
    13bc:	0f 90       	pop	r0
    13be:	cf 91       	pop	r28
    13c0:	df 91       	pop	r29
    13c2:	08 95       	ret

000013c4 <MDIO_Error_State_SetPinValue>:

/*Set Pin Value Function */
Error_State MDIO_Error_State_SetPinValue(u8 Copy_u8PinNumber,u8 Copy_u8PortNumber,u8 Copy_u8PinValue)
{
    13c4:	df 93       	push	r29
    13c6:	cf 93       	push	r28
    13c8:	00 d0       	rcall	.+0      	; 0x13ca <MDIO_Error_State_SetPinValue+0x6>
    13ca:	00 d0       	rcall	.+0      	; 0x13cc <MDIO_Error_State_SetPinValue+0x8>
    13cc:	00 d0       	rcall	.+0      	; 0x13ce <MDIO_Error_State_SetPinValue+0xa>
    13ce:	cd b7       	in	r28, 0x3d	; 61
    13d0:	de b7       	in	r29, 0x3e	; 62
    13d2:	8a 83       	std	Y+2, r24	; 0x02
    13d4:	6b 83       	std	Y+3, r22	; 0x03
    13d6:	4c 83       	std	Y+4, r20	; 0x04
	Error_State LOC_Error_State_ReturnState=OK;
    13d8:	81 e0       	ldi	r24, 0x01	; 1
    13da:	89 83       	std	Y+1, r24	; 0x01

	if((Copy_u8PinNumber>=0)&&(Copy_u8PinNumber<8))
    13dc:	8a 81       	ldd	r24, Y+2	; 0x02
    13de:	88 30       	cpi	r24, 0x08	; 8
    13e0:	08 f0       	brcs	.+2      	; 0x13e4 <MDIO_Error_State_SetPinValue+0x20>
    13e2:	e8 c0       	rjmp	.+464    	; 0x15b4 <MDIO_Error_State_SetPinValue+0x1f0>
	{
		switch(Copy_u8PortNumber)
    13e4:	8b 81       	ldd	r24, Y+3	; 0x03
    13e6:	28 2f       	mov	r18, r24
    13e8:	30 e0       	ldi	r19, 0x00	; 0
    13ea:	3e 83       	std	Y+6, r19	; 0x06
    13ec:	2d 83       	std	Y+5, r18	; 0x05
    13ee:	8d 81       	ldd	r24, Y+5	; 0x05
    13f0:	9e 81       	ldd	r25, Y+6	; 0x06
    13f2:	81 30       	cpi	r24, 0x01	; 1
    13f4:	91 05       	cpc	r25, r1
    13f6:	09 f4       	brne	.+2      	; 0x13fa <MDIO_Error_State_SetPinValue+0x36>
    13f8:	48 c0       	rjmp	.+144    	; 0x148a <MDIO_Error_State_SetPinValue+0xc6>
    13fa:	2d 81       	ldd	r18, Y+5	; 0x05
    13fc:	3e 81       	ldd	r19, Y+6	; 0x06
    13fe:	22 30       	cpi	r18, 0x02	; 2
    1400:	31 05       	cpc	r19, r1
    1402:	2c f4       	brge	.+10     	; 0x140e <MDIO_Error_State_SetPinValue+0x4a>
    1404:	8d 81       	ldd	r24, Y+5	; 0x05
    1406:	9e 81       	ldd	r25, Y+6	; 0x06
    1408:	00 97       	sbiw	r24, 0x00	; 0
    140a:	71 f0       	breq	.+28     	; 0x1428 <MDIO_Error_State_SetPinValue+0x64>
    140c:	d1 c0       	rjmp	.+418    	; 0x15b0 <MDIO_Error_State_SetPinValue+0x1ec>
    140e:	2d 81       	ldd	r18, Y+5	; 0x05
    1410:	3e 81       	ldd	r19, Y+6	; 0x06
    1412:	22 30       	cpi	r18, 0x02	; 2
    1414:	31 05       	cpc	r19, r1
    1416:	09 f4       	brne	.+2      	; 0x141a <MDIO_Error_State_SetPinValue+0x56>
    1418:	69 c0       	rjmp	.+210    	; 0x14ec <MDIO_Error_State_SetPinValue+0x128>
    141a:	8d 81       	ldd	r24, Y+5	; 0x05
    141c:	9e 81       	ldd	r25, Y+6	; 0x06
    141e:	83 30       	cpi	r24, 0x03	; 3
    1420:	91 05       	cpc	r25, r1
    1422:	09 f4       	brne	.+2      	; 0x1426 <MDIO_Error_State_SetPinValue+0x62>
    1424:	94 c0       	rjmp	.+296    	; 0x154e <MDIO_Error_State_SetPinValue+0x18a>
    1426:	c4 c0       	rjmp	.+392    	; 0x15b0 <MDIO_Error_State_SetPinValue+0x1ec>
		{
		case MDIO_PORTA:
			if(Copy_u8PinValue==PIN_HIGH)
    1428:	8c 81       	ldd	r24, Y+4	; 0x04
    142a:	81 30       	cpi	r24, 0x01	; 1
    142c:	a1 f4       	brne	.+40     	; 0x1456 <MDIO_Error_State_SetPinValue+0x92>
			{
				SET_BIT(PORTA,Copy_u8PinNumber);
    142e:	ab e3       	ldi	r26, 0x3B	; 59
    1430:	b0 e0       	ldi	r27, 0x00	; 0
    1432:	eb e3       	ldi	r30, 0x3B	; 59
    1434:	f0 e0       	ldi	r31, 0x00	; 0
    1436:	80 81       	ld	r24, Z
    1438:	48 2f       	mov	r20, r24
    143a:	8a 81       	ldd	r24, Y+2	; 0x02
    143c:	28 2f       	mov	r18, r24
    143e:	30 e0       	ldi	r19, 0x00	; 0
    1440:	81 e0       	ldi	r24, 0x01	; 1
    1442:	90 e0       	ldi	r25, 0x00	; 0
    1444:	02 2e       	mov	r0, r18
    1446:	02 c0       	rjmp	.+4      	; 0x144c <MDIO_Error_State_SetPinValue+0x88>
    1448:	88 0f       	add	r24, r24
    144a:	99 1f       	adc	r25, r25
    144c:	0a 94       	dec	r0
    144e:	e2 f7       	brpl	.-8      	; 0x1448 <MDIO_Error_State_SetPinValue+0x84>
    1450:	84 2b       	or	r24, r20
    1452:	8c 93       	st	X, r24
    1454:	b0 c0       	rjmp	.+352    	; 0x15b6 <MDIO_Error_State_SetPinValue+0x1f2>
			}
			else if(Copy_u8PinValue==PIN_LOW)
    1456:	8c 81       	ldd	r24, Y+4	; 0x04
    1458:	88 23       	and	r24, r24
    145a:	a9 f4       	brne	.+42     	; 0x1486 <MDIO_Error_State_SetPinValue+0xc2>
			{
				CLR_BIT(PORTA,Copy_u8PinNumber);
    145c:	ab e3       	ldi	r26, 0x3B	; 59
    145e:	b0 e0       	ldi	r27, 0x00	; 0
    1460:	eb e3       	ldi	r30, 0x3B	; 59
    1462:	f0 e0       	ldi	r31, 0x00	; 0
    1464:	80 81       	ld	r24, Z
    1466:	48 2f       	mov	r20, r24
    1468:	8a 81       	ldd	r24, Y+2	; 0x02
    146a:	28 2f       	mov	r18, r24
    146c:	30 e0       	ldi	r19, 0x00	; 0
    146e:	81 e0       	ldi	r24, 0x01	; 1
    1470:	90 e0       	ldi	r25, 0x00	; 0
    1472:	02 2e       	mov	r0, r18
    1474:	02 c0       	rjmp	.+4      	; 0x147a <MDIO_Error_State_SetPinValue+0xb6>
    1476:	88 0f       	add	r24, r24
    1478:	99 1f       	adc	r25, r25
    147a:	0a 94       	dec	r0
    147c:	e2 f7       	brpl	.-8      	; 0x1476 <MDIO_Error_State_SetPinValue+0xb2>
    147e:	80 95       	com	r24
    1480:	84 23       	and	r24, r20
    1482:	8c 93       	st	X, r24
    1484:	98 c0       	rjmp	.+304    	; 0x15b6 <MDIO_Error_State_SetPinValue+0x1f2>
			}
			else
			{
				LOC_Error_State_ReturnState=NOK;
    1486:	19 82       	std	Y+1, r1	; 0x01
    1488:	96 c0       	rjmp	.+300    	; 0x15b6 <MDIO_Error_State_SetPinValue+0x1f2>
			}
			break;
		case MDIO_PORTB:
			if(Copy_u8PinValue==PIN_HIGH)
    148a:	8c 81       	ldd	r24, Y+4	; 0x04
    148c:	81 30       	cpi	r24, 0x01	; 1
    148e:	a1 f4       	brne	.+40     	; 0x14b8 <MDIO_Error_State_SetPinValue+0xf4>
			{
				SET_BIT(PORTB,Copy_u8PinNumber);
    1490:	a8 e3       	ldi	r26, 0x38	; 56
    1492:	b0 e0       	ldi	r27, 0x00	; 0
    1494:	e8 e3       	ldi	r30, 0x38	; 56
    1496:	f0 e0       	ldi	r31, 0x00	; 0
    1498:	80 81       	ld	r24, Z
    149a:	48 2f       	mov	r20, r24
    149c:	8a 81       	ldd	r24, Y+2	; 0x02
    149e:	28 2f       	mov	r18, r24
    14a0:	30 e0       	ldi	r19, 0x00	; 0
    14a2:	81 e0       	ldi	r24, 0x01	; 1
    14a4:	90 e0       	ldi	r25, 0x00	; 0
    14a6:	02 2e       	mov	r0, r18
    14a8:	02 c0       	rjmp	.+4      	; 0x14ae <MDIO_Error_State_SetPinValue+0xea>
    14aa:	88 0f       	add	r24, r24
    14ac:	99 1f       	adc	r25, r25
    14ae:	0a 94       	dec	r0
    14b0:	e2 f7       	brpl	.-8      	; 0x14aa <MDIO_Error_State_SetPinValue+0xe6>
    14b2:	84 2b       	or	r24, r20
    14b4:	8c 93       	st	X, r24
    14b6:	7f c0       	rjmp	.+254    	; 0x15b6 <MDIO_Error_State_SetPinValue+0x1f2>
			}
			else if(Copy_u8PinValue==PIN_LOW)
    14b8:	8c 81       	ldd	r24, Y+4	; 0x04
    14ba:	88 23       	and	r24, r24
    14bc:	a9 f4       	brne	.+42     	; 0x14e8 <MDIO_Error_State_SetPinValue+0x124>
			{
				CLR_BIT(PORTB,Copy_u8PinNumber);
    14be:	a8 e3       	ldi	r26, 0x38	; 56
    14c0:	b0 e0       	ldi	r27, 0x00	; 0
    14c2:	e8 e3       	ldi	r30, 0x38	; 56
    14c4:	f0 e0       	ldi	r31, 0x00	; 0
    14c6:	80 81       	ld	r24, Z
    14c8:	48 2f       	mov	r20, r24
    14ca:	8a 81       	ldd	r24, Y+2	; 0x02
    14cc:	28 2f       	mov	r18, r24
    14ce:	30 e0       	ldi	r19, 0x00	; 0
    14d0:	81 e0       	ldi	r24, 0x01	; 1
    14d2:	90 e0       	ldi	r25, 0x00	; 0
    14d4:	02 2e       	mov	r0, r18
    14d6:	02 c0       	rjmp	.+4      	; 0x14dc <MDIO_Error_State_SetPinValue+0x118>
    14d8:	88 0f       	add	r24, r24
    14da:	99 1f       	adc	r25, r25
    14dc:	0a 94       	dec	r0
    14de:	e2 f7       	brpl	.-8      	; 0x14d8 <MDIO_Error_State_SetPinValue+0x114>
    14e0:	80 95       	com	r24
    14e2:	84 23       	and	r24, r20
    14e4:	8c 93       	st	X, r24
    14e6:	67 c0       	rjmp	.+206    	; 0x15b6 <MDIO_Error_State_SetPinValue+0x1f2>
			}
			else
			{
				LOC_Error_State_ReturnState=NOK;
    14e8:	19 82       	std	Y+1, r1	; 0x01
    14ea:	65 c0       	rjmp	.+202    	; 0x15b6 <MDIO_Error_State_SetPinValue+0x1f2>
			}
			break;
		case MDIO_PORTC:
			if(Copy_u8PinValue==PIN_HIGH)
    14ec:	8c 81       	ldd	r24, Y+4	; 0x04
    14ee:	81 30       	cpi	r24, 0x01	; 1
    14f0:	a1 f4       	brne	.+40     	; 0x151a <MDIO_Error_State_SetPinValue+0x156>
			{
				SET_BIT(PORTC,Copy_u8PinNumber);
    14f2:	a5 e3       	ldi	r26, 0x35	; 53
    14f4:	b0 e0       	ldi	r27, 0x00	; 0
    14f6:	e5 e3       	ldi	r30, 0x35	; 53
    14f8:	f0 e0       	ldi	r31, 0x00	; 0
    14fa:	80 81       	ld	r24, Z
    14fc:	48 2f       	mov	r20, r24
    14fe:	8a 81       	ldd	r24, Y+2	; 0x02
    1500:	28 2f       	mov	r18, r24
    1502:	30 e0       	ldi	r19, 0x00	; 0
    1504:	81 e0       	ldi	r24, 0x01	; 1
    1506:	90 e0       	ldi	r25, 0x00	; 0
    1508:	02 2e       	mov	r0, r18
    150a:	02 c0       	rjmp	.+4      	; 0x1510 <MDIO_Error_State_SetPinValue+0x14c>
    150c:	88 0f       	add	r24, r24
    150e:	99 1f       	adc	r25, r25
    1510:	0a 94       	dec	r0
    1512:	e2 f7       	brpl	.-8      	; 0x150c <MDIO_Error_State_SetPinValue+0x148>
    1514:	84 2b       	or	r24, r20
    1516:	8c 93       	st	X, r24
    1518:	4e c0       	rjmp	.+156    	; 0x15b6 <MDIO_Error_State_SetPinValue+0x1f2>
			}
			else if(Copy_u8PinValue==PIN_LOW)
    151a:	8c 81       	ldd	r24, Y+4	; 0x04
    151c:	88 23       	and	r24, r24
    151e:	a9 f4       	brne	.+42     	; 0x154a <MDIO_Error_State_SetPinValue+0x186>
			{
				CLR_BIT(PORTC,Copy_u8PinNumber);
    1520:	a5 e3       	ldi	r26, 0x35	; 53
    1522:	b0 e0       	ldi	r27, 0x00	; 0
    1524:	e5 e3       	ldi	r30, 0x35	; 53
    1526:	f0 e0       	ldi	r31, 0x00	; 0
    1528:	80 81       	ld	r24, Z
    152a:	48 2f       	mov	r20, r24
    152c:	8a 81       	ldd	r24, Y+2	; 0x02
    152e:	28 2f       	mov	r18, r24
    1530:	30 e0       	ldi	r19, 0x00	; 0
    1532:	81 e0       	ldi	r24, 0x01	; 1
    1534:	90 e0       	ldi	r25, 0x00	; 0
    1536:	02 2e       	mov	r0, r18
    1538:	02 c0       	rjmp	.+4      	; 0x153e <MDIO_Error_State_SetPinValue+0x17a>
    153a:	88 0f       	add	r24, r24
    153c:	99 1f       	adc	r25, r25
    153e:	0a 94       	dec	r0
    1540:	e2 f7       	brpl	.-8      	; 0x153a <MDIO_Error_State_SetPinValue+0x176>
    1542:	80 95       	com	r24
    1544:	84 23       	and	r24, r20
    1546:	8c 93       	st	X, r24
    1548:	36 c0       	rjmp	.+108    	; 0x15b6 <MDIO_Error_State_SetPinValue+0x1f2>
			}
			else
			{
				LOC_Error_State_ReturnState=NOK;
    154a:	19 82       	std	Y+1, r1	; 0x01
    154c:	34 c0       	rjmp	.+104    	; 0x15b6 <MDIO_Error_State_SetPinValue+0x1f2>
			}
			break;	
		case MDIO_PORTD:
			if(Copy_u8PinValue==PIN_HIGH)
    154e:	8c 81       	ldd	r24, Y+4	; 0x04
    1550:	81 30       	cpi	r24, 0x01	; 1
    1552:	a1 f4       	brne	.+40     	; 0x157c <MDIO_Error_State_SetPinValue+0x1b8>
			{
				SET_BIT(PORTD,Copy_u8PinNumber);
    1554:	a2 e3       	ldi	r26, 0x32	; 50
    1556:	b0 e0       	ldi	r27, 0x00	; 0
    1558:	e2 e3       	ldi	r30, 0x32	; 50
    155a:	f0 e0       	ldi	r31, 0x00	; 0
    155c:	80 81       	ld	r24, Z
    155e:	48 2f       	mov	r20, r24
    1560:	8a 81       	ldd	r24, Y+2	; 0x02
    1562:	28 2f       	mov	r18, r24
    1564:	30 e0       	ldi	r19, 0x00	; 0
    1566:	81 e0       	ldi	r24, 0x01	; 1
    1568:	90 e0       	ldi	r25, 0x00	; 0
    156a:	02 2e       	mov	r0, r18
    156c:	02 c0       	rjmp	.+4      	; 0x1572 <MDIO_Error_State_SetPinValue+0x1ae>
    156e:	88 0f       	add	r24, r24
    1570:	99 1f       	adc	r25, r25
    1572:	0a 94       	dec	r0
    1574:	e2 f7       	brpl	.-8      	; 0x156e <MDIO_Error_State_SetPinValue+0x1aa>
    1576:	84 2b       	or	r24, r20
    1578:	8c 93       	st	X, r24
    157a:	1d c0       	rjmp	.+58     	; 0x15b6 <MDIO_Error_State_SetPinValue+0x1f2>
			}
			else if(Copy_u8PinValue==PIN_LOW)
    157c:	8c 81       	ldd	r24, Y+4	; 0x04
    157e:	88 23       	and	r24, r24
    1580:	a9 f4       	brne	.+42     	; 0x15ac <MDIO_Error_State_SetPinValue+0x1e8>
			{
				CLR_BIT(PORTD,Copy_u8PinNumber);
    1582:	a2 e3       	ldi	r26, 0x32	; 50
    1584:	b0 e0       	ldi	r27, 0x00	; 0
    1586:	e2 e3       	ldi	r30, 0x32	; 50
    1588:	f0 e0       	ldi	r31, 0x00	; 0
    158a:	80 81       	ld	r24, Z
    158c:	48 2f       	mov	r20, r24
    158e:	8a 81       	ldd	r24, Y+2	; 0x02
    1590:	28 2f       	mov	r18, r24
    1592:	30 e0       	ldi	r19, 0x00	; 0
    1594:	81 e0       	ldi	r24, 0x01	; 1
    1596:	90 e0       	ldi	r25, 0x00	; 0
    1598:	02 2e       	mov	r0, r18
    159a:	02 c0       	rjmp	.+4      	; 0x15a0 <MDIO_Error_State_SetPinValue+0x1dc>
    159c:	88 0f       	add	r24, r24
    159e:	99 1f       	adc	r25, r25
    15a0:	0a 94       	dec	r0
    15a2:	e2 f7       	brpl	.-8      	; 0x159c <MDIO_Error_State_SetPinValue+0x1d8>
    15a4:	80 95       	com	r24
    15a6:	84 23       	and	r24, r20
    15a8:	8c 93       	st	X, r24
    15aa:	05 c0       	rjmp	.+10     	; 0x15b6 <MDIO_Error_State_SetPinValue+0x1f2>
			}
			else
			{
				LOC_Error_State_ReturnState=NOK;
    15ac:	19 82       	std	Y+1, r1	; 0x01
    15ae:	03 c0       	rjmp	.+6      	; 0x15b6 <MDIO_Error_State_SetPinValue+0x1f2>
			}
			break;
		default:
			LOC_Error_State_ReturnState=NOK;
    15b0:	19 82       	std	Y+1, r1	; 0x01
    15b2:	01 c0       	rjmp	.+2      	; 0x15b6 <MDIO_Error_State_SetPinValue+0x1f2>
			break;
		}
	}
	else
	{
		LOC_Error_State_ReturnState=NOK;
    15b4:	19 82       	std	Y+1, r1	; 0x01
	}

	return LOC_Error_State_ReturnState;
    15b6:	89 81       	ldd	r24, Y+1	; 0x01
}
    15b8:	26 96       	adiw	r28, 0x06	; 6
    15ba:	0f b6       	in	r0, 0x3f	; 63
    15bc:	f8 94       	cli
    15be:	de bf       	out	0x3e, r29	; 62
    15c0:	0f be       	out	0x3f, r0	; 63
    15c2:	cd bf       	out	0x3d, r28	; 61
    15c4:	cf 91       	pop	r28
    15c6:	df 91       	pop	r29
    15c8:	08 95       	ret

000015ca <MDIO_Error_State_SetPortValue>:

/*Set Port Value Function */
Error_State MDIO_Error_State_SetPortValue(u8 Copy_u8PortNumber,u8 Copy_u8PortValue)
{
    15ca:	df 93       	push	r29
    15cc:	cf 93       	push	r28
    15ce:	00 d0       	rcall	.+0      	; 0x15d0 <MDIO_Error_State_SetPortValue+0x6>
    15d0:	00 d0       	rcall	.+0      	; 0x15d2 <MDIO_Error_State_SetPortValue+0x8>
    15d2:	0f 92       	push	r0
    15d4:	cd b7       	in	r28, 0x3d	; 61
    15d6:	de b7       	in	r29, 0x3e	; 62
    15d8:	8a 83       	std	Y+2, r24	; 0x02
    15da:	6b 83       	std	Y+3, r22	; 0x03
	Error_State LOC_Error_State_ReturnState=OK;
    15dc:	81 e0       	ldi	r24, 0x01	; 1
    15de:	89 83       	std	Y+1, r24	; 0x01
	switch(Copy_u8PortNumber)
    15e0:	8a 81       	ldd	r24, Y+2	; 0x02
    15e2:	28 2f       	mov	r18, r24
    15e4:	30 e0       	ldi	r19, 0x00	; 0
    15e6:	3d 83       	std	Y+5, r19	; 0x05
    15e8:	2c 83       	std	Y+4, r18	; 0x04
    15ea:	8c 81       	ldd	r24, Y+4	; 0x04
    15ec:	9d 81       	ldd	r25, Y+5	; 0x05
    15ee:	81 30       	cpi	r24, 0x01	; 1
    15f0:	91 05       	cpc	r25, r1
    15f2:	d1 f0       	breq	.+52     	; 0x1628 <MDIO_Error_State_SetPortValue+0x5e>
    15f4:	2c 81       	ldd	r18, Y+4	; 0x04
    15f6:	3d 81       	ldd	r19, Y+5	; 0x05
    15f8:	22 30       	cpi	r18, 0x02	; 2
    15fa:	31 05       	cpc	r19, r1
    15fc:	2c f4       	brge	.+10     	; 0x1608 <MDIO_Error_State_SetPortValue+0x3e>
    15fe:	8c 81       	ldd	r24, Y+4	; 0x04
    1600:	9d 81       	ldd	r25, Y+5	; 0x05
    1602:	00 97       	sbiw	r24, 0x00	; 0
    1604:	61 f0       	breq	.+24     	; 0x161e <MDIO_Error_State_SetPortValue+0x54>
    1606:	1f c0       	rjmp	.+62     	; 0x1646 <MDIO_Error_State_SetPortValue+0x7c>
    1608:	2c 81       	ldd	r18, Y+4	; 0x04
    160a:	3d 81       	ldd	r19, Y+5	; 0x05
    160c:	22 30       	cpi	r18, 0x02	; 2
    160e:	31 05       	cpc	r19, r1
    1610:	81 f0       	breq	.+32     	; 0x1632 <MDIO_Error_State_SetPortValue+0x68>
    1612:	8c 81       	ldd	r24, Y+4	; 0x04
    1614:	9d 81       	ldd	r25, Y+5	; 0x05
    1616:	83 30       	cpi	r24, 0x03	; 3
    1618:	91 05       	cpc	r25, r1
    161a:	81 f0       	breq	.+32     	; 0x163c <MDIO_Error_State_SetPortValue+0x72>
    161c:	14 c0       	rjmp	.+40     	; 0x1646 <MDIO_Error_State_SetPortValue+0x7c>
	{
	case MDIO_PORTA:
		PORTA=Copy_u8PortValue;
    161e:	eb e3       	ldi	r30, 0x3B	; 59
    1620:	f0 e0       	ldi	r31, 0x00	; 0
    1622:	8b 81       	ldd	r24, Y+3	; 0x03
    1624:	80 83       	st	Z, r24
    1626:	10 c0       	rjmp	.+32     	; 0x1648 <MDIO_Error_State_SetPortValue+0x7e>
		break;
	case MDIO_PORTB:
		PORTB=Copy_u8PortValue;
    1628:	e8 e3       	ldi	r30, 0x38	; 56
    162a:	f0 e0       	ldi	r31, 0x00	; 0
    162c:	8b 81       	ldd	r24, Y+3	; 0x03
    162e:	80 83       	st	Z, r24
    1630:	0b c0       	rjmp	.+22     	; 0x1648 <MDIO_Error_State_SetPortValue+0x7e>
		break;
	case MDIO_PORTC:
		PORTC=Copy_u8PortValue;
    1632:	e5 e3       	ldi	r30, 0x35	; 53
    1634:	f0 e0       	ldi	r31, 0x00	; 0
    1636:	8b 81       	ldd	r24, Y+3	; 0x03
    1638:	80 83       	st	Z, r24
    163a:	06 c0       	rjmp	.+12     	; 0x1648 <MDIO_Error_State_SetPortValue+0x7e>
		break;	
	case MDIO_PORTD:
		PORTD=Copy_u8PortValue;
    163c:	e2 e3       	ldi	r30, 0x32	; 50
    163e:	f0 e0       	ldi	r31, 0x00	; 0
    1640:	8b 81       	ldd	r24, Y+3	; 0x03
    1642:	80 83       	st	Z, r24
    1644:	01 c0       	rjmp	.+2      	; 0x1648 <MDIO_Error_State_SetPortValue+0x7e>
		break;	
	default:
		LOC_Error_State_ReturnState=NOK;
    1646:	19 82       	std	Y+1, r1	; 0x01
		break;
	}
	return LOC_Error_State_ReturnState;
    1648:	89 81       	ldd	r24, Y+1	; 0x01
}
    164a:	0f 90       	pop	r0
    164c:	0f 90       	pop	r0
    164e:	0f 90       	pop	r0
    1650:	0f 90       	pop	r0
    1652:	0f 90       	pop	r0
    1654:	cf 91       	pop	r28
    1656:	df 91       	pop	r29
    1658:	08 95       	ret

0000165a <MDIO_Error_State_GetPinValue>:

/*Get Pin Value Function */
Error_State MDIO_Error_State_GetPinValue(u8 Copy_u8PinNumber,u8 Copy_u8PortNumber,u8* P_u8PinValue)
{
    165a:	df 93       	push	r29
    165c:	cf 93       	push	r28
    165e:	cd b7       	in	r28, 0x3d	; 61
    1660:	de b7       	in	r29, 0x3e	; 62
    1662:	27 97       	sbiw	r28, 0x07	; 7
    1664:	0f b6       	in	r0, 0x3f	; 63
    1666:	f8 94       	cli
    1668:	de bf       	out	0x3e, r29	; 62
    166a:	0f be       	out	0x3f, r0	; 63
    166c:	cd bf       	out	0x3d, r28	; 61
    166e:	8a 83       	std	Y+2, r24	; 0x02
    1670:	6b 83       	std	Y+3, r22	; 0x03
    1672:	5d 83       	std	Y+5, r21	; 0x05
    1674:	4c 83       	std	Y+4, r20	; 0x04
	Error_State LOC_Error_State_ReturnState=OK;
    1676:	81 e0       	ldi	r24, 0x01	; 1
    1678:	89 83       	std	Y+1, r24	; 0x01

	if(((Copy_u8PinNumber>=0)&&(Copy_u8PinNumber<8))&&(P_u8PinValue!=NULL_POINTER))
    167a:	8a 81       	ldd	r24, Y+2	; 0x02
    167c:	88 30       	cpi	r24, 0x08	; 8
    167e:	08 f0       	brcs	.+2      	; 0x1682 <MDIO_Error_State_GetPinValue+0x28>
    1680:	79 c0       	rjmp	.+242    	; 0x1774 <MDIO_Error_State_GetPinValue+0x11a>
    1682:	8c 81       	ldd	r24, Y+4	; 0x04
    1684:	9d 81       	ldd	r25, Y+5	; 0x05
    1686:	81 30       	cpi	r24, 0x01	; 1
    1688:	91 05       	cpc	r25, r1
    168a:	09 f4       	brne	.+2      	; 0x168e <MDIO_Error_State_GetPinValue+0x34>
    168c:	73 c0       	rjmp	.+230    	; 0x1774 <MDIO_Error_State_GetPinValue+0x11a>
	{
		switch(Copy_u8PortNumber)
    168e:	8b 81       	ldd	r24, Y+3	; 0x03
    1690:	28 2f       	mov	r18, r24
    1692:	30 e0       	ldi	r19, 0x00	; 0
    1694:	3f 83       	std	Y+7, r19	; 0x07
    1696:	2e 83       	std	Y+6, r18	; 0x06
    1698:	4e 81       	ldd	r20, Y+6	; 0x06
    169a:	5f 81       	ldd	r21, Y+7	; 0x07
    169c:	41 30       	cpi	r20, 0x01	; 1
    169e:	51 05       	cpc	r21, r1
    16a0:	59 f1       	breq	.+86     	; 0x16f8 <MDIO_Error_State_GetPinValue+0x9e>
    16a2:	8e 81       	ldd	r24, Y+6	; 0x06
    16a4:	9f 81       	ldd	r25, Y+7	; 0x07
    16a6:	82 30       	cpi	r24, 0x02	; 2
    16a8:	91 05       	cpc	r25, r1
    16aa:	34 f4       	brge	.+12     	; 0x16b8 <MDIO_Error_State_GetPinValue+0x5e>
    16ac:	2e 81       	ldd	r18, Y+6	; 0x06
    16ae:	3f 81       	ldd	r19, Y+7	; 0x07
    16b0:	21 15       	cp	r18, r1
    16b2:	31 05       	cpc	r19, r1
    16b4:	69 f0       	breq	.+26     	; 0x16d0 <MDIO_Error_State_GetPinValue+0x76>
    16b6:	5c c0       	rjmp	.+184    	; 0x1770 <MDIO_Error_State_GetPinValue+0x116>
    16b8:	4e 81       	ldd	r20, Y+6	; 0x06
    16ba:	5f 81       	ldd	r21, Y+7	; 0x07
    16bc:	42 30       	cpi	r20, 0x02	; 2
    16be:	51 05       	cpc	r21, r1
    16c0:	79 f1       	breq	.+94     	; 0x1720 <MDIO_Error_State_GetPinValue+0xc6>
    16c2:	8e 81       	ldd	r24, Y+6	; 0x06
    16c4:	9f 81       	ldd	r25, Y+7	; 0x07
    16c6:	83 30       	cpi	r24, 0x03	; 3
    16c8:	91 05       	cpc	r25, r1
    16ca:	09 f4       	brne	.+2      	; 0x16ce <MDIO_Error_State_GetPinValue+0x74>
    16cc:	3d c0       	rjmp	.+122    	; 0x1748 <MDIO_Error_State_GetPinValue+0xee>
    16ce:	50 c0       	rjmp	.+160    	; 0x1770 <MDIO_Error_State_GetPinValue+0x116>
		{
		case MDIO_PORTA:
			*P_u8PinValue=GET_BIT(PINA,Copy_u8PinNumber);
    16d0:	e9 e3       	ldi	r30, 0x39	; 57
    16d2:	f0 e0       	ldi	r31, 0x00	; 0
    16d4:	80 81       	ld	r24, Z
    16d6:	28 2f       	mov	r18, r24
    16d8:	30 e0       	ldi	r19, 0x00	; 0
    16da:	8a 81       	ldd	r24, Y+2	; 0x02
    16dc:	88 2f       	mov	r24, r24
    16de:	90 e0       	ldi	r25, 0x00	; 0
    16e0:	a9 01       	movw	r20, r18
    16e2:	02 c0       	rjmp	.+4      	; 0x16e8 <MDIO_Error_State_GetPinValue+0x8e>
    16e4:	55 95       	asr	r21
    16e6:	47 95       	ror	r20
    16e8:	8a 95       	dec	r24
    16ea:	e2 f7       	brpl	.-8      	; 0x16e4 <MDIO_Error_State_GetPinValue+0x8a>
    16ec:	ca 01       	movw	r24, r20
    16ee:	81 70       	andi	r24, 0x01	; 1
    16f0:	ec 81       	ldd	r30, Y+4	; 0x04
    16f2:	fd 81       	ldd	r31, Y+5	; 0x05
    16f4:	80 83       	st	Z, r24
    16f6:	3f c0       	rjmp	.+126    	; 0x1776 <MDIO_Error_State_GetPinValue+0x11c>
			break;
		case MDIO_PORTB:
			*P_u8PinValue=GET_BIT(PINB,Copy_u8PinNumber);
    16f8:	e6 e3       	ldi	r30, 0x36	; 54
    16fa:	f0 e0       	ldi	r31, 0x00	; 0
    16fc:	80 81       	ld	r24, Z
    16fe:	28 2f       	mov	r18, r24
    1700:	30 e0       	ldi	r19, 0x00	; 0
    1702:	8a 81       	ldd	r24, Y+2	; 0x02
    1704:	88 2f       	mov	r24, r24
    1706:	90 e0       	ldi	r25, 0x00	; 0
    1708:	a9 01       	movw	r20, r18
    170a:	02 c0       	rjmp	.+4      	; 0x1710 <MDIO_Error_State_GetPinValue+0xb6>
    170c:	55 95       	asr	r21
    170e:	47 95       	ror	r20
    1710:	8a 95       	dec	r24
    1712:	e2 f7       	brpl	.-8      	; 0x170c <MDIO_Error_State_GetPinValue+0xb2>
    1714:	ca 01       	movw	r24, r20
    1716:	81 70       	andi	r24, 0x01	; 1
    1718:	ec 81       	ldd	r30, Y+4	; 0x04
    171a:	fd 81       	ldd	r31, Y+5	; 0x05
    171c:	80 83       	st	Z, r24
    171e:	2b c0       	rjmp	.+86     	; 0x1776 <MDIO_Error_State_GetPinValue+0x11c>
			break;
		case MDIO_PORTC:
			*P_u8PinValue=GET_BIT(PINC,Copy_u8PinNumber);
    1720:	e3 e3       	ldi	r30, 0x33	; 51
    1722:	f0 e0       	ldi	r31, 0x00	; 0
    1724:	80 81       	ld	r24, Z
    1726:	28 2f       	mov	r18, r24
    1728:	30 e0       	ldi	r19, 0x00	; 0
    172a:	8a 81       	ldd	r24, Y+2	; 0x02
    172c:	88 2f       	mov	r24, r24
    172e:	90 e0       	ldi	r25, 0x00	; 0
    1730:	a9 01       	movw	r20, r18
    1732:	02 c0       	rjmp	.+4      	; 0x1738 <MDIO_Error_State_GetPinValue+0xde>
    1734:	55 95       	asr	r21
    1736:	47 95       	ror	r20
    1738:	8a 95       	dec	r24
    173a:	e2 f7       	brpl	.-8      	; 0x1734 <MDIO_Error_State_GetPinValue+0xda>
    173c:	ca 01       	movw	r24, r20
    173e:	81 70       	andi	r24, 0x01	; 1
    1740:	ec 81       	ldd	r30, Y+4	; 0x04
    1742:	fd 81       	ldd	r31, Y+5	; 0x05
    1744:	80 83       	st	Z, r24
    1746:	17 c0       	rjmp	.+46     	; 0x1776 <MDIO_Error_State_GetPinValue+0x11c>
			break;
		case MDIO_PORTD:
			*P_u8PinValue=GET_BIT(PIND,Copy_u8PinNumber);
    1748:	e0 e3       	ldi	r30, 0x30	; 48
    174a:	f0 e0       	ldi	r31, 0x00	; 0
    174c:	80 81       	ld	r24, Z
    174e:	28 2f       	mov	r18, r24
    1750:	30 e0       	ldi	r19, 0x00	; 0
    1752:	8a 81       	ldd	r24, Y+2	; 0x02
    1754:	88 2f       	mov	r24, r24
    1756:	90 e0       	ldi	r25, 0x00	; 0
    1758:	a9 01       	movw	r20, r18
    175a:	02 c0       	rjmp	.+4      	; 0x1760 <MDIO_Error_State_GetPinValue+0x106>
    175c:	55 95       	asr	r21
    175e:	47 95       	ror	r20
    1760:	8a 95       	dec	r24
    1762:	e2 f7       	brpl	.-8      	; 0x175c <MDIO_Error_State_GetPinValue+0x102>
    1764:	ca 01       	movw	r24, r20
    1766:	81 70       	andi	r24, 0x01	; 1
    1768:	ec 81       	ldd	r30, Y+4	; 0x04
    176a:	fd 81       	ldd	r31, Y+5	; 0x05
    176c:	80 83       	st	Z, r24
    176e:	03 c0       	rjmp	.+6      	; 0x1776 <MDIO_Error_State_GetPinValue+0x11c>
			break;
		default:
			LOC_Error_State_ReturnState=NOK;
    1770:	19 82       	std	Y+1, r1	; 0x01
    1772:	01 c0       	rjmp	.+2      	; 0x1776 <MDIO_Error_State_GetPinValue+0x11c>
			break;		
		}
	}
	else
	{
		LOC_Error_State_ReturnState=NOK;
    1774:	19 82       	std	Y+1, r1	; 0x01
	}

	return LOC_Error_State_ReturnState;
    1776:	89 81       	ldd	r24, Y+1	; 0x01
}
    1778:	27 96       	adiw	r28, 0x07	; 7
    177a:	0f b6       	in	r0, 0x3f	; 63
    177c:	f8 94       	cli
    177e:	de bf       	out	0x3e, r29	; 62
    1780:	0f be       	out	0x3f, r0	; 63
    1782:	cd bf       	out	0x3d, r28	; 61
    1784:	cf 91       	pop	r28
    1786:	df 91       	pop	r29
    1788:	08 95       	ret

0000178a <MDIO_Error_State_SetNippleValue>:
/*Set Nipple Direction Function */

/*Set Nipple Values Function */
Error_State MDIO_Error_State_SetNippleValue(u8 Copy_u8PinStart,u8 Copy_u8PortNumber,u8 Copy_u8Value)
{
    178a:	df 93       	push	r29
    178c:	cf 93       	push	r28
    178e:	00 d0       	rcall	.+0      	; 0x1790 <MDIO_Error_State_SetNippleValue+0x6>
    1790:	00 d0       	rcall	.+0      	; 0x1792 <MDIO_Error_State_SetNippleValue+0x8>
    1792:	00 d0       	rcall	.+0      	; 0x1794 <MDIO_Error_State_SetNippleValue+0xa>
    1794:	cd b7       	in	r28, 0x3d	; 61
    1796:	de b7       	in	r29, 0x3e	; 62
    1798:	8a 83       	std	Y+2, r24	; 0x02
    179a:	6b 83       	std	Y+3, r22	; 0x03
    179c:	4c 83       	std	Y+4, r20	; 0x04
	Error_State LOC_Error_State_ReturnState=OK;
    179e:	81 e0       	ldi	r24, 0x01	; 1
    17a0:	89 83       	std	Y+1, r24	; 0x01
	if(Copy_u8PinStart<=4)
    17a2:	8a 81       	ldd	r24, Y+2	; 0x02
    17a4:	85 30       	cpi	r24, 0x05	; 5
    17a6:	08 f0       	brcs	.+2      	; 0x17aa <MDIO_Error_State_SetNippleValue+0x20>
    17a8:	97 c0       	rjmp	.+302    	; 0x18d8 <MDIO_Error_State_SetNippleValue+0x14e>
	{
		switch(Copy_u8PortNumber)
    17aa:	8b 81       	ldd	r24, Y+3	; 0x03
    17ac:	28 2f       	mov	r18, r24
    17ae:	30 e0       	ldi	r19, 0x00	; 0
    17b0:	3e 83       	std	Y+6, r19	; 0x06
    17b2:	2d 83       	std	Y+5, r18	; 0x05
    17b4:	8d 81       	ldd	r24, Y+5	; 0x05
    17b6:	9e 81       	ldd	r25, Y+6	; 0x06
    17b8:	81 30       	cpi	r24, 0x01	; 1
    17ba:	91 05       	cpc	r25, r1
    17bc:	a1 f1       	breq	.+104    	; 0x1826 <MDIO_Error_State_SetNippleValue+0x9c>
    17be:	2d 81       	ldd	r18, Y+5	; 0x05
    17c0:	3e 81       	ldd	r19, Y+6	; 0x06
    17c2:	22 30       	cpi	r18, 0x02	; 2
    17c4:	31 05       	cpc	r19, r1
    17c6:	2c f4       	brge	.+10     	; 0x17d2 <MDIO_Error_State_SetNippleValue+0x48>
    17c8:	8d 81       	ldd	r24, Y+5	; 0x05
    17ca:	9e 81       	ldd	r25, Y+6	; 0x06
    17cc:	00 97       	sbiw	r24, 0x00	; 0
    17ce:	71 f0       	breq	.+28     	; 0x17ec <MDIO_Error_State_SetNippleValue+0x62>
    17d0:	81 c0       	rjmp	.+258    	; 0x18d4 <MDIO_Error_State_SetNippleValue+0x14a>
    17d2:	2d 81       	ldd	r18, Y+5	; 0x05
    17d4:	3e 81       	ldd	r19, Y+6	; 0x06
    17d6:	22 30       	cpi	r18, 0x02	; 2
    17d8:	31 05       	cpc	r19, r1
    17da:	09 f4       	brne	.+2      	; 0x17de <MDIO_Error_State_SetNippleValue+0x54>
    17dc:	41 c0       	rjmp	.+130    	; 0x1860 <MDIO_Error_State_SetNippleValue+0xd6>
    17de:	8d 81       	ldd	r24, Y+5	; 0x05
    17e0:	9e 81       	ldd	r25, Y+6	; 0x06
    17e2:	83 30       	cpi	r24, 0x03	; 3
    17e4:	91 05       	cpc	r25, r1
    17e6:	09 f4       	brne	.+2      	; 0x17ea <MDIO_Error_State_SetNippleValue+0x60>
    17e8:	58 c0       	rjmp	.+176    	; 0x189a <MDIO_Error_State_SetNippleValue+0x110>
    17ea:	74 c0       	rjmp	.+232    	; 0x18d4 <MDIO_Error_State_SetNippleValue+0x14a>
		case MDIO_PORTA:
		/*for(u8 i=Copy_u8PinStart;i<=7;i++)
		{
			CLR_BIT(PORTA,i);
		}*/
			PORTA&=(~(0x0F<<Copy_u8PinStart));
    17ec:	ab e3       	ldi	r26, 0x3B	; 59
    17ee:	b0 e0       	ldi	r27, 0x00	; 0
    17f0:	eb e3       	ldi	r30, 0x3B	; 59
    17f2:	f0 e0       	ldi	r31, 0x00	; 0
    17f4:	80 81       	ld	r24, Z
    17f6:	48 2f       	mov	r20, r24
    17f8:	8a 81       	ldd	r24, Y+2	; 0x02
    17fa:	28 2f       	mov	r18, r24
    17fc:	30 e0       	ldi	r19, 0x00	; 0
    17fe:	8f e0       	ldi	r24, 0x0F	; 15
    1800:	90 e0       	ldi	r25, 0x00	; 0
    1802:	02 2e       	mov	r0, r18
    1804:	02 c0       	rjmp	.+4      	; 0x180a <MDIO_Error_State_SetNippleValue+0x80>
    1806:	88 0f       	add	r24, r24
    1808:	99 1f       	adc	r25, r25
    180a:	0a 94       	dec	r0
    180c:	e2 f7       	brpl	.-8      	; 0x1806 <MDIO_Error_State_SetNippleValue+0x7c>
    180e:	80 95       	com	r24
    1810:	84 23       	and	r24, r20
    1812:	8c 93       	st	X, r24
			PORTA|=Copy_u8Value;
    1814:	ab e3       	ldi	r26, 0x3B	; 59
    1816:	b0 e0       	ldi	r27, 0x00	; 0
    1818:	eb e3       	ldi	r30, 0x3B	; 59
    181a:	f0 e0       	ldi	r31, 0x00	; 0
    181c:	90 81       	ld	r25, Z
    181e:	8c 81       	ldd	r24, Y+4	; 0x04
    1820:	89 2b       	or	r24, r25
    1822:	8c 93       	st	X, r24
    1824:	5a c0       	rjmp	.+180    	; 0x18da <MDIO_Error_State_SetNippleValue+0x150>
		case MDIO_PORTB:
			/*for(u8 i=Copy_u8PinStart;i<=Copy_u8PinEnd;i++)
		{
			CLR_BIT(PORTA,i);
		}*/
			PORTB&=(~(0x0F<<Copy_u8PinStart));
    1826:	a8 e3       	ldi	r26, 0x38	; 56
    1828:	b0 e0       	ldi	r27, 0x00	; 0
    182a:	e8 e3       	ldi	r30, 0x38	; 56
    182c:	f0 e0       	ldi	r31, 0x00	; 0
    182e:	80 81       	ld	r24, Z
    1830:	48 2f       	mov	r20, r24
    1832:	8a 81       	ldd	r24, Y+2	; 0x02
    1834:	28 2f       	mov	r18, r24
    1836:	30 e0       	ldi	r19, 0x00	; 0
    1838:	8f e0       	ldi	r24, 0x0F	; 15
    183a:	90 e0       	ldi	r25, 0x00	; 0
    183c:	02 2e       	mov	r0, r18
    183e:	02 c0       	rjmp	.+4      	; 0x1844 <MDIO_Error_State_SetNippleValue+0xba>
    1840:	88 0f       	add	r24, r24
    1842:	99 1f       	adc	r25, r25
    1844:	0a 94       	dec	r0
    1846:	e2 f7       	brpl	.-8      	; 0x1840 <MDIO_Error_State_SetNippleValue+0xb6>
    1848:	80 95       	com	r24
    184a:	84 23       	and	r24, r20
    184c:	8c 93       	st	X, r24
			PORTB|=Copy_u8Value;
    184e:	a8 e3       	ldi	r26, 0x38	; 56
    1850:	b0 e0       	ldi	r27, 0x00	; 0
    1852:	e8 e3       	ldi	r30, 0x38	; 56
    1854:	f0 e0       	ldi	r31, 0x00	; 0
    1856:	90 81       	ld	r25, Z
    1858:	8c 81       	ldd	r24, Y+4	; 0x04
    185a:	89 2b       	or	r24, r25
    185c:	8c 93       	st	X, r24
    185e:	3d c0       	rjmp	.+122    	; 0x18da <MDIO_Error_State_SetNippleValue+0x150>
		case MDIO_PORTC:
			/*for(u8 i=Copy_u8PinStart;i<=Copy_u8PinEnd;i++)
		{
			CLR_BIT(PORTA,i);
		}*/
			PORTC&=(~(0x0F<<Copy_u8PinStart));
    1860:	a5 e3       	ldi	r26, 0x35	; 53
    1862:	b0 e0       	ldi	r27, 0x00	; 0
    1864:	e5 e3       	ldi	r30, 0x35	; 53
    1866:	f0 e0       	ldi	r31, 0x00	; 0
    1868:	80 81       	ld	r24, Z
    186a:	48 2f       	mov	r20, r24
    186c:	8a 81       	ldd	r24, Y+2	; 0x02
    186e:	28 2f       	mov	r18, r24
    1870:	30 e0       	ldi	r19, 0x00	; 0
    1872:	8f e0       	ldi	r24, 0x0F	; 15
    1874:	90 e0       	ldi	r25, 0x00	; 0
    1876:	02 2e       	mov	r0, r18
    1878:	02 c0       	rjmp	.+4      	; 0x187e <MDIO_Error_State_SetNippleValue+0xf4>
    187a:	88 0f       	add	r24, r24
    187c:	99 1f       	adc	r25, r25
    187e:	0a 94       	dec	r0
    1880:	e2 f7       	brpl	.-8      	; 0x187a <MDIO_Error_State_SetNippleValue+0xf0>
    1882:	80 95       	com	r24
    1884:	84 23       	and	r24, r20
    1886:	8c 93       	st	X, r24
			PORTC|=Copy_u8Value;
    1888:	a5 e3       	ldi	r26, 0x35	; 53
    188a:	b0 e0       	ldi	r27, 0x00	; 0
    188c:	e5 e3       	ldi	r30, 0x35	; 53
    188e:	f0 e0       	ldi	r31, 0x00	; 0
    1890:	90 81       	ld	r25, Z
    1892:	8c 81       	ldd	r24, Y+4	; 0x04
    1894:	89 2b       	or	r24, r25
    1896:	8c 93       	st	X, r24
    1898:	20 c0       	rjmp	.+64     	; 0x18da <MDIO_Error_State_SetNippleValue+0x150>
		case MDIO_PORTD:
			/*for(u8 i=Copy_u8PinStart;i<=Copy_u8PinEnd;i++)
		{
			CLR_BIT(PORTA,i);
		}*/
			PORTD&=(~(0x0F<<Copy_u8PinStart));
    189a:	a2 e3       	ldi	r26, 0x32	; 50
    189c:	b0 e0       	ldi	r27, 0x00	; 0
    189e:	e2 e3       	ldi	r30, 0x32	; 50
    18a0:	f0 e0       	ldi	r31, 0x00	; 0
    18a2:	80 81       	ld	r24, Z
    18a4:	48 2f       	mov	r20, r24
    18a6:	8a 81       	ldd	r24, Y+2	; 0x02
    18a8:	28 2f       	mov	r18, r24
    18aa:	30 e0       	ldi	r19, 0x00	; 0
    18ac:	8f e0       	ldi	r24, 0x0F	; 15
    18ae:	90 e0       	ldi	r25, 0x00	; 0
    18b0:	02 2e       	mov	r0, r18
    18b2:	02 c0       	rjmp	.+4      	; 0x18b8 <MDIO_Error_State_SetNippleValue+0x12e>
    18b4:	88 0f       	add	r24, r24
    18b6:	99 1f       	adc	r25, r25
    18b8:	0a 94       	dec	r0
    18ba:	e2 f7       	brpl	.-8      	; 0x18b4 <MDIO_Error_State_SetNippleValue+0x12a>
    18bc:	80 95       	com	r24
    18be:	84 23       	and	r24, r20
    18c0:	8c 93       	st	X, r24
			PORTD|=Copy_u8Value;
    18c2:	a2 e3       	ldi	r26, 0x32	; 50
    18c4:	b0 e0       	ldi	r27, 0x00	; 0
    18c6:	e2 e3       	ldi	r30, 0x32	; 50
    18c8:	f0 e0       	ldi	r31, 0x00	; 0
    18ca:	90 81       	ld	r25, Z
    18cc:	8c 81       	ldd	r24, Y+4	; 0x04
    18ce:	89 2b       	or	r24, r25
    18d0:	8c 93       	st	X, r24
    18d2:	03 c0       	rjmp	.+6      	; 0x18da <MDIO_Error_State_SetNippleValue+0x150>
			break;
		default:
			LOC_Error_State_ReturnState=NOK;
    18d4:	19 82       	std	Y+1, r1	; 0x01
    18d6:	01 c0       	rjmp	.+2      	; 0x18da <MDIO_Error_State_SetNippleValue+0x150>
		}
	}
	else
	{
		LOC_Error_State_ReturnState=NOK;
    18d8:	19 82       	std	Y+1, r1	; 0x01
	}
	return LOC_Error_State_ReturnState;
    18da:	89 81       	ldd	r24, Y+1	; 0x01
}
    18dc:	26 96       	adiw	r28, 0x06	; 6
    18de:	0f b6       	in	r0, 0x3f	; 63
    18e0:	f8 94       	cli
    18e2:	de bf       	out	0x3e, r29	; 62
    18e4:	0f be       	out	0x3f, r0	; 63
    18e6:	cd bf       	out	0x3d, r28	; 61
    18e8:	cf 91       	pop	r28
    18ea:	df 91       	pop	r29
    18ec:	08 95       	ret

000018ee <MADC_VidInit>:

void (*MADC_CallBack)(void);

/*ADC Initialization*/
void MADC_VidInit(void)
{
    18ee:	df 93       	push	r29
    18f0:	cf 93       	push	r28
    18f2:	cd b7       	in	r28, 0x3d	; 61
    18f4:	de b7       	in	r29, 0x3e	; 62
	/*Select Reference Voltage*/
#if MADC_SET_REFERENCEVOLATGE == MADC_AVCC_REFERENCEVOLATGE
	SET_BIT(ADMUX,6);
    18f6:	a7 e2       	ldi	r26, 0x27	; 39
    18f8:	b0 e0       	ldi	r27, 0x00	; 0
    18fa:	e7 e2       	ldi	r30, 0x27	; 39
    18fc:	f0 e0       	ldi	r31, 0x00	; 0
    18fe:	80 81       	ld	r24, Z
    1900:	80 64       	ori	r24, 0x40	; 64
    1902:	8c 93       	st	X, r24
	CLR_BIT(ADMUX,7);
    1904:	a7 e2       	ldi	r26, 0x27	; 39
    1906:	b0 e0       	ldi	r27, 0x00	; 0
    1908:	e7 e2       	ldi	r30, 0x27	; 39
    190a:	f0 e0       	ldi	r31, 0x00	; 0
    190c:	80 81       	ld	r24, Z
    190e:	8f 77       	andi	r24, 0x7F	; 127
    1910:	8c 93       	st	X, r24
	SET_BIT(ADMUX,7);
#else
#error"ADC Reference Voltage Option I s not valid.... "
#endif
/*Set Prescaler*/
ADCSRA&=MADC_BIT_MASKING_PRESCALER;
    1912:	a6 e2       	ldi	r26, 0x26	; 38
    1914:	b0 e0       	ldi	r27, 0x00	; 0
    1916:	e6 e2       	ldi	r30, 0x26	; 38
    1918:	f0 e0       	ldi	r31, 0x00	; 0
    191a:	80 81       	ld	r24, Z
    191c:	88 7f       	andi	r24, 0xF8	; 248
    191e:	8c 93       	st	X, r24
ADCSRA|=MADC_SET_PRESCALER;
    1920:	a6 e2       	ldi	r26, 0x26	; 38
    1922:	b0 e0       	ldi	r27, 0x00	; 0
    1924:	e6 e2       	ldi	r30, 0x26	; 38
    1926:	f0 e0       	ldi	r31, 0x00	; 0
    1928:	80 81       	ld	r24, Z
    192a:	87 60       	ori	r24, 0x07	; 7
    192c:	8c 93       	st	X, r24

#if MADC_SET_ADJUST == MADC_LEFT_ADJUST
	SET_BIT(ADMUX,5);
#elif MADC_SET_ADJUST == MADC_RIGHT_ADJUST
	CLR_BIT(ADMUX,5);
    192e:	a7 e2       	ldi	r26, 0x27	; 39
    1930:	b0 e0       	ldi	r27, 0x00	; 0
    1932:	e7 e2       	ldi	r30, 0x27	; 39
    1934:	f0 e0       	ldi	r31, 0x00	; 0
    1936:	80 81       	ld	r24, Z
    1938:	8f 7d       	andi	r24, 0xDF	; 223
    193a:	8c 93       	st	X, r24
#else
#error"ADC Left adjust option is not valid...."
#endif
/*Enable To ADC*/
SET_BIT(ADCSRA,7);
    193c:	a6 e2       	ldi	r26, 0x26	; 38
    193e:	b0 e0       	ldi	r27, 0x00	; 0
    1940:	e6 e2       	ldi	r30, 0x26	; 38
    1942:	f0 e0       	ldi	r31, 0x00	; 0
    1944:	80 81       	ld	r24, Z
    1946:	80 68       	ori	r24, 0x80	; 128
    1948:	8c 93       	st	X, r24
}
    194a:	cf 91       	pop	r28
    194c:	df 91       	pop	r29
    194e:	08 95       	ret

00001950 <MADC_VidADCInterruptEnable>:
void MADC_VidADCInterruptEnable(void)
{
    1950:	df 93       	push	r29
    1952:	cf 93       	push	r28
    1954:	cd b7       	in	r28, 0x3d	; 61
    1956:	de b7       	in	r29, 0x3e	; 62
	SET_BIT(ADCSRA,3);
    1958:	a6 e2       	ldi	r26, 0x26	; 38
    195a:	b0 e0       	ldi	r27, 0x00	; 0
    195c:	e6 e2       	ldi	r30, 0x26	; 38
    195e:	f0 e0       	ldi	r31, 0x00	; 0
    1960:	80 81       	ld	r24, Z
    1962:	88 60       	ori	r24, 0x08	; 8
    1964:	8c 93       	st	X, r24
}
    1966:	cf 91       	pop	r28
    1968:	df 91       	pop	r29
    196a:	08 95       	ret

0000196c <MADC_u16ADC_StartConversion>:
/*ADC Start Conversion-->Polling , Return ADC Value*/
u16 MADC_u16ADC_StartConversion(u8 Copy_u8Channel)
{
    196c:	df 93       	push	r29
    196e:	cf 93       	push	r28
    1970:	0f 92       	push	r0
    1972:	cd b7       	in	r28, 0x3d	; 61
    1974:	de b7       	in	r29, 0x3e	; 62
    1976:	89 83       	std	Y+1, r24	; 0x01
	/*Select Channel*/
	Copy_u8Channel&=MADC_BIT_MASKING_CHANNEL;
    1978:	89 81       	ldd	r24, Y+1	; 0x01
    197a:	87 70       	andi	r24, 0x07	; 7
    197c:	89 83       	std	Y+1, r24	; 0x01
	ADMUX&=MADC_BIT_MASKING_REG_CHANNEL;
    197e:	a7 e2       	ldi	r26, 0x27	; 39
    1980:	b0 e0       	ldi	r27, 0x00	; 0
    1982:	e7 e2       	ldi	r30, 0x27	; 39
    1984:	f0 e0       	ldi	r31, 0x00	; 0
    1986:	80 81       	ld	r24, Z
    1988:	80 7e       	andi	r24, 0xE0	; 224
    198a:	8c 93       	st	X, r24
	ADMUX|=Copy_u8Channel;
    198c:	a7 e2       	ldi	r26, 0x27	; 39
    198e:	b0 e0       	ldi	r27, 0x00	; 0
    1990:	e7 e2       	ldi	r30, 0x27	; 39
    1992:	f0 e0       	ldi	r31, 0x00	; 0
    1994:	90 81       	ld	r25, Z
    1996:	89 81       	ldd	r24, Y+1	; 0x01
    1998:	89 2b       	or	r24, r25
    199a:	8c 93       	st	X, r24
   /*send Start Conversion*/
	SET_BIT(ADCSRA,6);
    199c:	a6 e2       	ldi	r26, 0x26	; 38
    199e:	b0 e0       	ldi	r27, 0x00	; 0
    19a0:	e6 e2       	ldi	r30, 0x26	; 38
    19a2:	f0 e0       	ldi	r31, 0x00	; 0
    19a4:	80 81       	ld	r24, Z
    19a6:	80 64       	ori	r24, 0x40	; 64
    19a8:	8c 93       	st	X, r24
	/*Wait On ADC Conversion Completed Flag is set to one */
	while(GET_BIT(ADCSRA,4)==0);
    19aa:	e6 e2       	ldi	r30, 0x26	; 38
    19ac:	f0 e0       	ldi	r31, 0x00	; 0
    19ae:	80 81       	ld	r24, Z
    19b0:	82 95       	swap	r24
    19b2:	8f 70       	andi	r24, 0x0F	; 15
    19b4:	88 2f       	mov	r24, r24
    19b6:	90 e0       	ldi	r25, 0x00	; 0
    19b8:	81 70       	andi	r24, 0x01	; 1
    19ba:	90 70       	andi	r25, 0x00	; 0
    19bc:	00 97       	sbiw	r24, 0x00	; 0
    19be:	a9 f3       	breq	.-22     	; 0x19aa <MADC_u16ADC_StartConversion+0x3e>

	return ADC;
    19c0:	e4 e2       	ldi	r30, 0x24	; 36
    19c2:	f0 e0       	ldi	r31, 0x00	; 0
    19c4:	80 81       	ld	r24, Z
    19c6:	91 81       	ldd	r25, Z+1	; 0x01
}
    19c8:	0f 90       	pop	r0
    19ca:	cf 91       	pop	r28
    19cc:	df 91       	pop	r29
    19ce:	08 95       	ret

000019d0 <MADC_u16ADC_StartConversion_With_Interrupt>:
void MADC_u16ADC_StartConversion_With_Interrupt(u8 Copy_u8Channel)
{
    19d0:	df 93       	push	r29
    19d2:	cf 93       	push	r28
    19d4:	0f 92       	push	r0
    19d6:	cd b7       	in	r28, 0x3d	; 61
    19d8:	de b7       	in	r29, 0x3e	; 62
    19da:	89 83       	std	Y+1, r24	; 0x01
	/*Select Channel*/
	Copy_u8Channel&=MADC_BIT_MASKING_CHANNEL;
    19dc:	89 81       	ldd	r24, Y+1	; 0x01
    19de:	87 70       	andi	r24, 0x07	; 7
    19e0:	89 83       	std	Y+1, r24	; 0x01
	ADMUX&=MADC_BIT_MASKING_REG_CHANNEL;
    19e2:	a7 e2       	ldi	r26, 0x27	; 39
    19e4:	b0 e0       	ldi	r27, 0x00	; 0
    19e6:	e7 e2       	ldi	r30, 0x27	; 39
    19e8:	f0 e0       	ldi	r31, 0x00	; 0
    19ea:	80 81       	ld	r24, Z
    19ec:	80 7e       	andi	r24, 0xE0	; 224
    19ee:	8c 93       	st	X, r24
	ADMUX|=Copy_u8Channel;
    19f0:	a7 e2       	ldi	r26, 0x27	; 39
    19f2:	b0 e0       	ldi	r27, 0x00	; 0
    19f4:	e7 e2       	ldi	r30, 0x27	; 39
    19f6:	f0 e0       	ldi	r31, 0x00	; 0
    19f8:	90 81       	ld	r25, Z
    19fa:	89 81       	ldd	r24, Y+1	; 0x01
    19fc:	89 2b       	or	r24, r25
    19fe:	8c 93       	st	X, r24
   /*send Start Conversion*/
	SET_BIT(ADCSRA,6);
    1a00:	a6 e2       	ldi	r26, 0x26	; 38
    1a02:	b0 e0       	ldi	r27, 0x00	; 0
    1a04:	e6 e2       	ldi	r30, 0x26	; 38
    1a06:	f0 e0       	ldi	r31, 0x00	; 0
    1a08:	80 81       	ld	r24, Z
    1a0a:	80 64       	ori	r24, 0x40	; 64
    1a0c:	8c 93       	st	X, r24
}
    1a0e:	0f 90       	pop	r0
    1a10:	cf 91       	pop	r28
    1a12:	df 91       	pop	r29
    1a14:	08 95       	ret

00001a16 <MADC_u16ADCRead>:
u16 MADC_u16ADCRead(void)
{
    1a16:	df 93       	push	r29
    1a18:	cf 93       	push	r28
    1a1a:	cd b7       	in	r28, 0x3d	; 61
    1a1c:	de b7       	in	r29, 0x3e	; 62
	return ADC;
    1a1e:	e4 e2       	ldi	r30, 0x24	; 36
    1a20:	f0 e0       	ldi	r31, 0x00	; 0
    1a22:	80 81       	ld	r24, Z
    1a24:	91 81       	ldd	r25, Z+1	; 0x01
}
    1a26:	cf 91       	pop	r28
    1a28:	df 91       	pop	r29
    1a2a:	08 95       	ret

00001a2c <MADC_VidSetCallBack>:
void MADC_VidSetCallBack(void (*Copy_pFun)(void))
{
    1a2c:	df 93       	push	r29
    1a2e:	cf 93       	push	r28
    1a30:	00 d0       	rcall	.+0      	; 0x1a32 <MADC_VidSetCallBack+0x6>
    1a32:	cd b7       	in	r28, 0x3d	; 61
    1a34:	de b7       	in	r29, 0x3e	; 62
    1a36:	9a 83       	std	Y+2, r25	; 0x02
    1a38:	89 83       	std	Y+1, r24	; 0x01
	MADC_CallBack=Copy_pFun;
    1a3a:	89 81       	ldd	r24, Y+1	; 0x01
    1a3c:	9a 81       	ldd	r25, Y+2	; 0x02
    1a3e:	90 93 03 08 	sts	0x0803, r25
    1a42:	80 93 02 08 	sts	0x0802, r24
}
    1a46:	0f 90       	pop	r0
    1a48:	0f 90       	pop	r0
    1a4a:	cf 91       	pop	r28
    1a4c:	df 91       	pop	r29
    1a4e:	08 95       	ret

00001a50 <__vector_16>:

void __vector_16(void)
{
    1a50:	1f 92       	push	r1
    1a52:	0f 92       	push	r0
    1a54:	0f b6       	in	r0, 0x3f	; 63
    1a56:	0f 92       	push	r0
    1a58:	11 24       	eor	r1, r1
    1a5a:	2f 93       	push	r18
    1a5c:	3f 93       	push	r19
    1a5e:	4f 93       	push	r20
    1a60:	5f 93       	push	r21
    1a62:	6f 93       	push	r22
    1a64:	7f 93       	push	r23
    1a66:	8f 93       	push	r24
    1a68:	9f 93       	push	r25
    1a6a:	af 93       	push	r26
    1a6c:	bf 93       	push	r27
    1a6e:	ef 93       	push	r30
    1a70:	ff 93       	push	r31
    1a72:	df 93       	push	r29
    1a74:	cf 93       	push	r28
    1a76:	cd b7       	in	r28, 0x3d	; 61
    1a78:	de b7       	in	r29, 0x3e	; 62
	MADC_CallBack();
    1a7a:	e0 91 02 08 	lds	r30, 0x0802
    1a7e:	f0 91 03 08 	lds	r31, 0x0803
    1a82:	09 95       	icall
}
    1a84:	cf 91       	pop	r28
    1a86:	df 91       	pop	r29
    1a88:	ff 91       	pop	r31
    1a8a:	ef 91       	pop	r30
    1a8c:	bf 91       	pop	r27
    1a8e:	af 91       	pop	r26
    1a90:	9f 91       	pop	r25
    1a92:	8f 91       	pop	r24
    1a94:	7f 91       	pop	r23
    1a96:	6f 91       	pop	r22
    1a98:	5f 91       	pop	r21
    1a9a:	4f 91       	pop	r20
    1a9c:	3f 91       	pop	r19
    1a9e:	2f 91       	pop	r18
    1aa0:	0f 90       	pop	r0
    1aa2:	0f be       	out	0x3f, r0	; 63
    1aa4:	0f 90       	pop	r0
    1aa6:	1f 90       	pop	r1
    1aa8:	18 95       	reti

00001aaa <TWI_Ini>:


#include "I2C_master.h"

void TWI_Ini(void)
{
    1aaa:	df 93       	push	r29
    1aac:	cf 93       	push	r28
    1aae:	cd b7       	in	r28, 0x3d	; 61
    1ab0:	de b7       	in	r29, 0x3e	; 62
	TWBR = 32;
    1ab2:	e0 e2       	ldi	r30, 0x20	; 32
    1ab4:	f0 e0       	ldi	r31, 0x00	; 0
    1ab6:	80 e2       	ldi	r24, 0x20	; 32
    1ab8:	80 83       	st	Z, r24
	TWSR = 0x00;
    1aba:	e1 e2       	ldi	r30, 0x21	; 33
    1abc:	f0 e0       	ldi	r31, 0x00	; 0
    1abe:	10 82       	st	Z, r1
	
}
    1ac0:	cf 91       	pop	r28
    1ac2:	df 91       	pop	r29
    1ac4:	08 95       	ret

00001ac6 <TWI_start>:


void TWI_start(void)
{
    1ac6:	df 93       	push	r29
    1ac8:	cf 93       	push	r28
    1aca:	cd b7       	in	r28, 0x3d	; 61
    1acc:	de b7       	in	r29, 0x3e	; 62
	TWCR=(1<<TWINT)|(1<<TWSTA)|(1<<TWEN);
    1ace:	e6 e5       	ldi	r30, 0x56	; 86
    1ad0:	f0 e0       	ldi	r31, 0x00	; 0
    1ad2:	84 ea       	ldi	r24, 0xA4	; 164
    1ad4:	80 83       	st	Z, r24
	while (!( TWCR & (1<<TWINT) ) );
    1ad6:	e6 e5       	ldi	r30, 0x56	; 86
    1ad8:	f0 e0       	ldi	r31, 0x00	; 0
    1ada:	80 81       	ld	r24, Z
    1adc:	88 23       	and	r24, r24
    1ade:	dc f7       	brge	.-10     	; 0x1ad6 <TWI_start+0x10>
	
	if ( !(( (TWSR & 0xF8) ==start) || ( (TWSR & 0xF8) == repeated_start)) )
    1ae0:	e1 e2       	ldi	r30, 0x21	; 33
    1ae2:	f0 e0       	ldi	r31, 0x00	; 0
    1ae4:	80 81       	ld	r24, Z
    1ae6:	88 2f       	mov	r24, r24
    1ae8:	90 e0       	ldi	r25, 0x00	; 0
    1aea:	88 7f       	andi	r24, 0xF8	; 248
    1aec:	90 70       	andi	r25, 0x00	; 0
    1aee:	88 30       	cpi	r24, 0x08	; 8
    1af0:	91 05       	cpc	r25, r1
    1af2:	61 f0       	breq	.+24     	; 0x1b0c <TWI_start+0x46>
    1af4:	e1 e2       	ldi	r30, 0x21	; 33
    1af6:	f0 e0       	ldi	r31, 0x00	; 0
    1af8:	80 81       	ld	r24, Z
    1afa:	88 2f       	mov	r24, r24
    1afc:	90 e0       	ldi	r25, 0x00	; 0
    1afe:	88 7f       	andi	r24, 0xF8	; 248
    1b00:	90 70       	andi	r25, 0x00	; 0
    1b02:	80 31       	cpi	r24, 0x10	; 16
    1b04:	91 05       	cpc	r25, r1
    1b06:	11 f0       	breq	.+4      	; 0x1b0c <TWI_start+0x46>
	{
		TWI_start();
    1b08:	0e 94 63 0d 	call	0x1ac6	; 0x1ac6 <TWI_start>
	}
}
    1b0c:	cf 91       	pop	r28
    1b0e:	df 91       	pop	r29
    1b10:	08 95       	ret

00001b12 <TWI_stop>:

void TWI_stop(void)
{
    1b12:	df 93       	push	r29
    1b14:	cf 93       	push	r28
    1b16:	cd b7       	in	r28, 0x3d	; 61
    1b18:	de b7       	in	r29, 0x3e	; 62
	TWCR=(1<<TWINT)|(1<<TWSTO)|(1<<TWEN) ;
    1b1a:	e6 e5       	ldi	r30, 0x56	; 86
    1b1c:	f0 e0       	ldi	r31, 0x00	; 0
    1b1e:	84 e9       	ldi	r24, 0x94	; 148
    1b20:	80 83       	st	Z, r24
}
    1b22:	cf 91       	pop	r28
    1b24:	df 91       	pop	r29
    1b26:	08 95       	ret

00001b28 <TWI_write>:



void TWI_write(char data)
{
    1b28:	df 93       	push	r29
    1b2a:	cf 93       	push	r28
    1b2c:	0f 92       	push	r0
    1b2e:	cd b7       	in	r28, 0x3d	; 61
    1b30:	de b7       	in	r29, 0x3e	; 62
    1b32:	89 83       	std	Y+1, r24	; 0x01
	TWDR = data;
    1b34:	e3 e2       	ldi	r30, 0x23	; 35
    1b36:	f0 e0       	ldi	r31, 0x00	; 0
    1b38:	89 81       	ldd	r24, Y+1	; 0x01
    1b3a:	80 83       	st	Z, r24
	TWCR = (1<<TWINT) | (1<<TWEN);
    1b3c:	e6 e5       	ldi	r30, 0x56	; 86
    1b3e:	f0 e0       	ldi	r31, 0x00	; 0
    1b40:	84 e8       	ldi	r24, 0x84	; 132
    1b42:	80 83       	st	Z, r24
	while ( !( TWCR & (1<<TWINT) ) );
    1b44:	e6 e5       	ldi	r30, 0x56	; 86
    1b46:	f0 e0       	ldi	r31, 0x00	; 0
    1b48:	80 81       	ld	r24, Z
    1b4a:	88 23       	and	r24, r24
    1b4c:	dc f7       	brge	.-10     	; 0x1b44 <TWI_write+0x1c>
	
}
    1b4e:	0f 90       	pop	r0
    1b50:	cf 91       	pop	r28
    1b52:	df 91       	pop	r29
    1b54:	08 95       	ret

00001b56 <TWI_read>:


char TWI_read(char ACKM_NACKM)
{
    1b56:	df 93       	push	r29
    1b58:	cf 93       	push	r28
    1b5a:	0f 92       	push	r0
    1b5c:	cd b7       	in	r28, 0x3d	; 61
    1b5e:	de b7       	in	r29, 0x3e	; 62
    1b60:	89 83       	std	Y+1, r24	; 0x01
	TWCR = (1<<TWINT) | (1<<TWEN) | (ACKM_NACKM<<TWEA);
    1b62:	e6 e5       	ldi	r30, 0x56	; 86
    1b64:	f0 e0       	ldi	r31, 0x00	; 0
    1b66:	89 81       	ldd	r24, Y+1	; 0x01
    1b68:	88 2f       	mov	r24, r24
    1b6a:	90 e0       	ldi	r25, 0x00	; 0
    1b6c:	00 24       	eor	r0, r0
    1b6e:	96 95       	lsr	r25
    1b70:	87 95       	ror	r24
    1b72:	07 94       	ror	r0
    1b74:	96 95       	lsr	r25
    1b76:	87 95       	ror	r24
    1b78:	07 94       	ror	r0
    1b7a:	98 2f       	mov	r25, r24
    1b7c:	80 2d       	mov	r24, r0
    1b7e:	84 68       	ori	r24, 0x84	; 132
    1b80:	80 83       	st	Z, r24
	while ( !( TWCR & (1<<TWINT) ) );
    1b82:	e6 e5       	ldi	r30, 0x56	; 86
    1b84:	f0 e0       	ldi	r31, 0x00	; 0
    1b86:	80 81       	ld	r24, Z
    1b88:	88 23       	and	r24, r24
    1b8a:	dc f7       	brge	.-10     	; 0x1b82 <TWI_read+0x2c>
	return TWDR;
    1b8c:	e3 e2       	ldi	r30, 0x23	; 35
    1b8e:	f0 e0       	ldi	r31, 0x00	; 0
    1b90:	80 81       	ld	r24, Z
}
    1b92:	0f 90       	pop	r0
    1b94:	cf 91       	pop	r28
    1b96:	df 91       	pop	r29
    1b98:	08 95       	ret

00001b9a <HCLCD_VidWriteCommand_8Bits>:
#include"HCLCD_Interface.h"

#include"util/delay.h"

void HCLCD_VidWriteCommand_8Bits(u8 Copy_u8Command)
{
    1b9a:	df 93       	push	r29
    1b9c:	cf 93       	push	r28
    1b9e:	cd b7       	in	r28, 0x3d	; 61
    1ba0:	de b7       	in	r29, 0x3e	; 62
    1ba2:	6d 97       	sbiw	r28, 0x1d	; 29
    1ba4:	0f b6       	in	r0, 0x3f	; 63
    1ba6:	f8 94       	cli
    1ba8:	de bf       	out	0x3e, r29	; 62
    1baa:	0f be       	out	0x3f, r0	; 63
    1bac:	cd bf       	out	0x3d, r28	; 61
    1bae:	8d 8f       	std	Y+29, r24	; 0x1d
	/*select Command register--> Write zero on Rs pin*/
	MDIO_Error_State_SetPinValue(RS,CONTROL_PORT,PIN_LOW);
    1bb0:	81 e0       	ldi	r24, 0x01	; 1
    1bb2:	61 e0       	ldi	r22, 0x01	; 1
    1bb4:	40 e0       	ldi	r20, 0x00	; 0
    1bb6:	0e 94 e2 09 	call	0x13c4	; 0x13c4 <MDIO_Error_State_SetPinValue>
	/*select Write mode--> Write zero on RW pin*/
	//MDIO_Error_State_SetPinValue(RW,CONTROL_PORT,PIN_LOW);
	/*Send Command ON port Data*/
	MDIO_Error_State_SetPortValue(DATA_PORT,Copy_u8Command);
    1bba:	80 e0       	ldi	r24, 0x00	; 0
    1bbc:	6d 8d       	ldd	r22, Y+29	; 0x1d
    1bbe:	0e 94 e5 0a 	call	0x15ca	; 0x15ca <MDIO_Error_State_SetPortValue>
	/*Send Enable*/
	MDIO_Error_State_SetPinValue(E,CONTROL_PORT,PIN_HIGH);
    1bc2:	83 e0       	ldi	r24, 0x03	; 3
    1bc4:	61 e0       	ldi	r22, 0x01	; 1
    1bc6:	41 e0       	ldi	r20, 0x01	; 1
    1bc8:	0e 94 e2 09 	call	0x13c4	; 0x13c4 <MDIO_Error_State_SetPinValue>
    1bcc:	80 e0       	ldi	r24, 0x00	; 0
    1bce:	90 e0       	ldi	r25, 0x00	; 0
    1bd0:	a0 e0       	ldi	r26, 0x00	; 0
    1bd2:	b0 e4       	ldi	r27, 0x40	; 64
    1bd4:	89 8f       	std	Y+25, r24	; 0x19
    1bd6:	9a 8f       	std	Y+26, r25	; 0x1a
    1bd8:	ab 8f       	std	Y+27, r26	; 0x1b
    1bda:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1bdc:	69 8d       	ldd	r22, Y+25	; 0x19
    1bde:	7a 8d       	ldd	r23, Y+26	; 0x1a
    1be0:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1be2:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1be4:	20 e0       	ldi	r18, 0x00	; 0
    1be6:	30 e0       	ldi	r19, 0x00	; 0
    1be8:	4a e7       	ldi	r20, 0x7A	; 122
    1bea:	53 e4       	ldi	r21, 0x43	; 67
    1bec:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1bf0:	dc 01       	movw	r26, r24
    1bf2:	cb 01       	movw	r24, r22
    1bf4:	8d 8b       	std	Y+21, r24	; 0x15
    1bf6:	9e 8b       	std	Y+22, r25	; 0x16
    1bf8:	af 8b       	std	Y+23, r26	; 0x17
    1bfa:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    1bfc:	6d 89       	ldd	r22, Y+21	; 0x15
    1bfe:	7e 89       	ldd	r23, Y+22	; 0x16
    1c00:	8f 89       	ldd	r24, Y+23	; 0x17
    1c02:	98 8d       	ldd	r25, Y+24	; 0x18
    1c04:	20 e0       	ldi	r18, 0x00	; 0
    1c06:	30 e0       	ldi	r19, 0x00	; 0
    1c08:	40 e8       	ldi	r20, 0x80	; 128
    1c0a:	5f e3       	ldi	r21, 0x3F	; 63
    1c0c:	0e 94 55 04 	call	0x8aa	; 0x8aa <__ltsf2>
    1c10:	88 23       	and	r24, r24
    1c12:	2c f4       	brge	.+10     	; 0x1c1e <HCLCD_VidWriteCommand_8Bits+0x84>
		__ticks = 1;
    1c14:	81 e0       	ldi	r24, 0x01	; 1
    1c16:	90 e0       	ldi	r25, 0x00	; 0
    1c18:	9c 8b       	std	Y+20, r25	; 0x14
    1c1a:	8b 8b       	std	Y+19, r24	; 0x13
    1c1c:	3f c0       	rjmp	.+126    	; 0x1c9c <HCLCD_VidWriteCommand_8Bits+0x102>
	else if (__tmp > 65535)
    1c1e:	6d 89       	ldd	r22, Y+21	; 0x15
    1c20:	7e 89       	ldd	r23, Y+22	; 0x16
    1c22:	8f 89       	ldd	r24, Y+23	; 0x17
    1c24:	98 8d       	ldd	r25, Y+24	; 0x18
    1c26:	20 e0       	ldi	r18, 0x00	; 0
    1c28:	3f ef       	ldi	r19, 0xFF	; 255
    1c2a:	4f e7       	ldi	r20, 0x7F	; 127
    1c2c:	57 e4       	ldi	r21, 0x47	; 71
    1c2e:	0e 94 f5 03 	call	0x7ea	; 0x7ea <__gtsf2>
    1c32:	18 16       	cp	r1, r24
    1c34:	4c f5       	brge	.+82     	; 0x1c88 <HCLCD_VidWriteCommand_8Bits+0xee>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1c36:	69 8d       	ldd	r22, Y+25	; 0x19
    1c38:	7a 8d       	ldd	r23, Y+26	; 0x1a
    1c3a:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1c3c:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1c3e:	20 e0       	ldi	r18, 0x00	; 0
    1c40:	30 e0       	ldi	r19, 0x00	; 0
    1c42:	40 e2       	ldi	r20, 0x20	; 32
    1c44:	51 e4       	ldi	r21, 0x41	; 65
    1c46:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1c4a:	dc 01       	movw	r26, r24
    1c4c:	cb 01       	movw	r24, r22
    1c4e:	bc 01       	movw	r22, r24
    1c50:	cd 01       	movw	r24, r26
    1c52:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1c56:	dc 01       	movw	r26, r24
    1c58:	cb 01       	movw	r24, r22
    1c5a:	9c 8b       	std	Y+20, r25	; 0x14
    1c5c:	8b 8b       	std	Y+19, r24	; 0x13
    1c5e:	0f c0       	rjmp	.+30     	; 0x1c7e <HCLCD_VidWriteCommand_8Bits+0xe4>
    1c60:	89 e1       	ldi	r24, 0x19	; 25
    1c62:	90 e0       	ldi	r25, 0x00	; 0
    1c64:	9a 8b       	std	Y+18, r25	; 0x12
    1c66:	89 8b       	std	Y+17, r24	; 0x11
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    1c68:	89 89       	ldd	r24, Y+17	; 0x11
    1c6a:	9a 89       	ldd	r25, Y+18	; 0x12
    1c6c:	01 97       	sbiw	r24, 0x01	; 1
    1c6e:	f1 f7       	brne	.-4      	; 0x1c6c <HCLCD_VidWriteCommand_8Bits+0xd2>
    1c70:	9a 8b       	std	Y+18, r25	; 0x12
    1c72:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1c74:	8b 89       	ldd	r24, Y+19	; 0x13
    1c76:	9c 89       	ldd	r25, Y+20	; 0x14
    1c78:	01 97       	sbiw	r24, 0x01	; 1
    1c7a:	9c 8b       	std	Y+20, r25	; 0x14
    1c7c:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1c7e:	8b 89       	ldd	r24, Y+19	; 0x13
    1c80:	9c 89       	ldd	r25, Y+20	; 0x14
    1c82:	00 97       	sbiw	r24, 0x00	; 0
    1c84:	69 f7       	brne	.-38     	; 0x1c60 <HCLCD_VidWriteCommand_8Bits+0xc6>
    1c86:	14 c0       	rjmp	.+40     	; 0x1cb0 <HCLCD_VidWriteCommand_8Bits+0x116>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1c88:	6d 89       	ldd	r22, Y+21	; 0x15
    1c8a:	7e 89       	ldd	r23, Y+22	; 0x16
    1c8c:	8f 89       	ldd	r24, Y+23	; 0x17
    1c8e:	98 8d       	ldd	r25, Y+24	; 0x18
    1c90:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1c94:	dc 01       	movw	r26, r24
    1c96:	cb 01       	movw	r24, r22
    1c98:	9c 8b       	std	Y+20, r25	; 0x14
    1c9a:	8b 8b       	std	Y+19, r24	; 0x13
    1c9c:	8b 89       	ldd	r24, Y+19	; 0x13
    1c9e:	9c 89       	ldd	r25, Y+20	; 0x14
    1ca0:	98 8b       	std	Y+16, r25	; 0x10
    1ca2:	8f 87       	std	Y+15, r24	; 0x0f
    1ca4:	8f 85       	ldd	r24, Y+15	; 0x0f
    1ca6:	98 89       	ldd	r25, Y+16	; 0x10
    1ca8:	01 97       	sbiw	r24, 0x01	; 1
    1caa:	f1 f7       	brne	.-4      	; 0x1ca8 <HCLCD_VidWriteCommand_8Bits+0x10e>
    1cac:	98 8b       	std	Y+16, r25	; 0x10
    1cae:	8f 87       	std	Y+15, r24	; 0x0f
	_delay_ms(2);
	MDIO_Error_State_SetPinValue(E,CONTROL_PORT,PIN_LOW);
    1cb0:	83 e0       	ldi	r24, 0x03	; 3
    1cb2:	61 e0       	ldi	r22, 0x01	; 1
    1cb4:	40 e0       	ldi	r20, 0x00	; 0
    1cb6:	0e 94 e2 09 	call	0x13c4	; 0x13c4 <MDIO_Error_State_SetPinValue>
    1cba:	80 e0       	ldi	r24, 0x00	; 0
    1cbc:	90 e0       	ldi	r25, 0x00	; 0
    1cbe:	a0 e0       	ldi	r26, 0x00	; 0
    1cc0:	b0 e4       	ldi	r27, 0x40	; 64
    1cc2:	8b 87       	std	Y+11, r24	; 0x0b
    1cc4:	9c 87       	std	Y+12, r25	; 0x0c
    1cc6:	ad 87       	std	Y+13, r26	; 0x0d
    1cc8:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1cca:	6b 85       	ldd	r22, Y+11	; 0x0b
    1ccc:	7c 85       	ldd	r23, Y+12	; 0x0c
    1cce:	8d 85       	ldd	r24, Y+13	; 0x0d
    1cd0:	9e 85       	ldd	r25, Y+14	; 0x0e
    1cd2:	20 e0       	ldi	r18, 0x00	; 0
    1cd4:	30 e0       	ldi	r19, 0x00	; 0
    1cd6:	4a e7       	ldi	r20, 0x7A	; 122
    1cd8:	53 e4       	ldi	r21, 0x43	; 67
    1cda:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1cde:	dc 01       	movw	r26, r24
    1ce0:	cb 01       	movw	r24, r22
    1ce2:	8f 83       	std	Y+7, r24	; 0x07
    1ce4:	98 87       	std	Y+8, r25	; 0x08
    1ce6:	a9 87       	std	Y+9, r26	; 0x09
    1ce8:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    1cea:	6f 81       	ldd	r22, Y+7	; 0x07
    1cec:	78 85       	ldd	r23, Y+8	; 0x08
    1cee:	89 85       	ldd	r24, Y+9	; 0x09
    1cf0:	9a 85       	ldd	r25, Y+10	; 0x0a
    1cf2:	20 e0       	ldi	r18, 0x00	; 0
    1cf4:	30 e0       	ldi	r19, 0x00	; 0
    1cf6:	40 e8       	ldi	r20, 0x80	; 128
    1cf8:	5f e3       	ldi	r21, 0x3F	; 63
    1cfa:	0e 94 55 04 	call	0x8aa	; 0x8aa <__ltsf2>
    1cfe:	88 23       	and	r24, r24
    1d00:	2c f4       	brge	.+10     	; 0x1d0c <HCLCD_VidWriteCommand_8Bits+0x172>
		__ticks = 1;
    1d02:	81 e0       	ldi	r24, 0x01	; 1
    1d04:	90 e0       	ldi	r25, 0x00	; 0
    1d06:	9e 83       	std	Y+6, r25	; 0x06
    1d08:	8d 83       	std	Y+5, r24	; 0x05
    1d0a:	3f c0       	rjmp	.+126    	; 0x1d8a <HCLCD_VidWriteCommand_8Bits+0x1f0>
	else if (__tmp > 65535)
    1d0c:	6f 81       	ldd	r22, Y+7	; 0x07
    1d0e:	78 85       	ldd	r23, Y+8	; 0x08
    1d10:	89 85       	ldd	r24, Y+9	; 0x09
    1d12:	9a 85       	ldd	r25, Y+10	; 0x0a
    1d14:	20 e0       	ldi	r18, 0x00	; 0
    1d16:	3f ef       	ldi	r19, 0xFF	; 255
    1d18:	4f e7       	ldi	r20, 0x7F	; 127
    1d1a:	57 e4       	ldi	r21, 0x47	; 71
    1d1c:	0e 94 f5 03 	call	0x7ea	; 0x7ea <__gtsf2>
    1d20:	18 16       	cp	r1, r24
    1d22:	4c f5       	brge	.+82     	; 0x1d76 <HCLCD_VidWriteCommand_8Bits+0x1dc>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1d24:	6b 85       	ldd	r22, Y+11	; 0x0b
    1d26:	7c 85       	ldd	r23, Y+12	; 0x0c
    1d28:	8d 85       	ldd	r24, Y+13	; 0x0d
    1d2a:	9e 85       	ldd	r25, Y+14	; 0x0e
    1d2c:	20 e0       	ldi	r18, 0x00	; 0
    1d2e:	30 e0       	ldi	r19, 0x00	; 0
    1d30:	40 e2       	ldi	r20, 0x20	; 32
    1d32:	51 e4       	ldi	r21, 0x41	; 65
    1d34:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1d38:	dc 01       	movw	r26, r24
    1d3a:	cb 01       	movw	r24, r22
    1d3c:	bc 01       	movw	r22, r24
    1d3e:	cd 01       	movw	r24, r26
    1d40:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1d44:	dc 01       	movw	r26, r24
    1d46:	cb 01       	movw	r24, r22
    1d48:	9e 83       	std	Y+6, r25	; 0x06
    1d4a:	8d 83       	std	Y+5, r24	; 0x05
    1d4c:	0f c0       	rjmp	.+30     	; 0x1d6c <HCLCD_VidWriteCommand_8Bits+0x1d2>
    1d4e:	89 e1       	ldi	r24, 0x19	; 25
    1d50:	90 e0       	ldi	r25, 0x00	; 0
    1d52:	9c 83       	std	Y+4, r25	; 0x04
    1d54:	8b 83       	std	Y+3, r24	; 0x03
    1d56:	8b 81       	ldd	r24, Y+3	; 0x03
    1d58:	9c 81       	ldd	r25, Y+4	; 0x04
    1d5a:	01 97       	sbiw	r24, 0x01	; 1
    1d5c:	f1 f7       	brne	.-4      	; 0x1d5a <HCLCD_VidWriteCommand_8Bits+0x1c0>
    1d5e:	9c 83       	std	Y+4, r25	; 0x04
    1d60:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1d62:	8d 81       	ldd	r24, Y+5	; 0x05
    1d64:	9e 81       	ldd	r25, Y+6	; 0x06
    1d66:	01 97       	sbiw	r24, 0x01	; 1
    1d68:	9e 83       	std	Y+6, r25	; 0x06
    1d6a:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1d6c:	8d 81       	ldd	r24, Y+5	; 0x05
    1d6e:	9e 81       	ldd	r25, Y+6	; 0x06
    1d70:	00 97       	sbiw	r24, 0x00	; 0
    1d72:	69 f7       	brne	.-38     	; 0x1d4e <HCLCD_VidWriteCommand_8Bits+0x1b4>
    1d74:	14 c0       	rjmp	.+40     	; 0x1d9e <HCLCD_VidWriteCommand_8Bits+0x204>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1d76:	6f 81       	ldd	r22, Y+7	; 0x07
    1d78:	78 85       	ldd	r23, Y+8	; 0x08
    1d7a:	89 85       	ldd	r24, Y+9	; 0x09
    1d7c:	9a 85       	ldd	r25, Y+10	; 0x0a
    1d7e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1d82:	dc 01       	movw	r26, r24
    1d84:	cb 01       	movw	r24, r22
    1d86:	9e 83       	std	Y+6, r25	; 0x06
    1d88:	8d 83       	std	Y+5, r24	; 0x05
    1d8a:	8d 81       	ldd	r24, Y+5	; 0x05
    1d8c:	9e 81       	ldd	r25, Y+6	; 0x06
    1d8e:	9a 83       	std	Y+2, r25	; 0x02
    1d90:	89 83       	std	Y+1, r24	; 0x01
    1d92:	89 81       	ldd	r24, Y+1	; 0x01
    1d94:	9a 81       	ldd	r25, Y+2	; 0x02
    1d96:	01 97       	sbiw	r24, 0x01	; 1
    1d98:	f1 f7       	brne	.-4      	; 0x1d96 <HCLCD_VidWriteCommand_8Bits+0x1fc>
    1d9a:	9a 83       	std	Y+2, r25	; 0x02
    1d9c:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(2);
	MDIO_Error_State_SetPinValue(E,CONTROL_PORT,PIN_HIGH);	
    1d9e:	83 e0       	ldi	r24, 0x03	; 3
    1da0:	61 e0       	ldi	r22, 0x01	; 1
    1da2:	41 e0       	ldi	r20, 0x01	; 1
    1da4:	0e 94 e2 09 	call	0x13c4	; 0x13c4 <MDIO_Error_State_SetPinValue>
}
    1da8:	6d 96       	adiw	r28, 0x1d	; 29
    1daa:	0f b6       	in	r0, 0x3f	; 63
    1dac:	f8 94       	cli
    1dae:	de bf       	out	0x3e, r29	; 62
    1db0:	0f be       	out	0x3f, r0	; 63
    1db2:	cd bf       	out	0x3d, r28	; 61
    1db4:	cf 91       	pop	r28
    1db6:	df 91       	pop	r29
    1db8:	08 95       	ret

00001dba <HCLCD_Vid8Bits_Init>:

void HCLCD_Vid8Bits_Init(void)
{
    1dba:	df 93       	push	r29
    1dbc:	cf 93       	push	r28
    1dbe:	cd b7       	in	r28, 0x3d	; 61
    1dc0:	de b7       	in	r29, 0x3e	; 62
    1dc2:	e8 97       	sbiw	r28, 0x38	; 56
    1dc4:	0f b6       	in	r0, 0x3f	; 63
    1dc6:	f8 94       	cli
    1dc8:	de bf       	out	0x3e, r29	; 62
    1dca:	0f be       	out	0x3f, r0	; 63
    1dcc:	cd bf       	out	0x3d, r28	; 61
	/*LCD Data and control port intialization*/
	MDIO_Error_State_SetPortDirection(DATA_PORT,PORT_OUTPUT);
    1dce:	80 e0       	ldi	r24, 0x00	; 0
    1dd0:	6f ef       	ldi	r22, 0xFF	; 255
    1dd2:	0e 94 92 09 	call	0x1324	; 0x1324 <MDIO_Error_State_SetPortDirection>
	MDIO_Error_State_SetPinDirection(RS,CONTROL_PORT,PIN_OUTPUT);
    1dd6:	81 e0       	ldi	r24, 0x01	; 1
    1dd8:	61 e0       	ldi	r22, 0x01	; 1
    1dda:	41 e0       	ldi	r20, 0x01	; 1
    1ddc:	0e 94 8f 08 	call	0x111e	; 0x111e <MDIO_Error_State_SetPinDirection>
	//MDIO_Error_State_SetPinDirection(RW,CONTROL_PORT,PIN_OUTPUT);
	MDIO_Error_State_SetPinDirection(E,CONTROL_PORT,PIN_OUTPUT);
    1de0:	83 e0       	ldi	r24, 0x03	; 3
    1de2:	61 e0       	ldi	r22, 0x01	; 1
    1de4:	41 e0       	ldi	r20, 0x01	; 1
    1de6:	0e 94 8f 08 	call	0x111e	; 0x111e <MDIO_Error_State_SetPinDirection>
    1dea:	80 e0       	ldi	r24, 0x00	; 0
    1dec:	90 e0       	ldi	r25, 0x00	; 0
    1dee:	a0 ef       	ldi	r26, 0xF0	; 240
    1df0:	b1 e4       	ldi	r27, 0x41	; 65
    1df2:	8d ab       	std	Y+53, r24	; 0x35
    1df4:	9e ab       	std	Y+54, r25	; 0x36
    1df6:	af ab       	std	Y+55, r26	; 0x37
    1df8:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1dfa:	6d a9       	ldd	r22, Y+53	; 0x35
    1dfc:	7e a9       	ldd	r23, Y+54	; 0x36
    1dfe:	8f a9       	ldd	r24, Y+55	; 0x37
    1e00:	98 ad       	ldd	r25, Y+56	; 0x38
    1e02:	20 e0       	ldi	r18, 0x00	; 0
    1e04:	30 e0       	ldi	r19, 0x00	; 0
    1e06:	4a e7       	ldi	r20, 0x7A	; 122
    1e08:	53 e4       	ldi	r21, 0x43	; 67
    1e0a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1e0e:	dc 01       	movw	r26, r24
    1e10:	cb 01       	movw	r24, r22
    1e12:	89 ab       	std	Y+49, r24	; 0x31
    1e14:	9a ab       	std	Y+50, r25	; 0x32
    1e16:	ab ab       	std	Y+51, r26	; 0x33
    1e18:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
    1e1a:	69 a9       	ldd	r22, Y+49	; 0x31
    1e1c:	7a a9       	ldd	r23, Y+50	; 0x32
    1e1e:	8b a9       	ldd	r24, Y+51	; 0x33
    1e20:	9c a9       	ldd	r25, Y+52	; 0x34
    1e22:	20 e0       	ldi	r18, 0x00	; 0
    1e24:	30 e0       	ldi	r19, 0x00	; 0
    1e26:	40 e8       	ldi	r20, 0x80	; 128
    1e28:	5f e3       	ldi	r21, 0x3F	; 63
    1e2a:	0e 94 55 04 	call	0x8aa	; 0x8aa <__ltsf2>
    1e2e:	88 23       	and	r24, r24
    1e30:	2c f4       	brge	.+10     	; 0x1e3c <HCLCD_Vid8Bits_Init+0x82>
		__ticks = 1;
    1e32:	81 e0       	ldi	r24, 0x01	; 1
    1e34:	90 e0       	ldi	r25, 0x00	; 0
    1e36:	98 ab       	std	Y+48, r25	; 0x30
    1e38:	8f a7       	std	Y+47, r24	; 0x2f
    1e3a:	3f c0       	rjmp	.+126    	; 0x1eba <HCLCD_Vid8Bits_Init+0x100>
	else if (__tmp > 65535)
    1e3c:	69 a9       	ldd	r22, Y+49	; 0x31
    1e3e:	7a a9       	ldd	r23, Y+50	; 0x32
    1e40:	8b a9       	ldd	r24, Y+51	; 0x33
    1e42:	9c a9       	ldd	r25, Y+52	; 0x34
    1e44:	20 e0       	ldi	r18, 0x00	; 0
    1e46:	3f ef       	ldi	r19, 0xFF	; 255
    1e48:	4f e7       	ldi	r20, 0x7F	; 127
    1e4a:	57 e4       	ldi	r21, 0x47	; 71
    1e4c:	0e 94 f5 03 	call	0x7ea	; 0x7ea <__gtsf2>
    1e50:	18 16       	cp	r1, r24
    1e52:	4c f5       	brge	.+82     	; 0x1ea6 <HCLCD_Vid8Bits_Init+0xec>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1e54:	6d a9       	ldd	r22, Y+53	; 0x35
    1e56:	7e a9       	ldd	r23, Y+54	; 0x36
    1e58:	8f a9       	ldd	r24, Y+55	; 0x37
    1e5a:	98 ad       	ldd	r25, Y+56	; 0x38
    1e5c:	20 e0       	ldi	r18, 0x00	; 0
    1e5e:	30 e0       	ldi	r19, 0x00	; 0
    1e60:	40 e2       	ldi	r20, 0x20	; 32
    1e62:	51 e4       	ldi	r21, 0x41	; 65
    1e64:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1e68:	dc 01       	movw	r26, r24
    1e6a:	cb 01       	movw	r24, r22
    1e6c:	bc 01       	movw	r22, r24
    1e6e:	cd 01       	movw	r24, r26
    1e70:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1e74:	dc 01       	movw	r26, r24
    1e76:	cb 01       	movw	r24, r22
    1e78:	98 ab       	std	Y+48, r25	; 0x30
    1e7a:	8f a7       	std	Y+47, r24	; 0x2f
    1e7c:	0f c0       	rjmp	.+30     	; 0x1e9c <HCLCD_Vid8Bits_Init+0xe2>
    1e7e:	89 e1       	ldi	r24, 0x19	; 25
    1e80:	90 e0       	ldi	r25, 0x00	; 0
    1e82:	9e a7       	std	Y+46, r25	; 0x2e
    1e84:	8d a7       	std	Y+45, r24	; 0x2d
    1e86:	8d a5       	ldd	r24, Y+45	; 0x2d
    1e88:	9e a5       	ldd	r25, Y+46	; 0x2e
    1e8a:	01 97       	sbiw	r24, 0x01	; 1
    1e8c:	f1 f7       	brne	.-4      	; 0x1e8a <HCLCD_Vid8Bits_Init+0xd0>
    1e8e:	9e a7       	std	Y+46, r25	; 0x2e
    1e90:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1e92:	8f a5       	ldd	r24, Y+47	; 0x2f
    1e94:	98 a9       	ldd	r25, Y+48	; 0x30
    1e96:	01 97       	sbiw	r24, 0x01	; 1
    1e98:	98 ab       	std	Y+48, r25	; 0x30
    1e9a:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1e9c:	8f a5       	ldd	r24, Y+47	; 0x2f
    1e9e:	98 a9       	ldd	r25, Y+48	; 0x30
    1ea0:	00 97       	sbiw	r24, 0x00	; 0
    1ea2:	69 f7       	brne	.-38     	; 0x1e7e <HCLCD_Vid8Bits_Init+0xc4>
    1ea4:	14 c0       	rjmp	.+40     	; 0x1ece <HCLCD_Vid8Bits_Init+0x114>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1ea6:	69 a9       	ldd	r22, Y+49	; 0x31
    1ea8:	7a a9       	ldd	r23, Y+50	; 0x32
    1eaa:	8b a9       	ldd	r24, Y+51	; 0x33
    1eac:	9c a9       	ldd	r25, Y+52	; 0x34
    1eae:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1eb2:	dc 01       	movw	r26, r24
    1eb4:	cb 01       	movw	r24, r22
    1eb6:	98 ab       	std	Y+48, r25	; 0x30
    1eb8:	8f a7       	std	Y+47, r24	; 0x2f
    1eba:	8f a5       	ldd	r24, Y+47	; 0x2f
    1ebc:	98 a9       	ldd	r25, Y+48	; 0x30
    1ebe:	9c a7       	std	Y+44, r25	; 0x2c
    1ec0:	8b a7       	std	Y+43, r24	; 0x2b
    1ec2:	8b a5       	ldd	r24, Y+43	; 0x2b
    1ec4:	9c a5       	ldd	r25, Y+44	; 0x2c
    1ec6:	01 97       	sbiw	r24, 0x01	; 1
    1ec8:	f1 f7       	brne	.-4      	; 0x1ec6 <HCLCD_Vid8Bits_Init+0x10c>
    1eca:	9c a7       	std	Y+44, r25	; 0x2c
    1ecc:	8b a7       	std	Y+43, r24	; 0x2b

	/*wait to 30ms*/
	_delay_ms(30);
	/*send function set command*/
	HCLCD_VidWriteCommand_8Bits(HCLCD_FUNCTION_SET);
    1ece:	88 e2       	ldi	r24, 0x28	; 40
    1ed0:	0e 94 cd 0d 	call	0x1b9a	; 0x1b9a <HCLCD_VidWriteCommand_8Bits>
    1ed4:	80 e0       	ldi	r24, 0x00	; 0
    1ed6:	90 e0       	ldi	r25, 0x00	; 0
    1ed8:	a0 e8       	ldi	r26, 0x80	; 128
    1eda:	bf e3       	ldi	r27, 0x3F	; 63
    1edc:	8f a3       	std	Y+39, r24	; 0x27
    1ede:	98 a7       	std	Y+40, r25	; 0x28
    1ee0:	a9 a7       	std	Y+41, r26	; 0x29
    1ee2:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1ee4:	6f a1       	ldd	r22, Y+39	; 0x27
    1ee6:	78 a5       	ldd	r23, Y+40	; 0x28
    1ee8:	89 a5       	ldd	r24, Y+41	; 0x29
    1eea:	9a a5       	ldd	r25, Y+42	; 0x2a
    1eec:	20 e0       	ldi	r18, 0x00	; 0
    1eee:	30 e0       	ldi	r19, 0x00	; 0
    1ef0:	4a e7       	ldi	r20, 0x7A	; 122
    1ef2:	53 e4       	ldi	r21, 0x43	; 67
    1ef4:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1ef8:	dc 01       	movw	r26, r24
    1efa:	cb 01       	movw	r24, r22
    1efc:	8b a3       	std	Y+35, r24	; 0x23
    1efe:	9c a3       	std	Y+36, r25	; 0x24
    1f00:	ad a3       	std	Y+37, r26	; 0x25
    1f02:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    1f04:	6b a1       	ldd	r22, Y+35	; 0x23
    1f06:	7c a1       	ldd	r23, Y+36	; 0x24
    1f08:	8d a1       	ldd	r24, Y+37	; 0x25
    1f0a:	9e a1       	ldd	r25, Y+38	; 0x26
    1f0c:	20 e0       	ldi	r18, 0x00	; 0
    1f0e:	30 e0       	ldi	r19, 0x00	; 0
    1f10:	40 e8       	ldi	r20, 0x80	; 128
    1f12:	5f e3       	ldi	r21, 0x3F	; 63
    1f14:	0e 94 55 04 	call	0x8aa	; 0x8aa <__ltsf2>
    1f18:	88 23       	and	r24, r24
    1f1a:	2c f4       	brge	.+10     	; 0x1f26 <HCLCD_Vid8Bits_Init+0x16c>
		__ticks = 1;
    1f1c:	81 e0       	ldi	r24, 0x01	; 1
    1f1e:	90 e0       	ldi	r25, 0x00	; 0
    1f20:	9a a3       	std	Y+34, r25	; 0x22
    1f22:	89 a3       	std	Y+33, r24	; 0x21
    1f24:	3f c0       	rjmp	.+126    	; 0x1fa4 <HCLCD_Vid8Bits_Init+0x1ea>
	else if (__tmp > 65535)
    1f26:	6b a1       	ldd	r22, Y+35	; 0x23
    1f28:	7c a1       	ldd	r23, Y+36	; 0x24
    1f2a:	8d a1       	ldd	r24, Y+37	; 0x25
    1f2c:	9e a1       	ldd	r25, Y+38	; 0x26
    1f2e:	20 e0       	ldi	r18, 0x00	; 0
    1f30:	3f ef       	ldi	r19, 0xFF	; 255
    1f32:	4f e7       	ldi	r20, 0x7F	; 127
    1f34:	57 e4       	ldi	r21, 0x47	; 71
    1f36:	0e 94 f5 03 	call	0x7ea	; 0x7ea <__gtsf2>
    1f3a:	18 16       	cp	r1, r24
    1f3c:	4c f5       	brge	.+82     	; 0x1f90 <HCLCD_Vid8Bits_Init+0x1d6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1f3e:	6f a1       	ldd	r22, Y+39	; 0x27
    1f40:	78 a5       	ldd	r23, Y+40	; 0x28
    1f42:	89 a5       	ldd	r24, Y+41	; 0x29
    1f44:	9a a5       	ldd	r25, Y+42	; 0x2a
    1f46:	20 e0       	ldi	r18, 0x00	; 0
    1f48:	30 e0       	ldi	r19, 0x00	; 0
    1f4a:	40 e2       	ldi	r20, 0x20	; 32
    1f4c:	51 e4       	ldi	r21, 0x41	; 65
    1f4e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1f52:	dc 01       	movw	r26, r24
    1f54:	cb 01       	movw	r24, r22
    1f56:	bc 01       	movw	r22, r24
    1f58:	cd 01       	movw	r24, r26
    1f5a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1f5e:	dc 01       	movw	r26, r24
    1f60:	cb 01       	movw	r24, r22
    1f62:	9a a3       	std	Y+34, r25	; 0x22
    1f64:	89 a3       	std	Y+33, r24	; 0x21
    1f66:	0f c0       	rjmp	.+30     	; 0x1f86 <HCLCD_Vid8Bits_Init+0x1cc>
    1f68:	89 e1       	ldi	r24, 0x19	; 25
    1f6a:	90 e0       	ldi	r25, 0x00	; 0
    1f6c:	98 a3       	std	Y+32, r25	; 0x20
    1f6e:	8f 8f       	std	Y+31, r24	; 0x1f
    1f70:	8f 8d       	ldd	r24, Y+31	; 0x1f
    1f72:	98 a1       	ldd	r25, Y+32	; 0x20
    1f74:	01 97       	sbiw	r24, 0x01	; 1
    1f76:	f1 f7       	brne	.-4      	; 0x1f74 <HCLCD_Vid8Bits_Init+0x1ba>
    1f78:	98 a3       	std	Y+32, r25	; 0x20
    1f7a:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1f7c:	89 a1       	ldd	r24, Y+33	; 0x21
    1f7e:	9a a1       	ldd	r25, Y+34	; 0x22
    1f80:	01 97       	sbiw	r24, 0x01	; 1
    1f82:	9a a3       	std	Y+34, r25	; 0x22
    1f84:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1f86:	89 a1       	ldd	r24, Y+33	; 0x21
    1f88:	9a a1       	ldd	r25, Y+34	; 0x22
    1f8a:	00 97       	sbiw	r24, 0x00	; 0
    1f8c:	69 f7       	brne	.-38     	; 0x1f68 <HCLCD_Vid8Bits_Init+0x1ae>
    1f8e:	14 c0       	rjmp	.+40     	; 0x1fb8 <HCLCD_Vid8Bits_Init+0x1fe>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1f90:	6b a1       	ldd	r22, Y+35	; 0x23
    1f92:	7c a1       	ldd	r23, Y+36	; 0x24
    1f94:	8d a1       	ldd	r24, Y+37	; 0x25
    1f96:	9e a1       	ldd	r25, Y+38	; 0x26
    1f98:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1f9c:	dc 01       	movw	r26, r24
    1f9e:	cb 01       	movw	r24, r22
    1fa0:	9a a3       	std	Y+34, r25	; 0x22
    1fa2:	89 a3       	std	Y+33, r24	; 0x21
    1fa4:	89 a1       	ldd	r24, Y+33	; 0x21
    1fa6:	9a a1       	ldd	r25, Y+34	; 0x22
    1fa8:	9e 8f       	std	Y+30, r25	; 0x1e
    1faa:	8d 8f       	std	Y+29, r24	; 0x1d
    1fac:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1fae:	9e 8d       	ldd	r25, Y+30	; 0x1e
    1fb0:	01 97       	sbiw	r24, 0x01	; 1
    1fb2:	f1 f7       	brne	.-4      	; 0x1fb0 <HCLCD_Vid8Bits_Init+0x1f6>
    1fb4:	9e 8f       	std	Y+30, r25	; 0x1e
    1fb6:	8d 8f       	std	Y+29, r24	; 0x1d
	_delay_ms(1);
	/*send Display on/off  command*/
	HCLCD_VidWriteCommand_8Bits(HCLCD_DISPLAY_ON_OFF);
    1fb8:	8f e0       	ldi	r24, 0x0F	; 15
    1fba:	0e 94 cd 0d 	call	0x1b9a	; 0x1b9a <HCLCD_VidWriteCommand_8Bits>
    1fbe:	80 e0       	ldi	r24, 0x00	; 0
    1fc0:	90 e0       	ldi	r25, 0x00	; 0
    1fc2:	a0 e8       	ldi	r26, 0x80	; 128
    1fc4:	bf e3       	ldi	r27, 0x3F	; 63
    1fc6:	89 8f       	std	Y+25, r24	; 0x19
    1fc8:	9a 8f       	std	Y+26, r25	; 0x1a
    1fca:	ab 8f       	std	Y+27, r26	; 0x1b
    1fcc:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1fce:	69 8d       	ldd	r22, Y+25	; 0x19
    1fd0:	7a 8d       	ldd	r23, Y+26	; 0x1a
    1fd2:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1fd4:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1fd6:	20 e0       	ldi	r18, 0x00	; 0
    1fd8:	30 e0       	ldi	r19, 0x00	; 0
    1fda:	4a e7       	ldi	r20, 0x7A	; 122
    1fdc:	53 e4       	ldi	r21, 0x43	; 67
    1fde:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1fe2:	dc 01       	movw	r26, r24
    1fe4:	cb 01       	movw	r24, r22
    1fe6:	8d 8b       	std	Y+21, r24	; 0x15
    1fe8:	9e 8b       	std	Y+22, r25	; 0x16
    1fea:	af 8b       	std	Y+23, r26	; 0x17
    1fec:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    1fee:	6d 89       	ldd	r22, Y+21	; 0x15
    1ff0:	7e 89       	ldd	r23, Y+22	; 0x16
    1ff2:	8f 89       	ldd	r24, Y+23	; 0x17
    1ff4:	98 8d       	ldd	r25, Y+24	; 0x18
    1ff6:	20 e0       	ldi	r18, 0x00	; 0
    1ff8:	30 e0       	ldi	r19, 0x00	; 0
    1ffa:	40 e8       	ldi	r20, 0x80	; 128
    1ffc:	5f e3       	ldi	r21, 0x3F	; 63
    1ffe:	0e 94 55 04 	call	0x8aa	; 0x8aa <__ltsf2>
    2002:	88 23       	and	r24, r24
    2004:	2c f4       	brge	.+10     	; 0x2010 <HCLCD_Vid8Bits_Init+0x256>
		__ticks = 1;
    2006:	81 e0       	ldi	r24, 0x01	; 1
    2008:	90 e0       	ldi	r25, 0x00	; 0
    200a:	9c 8b       	std	Y+20, r25	; 0x14
    200c:	8b 8b       	std	Y+19, r24	; 0x13
    200e:	3f c0       	rjmp	.+126    	; 0x208e <HCLCD_Vid8Bits_Init+0x2d4>
	else if (__tmp > 65535)
    2010:	6d 89       	ldd	r22, Y+21	; 0x15
    2012:	7e 89       	ldd	r23, Y+22	; 0x16
    2014:	8f 89       	ldd	r24, Y+23	; 0x17
    2016:	98 8d       	ldd	r25, Y+24	; 0x18
    2018:	20 e0       	ldi	r18, 0x00	; 0
    201a:	3f ef       	ldi	r19, 0xFF	; 255
    201c:	4f e7       	ldi	r20, 0x7F	; 127
    201e:	57 e4       	ldi	r21, 0x47	; 71
    2020:	0e 94 f5 03 	call	0x7ea	; 0x7ea <__gtsf2>
    2024:	18 16       	cp	r1, r24
    2026:	4c f5       	brge	.+82     	; 0x207a <HCLCD_Vid8Bits_Init+0x2c0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2028:	69 8d       	ldd	r22, Y+25	; 0x19
    202a:	7a 8d       	ldd	r23, Y+26	; 0x1a
    202c:	8b 8d       	ldd	r24, Y+27	; 0x1b
    202e:	9c 8d       	ldd	r25, Y+28	; 0x1c
    2030:	20 e0       	ldi	r18, 0x00	; 0
    2032:	30 e0       	ldi	r19, 0x00	; 0
    2034:	40 e2       	ldi	r20, 0x20	; 32
    2036:	51 e4       	ldi	r21, 0x41	; 65
    2038:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    203c:	dc 01       	movw	r26, r24
    203e:	cb 01       	movw	r24, r22
    2040:	bc 01       	movw	r22, r24
    2042:	cd 01       	movw	r24, r26
    2044:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2048:	dc 01       	movw	r26, r24
    204a:	cb 01       	movw	r24, r22
    204c:	9c 8b       	std	Y+20, r25	; 0x14
    204e:	8b 8b       	std	Y+19, r24	; 0x13
    2050:	0f c0       	rjmp	.+30     	; 0x2070 <HCLCD_Vid8Bits_Init+0x2b6>
    2052:	89 e1       	ldi	r24, 0x19	; 25
    2054:	90 e0       	ldi	r25, 0x00	; 0
    2056:	9a 8b       	std	Y+18, r25	; 0x12
    2058:	89 8b       	std	Y+17, r24	; 0x11
    205a:	89 89       	ldd	r24, Y+17	; 0x11
    205c:	9a 89       	ldd	r25, Y+18	; 0x12
    205e:	01 97       	sbiw	r24, 0x01	; 1
    2060:	f1 f7       	brne	.-4      	; 0x205e <HCLCD_Vid8Bits_Init+0x2a4>
    2062:	9a 8b       	std	Y+18, r25	; 0x12
    2064:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2066:	8b 89       	ldd	r24, Y+19	; 0x13
    2068:	9c 89       	ldd	r25, Y+20	; 0x14
    206a:	01 97       	sbiw	r24, 0x01	; 1
    206c:	9c 8b       	std	Y+20, r25	; 0x14
    206e:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2070:	8b 89       	ldd	r24, Y+19	; 0x13
    2072:	9c 89       	ldd	r25, Y+20	; 0x14
    2074:	00 97       	sbiw	r24, 0x00	; 0
    2076:	69 f7       	brne	.-38     	; 0x2052 <HCLCD_Vid8Bits_Init+0x298>
    2078:	14 c0       	rjmp	.+40     	; 0x20a2 <HCLCD_Vid8Bits_Init+0x2e8>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    207a:	6d 89       	ldd	r22, Y+21	; 0x15
    207c:	7e 89       	ldd	r23, Y+22	; 0x16
    207e:	8f 89       	ldd	r24, Y+23	; 0x17
    2080:	98 8d       	ldd	r25, Y+24	; 0x18
    2082:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2086:	dc 01       	movw	r26, r24
    2088:	cb 01       	movw	r24, r22
    208a:	9c 8b       	std	Y+20, r25	; 0x14
    208c:	8b 8b       	std	Y+19, r24	; 0x13
    208e:	8b 89       	ldd	r24, Y+19	; 0x13
    2090:	9c 89       	ldd	r25, Y+20	; 0x14
    2092:	98 8b       	std	Y+16, r25	; 0x10
    2094:	8f 87       	std	Y+15, r24	; 0x0f
    2096:	8f 85       	ldd	r24, Y+15	; 0x0f
    2098:	98 89       	ldd	r25, Y+16	; 0x10
    209a:	01 97       	sbiw	r24, 0x01	; 1
    209c:	f1 f7       	brne	.-4      	; 0x209a <HCLCD_Vid8Bits_Init+0x2e0>
    209e:	98 8b       	std	Y+16, r25	; 0x10
    20a0:	8f 87       	std	Y+15, r24	; 0x0f
	_delay_ms(1);
	/*send Display Clear  command*/
	HCLCD_VidWriteCommand_8Bits(DISPLAY_CLEAR);
    20a2:	81 e0       	ldi	r24, 0x01	; 1
    20a4:	0e 94 cd 0d 	call	0x1b9a	; 0x1b9a <HCLCD_VidWriteCommand_8Bits>
    20a8:	80 e0       	ldi	r24, 0x00	; 0
    20aa:	90 e0       	ldi	r25, 0x00	; 0
    20ac:	a0 e0       	ldi	r26, 0x00	; 0
    20ae:	b0 e4       	ldi	r27, 0x40	; 64
    20b0:	8b 87       	std	Y+11, r24	; 0x0b
    20b2:	9c 87       	std	Y+12, r25	; 0x0c
    20b4:	ad 87       	std	Y+13, r26	; 0x0d
    20b6:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    20b8:	6b 85       	ldd	r22, Y+11	; 0x0b
    20ba:	7c 85       	ldd	r23, Y+12	; 0x0c
    20bc:	8d 85       	ldd	r24, Y+13	; 0x0d
    20be:	9e 85       	ldd	r25, Y+14	; 0x0e
    20c0:	20 e0       	ldi	r18, 0x00	; 0
    20c2:	30 e0       	ldi	r19, 0x00	; 0
    20c4:	4a e7       	ldi	r20, 0x7A	; 122
    20c6:	53 e4       	ldi	r21, 0x43	; 67
    20c8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    20cc:	dc 01       	movw	r26, r24
    20ce:	cb 01       	movw	r24, r22
    20d0:	8f 83       	std	Y+7, r24	; 0x07
    20d2:	98 87       	std	Y+8, r25	; 0x08
    20d4:	a9 87       	std	Y+9, r26	; 0x09
    20d6:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    20d8:	6f 81       	ldd	r22, Y+7	; 0x07
    20da:	78 85       	ldd	r23, Y+8	; 0x08
    20dc:	89 85       	ldd	r24, Y+9	; 0x09
    20de:	9a 85       	ldd	r25, Y+10	; 0x0a
    20e0:	20 e0       	ldi	r18, 0x00	; 0
    20e2:	30 e0       	ldi	r19, 0x00	; 0
    20e4:	40 e8       	ldi	r20, 0x80	; 128
    20e6:	5f e3       	ldi	r21, 0x3F	; 63
    20e8:	0e 94 55 04 	call	0x8aa	; 0x8aa <__ltsf2>
    20ec:	88 23       	and	r24, r24
    20ee:	2c f4       	brge	.+10     	; 0x20fa <HCLCD_Vid8Bits_Init+0x340>
		__ticks = 1;
    20f0:	81 e0       	ldi	r24, 0x01	; 1
    20f2:	90 e0       	ldi	r25, 0x00	; 0
    20f4:	9e 83       	std	Y+6, r25	; 0x06
    20f6:	8d 83       	std	Y+5, r24	; 0x05
    20f8:	3f c0       	rjmp	.+126    	; 0x2178 <HCLCD_Vid8Bits_Init+0x3be>
	else if (__tmp > 65535)
    20fa:	6f 81       	ldd	r22, Y+7	; 0x07
    20fc:	78 85       	ldd	r23, Y+8	; 0x08
    20fe:	89 85       	ldd	r24, Y+9	; 0x09
    2100:	9a 85       	ldd	r25, Y+10	; 0x0a
    2102:	20 e0       	ldi	r18, 0x00	; 0
    2104:	3f ef       	ldi	r19, 0xFF	; 255
    2106:	4f e7       	ldi	r20, 0x7F	; 127
    2108:	57 e4       	ldi	r21, 0x47	; 71
    210a:	0e 94 f5 03 	call	0x7ea	; 0x7ea <__gtsf2>
    210e:	18 16       	cp	r1, r24
    2110:	4c f5       	brge	.+82     	; 0x2164 <HCLCD_Vid8Bits_Init+0x3aa>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2112:	6b 85       	ldd	r22, Y+11	; 0x0b
    2114:	7c 85       	ldd	r23, Y+12	; 0x0c
    2116:	8d 85       	ldd	r24, Y+13	; 0x0d
    2118:	9e 85       	ldd	r25, Y+14	; 0x0e
    211a:	20 e0       	ldi	r18, 0x00	; 0
    211c:	30 e0       	ldi	r19, 0x00	; 0
    211e:	40 e2       	ldi	r20, 0x20	; 32
    2120:	51 e4       	ldi	r21, 0x41	; 65
    2122:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2126:	dc 01       	movw	r26, r24
    2128:	cb 01       	movw	r24, r22
    212a:	bc 01       	movw	r22, r24
    212c:	cd 01       	movw	r24, r26
    212e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2132:	dc 01       	movw	r26, r24
    2134:	cb 01       	movw	r24, r22
    2136:	9e 83       	std	Y+6, r25	; 0x06
    2138:	8d 83       	std	Y+5, r24	; 0x05
    213a:	0f c0       	rjmp	.+30     	; 0x215a <HCLCD_Vid8Bits_Init+0x3a0>
    213c:	89 e1       	ldi	r24, 0x19	; 25
    213e:	90 e0       	ldi	r25, 0x00	; 0
    2140:	9c 83       	std	Y+4, r25	; 0x04
    2142:	8b 83       	std	Y+3, r24	; 0x03
    2144:	8b 81       	ldd	r24, Y+3	; 0x03
    2146:	9c 81       	ldd	r25, Y+4	; 0x04
    2148:	01 97       	sbiw	r24, 0x01	; 1
    214a:	f1 f7       	brne	.-4      	; 0x2148 <HCLCD_Vid8Bits_Init+0x38e>
    214c:	9c 83       	std	Y+4, r25	; 0x04
    214e:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2150:	8d 81       	ldd	r24, Y+5	; 0x05
    2152:	9e 81       	ldd	r25, Y+6	; 0x06
    2154:	01 97       	sbiw	r24, 0x01	; 1
    2156:	9e 83       	std	Y+6, r25	; 0x06
    2158:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    215a:	8d 81       	ldd	r24, Y+5	; 0x05
    215c:	9e 81       	ldd	r25, Y+6	; 0x06
    215e:	00 97       	sbiw	r24, 0x00	; 0
    2160:	69 f7       	brne	.-38     	; 0x213c <HCLCD_Vid8Bits_Init+0x382>
    2162:	14 c0       	rjmp	.+40     	; 0x218c <HCLCD_Vid8Bits_Init+0x3d2>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2164:	6f 81       	ldd	r22, Y+7	; 0x07
    2166:	78 85       	ldd	r23, Y+8	; 0x08
    2168:	89 85       	ldd	r24, Y+9	; 0x09
    216a:	9a 85       	ldd	r25, Y+10	; 0x0a
    216c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2170:	dc 01       	movw	r26, r24
    2172:	cb 01       	movw	r24, r22
    2174:	9e 83       	std	Y+6, r25	; 0x06
    2176:	8d 83       	std	Y+5, r24	; 0x05
    2178:	8d 81       	ldd	r24, Y+5	; 0x05
    217a:	9e 81       	ldd	r25, Y+6	; 0x06
    217c:	9a 83       	std	Y+2, r25	; 0x02
    217e:	89 83       	std	Y+1, r24	; 0x01
    2180:	89 81       	ldd	r24, Y+1	; 0x01
    2182:	9a 81       	ldd	r25, Y+2	; 0x02
    2184:	01 97       	sbiw	r24, 0x01	; 1
    2186:	f1 f7       	brne	.-4      	; 0x2184 <HCLCD_Vid8Bits_Init+0x3ca>
    2188:	9a 83       	std	Y+2, r25	; 0x02
    218a:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(2);
	/*send Entry Mode  set command*/
	HCLCD_VidWriteCommand_8Bits(HCLCD_ENTRY_MODE_SET);
    218c:	86 e0       	ldi	r24, 0x06	; 6
    218e:	0e 94 cd 0d 	call	0x1b9a	; 0x1b9a <HCLCD_VidWriteCommand_8Bits>
}
    2192:	e8 96       	adiw	r28, 0x38	; 56
    2194:	0f b6       	in	r0, 0x3f	; 63
    2196:	f8 94       	cli
    2198:	de bf       	out	0x3e, r29	; 62
    219a:	0f be       	out	0x3f, r0	; 63
    219c:	cd bf       	out	0x3d, r28	; 61
    219e:	cf 91       	pop	r28
    21a0:	df 91       	pop	r29
    21a2:	08 95       	ret

000021a4 <HCLCD_VidWriteChar_8Bits>:
void HCLCD_VidWriteChar_8Bits(u8 Copy_u8Data)
{
    21a4:	df 93       	push	r29
    21a6:	cf 93       	push	r28
    21a8:	cd b7       	in	r28, 0x3d	; 61
    21aa:	de b7       	in	r29, 0x3e	; 62
    21ac:	6d 97       	sbiw	r28, 0x1d	; 29
    21ae:	0f b6       	in	r0, 0x3f	; 63
    21b0:	f8 94       	cli
    21b2:	de bf       	out	0x3e, r29	; 62
    21b4:	0f be       	out	0x3f, r0	; 63
    21b6:	cd bf       	out	0x3d, r28	; 61
    21b8:	8d 8f       	std	Y+29, r24	; 0x1d
	/*select Data register--> Write one on Rs pin*/
	MDIO_Error_State_SetPinValue(RS,CONTROL_PORT,PIN_HIGH);
    21ba:	81 e0       	ldi	r24, 0x01	; 1
    21bc:	61 e0       	ldi	r22, 0x01	; 1
    21be:	41 e0       	ldi	r20, 0x01	; 1
    21c0:	0e 94 e2 09 	call	0x13c4	; 0x13c4 <MDIO_Error_State_SetPinValue>
	/*select Write mode--> Write zero on RW pin*/
	//MDIO_Error_State_SetPinValue(RW,CONTROL_PORT,PIN_LOW);
	/*Send Command ON port Data*/
	MDIO_Error_State_SetPortValue(DATA_PORT,Copy_u8Data);
    21c4:	80 e0       	ldi	r24, 0x00	; 0
    21c6:	6d 8d       	ldd	r22, Y+29	; 0x1d
    21c8:	0e 94 e5 0a 	call	0x15ca	; 0x15ca <MDIO_Error_State_SetPortValue>
	/*Send Enable*/
	MDIO_Error_State_SetPinValue(E,CONTROL_PORT,PIN_HIGH);
    21cc:	83 e0       	ldi	r24, 0x03	; 3
    21ce:	61 e0       	ldi	r22, 0x01	; 1
    21d0:	41 e0       	ldi	r20, 0x01	; 1
    21d2:	0e 94 e2 09 	call	0x13c4	; 0x13c4 <MDIO_Error_State_SetPinValue>
    21d6:	80 e0       	ldi	r24, 0x00	; 0
    21d8:	90 e0       	ldi	r25, 0x00	; 0
    21da:	a0 e0       	ldi	r26, 0x00	; 0
    21dc:	b0 e4       	ldi	r27, 0x40	; 64
    21de:	89 8f       	std	Y+25, r24	; 0x19
    21e0:	9a 8f       	std	Y+26, r25	; 0x1a
    21e2:	ab 8f       	std	Y+27, r26	; 0x1b
    21e4:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    21e6:	69 8d       	ldd	r22, Y+25	; 0x19
    21e8:	7a 8d       	ldd	r23, Y+26	; 0x1a
    21ea:	8b 8d       	ldd	r24, Y+27	; 0x1b
    21ec:	9c 8d       	ldd	r25, Y+28	; 0x1c
    21ee:	20 e0       	ldi	r18, 0x00	; 0
    21f0:	30 e0       	ldi	r19, 0x00	; 0
    21f2:	4a e7       	ldi	r20, 0x7A	; 122
    21f4:	53 e4       	ldi	r21, 0x43	; 67
    21f6:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    21fa:	dc 01       	movw	r26, r24
    21fc:	cb 01       	movw	r24, r22
    21fe:	8d 8b       	std	Y+21, r24	; 0x15
    2200:	9e 8b       	std	Y+22, r25	; 0x16
    2202:	af 8b       	std	Y+23, r26	; 0x17
    2204:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    2206:	6d 89       	ldd	r22, Y+21	; 0x15
    2208:	7e 89       	ldd	r23, Y+22	; 0x16
    220a:	8f 89       	ldd	r24, Y+23	; 0x17
    220c:	98 8d       	ldd	r25, Y+24	; 0x18
    220e:	20 e0       	ldi	r18, 0x00	; 0
    2210:	30 e0       	ldi	r19, 0x00	; 0
    2212:	40 e8       	ldi	r20, 0x80	; 128
    2214:	5f e3       	ldi	r21, 0x3F	; 63
    2216:	0e 94 55 04 	call	0x8aa	; 0x8aa <__ltsf2>
    221a:	88 23       	and	r24, r24
    221c:	2c f4       	brge	.+10     	; 0x2228 <HCLCD_VidWriteChar_8Bits+0x84>
		__ticks = 1;
    221e:	81 e0       	ldi	r24, 0x01	; 1
    2220:	90 e0       	ldi	r25, 0x00	; 0
    2222:	9c 8b       	std	Y+20, r25	; 0x14
    2224:	8b 8b       	std	Y+19, r24	; 0x13
    2226:	3f c0       	rjmp	.+126    	; 0x22a6 <HCLCD_VidWriteChar_8Bits+0x102>
	else if (__tmp > 65535)
    2228:	6d 89       	ldd	r22, Y+21	; 0x15
    222a:	7e 89       	ldd	r23, Y+22	; 0x16
    222c:	8f 89       	ldd	r24, Y+23	; 0x17
    222e:	98 8d       	ldd	r25, Y+24	; 0x18
    2230:	20 e0       	ldi	r18, 0x00	; 0
    2232:	3f ef       	ldi	r19, 0xFF	; 255
    2234:	4f e7       	ldi	r20, 0x7F	; 127
    2236:	57 e4       	ldi	r21, 0x47	; 71
    2238:	0e 94 f5 03 	call	0x7ea	; 0x7ea <__gtsf2>
    223c:	18 16       	cp	r1, r24
    223e:	4c f5       	brge	.+82     	; 0x2292 <HCLCD_VidWriteChar_8Bits+0xee>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2240:	69 8d       	ldd	r22, Y+25	; 0x19
    2242:	7a 8d       	ldd	r23, Y+26	; 0x1a
    2244:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2246:	9c 8d       	ldd	r25, Y+28	; 0x1c
    2248:	20 e0       	ldi	r18, 0x00	; 0
    224a:	30 e0       	ldi	r19, 0x00	; 0
    224c:	40 e2       	ldi	r20, 0x20	; 32
    224e:	51 e4       	ldi	r21, 0x41	; 65
    2250:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2254:	dc 01       	movw	r26, r24
    2256:	cb 01       	movw	r24, r22
    2258:	bc 01       	movw	r22, r24
    225a:	cd 01       	movw	r24, r26
    225c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2260:	dc 01       	movw	r26, r24
    2262:	cb 01       	movw	r24, r22
    2264:	9c 8b       	std	Y+20, r25	; 0x14
    2266:	8b 8b       	std	Y+19, r24	; 0x13
    2268:	0f c0       	rjmp	.+30     	; 0x2288 <HCLCD_VidWriteChar_8Bits+0xe4>
    226a:	89 e1       	ldi	r24, 0x19	; 25
    226c:	90 e0       	ldi	r25, 0x00	; 0
    226e:	9a 8b       	std	Y+18, r25	; 0x12
    2270:	89 8b       	std	Y+17, r24	; 0x11
    2272:	89 89       	ldd	r24, Y+17	; 0x11
    2274:	9a 89       	ldd	r25, Y+18	; 0x12
    2276:	01 97       	sbiw	r24, 0x01	; 1
    2278:	f1 f7       	brne	.-4      	; 0x2276 <HCLCD_VidWriteChar_8Bits+0xd2>
    227a:	9a 8b       	std	Y+18, r25	; 0x12
    227c:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    227e:	8b 89       	ldd	r24, Y+19	; 0x13
    2280:	9c 89       	ldd	r25, Y+20	; 0x14
    2282:	01 97       	sbiw	r24, 0x01	; 1
    2284:	9c 8b       	std	Y+20, r25	; 0x14
    2286:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2288:	8b 89       	ldd	r24, Y+19	; 0x13
    228a:	9c 89       	ldd	r25, Y+20	; 0x14
    228c:	00 97       	sbiw	r24, 0x00	; 0
    228e:	69 f7       	brne	.-38     	; 0x226a <HCLCD_VidWriteChar_8Bits+0xc6>
    2290:	14 c0       	rjmp	.+40     	; 0x22ba <HCLCD_VidWriteChar_8Bits+0x116>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2292:	6d 89       	ldd	r22, Y+21	; 0x15
    2294:	7e 89       	ldd	r23, Y+22	; 0x16
    2296:	8f 89       	ldd	r24, Y+23	; 0x17
    2298:	98 8d       	ldd	r25, Y+24	; 0x18
    229a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    229e:	dc 01       	movw	r26, r24
    22a0:	cb 01       	movw	r24, r22
    22a2:	9c 8b       	std	Y+20, r25	; 0x14
    22a4:	8b 8b       	std	Y+19, r24	; 0x13
    22a6:	8b 89       	ldd	r24, Y+19	; 0x13
    22a8:	9c 89       	ldd	r25, Y+20	; 0x14
    22aa:	98 8b       	std	Y+16, r25	; 0x10
    22ac:	8f 87       	std	Y+15, r24	; 0x0f
    22ae:	8f 85       	ldd	r24, Y+15	; 0x0f
    22b0:	98 89       	ldd	r25, Y+16	; 0x10
    22b2:	01 97       	sbiw	r24, 0x01	; 1
    22b4:	f1 f7       	brne	.-4      	; 0x22b2 <HCLCD_VidWriteChar_8Bits+0x10e>
    22b6:	98 8b       	std	Y+16, r25	; 0x10
    22b8:	8f 87       	std	Y+15, r24	; 0x0f
	_delay_ms(2);
	MDIO_Error_State_SetPinValue(E,CONTROL_PORT,PIN_LOW);
    22ba:	83 e0       	ldi	r24, 0x03	; 3
    22bc:	61 e0       	ldi	r22, 0x01	; 1
    22be:	40 e0       	ldi	r20, 0x00	; 0
    22c0:	0e 94 e2 09 	call	0x13c4	; 0x13c4 <MDIO_Error_State_SetPinValue>
    22c4:	80 e0       	ldi	r24, 0x00	; 0
    22c6:	90 e0       	ldi	r25, 0x00	; 0
    22c8:	a0 e0       	ldi	r26, 0x00	; 0
    22ca:	b0 e4       	ldi	r27, 0x40	; 64
    22cc:	8b 87       	std	Y+11, r24	; 0x0b
    22ce:	9c 87       	std	Y+12, r25	; 0x0c
    22d0:	ad 87       	std	Y+13, r26	; 0x0d
    22d2:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    22d4:	6b 85       	ldd	r22, Y+11	; 0x0b
    22d6:	7c 85       	ldd	r23, Y+12	; 0x0c
    22d8:	8d 85       	ldd	r24, Y+13	; 0x0d
    22da:	9e 85       	ldd	r25, Y+14	; 0x0e
    22dc:	20 e0       	ldi	r18, 0x00	; 0
    22de:	30 e0       	ldi	r19, 0x00	; 0
    22e0:	4a e7       	ldi	r20, 0x7A	; 122
    22e2:	53 e4       	ldi	r21, 0x43	; 67
    22e4:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    22e8:	dc 01       	movw	r26, r24
    22ea:	cb 01       	movw	r24, r22
    22ec:	8f 83       	std	Y+7, r24	; 0x07
    22ee:	98 87       	std	Y+8, r25	; 0x08
    22f0:	a9 87       	std	Y+9, r26	; 0x09
    22f2:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    22f4:	6f 81       	ldd	r22, Y+7	; 0x07
    22f6:	78 85       	ldd	r23, Y+8	; 0x08
    22f8:	89 85       	ldd	r24, Y+9	; 0x09
    22fa:	9a 85       	ldd	r25, Y+10	; 0x0a
    22fc:	20 e0       	ldi	r18, 0x00	; 0
    22fe:	30 e0       	ldi	r19, 0x00	; 0
    2300:	40 e8       	ldi	r20, 0x80	; 128
    2302:	5f e3       	ldi	r21, 0x3F	; 63
    2304:	0e 94 55 04 	call	0x8aa	; 0x8aa <__ltsf2>
    2308:	88 23       	and	r24, r24
    230a:	2c f4       	brge	.+10     	; 0x2316 <HCLCD_VidWriteChar_8Bits+0x172>
		__ticks = 1;
    230c:	81 e0       	ldi	r24, 0x01	; 1
    230e:	90 e0       	ldi	r25, 0x00	; 0
    2310:	9e 83       	std	Y+6, r25	; 0x06
    2312:	8d 83       	std	Y+5, r24	; 0x05
    2314:	3f c0       	rjmp	.+126    	; 0x2394 <HCLCD_VidWriteChar_8Bits+0x1f0>
	else if (__tmp > 65535)
    2316:	6f 81       	ldd	r22, Y+7	; 0x07
    2318:	78 85       	ldd	r23, Y+8	; 0x08
    231a:	89 85       	ldd	r24, Y+9	; 0x09
    231c:	9a 85       	ldd	r25, Y+10	; 0x0a
    231e:	20 e0       	ldi	r18, 0x00	; 0
    2320:	3f ef       	ldi	r19, 0xFF	; 255
    2322:	4f e7       	ldi	r20, 0x7F	; 127
    2324:	57 e4       	ldi	r21, 0x47	; 71
    2326:	0e 94 f5 03 	call	0x7ea	; 0x7ea <__gtsf2>
    232a:	18 16       	cp	r1, r24
    232c:	4c f5       	brge	.+82     	; 0x2380 <HCLCD_VidWriteChar_8Bits+0x1dc>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    232e:	6b 85       	ldd	r22, Y+11	; 0x0b
    2330:	7c 85       	ldd	r23, Y+12	; 0x0c
    2332:	8d 85       	ldd	r24, Y+13	; 0x0d
    2334:	9e 85       	ldd	r25, Y+14	; 0x0e
    2336:	20 e0       	ldi	r18, 0x00	; 0
    2338:	30 e0       	ldi	r19, 0x00	; 0
    233a:	40 e2       	ldi	r20, 0x20	; 32
    233c:	51 e4       	ldi	r21, 0x41	; 65
    233e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2342:	dc 01       	movw	r26, r24
    2344:	cb 01       	movw	r24, r22
    2346:	bc 01       	movw	r22, r24
    2348:	cd 01       	movw	r24, r26
    234a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    234e:	dc 01       	movw	r26, r24
    2350:	cb 01       	movw	r24, r22
    2352:	9e 83       	std	Y+6, r25	; 0x06
    2354:	8d 83       	std	Y+5, r24	; 0x05
    2356:	0f c0       	rjmp	.+30     	; 0x2376 <HCLCD_VidWriteChar_8Bits+0x1d2>
    2358:	89 e1       	ldi	r24, 0x19	; 25
    235a:	90 e0       	ldi	r25, 0x00	; 0
    235c:	9c 83       	std	Y+4, r25	; 0x04
    235e:	8b 83       	std	Y+3, r24	; 0x03
    2360:	8b 81       	ldd	r24, Y+3	; 0x03
    2362:	9c 81       	ldd	r25, Y+4	; 0x04
    2364:	01 97       	sbiw	r24, 0x01	; 1
    2366:	f1 f7       	brne	.-4      	; 0x2364 <HCLCD_VidWriteChar_8Bits+0x1c0>
    2368:	9c 83       	std	Y+4, r25	; 0x04
    236a:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    236c:	8d 81       	ldd	r24, Y+5	; 0x05
    236e:	9e 81       	ldd	r25, Y+6	; 0x06
    2370:	01 97       	sbiw	r24, 0x01	; 1
    2372:	9e 83       	std	Y+6, r25	; 0x06
    2374:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2376:	8d 81       	ldd	r24, Y+5	; 0x05
    2378:	9e 81       	ldd	r25, Y+6	; 0x06
    237a:	00 97       	sbiw	r24, 0x00	; 0
    237c:	69 f7       	brne	.-38     	; 0x2358 <HCLCD_VidWriteChar_8Bits+0x1b4>
    237e:	14 c0       	rjmp	.+40     	; 0x23a8 <HCLCD_VidWriteChar_8Bits+0x204>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2380:	6f 81       	ldd	r22, Y+7	; 0x07
    2382:	78 85       	ldd	r23, Y+8	; 0x08
    2384:	89 85       	ldd	r24, Y+9	; 0x09
    2386:	9a 85       	ldd	r25, Y+10	; 0x0a
    2388:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    238c:	dc 01       	movw	r26, r24
    238e:	cb 01       	movw	r24, r22
    2390:	9e 83       	std	Y+6, r25	; 0x06
    2392:	8d 83       	std	Y+5, r24	; 0x05
    2394:	8d 81       	ldd	r24, Y+5	; 0x05
    2396:	9e 81       	ldd	r25, Y+6	; 0x06
    2398:	9a 83       	std	Y+2, r25	; 0x02
    239a:	89 83       	std	Y+1, r24	; 0x01
    239c:	89 81       	ldd	r24, Y+1	; 0x01
    239e:	9a 81       	ldd	r25, Y+2	; 0x02
    23a0:	01 97       	sbiw	r24, 0x01	; 1
    23a2:	f1 f7       	brne	.-4      	; 0x23a0 <HCLCD_VidWriteChar_8Bits+0x1fc>
    23a4:	9a 83       	std	Y+2, r25	; 0x02
    23a6:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(2);
	MDIO_Error_State_SetPinValue(E,CONTROL_PORT,PIN_HIGH);	
    23a8:	83 e0       	ldi	r24, 0x03	; 3
    23aa:	61 e0       	ldi	r22, 0x01	; 1
    23ac:	41 e0       	ldi	r20, 0x01	; 1
    23ae:	0e 94 e2 09 	call	0x13c4	; 0x13c4 <MDIO_Error_State_SetPinValue>
}
    23b2:	6d 96       	adiw	r28, 0x1d	; 29
    23b4:	0f b6       	in	r0, 0x3f	; 63
    23b6:	f8 94       	cli
    23b8:	de bf       	out	0x3e, r29	; 62
    23ba:	0f be       	out	0x3f, r0	; 63
    23bc:	cd bf       	out	0x3d, r28	; 61
    23be:	cf 91       	pop	r28
    23c0:	df 91       	pop	r29
    23c2:	08 95       	ret

000023c4 <HCLCD_VidWriteString_8Bits>:

void HCLCD_VidWriteString_8Bits(u8* PCopy_u8String)
{
    23c4:	df 93       	push	r29
    23c6:	cf 93       	push	r28
    23c8:	00 d0       	rcall	.+0      	; 0x23ca <HCLCD_VidWriteString_8Bits+0x6>
    23ca:	0f 92       	push	r0
    23cc:	cd b7       	in	r28, 0x3d	; 61
    23ce:	de b7       	in	r29, 0x3e	; 62
    23d0:	9b 83       	std	Y+3, r25	; 0x03
    23d2:	8a 83       	std	Y+2, r24	; 0x02
	u8 Loc_u8Count=0;
    23d4:	19 82       	std	Y+1, r1	; 0x01
    23d6:	0e c0       	rjmp	.+28     	; 0x23f4 <HCLCD_VidWriteString_8Bits+0x30>
	while(PCopy_u8String[Loc_u8Count]!=NULL)
	{
		HCLCD_VidWriteChar_8Bits(PCopy_u8String[Loc_u8Count]);
    23d8:	89 81       	ldd	r24, Y+1	; 0x01
    23da:	28 2f       	mov	r18, r24
    23dc:	30 e0       	ldi	r19, 0x00	; 0
    23de:	8a 81       	ldd	r24, Y+2	; 0x02
    23e0:	9b 81       	ldd	r25, Y+3	; 0x03
    23e2:	fc 01       	movw	r30, r24
    23e4:	e2 0f       	add	r30, r18
    23e6:	f3 1f       	adc	r31, r19
    23e8:	80 81       	ld	r24, Z
    23ea:	0e 94 d2 10 	call	0x21a4	; 0x21a4 <HCLCD_VidWriteChar_8Bits>
		Loc_u8Count++;
    23ee:	89 81       	ldd	r24, Y+1	; 0x01
    23f0:	8f 5f       	subi	r24, 0xFF	; 255
    23f2:	89 83       	std	Y+1, r24	; 0x01
}

void HCLCD_VidWriteString_8Bits(u8* PCopy_u8String)
{
	u8 Loc_u8Count=0;
	while(PCopy_u8String[Loc_u8Count]!=NULL)
    23f4:	89 81       	ldd	r24, Y+1	; 0x01
    23f6:	28 2f       	mov	r18, r24
    23f8:	30 e0       	ldi	r19, 0x00	; 0
    23fa:	8a 81       	ldd	r24, Y+2	; 0x02
    23fc:	9b 81       	ldd	r25, Y+3	; 0x03
    23fe:	fc 01       	movw	r30, r24
    2400:	e2 0f       	add	r30, r18
    2402:	f3 1f       	adc	r31, r19
    2404:	80 81       	ld	r24, Z
    2406:	88 23       	and	r24, r24
    2408:	39 f7       	brne	.-50     	; 0x23d8 <HCLCD_VidWriteString_8Bits+0x14>
	{
		HCLCD_VidWriteChar_8Bits(PCopy_u8String[Loc_u8Count]);
		Loc_u8Count++;
	}
}
    240a:	0f 90       	pop	r0
    240c:	0f 90       	pop	r0
    240e:	0f 90       	pop	r0
    2410:	cf 91       	pop	r28
    2412:	df 91       	pop	r29
    2414:	08 95       	ret

00002416 <HCLCD_VidWriteNumber_8Bits>:
void HCLCD_VidWriteNumber_8Bits(u32 Copy_u8Number)
{
    2416:	0f 93       	push	r16
    2418:	1f 93       	push	r17
    241a:	df 93       	push	r29
    241c:	cf 93       	push	r28
    241e:	cd b7       	in	r28, 0x3d	; 61
    2420:	de b7       	in	r29, 0x3e	; 62
    2422:	60 97       	sbiw	r28, 0x10	; 16
    2424:	0f b6       	in	r0, 0x3f	; 63
    2426:	f8 94       	cli
    2428:	de bf       	out	0x3e, r29	; 62
    242a:	0f be       	out	0x3f, r0	; 63
    242c:	cd bf       	out	0x3d, r28	; 61
    242e:	6d 87       	std	Y+13, r22	; 0x0d
    2430:	7e 87       	std	Y+14, r23	; 0x0e
    2432:	8f 87       	std	Y+15, r24	; 0x0f
    2434:	98 8b       	std	Y+16, r25	; 0x10
	u8 ARR_Digits[10];
	u8 LOC_Count=0;
    2436:	1a 82       	std	Y+2, r1	; 0x02
	if(Copy_u8Number>0)
    2438:	8d 85       	ldd	r24, Y+13	; 0x0d
    243a:	9e 85       	ldd	r25, Y+14	; 0x0e
    243c:	af 85       	ldd	r26, Y+15	; 0x0f
    243e:	b8 89       	ldd	r27, Y+16	; 0x10
    2440:	00 97       	sbiw	r24, 0x00	; 0
    2442:	a1 05       	cpc	r26, r1
    2444:	b1 05       	cpc	r27, r1
    2446:	09 f4       	brne	.+2      	; 0x244a <HCLCD_VidWriteNumber_8Bits+0x34>
    2448:	4f c0       	rjmp	.+158    	; 0x24e8 <HCLCD_VidWriteNumber_8Bits+0xd2>
    244a:	2d c0       	rjmp	.+90     	; 0x24a6 <HCLCD_VidWriteNumber_8Bits+0x90>
	{
		while(Copy_u8Number!=0)
		{
			ARR_Digits[LOC_Count]=Copy_u8Number%10;
    244c:	8a 81       	ldd	r24, Y+2	; 0x02
    244e:	08 2f       	mov	r16, r24
    2450:	10 e0       	ldi	r17, 0x00	; 0
    2452:	8d 85       	ldd	r24, Y+13	; 0x0d
    2454:	9e 85       	ldd	r25, Y+14	; 0x0e
    2456:	af 85       	ldd	r26, Y+15	; 0x0f
    2458:	b8 89       	ldd	r27, Y+16	; 0x10
    245a:	2a e0       	ldi	r18, 0x0A	; 10
    245c:	30 e0       	ldi	r19, 0x00	; 0
    245e:	40 e0       	ldi	r20, 0x00	; 0
    2460:	50 e0       	ldi	r21, 0x00	; 0
    2462:	bc 01       	movw	r22, r24
    2464:	cd 01       	movw	r24, r26
    2466:	0e 94 27 4c 	call	0x984e	; 0x984e <__udivmodsi4>
    246a:	dc 01       	movw	r26, r24
    246c:	cb 01       	movw	r24, r22
    246e:	28 2f       	mov	r18, r24
    2470:	ce 01       	movw	r24, r28
    2472:	03 96       	adiw	r24, 0x03	; 3
    2474:	fc 01       	movw	r30, r24
    2476:	e0 0f       	add	r30, r16
    2478:	f1 1f       	adc	r31, r17
    247a:	20 83       	st	Z, r18
			Copy_u8Number/=10;
    247c:	8d 85       	ldd	r24, Y+13	; 0x0d
    247e:	9e 85       	ldd	r25, Y+14	; 0x0e
    2480:	af 85       	ldd	r26, Y+15	; 0x0f
    2482:	b8 89       	ldd	r27, Y+16	; 0x10
    2484:	2a e0       	ldi	r18, 0x0A	; 10
    2486:	30 e0       	ldi	r19, 0x00	; 0
    2488:	40 e0       	ldi	r20, 0x00	; 0
    248a:	50 e0       	ldi	r21, 0x00	; 0
    248c:	bc 01       	movw	r22, r24
    248e:	cd 01       	movw	r24, r26
    2490:	0e 94 27 4c 	call	0x984e	; 0x984e <__udivmodsi4>
    2494:	da 01       	movw	r26, r20
    2496:	c9 01       	movw	r24, r18
    2498:	8d 87       	std	Y+13, r24	; 0x0d
    249a:	9e 87       	std	Y+14, r25	; 0x0e
    249c:	af 87       	std	Y+15, r26	; 0x0f
    249e:	b8 8b       	std	Y+16, r27	; 0x10
			LOC_Count++;
    24a0:	8a 81       	ldd	r24, Y+2	; 0x02
    24a2:	8f 5f       	subi	r24, 0xFF	; 255
    24a4:	8a 83       	std	Y+2, r24	; 0x02
{
	u8 ARR_Digits[10];
	u8 LOC_Count=0;
	if(Copy_u8Number>0)
	{
		while(Copy_u8Number!=0)
    24a6:	8d 85       	ldd	r24, Y+13	; 0x0d
    24a8:	9e 85       	ldd	r25, Y+14	; 0x0e
    24aa:	af 85       	ldd	r26, Y+15	; 0x0f
    24ac:	b8 89       	ldd	r27, Y+16	; 0x10
    24ae:	00 97       	sbiw	r24, 0x00	; 0
    24b0:	a1 05       	cpc	r26, r1
    24b2:	b1 05       	cpc	r27, r1
    24b4:	59 f6       	brne	.-106    	; 0x244c <HCLCD_VidWriteNumber_8Bits+0x36>
		{
			ARR_Digits[LOC_Count]=Copy_u8Number%10;
			Copy_u8Number/=10;
			LOC_Count++;
		}
		for(s8 i=LOC_Count-1;i>=0;i--)
    24b6:	8a 81       	ldd	r24, Y+2	; 0x02
    24b8:	81 50       	subi	r24, 0x01	; 1
    24ba:	89 83       	std	Y+1, r24	; 0x01
    24bc:	11 c0       	rjmp	.+34     	; 0x24e0 <HCLCD_VidWriteNumber_8Bits+0xca>
		{
			HCLCD_VidWriteChar_8Bits(ARR_Digits[i]+'0');
    24be:	89 81       	ldd	r24, Y+1	; 0x01
    24c0:	28 2f       	mov	r18, r24
    24c2:	33 27       	eor	r19, r19
    24c4:	27 fd       	sbrc	r18, 7
    24c6:	30 95       	com	r19
    24c8:	ce 01       	movw	r24, r28
    24ca:	03 96       	adiw	r24, 0x03	; 3
    24cc:	fc 01       	movw	r30, r24
    24ce:	e2 0f       	add	r30, r18
    24d0:	f3 1f       	adc	r31, r19
    24d2:	80 81       	ld	r24, Z
    24d4:	80 5d       	subi	r24, 0xD0	; 208
    24d6:	0e 94 d2 10 	call	0x21a4	; 0x21a4 <HCLCD_VidWriteChar_8Bits>
		{
			ARR_Digits[LOC_Count]=Copy_u8Number%10;
			Copy_u8Number/=10;
			LOC_Count++;
		}
		for(s8 i=LOC_Count-1;i>=0;i--)
    24da:	89 81       	ldd	r24, Y+1	; 0x01
    24dc:	81 50       	subi	r24, 0x01	; 1
    24de:	89 83       	std	Y+1, r24	; 0x01
    24e0:	89 81       	ldd	r24, Y+1	; 0x01
    24e2:	88 23       	and	r24, r24
    24e4:	64 f7       	brge	.-40     	; 0x24be <HCLCD_VidWriteNumber_8Bits+0xa8>
    24e6:	03 c0       	rjmp	.+6      	; 0x24ee <HCLCD_VidWriteNumber_8Bits+0xd8>
			HCLCD_VidWriteChar_8Bits(ARR_Digits[i]+'0');
		}
	}
	else
	{
		HCLCD_VidWriteChar_8Bits('0');
    24e8:	80 e3       	ldi	r24, 0x30	; 48
    24ea:	0e 94 d2 10 	call	0x21a4	; 0x21a4 <HCLCD_VidWriteChar_8Bits>
	}
}
    24ee:	60 96       	adiw	r28, 0x10	; 16
    24f0:	0f b6       	in	r0, 0x3f	; 63
    24f2:	f8 94       	cli
    24f4:	de bf       	out	0x3e, r29	; 62
    24f6:	0f be       	out	0x3f, r0	; 63
    24f8:	cd bf       	out	0x3d, r28	; 61
    24fa:	cf 91       	pop	r28
    24fc:	df 91       	pop	r29
    24fe:	1f 91       	pop	r17
    2500:	0f 91       	pop	r16
    2502:	08 95       	ret

00002504 <HCLCD_VidSetPosition>:
void HCLCD_VidSetPosition(u8 Copy_u8LineNumber , u8 Copy_u8PositionNumber)
{
    2504:	df 93       	push	r29
    2506:	cf 93       	push	r28
    2508:	00 d0       	rcall	.+0      	; 0x250a <HCLCD_VidSetPosition+0x6>
    250a:	cd b7       	in	r28, 0x3d	; 61
    250c:	de b7       	in	r29, 0x3e	; 62
    250e:	89 83       	std	Y+1, r24	; 0x01
    2510:	6a 83       	std	Y+2, r22	; 0x02
	if((Copy_u8LineNumber==HCLCD_LINE1)&&((Copy_u8PositionNumber>=0)&&(Copy_u8PositionNumber<16)))
    2512:	89 81       	ldd	r24, Y+1	; 0x01
    2514:	81 30       	cpi	r24, 0x01	; 1
    2516:	41 f4       	brne	.+16     	; 0x2528 <HCLCD_VidSetPosition+0x24>
    2518:	8a 81       	ldd	r24, Y+2	; 0x02
    251a:	80 31       	cpi	r24, 0x10	; 16
    251c:	28 f4       	brcc	.+10     	; 0x2528 <HCLCD_VidSetPosition+0x24>
	{
		HCLCD_VidWriteCommand_8Bits((LINE1_OFFSET_ADDRESS+Copy_u8PositionNumber));
    251e:	8a 81       	ldd	r24, Y+2	; 0x02
    2520:	80 58       	subi	r24, 0x80	; 128
    2522:	0e 94 cd 0d 	call	0x1b9a	; 0x1b9a <HCLCD_VidWriteCommand_8Bits>
    2526:	0a c0       	rjmp	.+20     	; 0x253c <HCLCD_VidSetPosition+0x38>
	}
	else if((Copy_u8LineNumber==HCLCD_LINE2)&&((Copy_u8PositionNumber>=0)&&(Copy_u8PositionNumber<16)))
    2528:	89 81       	ldd	r24, Y+1	; 0x01
    252a:	82 30       	cpi	r24, 0x02	; 2
    252c:	39 f4       	brne	.+14     	; 0x253c <HCLCD_VidSetPosition+0x38>
    252e:	8a 81       	ldd	r24, Y+2	; 0x02
    2530:	80 31       	cpi	r24, 0x10	; 16
    2532:	20 f4       	brcc	.+8      	; 0x253c <HCLCD_VidSetPosition+0x38>
	{
		HCLCD_VidWriteCommand_8Bits((LINE2_OFFSET_ADDRESS+Copy_u8PositionNumber));
    2534:	8a 81       	ldd	r24, Y+2	; 0x02
    2536:	80 54       	subi	r24, 0x40	; 64
    2538:	0e 94 cd 0d 	call	0x1b9a	; 0x1b9a <HCLCD_VidWriteCommand_8Bits>
	}
	else
	{
		/*Do Nothing*/
	}
}
    253c:	0f 90       	pop	r0
    253e:	0f 90       	pop	r0
    2540:	cf 91       	pop	r28
    2542:	df 91       	pop	r29
    2544:	08 95       	ret

00002546 <HCLCD_VidWriteCommand_4Bits>:

void HCLCD_VidWriteCommand_4Bits(u8 Copy_u8Command)
{
    2546:	df 93       	push	r29
    2548:	cf 93       	push	r28
    254a:	cd b7       	in	r28, 0x3d	; 61
    254c:	de b7       	in	r29, 0x3e	; 62
    254e:	60 97       	sbiw	r28, 0x10	; 16
    2550:	0f b6       	in	r0, 0x3f	; 63
    2552:	f8 94       	cli
    2554:	de bf       	out	0x3e, r29	; 62
    2556:	0f be       	out	0x3f, r0	; 63
    2558:	cd bf       	out	0x3d, r28	; 61
    255a:	88 8b       	std	Y+16, r24	; 0x10
	u8 LOC_u8CopyCommand;
	/*select Command register--> Write zero on Rs pin*/
	MDIO_Error_State_SetPinValue(RS,CONTROL_PORT,PIN_LOW);
    255c:	81 e0       	ldi	r24, 0x01	; 1
    255e:	61 e0       	ldi	r22, 0x01	; 1
    2560:	40 e0       	ldi	r20, 0x00	; 0
    2562:	0e 94 e2 09 	call	0x13c4	; 0x13c4 <MDIO_Error_State_SetPinValue>
	/*select Write mode--> Write zero on RW pin*/
	//MDIO_Error_State_SetPinValue(RW,CONTROL_PORT,PIN_LOW);
	/*Send  Command*/
	LOC_u8CopyCommand=(Copy_u8Command&0x0F)<<HCLCD_PINSTART;
    2566:	88 89       	ldd	r24, Y+16	; 0x10
    2568:	88 2f       	mov	r24, r24
    256a:	90 e0       	ldi	r25, 0x00	; 0
    256c:	82 95       	swap	r24
    256e:	92 95       	swap	r25
    2570:	90 7f       	andi	r25, 0xF0	; 240
    2572:	98 27       	eor	r25, r24
    2574:	80 7f       	andi	r24, 0xF0	; 240
    2576:	98 27       	eor	r25, r24
    2578:	8f 87       	std	Y+15, r24	; 0x0f
	MDIO_Error_State_SetNippleValue(HCLCD_PINSTART,DATA_PORT,LOC_u8CopyCommand);
    257a:	84 e0       	ldi	r24, 0x04	; 4
    257c:	60 e0       	ldi	r22, 0x00	; 0
    257e:	4f 85       	ldd	r20, Y+15	; 0x0f
    2580:	0e 94 c5 0b 	call	0x178a	; 0x178a <MDIO_Error_State_SetNippleValue>
	/*Send Enable*/
	MDIO_Error_State_SetPinValue(E,CONTROL_PORT,PIN_HIGH);
    2584:	83 e0       	ldi	r24, 0x03	; 3
    2586:	61 e0       	ldi	r22, 0x01	; 1
    2588:	41 e0       	ldi	r20, 0x01	; 1
    258a:	0e 94 e2 09 	call	0x13c4	; 0x13c4 <MDIO_Error_State_SetPinValue>
    258e:	80 e0       	ldi	r24, 0x00	; 0
    2590:	90 e0       	ldi	r25, 0x00	; 0
    2592:	a0 e0       	ldi	r26, 0x00	; 0
    2594:	b0 e4       	ldi	r27, 0x40	; 64
    2596:	8b 87       	std	Y+11, r24	; 0x0b
    2598:	9c 87       	std	Y+12, r25	; 0x0c
    259a:	ad 87       	std	Y+13, r26	; 0x0d
    259c:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    259e:	6b 85       	ldd	r22, Y+11	; 0x0b
    25a0:	7c 85       	ldd	r23, Y+12	; 0x0c
    25a2:	8d 85       	ldd	r24, Y+13	; 0x0d
    25a4:	9e 85       	ldd	r25, Y+14	; 0x0e
    25a6:	20 e0       	ldi	r18, 0x00	; 0
    25a8:	30 e0       	ldi	r19, 0x00	; 0
    25aa:	4a e7       	ldi	r20, 0x7A	; 122
    25ac:	53 e4       	ldi	r21, 0x43	; 67
    25ae:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    25b2:	dc 01       	movw	r26, r24
    25b4:	cb 01       	movw	r24, r22
    25b6:	8f 83       	std	Y+7, r24	; 0x07
    25b8:	98 87       	std	Y+8, r25	; 0x08
    25ba:	a9 87       	std	Y+9, r26	; 0x09
    25bc:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    25be:	6f 81       	ldd	r22, Y+7	; 0x07
    25c0:	78 85       	ldd	r23, Y+8	; 0x08
    25c2:	89 85       	ldd	r24, Y+9	; 0x09
    25c4:	9a 85       	ldd	r25, Y+10	; 0x0a
    25c6:	20 e0       	ldi	r18, 0x00	; 0
    25c8:	30 e0       	ldi	r19, 0x00	; 0
    25ca:	40 e8       	ldi	r20, 0x80	; 128
    25cc:	5f e3       	ldi	r21, 0x3F	; 63
    25ce:	0e 94 55 04 	call	0x8aa	; 0x8aa <__ltsf2>
    25d2:	88 23       	and	r24, r24
    25d4:	2c f4       	brge	.+10     	; 0x25e0 <HCLCD_VidWriteCommand_4Bits+0x9a>
		__ticks = 1;
    25d6:	81 e0       	ldi	r24, 0x01	; 1
    25d8:	90 e0       	ldi	r25, 0x00	; 0
    25da:	9e 83       	std	Y+6, r25	; 0x06
    25dc:	8d 83       	std	Y+5, r24	; 0x05
    25de:	3f c0       	rjmp	.+126    	; 0x265e <HCLCD_VidWriteCommand_4Bits+0x118>
	else if (__tmp > 65535)
    25e0:	6f 81       	ldd	r22, Y+7	; 0x07
    25e2:	78 85       	ldd	r23, Y+8	; 0x08
    25e4:	89 85       	ldd	r24, Y+9	; 0x09
    25e6:	9a 85       	ldd	r25, Y+10	; 0x0a
    25e8:	20 e0       	ldi	r18, 0x00	; 0
    25ea:	3f ef       	ldi	r19, 0xFF	; 255
    25ec:	4f e7       	ldi	r20, 0x7F	; 127
    25ee:	57 e4       	ldi	r21, 0x47	; 71
    25f0:	0e 94 f5 03 	call	0x7ea	; 0x7ea <__gtsf2>
    25f4:	18 16       	cp	r1, r24
    25f6:	4c f5       	brge	.+82     	; 0x264a <HCLCD_VidWriteCommand_4Bits+0x104>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    25f8:	6b 85       	ldd	r22, Y+11	; 0x0b
    25fa:	7c 85       	ldd	r23, Y+12	; 0x0c
    25fc:	8d 85       	ldd	r24, Y+13	; 0x0d
    25fe:	9e 85       	ldd	r25, Y+14	; 0x0e
    2600:	20 e0       	ldi	r18, 0x00	; 0
    2602:	30 e0       	ldi	r19, 0x00	; 0
    2604:	40 e2       	ldi	r20, 0x20	; 32
    2606:	51 e4       	ldi	r21, 0x41	; 65
    2608:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    260c:	dc 01       	movw	r26, r24
    260e:	cb 01       	movw	r24, r22
    2610:	bc 01       	movw	r22, r24
    2612:	cd 01       	movw	r24, r26
    2614:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2618:	dc 01       	movw	r26, r24
    261a:	cb 01       	movw	r24, r22
    261c:	9e 83       	std	Y+6, r25	; 0x06
    261e:	8d 83       	std	Y+5, r24	; 0x05
    2620:	0f c0       	rjmp	.+30     	; 0x2640 <HCLCD_VidWriteCommand_4Bits+0xfa>
    2622:	89 e1       	ldi	r24, 0x19	; 25
    2624:	90 e0       	ldi	r25, 0x00	; 0
    2626:	9c 83       	std	Y+4, r25	; 0x04
    2628:	8b 83       	std	Y+3, r24	; 0x03
    262a:	8b 81       	ldd	r24, Y+3	; 0x03
    262c:	9c 81       	ldd	r25, Y+4	; 0x04
    262e:	01 97       	sbiw	r24, 0x01	; 1
    2630:	f1 f7       	brne	.-4      	; 0x262e <HCLCD_VidWriteCommand_4Bits+0xe8>
    2632:	9c 83       	std	Y+4, r25	; 0x04
    2634:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2636:	8d 81       	ldd	r24, Y+5	; 0x05
    2638:	9e 81       	ldd	r25, Y+6	; 0x06
    263a:	01 97       	sbiw	r24, 0x01	; 1
    263c:	9e 83       	std	Y+6, r25	; 0x06
    263e:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2640:	8d 81       	ldd	r24, Y+5	; 0x05
    2642:	9e 81       	ldd	r25, Y+6	; 0x06
    2644:	00 97       	sbiw	r24, 0x00	; 0
    2646:	69 f7       	brne	.-38     	; 0x2622 <HCLCD_VidWriteCommand_4Bits+0xdc>
    2648:	14 c0       	rjmp	.+40     	; 0x2672 <HCLCD_VidWriteCommand_4Bits+0x12c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    264a:	6f 81       	ldd	r22, Y+7	; 0x07
    264c:	78 85       	ldd	r23, Y+8	; 0x08
    264e:	89 85       	ldd	r24, Y+9	; 0x09
    2650:	9a 85       	ldd	r25, Y+10	; 0x0a
    2652:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2656:	dc 01       	movw	r26, r24
    2658:	cb 01       	movw	r24, r22
    265a:	9e 83       	std	Y+6, r25	; 0x06
    265c:	8d 83       	std	Y+5, r24	; 0x05
    265e:	8d 81       	ldd	r24, Y+5	; 0x05
    2660:	9e 81       	ldd	r25, Y+6	; 0x06
    2662:	9a 83       	std	Y+2, r25	; 0x02
    2664:	89 83       	std	Y+1, r24	; 0x01
    2666:	89 81       	ldd	r24, Y+1	; 0x01
    2668:	9a 81       	ldd	r25, Y+2	; 0x02
    266a:	01 97       	sbiw	r24, 0x01	; 1
    266c:	f1 f7       	brne	.-4      	; 0x266a <HCLCD_VidWriteCommand_4Bits+0x124>
    266e:	9a 83       	std	Y+2, r25	; 0x02
    2670:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(2);
	MDIO_Error_State_SetPinValue(E,CONTROL_PORT,PIN_LOW);
    2672:	83 e0       	ldi	r24, 0x03	; 3
    2674:	61 e0       	ldi	r22, 0x01	; 1
    2676:	40 e0       	ldi	r20, 0x00	; 0
    2678:	0e 94 e2 09 	call	0x13c4	; 0x13c4 <MDIO_Error_State_SetPinValue>
}
    267c:	60 96       	adiw	r28, 0x10	; 16
    267e:	0f b6       	in	r0, 0x3f	; 63
    2680:	f8 94       	cli
    2682:	de bf       	out	0x3e, r29	; 62
    2684:	0f be       	out	0x3f, r0	; 63
    2686:	cd bf       	out	0x3d, r28	; 61
    2688:	cf 91       	pop	r28
    268a:	df 91       	pop	r29
    268c:	08 95       	ret

0000268e <HCLCD_Vid4Bits_Init>:
void HCLCD_Vid4Bits_Init(void)
{
    268e:	df 93       	push	r29
    2690:	cf 93       	push	r28
    2692:	cd b7       	in	r28, 0x3d	; 61
    2694:	de b7       	in	r29, 0x3e	; 62
    2696:	e9 97       	sbiw	r28, 0x39	; 57
    2698:	0f b6       	in	r0, 0x3f	; 63
    269a:	f8 94       	cli
    269c:	de bf       	out	0x3e, r29	; 62
    269e:	0f be       	out	0x3f, r0	; 63
    26a0:	cd bf       	out	0x3d, r28	; 61
	s8 LOC_u8PinCount;
	/*LCD Data and control port initialization*/
	for(LOC_u8PinCount=HCLCD_PINEND;LOC_u8PinCount>=HCLCD_PINSTART;LOC_u8PinCount--)
    26a2:	87 e0       	ldi	r24, 0x07	; 7
    26a4:	89 af       	std	Y+57, r24	; 0x39
    26a6:	08 c0       	rjmp	.+16     	; 0x26b8 <HCLCD_Vid4Bits_Init+0x2a>
	{
	MDIO_Error_State_SetPinDirection(LOC_u8PinCount,DATA_PORT,PIN_OUTPUT);
    26a8:	89 ad       	ldd	r24, Y+57	; 0x39
    26aa:	60 e0       	ldi	r22, 0x00	; 0
    26ac:	41 e0       	ldi	r20, 0x01	; 1
    26ae:	0e 94 8f 08 	call	0x111e	; 0x111e <MDIO_Error_State_SetPinDirection>
}
void HCLCD_Vid4Bits_Init(void)
{
	s8 LOC_u8PinCount;
	/*LCD Data and control port initialization*/
	for(LOC_u8PinCount=HCLCD_PINEND;LOC_u8PinCount>=HCLCD_PINSTART;LOC_u8PinCount--)
    26b2:	89 ad       	ldd	r24, Y+57	; 0x39
    26b4:	81 50       	subi	r24, 0x01	; 1
    26b6:	89 af       	std	Y+57, r24	; 0x39
    26b8:	89 ad       	ldd	r24, Y+57	; 0x39
    26ba:	84 30       	cpi	r24, 0x04	; 4
    26bc:	ac f7       	brge	.-22     	; 0x26a8 <HCLCD_Vid4Bits_Init+0x1a>
	{
	MDIO_Error_State_SetPinDirection(LOC_u8PinCount,DATA_PORT,PIN_OUTPUT);
	}
	MDIO_Error_State_SetPinDirection(RS,CONTROL_PORT,PIN_OUTPUT);
    26be:	81 e0       	ldi	r24, 0x01	; 1
    26c0:	61 e0       	ldi	r22, 0x01	; 1
    26c2:	41 e0       	ldi	r20, 0x01	; 1
    26c4:	0e 94 8f 08 	call	0x111e	; 0x111e <MDIO_Error_State_SetPinDirection>
	//MDIO_Error_State_SetPinDirection(RW,CONTROL_PORT,PIN_OUTPUT);
	MDIO_Error_State_SetPinDirection(E,CONTROL_PORT,PIN_OUTPUT);
    26c8:	83 e0       	ldi	r24, 0x03	; 3
    26ca:	61 e0       	ldi	r22, 0x01	; 1
    26cc:	41 e0       	ldi	r20, 0x01	; 1
    26ce:	0e 94 8f 08 	call	0x111e	; 0x111e <MDIO_Error_State_SetPinDirection>
    26d2:	80 e0       	ldi	r24, 0x00	; 0
    26d4:	90 e0       	ldi	r25, 0x00	; 0
    26d6:	a0 ef       	ldi	r26, 0xF0	; 240
    26d8:	b1 e4       	ldi	r27, 0x41	; 65
    26da:	8d ab       	std	Y+53, r24	; 0x35
    26dc:	9e ab       	std	Y+54, r25	; 0x36
    26de:	af ab       	std	Y+55, r26	; 0x37
    26e0:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    26e2:	6d a9       	ldd	r22, Y+53	; 0x35
    26e4:	7e a9       	ldd	r23, Y+54	; 0x36
    26e6:	8f a9       	ldd	r24, Y+55	; 0x37
    26e8:	98 ad       	ldd	r25, Y+56	; 0x38
    26ea:	20 e0       	ldi	r18, 0x00	; 0
    26ec:	30 e0       	ldi	r19, 0x00	; 0
    26ee:	4a e7       	ldi	r20, 0x7A	; 122
    26f0:	53 e4       	ldi	r21, 0x43	; 67
    26f2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    26f6:	dc 01       	movw	r26, r24
    26f8:	cb 01       	movw	r24, r22
    26fa:	89 ab       	std	Y+49, r24	; 0x31
    26fc:	9a ab       	std	Y+50, r25	; 0x32
    26fe:	ab ab       	std	Y+51, r26	; 0x33
    2700:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
    2702:	69 a9       	ldd	r22, Y+49	; 0x31
    2704:	7a a9       	ldd	r23, Y+50	; 0x32
    2706:	8b a9       	ldd	r24, Y+51	; 0x33
    2708:	9c a9       	ldd	r25, Y+52	; 0x34
    270a:	20 e0       	ldi	r18, 0x00	; 0
    270c:	30 e0       	ldi	r19, 0x00	; 0
    270e:	40 e8       	ldi	r20, 0x80	; 128
    2710:	5f e3       	ldi	r21, 0x3F	; 63
    2712:	0e 94 55 04 	call	0x8aa	; 0x8aa <__ltsf2>
    2716:	88 23       	and	r24, r24
    2718:	2c f4       	brge	.+10     	; 0x2724 <HCLCD_Vid4Bits_Init+0x96>
		__ticks = 1;
    271a:	81 e0       	ldi	r24, 0x01	; 1
    271c:	90 e0       	ldi	r25, 0x00	; 0
    271e:	98 ab       	std	Y+48, r25	; 0x30
    2720:	8f a7       	std	Y+47, r24	; 0x2f
    2722:	3f c0       	rjmp	.+126    	; 0x27a2 <HCLCD_Vid4Bits_Init+0x114>
	else if (__tmp > 65535)
    2724:	69 a9       	ldd	r22, Y+49	; 0x31
    2726:	7a a9       	ldd	r23, Y+50	; 0x32
    2728:	8b a9       	ldd	r24, Y+51	; 0x33
    272a:	9c a9       	ldd	r25, Y+52	; 0x34
    272c:	20 e0       	ldi	r18, 0x00	; 0
    272e:	3f ef       	ldi	r19, 0xFF	; 255
    2730:	4f e7       	ldi	r20, 0x7F	; 127
    2732:	57 e4       	ldi	r21, 0x47	; 71
    2734:	0e 94 f5 03 	call	0x7ea	; 0x7ea <__gtsf2>
    2738:	18 16       	cp	r1, r24
    273a:	4c f5       	brge	.+82     	; 0x278e <HCLCD_Vid4Bits_Init+0x100>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    273c:	6d a9       	ldd	r22, Y+53	; 0x35
    273e:	7e a9       	ldd	r23, Y+54	; 0x36
    2740:	8f a9       	ldd	r24, Y+55	; 0x37
    2742:	98 ad       	ldd	r25, Y+56	; 0x38
    2744:	20 e0       	ldi	r18, 0x00	; 0
    2746:	30 e0       	ldi	r19, 0x00	; 0
    2748:	40 e2       	ldi	r20, 0x20	; 32
    274a:	51 e4       	ldi	r21, 0x41	; 65
    274c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2750:	dc 01       	movw	r26, r24
    2752:	cb 01       	movw	r24, r22
    2754:	bc 01       	movw	r22, r24
    2756:	cd 01       	movw	r24, r26
    2758:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    275c:	dc 01       	movw	r26, r24
    275e:	cb 01       	movw	r24, r22
    2760:	98 ab       	std	Y+48, r25	; 0x30
    2762:	8f a7       	std	Y+47, r24	; 0x2f
    2764:	0f c0       	rjmp	.+30     	; 0x2784 <HCLCD_Vid4Bits_Init+0xf6>
    2766:	89 e1       	ldi	r24, 0x19	; 25
    2768:	90 e0       	ldi	r25, 0x00	; 0
    276a:	9e a7       	std	Y+46, r25	; 0x2e
    276c:	8d a7       	std	Y+45, r24	; 0x2d
    276e:	8d a5       	ldd	r24, Y+45	; 0x2d
    2770:	9e a5       	ldd	r25, Y+46	; 0x2e
    2772:	01 97       	sbiw	r24, 0x01	; 1
    2774:	f1 f7       	brne	.-4      	; 0x2772 <HCLCD_Vid4Bits_Init+0xe4>
    2776:	9e a7       	std	Y+46, r25	; 0x2e
    2778:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    277a:	8f a5       	ldd	r24, Y+47	; 0x2f
    277c:	98 a9       	ldd	r25, Y+48	; 0x30
    277e:	01 97       	sbiw	r24, 0x01	; 1
    2780:	98 ab       	std	Y+48, r25	; 0x30
    2782:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2784:	8f a5       	ldd	r24, Y+47	; 0x2f
    2786:	98 a9       	ldd	r25, Y+48	; 0x30
    2788:	00 97       	sbiw	r24, 0x00	; 0
    278a:	69 f7       	brne	.-38     	; 0x2766 <HCLCD_Vid4Bits_Init+0xd8>
    278c:	14 c0       	rjmp	.+40     	; 0x27b6 <HCLCD_Vid4Bits_Init+0x128>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    278e:	69 a9       	ldd	r22, Y+49	; 0x31
    2790:	7a a9       	ldd	r23, Y+50	; 0x32
    2792:	8b a9       	ldd	r24, Y+51	; 0x33
    2794:	9c a9       	ldd	r25, Y+52	; 0x34
    2796:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    279a:	dc 01       	movw	r26, r24
    279c:	cb 01       	movw	r24, r22
    279e:	98 ab       	std	Y+48, r25	; 0x30
    27a0:	8f a7       	std	Y+47, r24	; 0x2f
    27a2:	8f a5       	ldd	r24, Y+47	; 0x2f
    27a4:	98 a9       	ldd	r25, Y+48	; 0x30
    27a6:	9c a7       	std	Y+44, r25	; 0x2c
    27a8:	8b a7       	std	Y+43, r24	; 0x2b
    27aa:	8b a5       	ldd	r24, Y+43	; 0x2b
    27ac:	9c a5       	ldd	r25, Y+44	; 0x2c
    27ae:	01 97       	sbiw	r24, 0x01	; 1
    27b0:	f1 f7       	brne	.-4      	; 0x27ae <HCLCD_Vid4Bits_Init+0x120>
    27b2:	9c a7       	std	Y+44, r25	; 0x2c
    27b4:	8b a7       	std	Y+43, r24	; 0x2b
	/*wait to 30ms*/
	_delay_ms(30);
	/*send function set command*/
	HCLCD_VidWriteCommand_4Bits(HCLCD_FUNCTION_SET>>4);
    27b6:	82 e0       	ldi	r24, 0x02	; 2
    27b8:	0e 94 a3 12 	call	0x2546	; 0x2546 <HCLCD_VidWriteCommand_4Bits>
	HCLCD_VidWriteCommand_4Bits(HCLCD_FUNCTION_SET>>4);
    27bc:	82 e0       	ldi	r24, 0x02	; 2
    27be:	0e 94 a3 12 	call	0x2546	; 0x2546 <HCLCD_VidWriteCommand_4Bits>
	HCLCD_VidWriteCommand_4Bits(HCLCD_FUNCTION_SET);
    27c2:	88 e2       	ldi	r24, 0x28	; 40
    27c4:	0e 94 a3 12 	call	0x2546	; 0x2546 <HCLCD_VidWriteCommand_4Bits>
    27c8:	80 e0       	ldi	r24, 0x00	; 0
    27ca:	90 e0       	ldi	r25, 0x00	; 0
    27cc:	a0 e8       	ldi	r26, 0x80	; 128
    27ce:	bf e3       	ldi	r27, 0x3F	; 63
    27d0:	8f a3       	std	Y+39, r24	; 0x27
    27d2:	98 a7       	std	Y+40, r25	; 0x28
    27d4:	a9 a7       	std	Y+41, r26	; 0x29
    27d6:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    27d8:	6f a1       	ldd	r22, Y+39	; 0x27
    27da:	78 a5       	ldd	r23, Y+40	; 0x28
    27dc:	89 a5       	ldd	r24, Y+41	; 0x29
    27de:	9a a5       	ldd	r25, Y+42	; 0x2a
    27e0:	20 e0       	ldi	r18, 0x00	; 0
    27e2:	30 e0       	ldi	r19, 0x00	; 0
    27e4:	4a e7       	ldi	r20, 0x7A	; 122
    27e6:	53 e4       	ldi	r21, 0x43	; 67
    27e8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    27ec:	dc 01       	movw	r26, r24
    27ee:	cb 01       	movw	r24, r22
    27f0:	8b a3       	std	Y+35, r24	; 0x23
    27f2:	9c a3       	std	Y+36, r25	; 0x24
    27f4:	ad a3       	std	Y+37, r26	; 0x25
    27f6:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    27f8:	6b a1       	ldd	r22, Y+35	; 0x23
    27fa:	7c a1       	ldd	r23, Y+36	; 0x24
    27fc:	8d a1       	ldd	r24, Y+37	; 0x25
    27fe:	9e a1       	ldd	r25, Y+38	; 0x26
    2800:	20 e0       	ldi	r18, 0x00	; 0
    2802:	30 e0       	ldi	r19, 0x00	; 0
    2804:	40 e8       	ldi	r20, 0x80	; 128
    2806:	5f e3       	ldi	r21, 0x3F	; 63
    2808:	0e 94 55 04 	call	0x8aa	; 0x8aa <__ltsf2>
    280c:	88 23       	and	r24, r24
    280e:	2c f4       	brge	.+10     	; 0x281a <HCLCD_Vid4Bits_Init+0x18c>
		__ticks = 1;
    2810:	81 e0       	ldi	r24, 0x01	; 1
    2812:	90 e0       	ldi	r25, 0x00	; 0
    2814:	9a a3       	std	Y+34, r25	; 0x22
    2816:	89 a3       	std	Y+33, r24	; 0x21
    2818:	3f c0       	rjmp	.+126    	; 0x2898 <HCLCD_Vid4Bits_Init+0x20a>
	else if (__tmp > 65535)
    281a:	6b a1       	ldd	r22, Y+35	; 0x23
    281c:	7c a1       	ldd	r23, Y+36	; 0x24
    281e:	8d a1       	ldd	r24, Y+37	; 0x25
    2820:	9e a1       	ldd	r25, Y+38	; 0x26
    2822:	20 e0       	ldi	r18, 0x00	; 0
    2824:	3f ef       	ldi	r19, 0xFF	; 255
    2826:	4f e7       	ldi	r20, 0x7F	; 127
    2828:	57 e4       	ldi	r21, 0x47	; 71
    282a:	0e 94 f5 03 	call	0x7ea	; 0x7ea <__gtsf2>
    282e:	18 16       	cp	r1, r24
    2830:	4c f5       	brge	.+82     	; 0x2884 <HCLCD_Vid4Bits_Init+0x1f6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2832:	6f a1       	ldd	r22, Y+39	; 0x27
    2834:	78 a5       	ldd	r23, Y+40	; 0x28
    2836:	89 a5       	ldd	r24, Y+41	; 0x29
    2838:	9a a5       	ldd	r25, Y+42	; 0x2a
    283a:	20 e0       	ldi	r18, 0x00	; 0
    283c:	30 e0       	ldi	r19, 0x00	; 0
    283e:	40 e2       	ldi	r20, 0x20	; 32
    2840:	51 e4       	ldi	r21, 0x41	; 65
    2842:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2846:	dc 01       	movw	r26, r24
    2848:	cb 01       	movw	r24, r22
    284a:	bc 01       	movw	r22, r24
    284c:	cd 01       	movw	r24, r26
    284e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2852:	dc 01       	movw	r26, r24
    2854:	cb 01       	movw	r24, r22
    2856:	9a a3       	std	Y+34, r25	; 0x22
    2858:	89 a3       	std	Y+33, r24	; 0x21
    285a:	0f c0       	rjmp	.+30     	; 0x287a <HCLCD_Vid4Bits_Init+0x1ec>
    285c:	89 e1       	ldi	r24, 0x19	; 25
    285e:	90 e0       	ldi	r25, 0x00	; 0
    2860:	98 a3       	std	Y+32, r25	; 0x20
    2862:	8f 8f       	std	Y+31, r24	; 0x1f
    2864:	8f 8d       	ldd	r24, Y+31	; 0x1f
    2866:	98 a1       	ldd	r25, Y+32	; 0x20
    2868:	01 97       	sbiw	r24, 0x01	; 1
    286a:	f1 f7       	brne	.-4      	; 0x2868 <HCLCD_Vid4Bits_Init+0x1da>
    286c:	98 a3       	std	Y+32, r25	; 0x20
    286e:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2870:	89 a1       	ldd	r24, Y+33	; 0x21
    2872:	9a a1       	ldd	r25, Y+34	; 0x22
    2874:	01 97       	sbiw	r24, 0x01	; 1
    2876:	9a a3       	std	Y+34, r25	; 0x22
    2878:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    287a:	89 a1       	ldd	r24, Y+33	; 0x21
    287c:	9a a1       	ldd	r25, Y+34	; 0x22
    287e:	00 97       	sbiw	r24, 0x00	; 0
    2880:	69 f7       	brne	.-38     	; 0x285c <HCLCD_Vid4Bits_Init+0x1ce>
    2882:	14 c0       	rjmp	.+40     	; 0x28ac <HCLCD_Vid4Bits_Init+0x21e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2884:	6b a1       	ldd	r22, Y+35	; 0x23
    2886:	7c a1       	ldd	r23, Y+36	; 0x24
    2888:	8d a1       	ldd	r24, Y+37	; 0x25
    288a:	9e a1       	ldd	r25, Y+38	; 0x26
    288c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2890:	dc 01       	movw	r26, r24
    2892:	cb 01       	movw	r24, r22
    2894:	9a a3       	std	Y+34, r25	; 0x22
    2896:	89 a3       	std	Y+33, r24	; 0x21
    2898:	89 a1       	ldd	r24, Y+33	; 0x21
    289a:	9a a1       	ldd	r25, Y+34	; 0x22
    289c:	9e 8f       	std	Y+30, r25	; 0x1e
    289e:	8d 8f       	std	Y+29, r24	; 0x1d
    28a0:	8d 8d       	ldd	r24, Y+29	; 0x1d
    28a2:	9e 8d       	ldd	r25, Y+30	; 0x1e
    28a4:	01 97       	sbiw	r24, 0x01	; 1
    28a6:	f1 f7       	brne	.-4      	; 0x28a4 <HCLCD_Vid4Bits_Init+0x216>
    28a8:	9e 8f       	std	Y+30, r25	; 0x1e
    28aa:	8d 8f       	std	Y+29, r24	; 0x1d
	_delay_ms(1);
	/*send Display on/off  command*/
	HCLCD_VidWriteCommand_4Bits(HCLCD_DISPLAY_ON_OFF>>4);
    28ac:	80 e0       	ldi	r24, 0x00	; 0
    28ae:	0e 94 a3 12 	call	0x2546	; 0x2546 <HCLCD_VidWriteCommand_4Bits>
	HCLCD_VidWriteCommand_4Bits(HCLCD_DISPLAY_ON_OFF);
    28b2:	8f e0       	ldi	r24, 0x0F	; 15
    28b4:	0e 94 a3 12 	call	0x2546	; 0x2546 <HCLCD_VidWriteCommand_4Bits>
    28b8:	80 e0       	ldi	r24, 0x00	; 0
    28ba:	90 e0       	ldi	r25, 0x00	; 0
    28bc:	a0 e8       	ldi	r26, 0x80	; 128
    28be:	bf e3       	ldi	r27, 0x3F	; 63
    28c0:	89 8f       	std	Y+25, r24	; 0x19
    28c2:	9a 8f       	std	Y+26, r25	; 0x1a
    28c4:	ab 8f       	std	Y+27, r26	; 0x1b
    28c6:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    28c8:	69 8d       	ldd	r22, Y+25	; 0x19
    28ca:	7a 8d       	ldd	r23, Y+26	; 0x1a
    28cc:	8b 8d       	ldd	r24, Y+27	; 0x1b
    28ce:	9c 8d       	ldd	r25, Y+28	; 0x1c
    28d0:	20 e0       	ldi	r18, 0x00	; 0
    28d2:	30 e0       	ldi	r19, 0x00	; 0
    28d4:	4a e7       	ldi	r20, 0x7A	; 122
    28d6:	53 e4       	ldi	r21, 0x43	; 67
    28d8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    28dc:	dc 01       	movw	r26, r24
    28de:	cb 01       	movw	r24, r22
    28e0:	8d 8b       	std	Y+21, r24	; 0x15
    28e2:	9e 8b       	std	Y+22, r25	; 0x16
    28e4:	af 8b       	std	Y+23, r26	; 0x17
    28e6:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    28e8:	6d 89       	ldd	r22, Y+21	; 0x15
    28ea:	7e 89       	ldd	r23, Y+22	; 0x16
    28ec:	8f 89       	ldd	r24, Y+23	; 0x17
    28ee:	98 8d       	ldd	r25, Y+24	; 0x18
    28f0:	20 e0       	ldi	r18, 0x00	; 0
    28f2:	30 e0       	ldi	r19, 0x00	; 0
    28f4:	40 e8       	ldi	r20, 0x80	; 128
    28f6:	5f e3       	ldi	r21, 0x3F	; 63
    28f8:	0e 94 55 04 	call	0x8aa	; 0x8aa <__ltsf2>
    28fc:	88 23       	and	r24, r24
    28fe:	2c f4       	brge	.+10     	; 0x290a <HCLCD_Vid4Bits_Init+0x27c>
		__ticks = 1;
    2900:	81 e0       	ldi	r24, 0x01	; 1
    2902:	90 e0       	ldi	r25, 0x00	; 0
    2904:	9c 8b       	std	Y+20, r25	; 0x14
    2906:	8b 8b       	std	Y+19, r24	; 0x13
    2908:	3f c0       	rjmp	.+126    	; 0x2988 <HCLCD_Vid4Bits_Init+0x2fa>
	else if (__tmp > 65535)
    290a:	6d 89       	ldd	r22, Y+21	; 0x15
    290c:	7e 89       	ldd	r23, Y+22	; 0x16
    290e:	8f 89       	ldd	r24, Y+23	; 0x17
    2910:	98 8d       	ldd	r25, Y+24	; 0x18
    2912:	20 e0       	ldi	r18, 0x00	; 0
    2914:	3f ef       	ldi	r19, 0xFF	; 255
    2916:	4f e7       	ldi	r20, 0x7F	; 127
    2918:	57 e4       	ldi	r21, 0x47	; 71
    291a:	0e 94 f5 03 	call	0x7ea	; 0x7ea <__gtsf2>
    291e:	18 16       	cp	r1, r24
    2920:	4c f5       	brge	.+82     	; 0x2974 <HCLCD_Vid4Bits_Init+0x2e6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2922:	69 8d       	ldd	r22, Y+25	; 0x19
    2924:	7a 8d       	ldd	r23, Y+26	; 0x1a
    2926:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2928:	9c 8d       	ldd	r25, Y+28	; 0x1c
    292a:	20 e0       	ldi	r18, 0x00	; 0
    292c:	30 e0       	ldi	r19, 0x00	; 0
    292e:	40 e2       	ldi	r20, 0x20	; 32
    2930:	51 e4       	ldi	r21, 0x41	; 65
    2932:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2936:	dc 01       	movw	r26, r24
    2938:	cb 01       	movw	r24, r22
    293a:	bc 01       	movw	r22, r24
    293c:	cd 01       	movw	r24, r26
    293e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2942:	dc 01       	movw	r26, r24
    2944:	cb 01       	movw	r24, r22
    2946:	9c 8b       	std	Y+20, r25	; 0x14
    2948:	8b 8b       	std	Y+19, r24	; 0x13
    294a:	0f c0       	rjmp	.+30     	; 0x296a <HCLCD_Vid4Bits_Init+0x2dc>
    294c:	89 e1       	ldi	r24, 0x19	; 25
    294e:	90 e0       	ldi	r25, 0x00	; 0
    2950:	9a 8b       	std	Y+18, r25	; 0x12
    2952:	89 8b       	std	Y+17, r24	; 0x11
    2954:	89 89       	ldd	r24, Y+17	; 0x11
    2956:	9a 89       	ldd	r25, Y+18	; 0x12
    2958:	01 97       	sbiw	r24, 0x01	; 1
    295a:	f1 f7       	brne	.-4      	; 0x2958 <HCLCD_Vid4Bits_Init+0x2ca>
    295c:	9a 8b       	std	Y+18, r25	; 0x12
    295e:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2960:	8b 89       	ldd	r24, Y+19	; 0x13
    2962:	9c 89       	ldd	r25, Y+20	; 0x14
    2964:	01 97       	sbiw	r24, 0x01	; 1
    2966:	9c 8b       	std	Y+20, r25	; 0x14
    2968:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    296a:	8b 89       	ldd	r24, Y+19	; 0x13
    296c:	9c 89       	ldd	r25, Y+20	; 0x14
    296e:	00 97       	sbiw	r24, 0x00	; 0
    2970:	69 f7       	brne	.-38     	; 0x294c <HCLCD_Vid4Bits_Init+0x2be>
    2972:	14 c0       	rjmp	.+40     	; 0x299c <HCLCD_Vid4Bits_Init+0x30e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2974:	6d 89       	ldd	r22, Y+21	; 0x15
    2976:	7e 89       	ldd	r23, Y+22	; 0x16
    2978:	8f 89       	ldd	r24, Y+23	; 0x17
    297a:	98 8d       	ldd	r25, Y+24	; 0x18
    297c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2980:	dc 01       	movw	r26, r24
    2982:	cb 01       	movw	r24, r22
    2984:	9c 8b       	std	Y+20, r25	; 0x14
    2986:	8b 8b       	std	Y+19, r24	; 0x13
    2988:	8b 89       	ldd	r24, Y+19	; 0x13
    298a:	9c 89       	ldd	r25, Y+20	; 0x14
    298c:	98 8b       	std	Y+16, r25	; 0x10
    298e:	8f 87       	std	Y+15, r24	; 0x0f
    2990:	8f 85       	ldd	r24, Y+15	; 0x0f
    2992:	98 89       	ldd	r25, Y+16	; 0x10
    2994:	01 97       	sbiw	r24, 0x01	; 1
    2996:	f1 f7       	brne	.-4      	; 0x2994 <HCLCD_Vid4Bits_Init+0x306>
    2998:	98 8b       	std	Y+16, r25	; 0x10
    299a:	8f 87       	std	Y+15, r24	; 0x0f
	_delay_ms(1);
	/*send Display Clear  command*/
	HCLCD_VidWriteCommand_4Bits(DISPLAY_CLEAR>>4);
    299c:	80 e0       	ldi	r24, 0x00	; 0
    299e:	0e 94 a3 12 	call	0x2546	; 0x2546 <HCLCD_VidWriteCommand_4Bits>
	HCLCD_VidWriteCommand_4Bits(DISPLAY_CLEAR);
    29a2:	81 e0       	ldi	r24, 0x01	; 1
    29a4:	0e 94 a3 12 	call	0x2546	; 0x2546 <HCLCD_VidWriteCommand_4Bits>
    29a8:	80 e0       	ldi	r24, 0x00	; 0
    29aa:	90 e0       	ldi	r25, 0x00	; 0
    29ac:	a0 e0       	ldi	r26, 0x00	; 0
    29ae:	b0 e4       	ldi	r27, 0x40	; 64
    29b0:	8b 87       	std	Y+11, r24	; 0x0b
    29b2:	9c 87       	std	Y+12, r25	; 0x0c
    29b4:	ad 87       	std	Y+13, r26	; 0x0d
    29b6:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    29b8:	6b 85       	ldd	r22, Y+11	; 0x0b
    29ba:	7c 85       	ldd	r23, Y+12	; 0x0c
    29bc:	8d 85       	ldd	r24, Y+13	; 0x0d
    29be:	9e 85       	ldd	r25, Y+14	; 0x0e
    29c0:	20 e0       	ldi	r18, 0x00	; 0
    29c2:	30 e0       	ldi	r19, 0x00	; 0
    29c4:	4a e7       	ldi	r20, 0x7A	; 122
    29c6:	53 e4       	ldi	r21, 0x43	; 67
    29c8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    29cc:	dc 01       	movw	r26, r24
    29ce:	cb 01       	movw	r24, r22
    29d0:	8f 83       	std	Y+7, r24	; 0x07
    29d2:	98 87       	std	Y+8, r25	; 0x08
    29d4:	a9 87       	std	Y+9, r26	; 0x09
    29d6:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    29d8:	6f 81       	ldd	r22, Y+7	; 0x07
    29da:	78 85       	ldd	r23, Y+8	; 0x08
    29dc:	89 85       	ldd	r24, Y+9	; 0x09
    29de:	9a 85       	ldd	r25, Y+10	; 0x0a
    29e0:	20 e0       	ldi	r18, 0x00	; 0
    29e2:	30 e0       	ldi	r19, 0x00	; 0
    29e4:	40 e8       	ldi	r20, 0x80	; 128
    29e6:	5f e3       	ldi	r21, 0x3F	; 63
    29e8:	0e 94 55 04 	call	0x8aa	; 0x8aa <__ltsf2>
    29ec:	88 23       	and	r24, r24
    29ee:	2c f4       	brge	.+10     	; 0x29fa <HCLCD_Vid4Bits_Init+0x36c>
		__ticks = 1;
    29f0:	81 e0       	ldi	r24, 0x01	; 1
    29f2:	90 e0       	ldi	r25, 0x00	; 0
    29f4:	9e 83       	std	Y+6, r25	; 0x06
    29f6:	8d 83       	std	Y+5, r24	; 0x05
    29f8:	3f c0       	rjmp	.+126    	; 0x2a78 <HCLCD_Vid4Bits_Init+0x3ea>
	else if (__tmp > 65535)
    29fa:	6f 81       	ldd	r22, Y+7	; 0x07
    29fc:	78 85       	ldd	r23, Y+8	; 0x08
    29fe:	89 85       	ldd	r24, Y+9	; 0x09
    2a00:	9a 85       	ldd	r25, Y+10	; 0x0a
    2a02:	20 e0       	ldi	r18, 0x00	; 0
    2a04:	3f ef       	ldi	r19, 0xFF	; 255
    2a06:	4f e7       	ldi	r20, 0x7F	; 127
    2a08:	57 e4       	ldi	r21, 0x47	; 71
    2a0a:	0e 94 f5 03 	call	0x7ea	; 0x7ea <__gtsf2>
    2a0e:	18 16       	cp	r1, r24
    2a10:	4c f5       	brge	.+82     	; 0x2a64 <HCLCD_Vid4Bits_Init+0x3d6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2a12:	6b 85       	ldd	r22, Y+11	; 0x0b
    2a14:	7c 85       	ldd	r23, Y+12	; 0x0c
    2a16:	8d 85       	ldd	r24, Y+13	; 0x0d
    2a18:	9e 85       	ldd	r25, Y+14	; 0x0e
    2a1a:	20 e0       	ldi	r18, 0x00	; 0
    2a1c:	30 e0       	ldi	r19, 0x00	; 0
    2a1e:	40 e2       	ldi	r20, 0x20	; 32
    2a20:	51 e4       	ldi	r21, 0x41	; 65
    2a22:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2a26:	dc 01       	movw	r26, r24
    2a28:	cb 01       	movw	r24, r22
    2a2a:	bc 01       	movw	r22, r24
    2a2c:	cd 01       	movw	r24, r26
    2a2e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2a32:	dc 01       	movw	r26, r24
    2a34:	cb 01       	movw	r24, r22
    2a36:	9e 83       	std	Y+6, r25	; 0x06
    2a38:	8d 83       	std	Y+5, r24	; 0x05
    2a3a:	0f c0       	rjmp	.+30     	; 0x2a5a <HCLCD_Vid4Bits_Init+0x3cc>
    2a3c:	89 e1       	ldi	r24, 0x19	; 25
    2a3e:	90 e0       	ldi	r25, 0x00	; 0
    2a40:	9c 83       	std	Y+4, r25	; 0x04
    2a42:	8b 83       	std	Y+3, r24	; 0x03
    2a44:	8b 81       	ldd	r24, Y+3	; 0x03
    2a46:	9c 81       	ldd	r25, Y+4	; 0x04
    2a48:	01 97       	sbiw	r24, 0x01	; 1
    2a4a:	f1 f7       	brne	.-4      	; 0x2a48 <HCLCD_Vid4Bits_Init+0x3ba>
    2a4c:	9c 83       	std	Y+4, r25	; 0x04
    2a4e:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2a50:	8d 81       	ldd	r24, Y+5	; 0x05
    2a52:	9e 81       	ldd	r25, Y+6	; 0x06
    2a54:	01 97       	sbiw	r24, 0x01	; 1
    2a56:	9e 83       	std	Y+6, r25	; 0x06
    2a58:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2a5a:	8d 81       	ldd	r24, Y+5	; 0x05
    2a5c:	9e 81       	ldd	r25, Y+6	; 0x06
    2a5e:	00 97       	sbiw	r24, 0x00	; 0
    2a60:	69 f7       	brne	.-38     	; 0x2a3c <HCLCD_Vid4Bits_Init+0x3ae>
    2a62:	14 c0       	rjmp	.+40     	; 0x2a8c <HCLCD_Vid4Bits_Init+0x3fe>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2a64:	6f 81       	ldd	r22, Y+7	; 0x07
    2a66:	78 85       	ldd	r23, Y+8	; 0x08
    2a68:	89 85       	ldd	r24, Y+9	; 0x09
    2a6a:	9a 85       	ldd	r25, Y+10	; 0x0a
    2a6c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2a70:	dc 01       	movw	r26, r24
    2a72:	cb 01       	movw	r24, r22
    2a74:	9e 83       	std	Y+6, r25	; 0x06
    2a76:	8d 83       	std	Y+5, r24	; 0x05
    2a78:	8d 81       	ldd	r24, Y+5	; 0x05
    2a7a:	9e 81       	ldd	r25, Y+6	; 0x06
    2a7c:	9a 83       	std	Y+2, r25	; 0x02
    2a7e:	89 83       	std	Y+1, r24	; 0x01
    2a80:	89 81       	ldd	r24, Y+1	; 0x01
    2a82:	9a 81       	ldd	r25, Y+2	; 0x02
    2a84:	01 97       	sbiw	r24, 0x01	; 1
    2a86:	f1 f7       	brne	.-4      	; 0x2a84 <HCLCD_Vid4Bits_Init+0x3f6>
    2a88:	9a 83       	std	Y+2, r25	; 0x02
    2a8a:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(2);
	/*send Entry Mode  set command*/
	HCLCD_VidWriteCommand_4Bits(HCLCD_ENTRY_MODE_SET>>4);
    2a8c:	80 e0       	ldi	r24, 0x00	; 0
    2a8e:	0e 94 a3 12 	call	0x2546	; 0x2546 <HCLCD_VidWriteCommand_4Bits>
	HCLCD_VidWriteCommand_4Bits(HCLCD_ENTRY_MODE_SET);
    2a92:	86 e0       	ldi	r24, 0x06	; 6
    2a94:	0e 94 a3 12 	call	0x2546	; 0x2546 <HCLCD_VidWriteCommand_4Bits>
}
    2a98:	e9 96       	adiw	r28, 0x39	; 57
    2a9a:	0f b6       	in	r0, 0x3f	; 63
    2a9c:	f8 94       	cli
    2a9e:	de bf       	out	0x3e, r29	; 62
    2aa0:	0f be       	out	0x3f, r0	; 63
    2aa2:	cd bf       	out	0x3d, r28	; 61
    2aa4:	cf 91       	pop	r28
    2aa6:	df 91       	pop	r29
    2aa8:	08 95       	ret

00002aaa <HCLCD_VidWriteChar_4Bits>:
void HCLCD_VidWriteChar_4Bits(u8 Copy_u8Data)
{
    2aaa:	df 93       	push	r29
    2aac:	cf 93       	push	r28
    2aae:	cd b7       	in	r28, 0x3d	; 61
    2ab0:	de b7       	in	r29, 0x3e	; 62
    2ab2:	60 97       	sbiw	r28, 0x10	; 16
    2ab4:	0f b6       	in	r0, 0x3f	; 63
    2ab6:	f8 94       	cli
    2ab8:	de bf       	out	0x3e, r29	; 62
    2aba:	0f be       	out	0x3f, r0	; 63
    2abc:	cd bf       	out	0x3d, r28	; 61
    2abe:	88 8b       	std	Y+16, r24	; 0x10
	u8 LOC_u8CopyData;
	/*select Data register--> Write One on Rs pin*/
	MDIO_Error_State_SetPinValue(RS,CONTROL_PORT,PIN_HIGH);
    2ac0:	81 e0       	ldi	r24, 0x01	; 1
    2ac2:	61 e0       	ldi	r22, 0x01	; 1
    2ac4:	41 e0       	ldi	r20, 0x01	; 1
    2ac6:	0e 94 e2 09 	call	0x13c4	; 0x13c4 <MDIO_Error_State_SetPinValue>
	/*select Write mode--> Write zero on RW pin*/
	//MDIO_Error_State_SetPinValue(RW,CONTROL_PORT,PIN_LOW);
	/*Send Data*/
	LOC_u8CopyData=(Copy_u8Data&0x0F)<<HCLCD_PINSTART;
    2aca:	88 89       	ldd	r24, Y+16	; 0x10
    2acc:	88 2f       	mov	r24, r24
    2ace:	90 e0       	ldi	r25, 0x00	; 0
    2ad0:	82 95       	swap	r24
    2ad2:	92 95       	swap	r25
    2ad4:	90 7f       	andi	r25, 0xF0	; 240
    2ad6:	98 27       	eor	r25, r24
    2ad8:	80 7f       	andi	r24, 0xF0	; 240
    2ada:	98 27       	eor	r25, r24
    2adc:	8f 87       	std	Y+15, r24	; 0x0f
	MDIO_Error_State_SetNippleValue(HCLCD_PINSTART,DATA_PORT,LOC_u8CopyData);
    2ade:	84 e0       	ldi	r24, 0x04	; 4
    2ae0:	60 e0       	ldi	r22, 0x00	; 0
    2ae2:	4f 85       	ldd	r20, Y+15	; 0x0f
    2ae4:	0e 94 c5 0b 	call	0x178a	; 0x178a <MDIO_Error_State_SetNippleValue>
	/*Send Enable*/
	MDIO_Error_State_SetPinValue(E,CONTROL_PORT,PIN_HIGH);
    2ae8:	83 e0       	ldi	r24, 0x03	; 3
    2aea:	61 e0       	ldi	r22, 0x01	; 1
    2aec:	41 e0       	ldi	r20, 0x01	; 1
    2aee:	0e 94 e2 09 	call	0x13c4	; 0x13c4 <MDIO_Error_State_SetPinValue>
    2af2:	80 e0       	ldi	r24, 0x00	; 0
    2af4:	90 e0       	ldi	r25, 0x00	; 0
    2af6:	a0 e0       	ldi	r26, 0x00	; 0
    2af8:	b0 e4       	ldi	r27, 0x40	; 64
    2afa:	8b 87       	std	Y+11, r24	; 0x0b
    2afc:	9c 87       	std	Y+12, r25	; 0x0c
    2afe:	ad 87       	std	Y+13, r26	; 0x0d
    2b00:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2b02:	6b 85       	ldd	r22, Y+11	; 0x0b
    2b04:	7c 85       	ldd	r23, Y+12	; 0x0c
    2b06:	8d 85       	ldd	r24, Y+13	; 0x0d
    2b08:	9e 85       	ldd	r25, Y+14	; 0x0e
    2b0a:	20 e0       	ldi	r18, 0x00	; 0
    2b0c:	30 e0       	ldi	r19, 0x00	; 0
    2b0e:	4a e7       	ldi	r20, 0x7A	; 122
    2b10:	53 e4       	ldi	r21, 0x43	; 67
    2b12:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2b16:	dc 01       	movw	r26, r24
    2b18:	cb 01       	movw	r24, r22
    2b1a:	8f 83       	std	Y+7, r24	; 0x07
    2b1c:	98 87       	std	Y+8, r25	; 0x08
    2b1e:	a9 87       	std	Y+9, r26	; 0x09
    2b20:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    2b22:	6f 81       	ldd	r22, Y+7	; 0x07
    2b24:	78 85       	ldd	r23, Y+8	; 0x08
    2b26:	89 85       	ldd	r24, Y+9	; 0x09
    2b28:	9a 85       	ldd	r25, Y+10	; 0x0a
    2b2a:	20 e0       	ldi	r18, 0x00	; 0
    2b2c:	30 e0       	ldi	r19, 0x00	; 0
    2b2e:	40 e8       	ldi	r20, 0x80	; 128
    2b30:	5f e3       	ldi	r21, 0x3F	; 63
    2b32:	0e 94 55 04 	call	0x8aa	; 0x8aa <__ltsf2>
    2b36:	88 23       	and	r24, r24
    2b38:	2c f4       	brge	.+10     	; 0x2b44 <HCLCD_VidWriteChar_4Bits+0x9a>
		__ticks = 1;
    2b3a:	81 e0       	ldi	r24, 0x01	; 1
    2b3c:	90 e0       	ldi	r25, 0x00	; 0
    2b3e:	9e 83       	std	Y+6, r25	; 0x06
    2b40:	8d 83       	std	Y+5, r24	; 0x05
    2b42:	3f c0       	rjmp	.+126    	; 0x2bc2 <HCLCD_VidWriteChar_4Bits+0x118>
	else if (__tmp > 65535)
    2b44:	6f 81       	ldd	r22, Y+7	; 0x07
    2b46:	78 85       	ldd	r23, Y+8	; 0x08
    2b48:	89 85       	ldd	r24, Y+9	; 0x09
    2b4a:	9a 85       	ldd	r25, Y+10	; 0x0a
    2b4c:	20 e0       	ldi	r18, 0x00	; 0
    2b4e:	3f ef       	ldi	r19, 0xFF	; 255
    2b50:	4f e7       	ldi	r20, 0x7F	; 127
    2b52:	57 e4       	ldi	r21, 0x47	; 71
    2b54:	0e 94 f5 03 	call	0x7ea	; 0x7ea <__gtsf2>
    2b58:	18 16       	cp	r1, r24
    2b5a:	4c f5       	brge	.+82     	; 0x2bae <HCLCD_VidWriteChar_4Bits+0x104>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2b5c:	6b 85       	ldd	r22, Y+11	; 0x0b
    2b5e:	7c 85       	ldd	r23, Y+12	; 0x0c
    2b60:	8d 85       	ldd	r24, Y+13	; 0x0d
    2b62:	9e 85       	ldd	r25, Y+14	; 0x0e
    2b64:	20 e0       	ldi	r18, 0x00	; 0
    2b66:	30 e0       	ldi	r19, 0x00	; 0
    2b68:	40 e2       	ldi	r20, 0x20	; 32
    2b6a:	51 e4       	ldi	r21, 0x41	; 65
    2b6c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2b70:	dc 01       	movw	r26, r24
    2b72:	cb 01       	movw	r24, r22
    2b74:	bc 01       	movw	r22, r24
    2b76:	cd 01       	movw	r24, r26
    2b78:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2b7c:	dc 01       	movw	r26, r24
    2b7e:	cb 01       	movw	r24, r22
    2b80:	9e 83       	std	Y+6, r25	; 0x06
    2b82:	8d 83       	std	Y+5, r24	; 0x05
    2b84:	0f c0       	rjmp	.+30     	; 0x2ba4 <HCLCD_VidWriteChar_4Bits+0xfa>
    2b86:	89 e1       	ldi	r24, 0x19	; 25
    2b88:	90 e0       	ldi	r25, 0x00	; 0
    2b8a:	9c 83       	std	Y+4, r25	; 0x04
    2b8c:	8b 83       	std	Y+3, r24	; 0x03
    2b8e:	8b 81       	ldd	r24, Y+3	; 0x03
    2b90:	9c 81       	ldd	r25, Y+4	; 0x04
    2b92:	01 97       	sbiw	r24, 0x01	; 1
    2b94:	f1 f7       	brne	.-4      	; 0x2b92 <HCLCD_VidWriteChar_4Bits+0xe8>
    2b96:	9c 83       	std	Y+4, r25	; 0x04
    2b98:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2b9a:	8d 81       	ldd	r24, Y+5	; 0x05
    2b9c:	9e 81       	ldd	r25, Y+6	; 0x06
    2b9e:	01 97       	sbiw	r24, 0x01	; 1
    2ba0:	9e 83       	std	Y+6, r25	; 0x06
    2ba2:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2ba4:	8d 81       	ldd	r24, Y+5	; 0x05
    2ba6:	9e 81       	ldd	r25, Y+6	; 0x06
    2ba8:	00 97       	sbiw	r24, 0x00	; 0
    2baa:	69 f7       	brne	.-38     	; 0x2b86 <HCLCD_VidWriteChar_4Bits+0xdc>
    2bac:	14 c0       	rjmp	.+40     	; 0x2bd6 <HCLCD_VidWriteChar_4Bits+0x12c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2bae:	6f 81       	ldd	r22, Y+7	; 0x07
    2bb0:	78 85       	ldd	r23, Y+8	; 0x08
    2bb2:	89 85       	ldd	r24, Y+9	; 0x09
    2bb4:	9a 85       	ldd	r25, Y+10	; 0x0a
    2bb6:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2bba:	dc 01       	movw	r26, r24
    2bbc:	cb 01       	movw	r24, r22
    2bbe:	9e 83       	std	Y+6, r25	; 0x06
    2bc0:	8d 83       	std	Y+5, r24	; 0x05
    2bc2:	8d 81       	ldd	r24, Y+5	; 0x05
    2bc4:	9e 81       	ldd	r25, Y+6	; 0x06
    2bc6:	9a 83       	std	Y+2, r25	; 0x02
    2bc8:	89 83       	std	Y+1, r24	; 0x01
    2bca:	89 81       	ldd	r24, Y+1	; 0x01
    2bcc:	9a 81       	ldd	r25, Y+2	; 0x02
    2bce:	01 97       	sbiw	r24, 0x01	; 1
    2bd0:	f1 f7       	brne	.-4      	; 0x2bce <HCLCD_VidWriteChar_4Bits+0x124>
    2bd2:	9a 83       	std	Y+2, r25	; 0x02
    2bd4:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(2);
	MDIO_Error_State_SetPinValue(E,CONTROL_PORT,PIN_LOW);
    2bd6:	83 e0       	ldi	r24, 0x03	; 3
    2bd8:	61 e0       	ldi	r22, 0x01	; 1
    2bda:	40 e0       	ldi	r20, 0x00	; 0
    2bdc:	0e 94 e2 09 	call	0x13c4	; 0x13c4 <MDIO_Error_State_SetPinValue>
}
    2be0:	60 96       	adiw	r28, 0x10	; 16
    2be2:	0f b6       	in	r0, 0x3f	; 63
    2be4:	f8 94       	cli
    2be6:	de bf       	out	0x3e, r29	; 62
    2be8:	0f be       	out	0x3f, r0	; 63
    2bea:	cd bf       	out	0x3d, r28	; 61
    2bec:	cf 91       	pop	r28
    2bee:	df 91       	pop	r29
    2bf0:	08 95       	ret

00002bf2 <HCLCD_VidSendChar_4Bits>:
void HCLCD_VidSendChar_4Bits(u8 Copy_u8Data)
{
    2bf2:	df 93       	push	r29
    2bf4:	cf 93       	push	r28
    2bf6:	0f 92       	push	r0
    2bf8:	cd b7       	in	r28, 0x3d	; 61
    2bfa:	de b7       	in	r29, 0x3e	; 62
    2bfc:	89 83       	std	Y+1, r24	; 0x01
	HCLCD_VidWriteChar_4Bits(Copy_u8Data>>4);
    2bfe:	89 81       	ldd	r24, Y+1	; 0x01
    2c00:	82 95       	swap	r24
    2c02:	8f 70       	andi	r24, 0x0F	; 15
    2c04:	0e 94 55 15 	call	0x2aaa	; 0x2aaa <HCLCD_VidWriteChar_4Bits>
	HCLCD_VidWriteChar_4Bits(Copy_u8Data);
    2c08:	89 81       	ldd	r24, Y+1	; 0x01
    2c0a:	0e 94 55 15 	call	0x2aaa	; 0x2aaa <HCLCD_VidWriteChar_4Bits>
}
    2c0e:	0f 90       	pop	r0
    2c10:	cf 91       	pop	r28
    2c12:	df 91       	pop	r29
    2c14:	08 95       	ret

00002c16 <HCLCD_VidWriteString_4Bits>:
void HCLCD_VidWriteString_4Bits(u8* PCopy_u8String)
{
    2c16:	df 93       	push	r29
    2c18:	cf 93       	push	r28
    2c1a:	00 d0       	rcall	.+0      	; 0x2c1c <HCLCD_VidWriteString_4Bits+0x6>
    2c1c:	0f 92       	push	r0
    2c1e:	cd b7       	in	r28, 0x3d	; 61
    2c20:	de b7       	in	r29, 0x3e	; 62
    2c22:	9b 83       	std	Y+3, r25	; 0x03
    2c24:	8a 83       	std	Y+2, r24	; 0x02
	u8 Loc_u8Count=0;
    2c26:	19 82       	std	Y+1, r1	; 0x01
    2c28:	0e c0       	rjmp	.+28     	; 0x2c46 <HCLCD_VidWriteString_4Bits+0x30>
	while(PCopy_u8String[Loc_u8Count]!=NULL)
	{
		HCLCD_VidSendChar_4Bits(PCopy_u8String[Loc_u8Count]);
    2c2a:	89 81       	ldd	r24, Y+1	; 0x01
    2c2c:	28 2f       	mov	r18, r24
    2c2e:	30 e0       	ldi	r19, 0x00	; 0
    2c30:	8a 81       	ldd	r24, Y+2	; 0x02
    2c32:	9b 81       	ldd	r25, Y+3	; 0x03
    2c34:	fc 01       	movw	r30, r24
    2c36:	e2 0f       	add	r30, r18
    2c38:	f3 1f       	adc	r31, r19
    2c3a:	80 81       	ld	r24, Z
    2c3c:	0e 94 f9 15 	call	0x2bf2	; 0x2bf2 <HCLCD_VidSendChar_4Bits>
		Loc_u8Count++;
    2c40:	89 81       	ldd	r24, Y+1	; 0x01
    2c42:	8f 5f       	subi	r24, 0xFF	; 255
    2c44:	89 83       	std	Y+1, r24	; 0x01
	HCLCD_VidWriteChar_4Bits(Copy_u8Data);
}
void HCLCD_VidWriteString_4Bits(u8* PCopy_u8String)
{
	u8 Loc_u8Count=0;
	while(PCopy_u8String[Loc_u8Count]!=NULL)
    2c46:	89 81       	ldd	r24, Y+1	; 0x01
    2c48:	28 2f       	mov	r18, r24
    2c4a:	30 e0       	ldi	r19, 0x00	; 0
    2c4c:	8a 81       	ldd	r24, Y+2	; 0x02
    2c4e:	9b 81       	ldd	r25, Y+3	; 0x03
    2c50:	fc 01       	movw	r30, r24
    2c52:	e2 0f       	add	r30, r18
    2c54:	f3 1f       	adc	r31, r19
    2c56:	80 81       	ld	r24, Z
    2c58:	88 23       	and	r24, r24
    2c5a:	39 f7       	brne	.-50     	; 0x2c2a <HCLCD_VidWriteString_4Bits+0x14>
	{
		HCLCD_VidSendChar_4Bits(PCopy_u8String[Loc_u8Count]);
		Loc_u8Count++;
	}
}
    2c5c:	0f 90       	pop	r0
    2c5e:	0f 90       	pop	r0
    2c60:	0f 90       	pop	r0
    2c62:	cf 91       	pop	r28
    2c64:	df 91       	pop	r29
    2c66:	08 95       	ret

00002c68 <HCLCD_VidWriteNumber_4Bits>:
void HCLCD_VidWriteNumber_4Bits(u32 Copy_u8Number)
{
    2c68:	0f 93       	push	r16
    2c6a:	1f 93       	push	r17
    2c6c:	df 93       	push	r29
    2c6e:	cf 93       	push	r28
    2c70:	cd b7       	in	r28, 0x3d	; 61
    2c72:	de b7       	in	r29, 0x3e	; 62
    2c74:	60 97       	sbiw	r28, 0x10	; 16
    2c76:	0f b6       	in	r0, 0x3f	; 63
    2c78:	f8 94       	cli
    2c7a:	de bf       	out	0x3e, r29	; 62
    2c7c:	0f be       	out	0x3f, r0	; 63
    2c7e:	cd bf       	out	0x3d, r28	; 61
    2c80:	6d 87       	std	Y+13, r22	; 0x0d
    2c82:	7e 87       	std	Y+14, r23	; 0x0e
    2c84:	8f 87       	std	Y+15, r24	; 0x0f
    2c86:	98 8b       	std	Y+16, r25	; 0x10
	u8 ARR_Digits[10];
	u8 LOC_Count=0;
    2c88:	1a 82       	std	Y+2, r1	; 0x02
	if(Copy_u8Number>0)
    2c8a:	8d 85       	ldd	r24, Y+13	; 0x0d
    2c8c:	9e 85       	ldd	r25, Y+14	; 0x0e
    2c8e:	af 85       	ldd	r26, Y+15	; 0x0f
    2c90:	b8 89       	ldd	r27, Y+16	; 0x10
    2c92:	00 97       	sbiw	r24, 0x00	; 0
    2c94:	a1 05       	cpc	r26, r1
    2c96:	b1 05       	cpc	r27, r1
    2c98:	09 f4       	brne	.+2      	; 0x2c9c <HCLCD_VidWriteNumber_4Bits+0x34>
    2c9a:	4f c0       	rjmp	.+158    	; 0x2d3a <HCLCD_VidWriteNumber_4Bits+0xd2>
    2c9c:	2d c0       	rjmp	.+90     	; 0x2cf8 <HCLCD_VidWriteNumber_4Bits+0x90>
	{
		while(Copy_u8Number!=0)
		{
			ARR_Digits[LOC_Count]=Copy_u8Number%10;
    2c9e:	8a 81       	ldd	r24, Y+2	; 0x02
    2ca0:	08 2f       	mov	r16, r24
    2ca2:	10 e0       	ldi	r17, 0x00	; 0
    2ca4:	8d 85       	ldd	r24, Y+13	; 0x0d
    2ca6:	9e 85       	ldd	r25, Y+14	; 0x0e
    2ca8:	af 85       	ldd	r26, Y+15	; 0x0f
    2caa:	b8 89       	ldd	r27, Y+16	; 0x10
    2cac:	2a e0       	ldi	r18, 0x0A	; 10
    2cae:	30 e0       	ldi	r19, 0x00	; 0
    2cb0:	40 e0       	ldi	r20, 0x00	; 0
    2cb2:	50 e0       	ldi	r21, 0x00	; 0
    2cb4:	bc 01       	movw	r22, r24
    2cb6:	cd 01       	movw	r24, r26
    2cb8:	0e 94 27 4c 	call	0x984e	; 0x984e <__udivmodsi4>
    2cbc:	dc 01       	movw	r26, r24
    2cbe:	cb 01       	movw	r24, r22
    2cc0:	28 2f       	mov	r18, r24
    2cc2:	ce 01       	movw	r24, r28
    2cc4:	03 96       	adiw	r24, 0x03	; 3
    2cc6:	fc 01       	movw	r30, r24
    2cc8:	e0 0f       	add	r30, r16
    2cca:	f1 1f       	adc	r31, r17
    2ccc:	20 83       	st	Z, r18
			Copy_u8Number/=10;
    2cce:	8d 85       	ldd	r24, Y+13	; 0x0d
    2cd0:	9e 85       	ldd	r25, Y+14	; 0x0e
    2cd2:	af 85       	ldd	r26, Y+15	; 0x0f
    2cd4:	b8 89       	ldd	r27, Y+16	; 0x10
    2cd6:	2a e0       	ldi	r18, 0x0A	; 10
    2cd8:	30 e0       	ldi	r19, 0x00	; 0
    2cda:	40 e0       	ldi	r20, 0x00	; 0
    2cdc:	50 e0       	ldi	r21, 0x00	; 0
    2cde:	bc 01       	movw	r22, r24
    2ce0:	cd 01       	movw	r24, r26
    2ce2:	0e 94 27 4c 	call	0x984e	; 0x984e <__udivmodsi4>
    2ce6:	da 01       	movw	r26, r20
    2ce8:	c9 01       	movw	r24, r18
    2cea:	8d 87       	std	Y+13, r24	; 0x0d
    2cec:	9e 87       	std	Y+14, r25	; 0x0e
    2cee:	af 87       	std	Y+15, r26	; 0x0f
    2cf0:	b8 8b       	std	Y+16, r27	; 0x10
			LOC_Count++;
    2cf2:	8a 81       	ldd	r24, Y+2	; 0x02
    2cf4:	8f 5f       	subi	r24, 0xFF	; 255
    2cf6:	8a 83       	std	Y+2, r24	; 0x02
{
	u8 ARR_Digits[10];
	u8 LOC_Count=0;
	if(Copy_u8Number>0)
	{
		while(Copy_u8Number!=0)
    2cf8:	8d 85       	ldd	r24, Y+13	; 0x0d
    2cfa:	9e 85       	ldd	r25, Y+14	; 0x0e
    2cfc:	af 85       	ldd	r26, Y+15	; 0x0f
    2cfe:	b8 89       	ldd	r27, Y+16	; 0x10
    2d00:	00 97       	sbiw	r24, 0x00	; 0
    2d02:	a1 05       	cpc	r26, r1
    2d04:	b1 05       	cpc	r27, r1
    2d06:	59 f6       	brne	.-106    	; 0x2c9e <HCLCD_VidWriteNumber_4Bits+0x36>
		{
			ARR_Digits[LOC_Count]=Copy_u8Number%10;
			Copy_u8Number/=10;
			LOC_Count++;
		}
		for(s8 i=LOC_Count-1;i>=0;i--)
    2d08:	8a 81       	ldd	r24, Y+2	; 0x02
    2d0a:	81 50       	subi	r24, 0x01	; 1
    2d0c:	89 83       	std	Y+1, r24	; 0x01
    2d0e:	11 c0       	rjmp	.+34     	; 0x2d32 <HCLCD_VidWriteNumber_4Bits+0xca>
		{
			HCLCD_VidSendChar_4Bits(ARR_Digits[i]+'0');
    2d10:	89 81       	ldd	r24, Y+1	; 0x01
    2d12:	28 2f       	mov	r18, r24
    2d14:	33 27       	eor	r19, r19
    2d16:	27 fd       	sbrc	r18, 7
    2d18:	30 95       	com	r19
    2d1a:	ce 01       	movw	r24, r28
    2d1c:	03 96       	adiw	r24, 0x03	; 3
    2d1e:	fc 01       	movw	r30, r24
    2d20:	e2 0f       	add	r30, r18
    2d22:	f3 1f       	adc	r31, r19
    2d24:	80 81       	ld	r24, Z
    2d26:	80 5d       	subi	r24, 0xD0	; 208
    2d28:	0e 94 f9 15 	call	0x2bf2	; 0x2bf2 <HCLCD_VidSendChar_4Bits>
		{
			ARR_Digits[LOC_Count]=Copy_u8Number%10;
			Copy_u8Number/=10;
			LOC_Count++;
		}
		for(s8 i=LOC_Count-1;i>=0;i--)
    2d2c:	89 81       	ldd	r24, Y+1	; 0x01
    2d2e:	81 50       	subi	r24, 0x01	; 1
    2d30:	89 83       	std	Y+1, r24	; 0x01
    2d32:	89 81       	ldd	r24, Y+1	; 0x01
    2d34:	88 23       	and	r24, r24
    2d36:	64 f7       	brge	.-40     	; 0x2d10 <HCLCD_VidWriteNumber_4Bits+0xa8>
    2d38:	03 c0       	rjmp	.+6      	; 0x2d40 <HCLCD_VidWriteNumber_4Bits+0xd8>
			HCLCD_VidSendChar_4Bits(ARR_Digits[i]+'0');
		}
	}
	else
	{
		HCLCD_VidWriteChar_8Bits('0');
    2d3a:	80 e3       	ldi	r24, 0x30	; 48
    2d3c:	0e 94 d2 10 	call	0x21a4	; 0x21a4 <HCLCD_VidWriteChar_8Bits>
	}
}
    2d40:	60 96       	adiw	r28, 0x10	; 16
    2d42:	0f b6       	in	r0, 0x3f	; 63
    2d44:	f8 94       	cli
    2d46:	de bf       	out	0x3e, r29	; 62
    2d48:	0f be       	out	0x3f, r0	; 63
    2d4a:	cd bf       	out	0x3d, r28	; 61
    2d4c:	cf 91       	pop	r28
    2d4e:	df 91       	pop	r29
    2d50:	1f 91       	pop	r17
    2d52:	0f 91       	pop	r16
    2d54:	08 95       	ret

00002d56 <HCLCD_VidSetPosition_4BitsMode>:
void HCLCD_VidSetPosition_4BitsMode(u8 Copy_u8LineNumber , u8 Copy_u8PositionNumber)
{
    2d56:	df 93       	push	r29
    2d58:	cf 93       	push	r28
    2d5a:	00 d0       	rcall	.+0      	; 0x2d5c <HCLCD_VidSetPosition_4BitsMode+0x6>
    2d5c:	cd b7       	in	r28, 0x3d	; 61
    2d5e:	de b7       	in	r29, 0x3e	; 62
    2d60:	89 83       	std	Y+1, r24	; 0x01
    2d62:	6a 83       	std	Y+2, r22	; 0x02
	if((Copy_u8LineNumber==HCLCD_LINE1)&&((Copy_u8PositionNumber>=0)&&(Copy_u8PositionNumber<16)))
    2d64:	89 81       	ldd	r24, Y+1	; 0x01
    2d66:	81 30       	cpi	r24, 0x01	; 1
    2d68:	b9 f4       	brne	.+46     	; 0x2d98 <HCLCD_VidSetPosition_4BitsMode+0x42>
    2d6a:	8a 81       	ldd	r24, Y+2	; 0x02
    2d6c:	80 31       	cpi	r24, 0x10	; 16
    2d6e:	a0 f4       	brcc	.+40     	; 0x2d98 <HCLCD_VidSetPosition_4BitsMode+0x42>
	{
		HCLCD_VidWriteCommand_4Bits((LINE1_OFFSET_ADDRESS+Copy_u8PositionNumber)>>4);
    2d70:	8a 81       	ldd	r24, Y+2	; 0x02
    2d72:	88 2f       	mov	r24, r24
    2d74:	90 e0       	ldi	r25, 0x00	; 0
    2d76:	80 58       	subi	r24, 0x80	; 128
    2d78:	9f 4f       	sbci	r25, 0xFF	; 255
    2d7a:	95 95       	asr	r25
    2d7c:	87 95       	ror	r24
    2d7e:	95 95       	asr	r25
    2d80:	87 95       	ror	r24
    2d82:	95 95       	asr	r25
    2d84:	87 95       	ror	r24
    2d86:	95 95       	asr	r25
    2d88:	87 95       	ror	r24
    2d8a:	0e 94 a3 12 	call	0x2546	; 0x2546 <HCLCD_VidWriteCommand_4Bits>
		HCLCD_VidWriteCommand_4Bits((LINE1_OFFSET_ADDRESS+Copy_u8PositionNumber));
    2d8e:	8a 81       	ldd	r24, Y+2	; 0x02
    2d90:	80 58       	subi	r24, 0x80	; 128
    2d92:	0e 94 a3 12 	call	0x2546	; 0x2546 <HCLCD_VidWriteCommand_4Bits>
    2d96:	19 c0       	rjmp	.+50     	; 0x2dca <HCLCD_VidSetPosition_4BitsMode+0x74>
	}
	else if((Copy_u8LineNumber==HCLCD_LINE2)&&((Copy_u8PositionNumber>=0)&&(Copy_u8PositionNumber<16)))
    2d98:	89 81       	ldd	r24, Y+1	; 0x01
    2d9a:	82 30       	cpi	r24, 0x02	; 2
    2d9c:	b1 f4       	brne	.+44     	; 0x2dca <HCLCD_VidSetPosition_4BitsMode+0x74>
    2d9e:	8a 81       	ldd	r24, Y+2	; 0x02
    2da0:	80 31       	cpi	r24, 0x10	; 16
    2da2:	98 f4       	brcc	.+38     	; 0x2dca <HCLCD_VidSetPosition_4BitsMode+0x74>
	{
		HCLCD_VidWriteCommand_4Bits((LINE2_OFFSET_ADDRESS+Copy_u8PositionNumber)>>4);
    2da4:	8a 81       	ldd	r24, Y+2	; 0x02
    2da6:	88 2f       	mov	r24, r24
    2da8:	90 e0       	ldi	r25, 0x00	; 0
    2daa:	80 54       	subi	r24, 0x40	; 64
    2dac:	9f 4f       	sbci	r25, 0xFF	; 255
    2dae:	95 95       	asr	r25
    2db0:	87 95       	ror	r24
    2db2:	95 95       	asr	r25
    2db4:	87 95       	ror	r24
    2db6:	95 95       	asr	r25
    2db8:	87 95       	ror	r24
    2dba:	95 95       	asr	r25
    2dbc:	87 95       	ror	r24
    2dbe:	0e 94 a3 12 	call	0x2546	; 0x2546 <HCLCD_VidWriteCommand_4Bits>
		HCLCD_VidWriteCommand_4Bits((LINE2_OFFSET_ADDRESS+Copy_u8PositionNumber));
    2dc2:	8a 81       	ldd	r24, Y+2	; 0x02
    2dc4:	80 54       	subi	r24, 0x40	; 64
    2dc6:	0e 94 a3 12 	call	0x2546	; 0x2546 <HCLCD_VidWriteCommand_4Bits>
	}
	else
	{
		/*Do Nothing*/
	}
}
    2dca:	0f 90       	pop	r0
    2dcc:	0f 90       	pop	r0
    2dce:	cf 91       	pop	r28
    2dd0:	df 91       	pop	r29
    2dd2:	08 95       	ret

00002dd4 <ADXL_init>:


#include "ADXL345_I2C.h"
void ADXL_init()
{
    2dd4:	df 93       	push	r29
    2dd6:	cf 93       	push	r28
    2dd8:	cd b7       	in	r28, 0x3d	; 61
    2dda:	de b7       	in	r29, 0x3e	; 62
	TWI_Ini();
    2ddc:	0e 94 55 0d 	call	0x1aaa	; 0x1aaa <TWI_Ini>
	ADXL_write(0x2D,0x08);
    2de0:	8d e2       	ldi	r24, 0x2D	; 45
    2de2:	68 e0       	ldi	r22, 0x08	; 8
    2de4:	0e 94 f7 16 	call	0x2dee	; 0x2dee <ADXL_write>
}
    2de8:	cf 91       	pop	r28
    2dea:	df 91       	pop	r29
    2dec:	08 95       	ret

00002dee <ADXL_write>:

void ADXL_write(char address,char data)
{
    2dee:	df 93       	push	r29
    2df0:	cf 93       	push	r28
    2df2:	00 d0       	rcall	.+0      	; 0x2df4 <ADXL_write+0x6>
    2df4:	cd b7       	in	r28, 0x3d	; 61
    2df6:	de b7       	in	r29, 0x3e	; 62
    2df8:	89 83       	std	Y+1, r24	; 0x01
    2dfa:	6a 83       	std	Y+2, r22	; 0x02
	
	TWI_start();
    2dfc:	0e 94 63 0d 	call	0x1ac6	; 0x1ac6 <TWI_start>
	TWI_write(dev_write);
    2e00:	86 ea       	ldi	r24, 0xA6	; 166
    2e02:	0e 94 94 0d 	call	0x1b28	; 0x1b28 <TWI_write>
	TWI_write(address);
    2e06:	89 81       	ldd	r24, Y+1	; 0x01
    2e08:	0e 94 94 0d 	call	0x1b28	; 0x1b28 <TWI_write>
	TWI_write(data);
    2e0c:	8a 81       	ldd	r24, Y+2	; 0x02
    2e0e:	0e 94 94 0d 	call	0x1b28	; 0x1b28 <TWI_write>
	TWI_stop();
    2e12:	0e 94 89 0d 	call	0x1b12	; 0x1b12 <TWI_stop>
}
    2e16:	0f 90       	pop	r0
    2e18:	0f 90       	pop	r0
    2e1a:	cf 91       	pop	r28
    2e1c:	df 91       	pop	r29
    2e1e:	08 95       	ret

00002e20 <ADXL_Acc>:


void ADXL_Acc(float data_array[])
{
    2e20:	0f 93       	push	r16
    2e22:	1f 93       	push	r17
    2e24:	df 93       	push	r29
    2e26:	cf 93       	push	r28
    2e28:	cd b7       	in	r28, 0x3d	; 61
    2e2a:	de b7       	in	r29, 0x3e	; 62
    2e2c:	2e 97       	sbiw	r28, 0x0e	; 14
    2e2e:	0f b6       	in	r0, 0x3f	; 63
    2e30:	f8 94       	cli
    2e32:	de bf       	out	0x3e, r29	; 62
    2e34:	0f be       	out	0x3f, r0	; 63
    2e36:	cd bf       	out	0x3d, r28	; 61
    2e38:	9e 87       	std	Y+14, r25	; 0x0e
    2e3a:	8d 87       	std	Y+13, r24	; 0x0d
	int x0,x1,y0,y1,z0,z1;
	TWI_start();
    2e3c:	0e 94 63 0d 	call	0x1ac6	; 0x1ac6 <TWI_start>
	TWI_write(dev_write);
    2e40:	86 ea       	ldi	r24, 0xA6	; 166
    2e42:	0e 94 94 0d 	call	0x1b28	; 0x1b28 <TWI_write>
	TWI_write(x0_address);
    2e46:	82 e3       	ldi	r24, 0x32	; 50
    2e48:	0e 94 94 0d 	call	0x1b28	; 0x1b28 <TWI_write>
	TWI_start();
    2e4c:	0e 94 63 0d 	call	0x1ac6	; 0x1ac6 <TWI_start>
	TWI_write(dev_read);
    2e50:	87 ea       	ldi	r24, 0xA7	; 167
    2e52:	0e 94 94 0d 	call	0x1b28	; 0x1b28 <TWI_write>
	x0=TWI_read(ACKM);
    2e56:	81 e0       	ldi	r24, 0x01	; 1
    2e58:	0e 94 ab 0d 	call	0x1b56	; 0x1b56 <TWI_read>
    2e5c:	88 2f       	mov	r24, r24
    2e5e:	90 e0       	ldi	r25, 0x00	; 0
    2e60:	9c 87       	std	Y+12, r25	; 0x0c
    2e62:	8b 87       	std	Y+11, r24	; 0x0b
	x1=TWI_read(ACKM);
    2e64:	81 e0       	ldi	r24, 0x01	; 1
    2e66:	0e 94 ab 0d 	call	0x1b56	; 0x1b56 <TWI_read>
    2e6a:	88 2f       	mov	r24, r24
    2e6c:	90 e0       	ldi	r25, 0x00	; 0
    2e6e:	9a 87       	std	Y+10, r25	; 0x0a
    2e70:	89 87       	std	Y+9, r24	; 0x09
	y0=TWI_read(ACKM);
    2e72:	81 e0       	ldi	r24, 0x01	; 1
    2e74:	0e 94 ab 0d 	call	0x1b56	; 0x1b56 <TWI_read>
    2e78:	88 2f       	mov	r24, r24
    2e7a:	90 e0       	ldi	r25, 0x00	; 0
    2e7c:	98 87       	std	Y+8, r25	; 0x08
    2e7e:	8f 83       	std	Y+7, r24	; 0x07
	y1=TWI_read(ACKM);
    2e80:	81 e0       	ldi	r24, 0x01	; 1
    2e82:	0e 94 ab 0d 	call	0x1b56	; 0x1b56 <TWI_read>
    2e86:	88 2f       	mov	r24, r24
    2e88:	90 e0       	ldi	r25, 0x00	; 0
    2e8a:	9e 83       	std	Y+6, r25	; 0x06
    2e8c:	8d 83       	std	Y+5, r24	; 0x05
	z0=TWI_read(ACKM);
    2e8e:	81 e0       	ldi	r24, 0x01	; 1
    2e90:	0e 94 ab 0d 	call	0x1b56	; 0x1b56 <TWI_read>
    2e94:	88 2f       	mov	r24, r24
    2e96:	90 e0       	ldi	r25, 0x00	; 0
    2e98:	9c 83       	std	Y+4, r25	; 0x04
    2e9a:	8b 83       	std	Y+3, r24	; 0x03
	z1=TWI_read(NACKM);
    2e9c:	80 e0       	ldi	r24, 0x00	; 0
    2e9e:	0e 94 ab 0d 	call	0x1b56	; 0x1b56 <TWI_read>
    2ea2:	88 2f       	mov	r24, r24
    2ea4:	90 e0       	ldi	r25, 0x00	; 0
    2ea6:	9a 83       	std	Y+2, r25	; 0x02
    2ea8:	89 83       	std	Y+1, r24	; 0x01
	TWI_stop();
    2eaa:	0e 94 89 0d 	call	0x1b12	; 0x1b12 <TWI_stop>
	data_array[0]=((x1<<8)|x0)*g/sensitivity;
    2eae:	89 85       	ldd	r24, Y+9	; 0x09
    2eb0:	9a 85       	ldd	r25, Y+10	; 0x0a
    2eb2:	38 2f       	mov	r19, r24
    2eb4:	22 27       	eor	r18, r18
    2eb6:	8b 85       	ldd	r24, Y+11	; 0x0b
    2eb8:	9c 85       	ldd	r25, Y+12	; 0x0c
    2eba:	82 2b       	or	r24, r18
    2ebc:	93 2b       	or	r25, r19
    2ebe:	aa 27       	eor	r26, r26
    2ec0:	97 fd       	sbrc	r25, 7
    2ec2:	a0 95       	com	r26
    2ec4:	ba 2f       	mov	r27, r26
    2ec6:	bc 01       	movw	r22, r24
    2ec8:	cd 01       	movw	r24, r26
    2eca:	0e 94 85 04 	call	0x90a	; 0x90a <__floatsisf>
    2ece:	dc 01       	movw	r26, r24
    2ed0:	cb 01       	movw	r24, r22
    2ed2:	bc 01       	movw	r22, r24
    2ed4:	cd 01       	movw	r24, r26
    2ed6:	2d ec       	ldi	r18, 0xCD	; 205
    2ed8:	3c ec       	ldi	r19, 0xCC	; 204
    2eda:	4c e1       	ldi	r20, 0x1C	; 28
    2edc:	51 e4       	ldi	r21, 0x41	; 65
    2ede:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2ee2:	dc 01       	movw	r26, r24
    2ee4:	cb 01       	movw	r24, r22
    2ee6:	bc 01       	movw	r22, r24
    2ee8:	cd 01       	movw	r24, r26
    2eea:	20 e0       	ldi	r18, 0x00	; 0
    2eec:	30 e0       	ldi	r19, 0x00	; 0
    2eee:	4d e8       	ldi	r20, 0x8D	; 141
    2ef0:	53 e4       	ldi	r21, 0x43	; 67
    2ef2:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    2ef6:	dc 01       	movw	r26, r24
    2ef8:	cb 01       	movw	r24, r22
    2efa:	ed 85       	ldd	r30, Y+13	; 0x0d
    2efc:	fe 85       	ldd	r31, Y+14	; 0x0e
    2efe:	80 83       	st	Z, r24
    2f00:	91 83       	std	Z+1, r25	; 0x01
    2f02:	a2 83       	std	Z+2, r26	; 0x02
    2f04:	b3 83       	std	Z+3, r27	; 0x03
	data_array[1]=((y1<<8)|y0)*g/sensitivity;
    2f06:	8d 85       	ldd	r24, Y+13	; 0x0d
    2f08:	9e 85       	ldd	r25, Y+14	; 0x0e
    2f0a:	8c 01       	movw	r16, r24
    2f0c:	0c 5f       	subi	r16, 0xFC	; 252
    2f0e:	1f 4f       	sbci	r17, 0xFF	; 255
    2f10:	8d 81       	ldd	r24, Y+5	; 0x05
    2f12:	9e 81       	ldd	r25, Y+6	; 0x06
    2f14:	38 2f       	mov	r19, r24
    2f16:	22 27       	eor	r18, r18
    2f18:	8f 81       	ldd	r24, Y+7	; 0x07
    2f1a:	98 85       	ldd	r25, Y+8	; 0x08
    2f1c:	82 2b       	or	r24, r18
    2f1e:	93 2b       	or	r25, r19
    2f20:	aa 27       	eor	r26, r26
    2f22:	97 fd       	sbrc	r25, 7
    2f24:	a0 95       	com	r26
    2f26:	ba 2f       	mov	r27, r26
    2f28:	bc 01       	movw	r22, r24
    2f2a:	cd 01       	movw	r24, r26
    2f2c:	0e 94 85 04 	call	0x90a	; 0x90a <__floatsisf>
    2f30:	dc 01       	movw	r26, r24
    2f32:	cb 01       	movw	r24, r22
    2f34:	bc 01       	movw	r22, r24
    2f36:	cd 01       	movw	r24, r26
    2f38:	2d ec       	ldi	r18, 0xCD	; 205
    2f3a:	3c ec       	ldi	r19, 0xCC	; 204
    2f3c:	4c e1       	ldi	r20, 0x1C	; 28
    2f3e:	51 e4       	ldi	r21, 0x41	; 65
    2f40:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2f44:	dc 01       	movw	r26, r24
    2f46:	cb 01       	movw	r24, r22
    2f48:	bc 01       	movw	r22, r24
    2f4a:	cd 01       	movw	r24, r26
    2f4c:	20 e0       	ldi	r18, 0x00	; 0
    2f4e:	30 e0       	ldi	r19, 0x00	; 0
    2f50:	4d e8       	ldi	r20, 0x8D	; 141
    2f52:	53 e4       	ldi	r21, 0x43	; 67
    2f54:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    2f58:	dc 01       	movw	r26, r24
    2f5a:	cb 01       	movw	r24, r22
    2f5c:	f8 01       	movw	r30, r16
    2f5e:	80 83       	st	Z, r24
    2f60:	91 83       	std	Z+1, r25	; 0x01
    2f62:	a2 83       	std	Z+2, r26	; 0x02
    2f64:	b3 83       	std	Z+3, r27	; 0x03
	data_array[2]=((z1<<8)|z0)*g/sensitivity ;
    2f66:	8d 85       	ldd	r24, Y+13	; 0x0d
    2f68:	9e 85       	ldd	r25, Y+14	; 0x0e
    2f6a:	8c 01       	movw	r16, r24
    2f6c:	08 5f       	subi	r16, 0xF8	; 248
    2f6e:	1f 4f       	sbci	r17, 0xFF	; 255
    2f70:	89 81       	ldd	r24, Y+1	; 0x01
    2f72:	9a 81       	ldd	r25, Y+2	; 0x02
    2f74:	38 2f       	mov	r19, r24
    2f76:	22 27       	eor	r18, r18
    2f78:	8b 81       	ldd	r24, Y+3	; 0x03
    2f7a:	9c 81       	ldd	r25, Y+4	; 0x04
    2f7c:	82 2b       	or	r24, r18
    2f7e:	93 2b       	or	r25, r19
    2f80:	aa 27       	eor	r26, r26
    2f82:	97 fd       	sbrc	r25, 7
    2f84:	a0 95       	com	r26
    2f86:	ba 2f       	mov	r27, r26
    2f88:	bc 01       	movw	r22, r24
    2f8a:	cd 01       	movw	r24, r26
    2f8c:	0e 94 85 04 	call	0x90a	; 0x90a <__floatsisf>
    2f90:	dc 01       	movw	r26, r24
    2f92:	cb 01       	movw	r24, r22
    2f94:	bc 01       	movw	r22, r24
    2f96:	cd 01       	movw	r24, r26
    2f98:	2d ec       	ldi	r18, 0xCD	; 205
    2f9a:	3c ec       	ldi	r19, 0xCC	; 204
    2f9c:	4c e1       	ldi	r20, 0x1C	; 28
    2f9e:	51 e4       	ldi	r21, 0x41	; 65
    2fa0:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2fa4:	dc 01       	movw	r26, r24
    2fa6:	cb 01       	movw	r24, r22
    2fa8:	bc 01       	movw	r22, r24
    2faa:	cd 01       	movw	r24, r26
    2fac:	20 e0       	ldi	r18, 0x00	; 0
    2fae:	30 e0       	ldi	r19, 0x00	; 0
    2fb0:	4d e8       	ldi	r20, 0x8D	; 141
    2fb2:	53 e4       	ldi	r21, 0x43	; 67
    2fb4:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    2fb8:	dc 01       	movw	r26, r24
    2fba:	cb 01       	movw	r24, r22
    2fbc:	f8 01       	movw	r30, r16
    2fbe:	80 83       	st	Z, r24
    2fc0:	91 83       	std	Z+1, r25	; 0x01
    2fc2:	a2 83       	std	Z+2, r26	; 0x02
    2fc4:	b3 83       	std	Z+3, r27	; 0x03
	
}
    2fc6:	2e 96       	adiw	r28, 0x0e	; 14
    2fc8:	0f b6       	in	r0, 0x3f	; 63
    2fca:	f8 94       	cli
    2fcc:	de bf       	out	0x3e, r29	; 62
    2fce:	0f be       	out	0x3f, r0	; 63
    2fd0:	cd bf       	out	0x3d, r28	; 61
    2fd2:	cf 91       	pop	r28
    2fd4:	df 91       	pop	r29
    2fd6:	1f 91       	pop	r17
    2fd8:	0f 91       	pop	r16
    2fda:	08 95       	ret

00002fdc <xCoRoutineCreate>:
/*-----------------------------------------------------------*/

    BaseType_t xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode,
                                 UBaseType_t uxPriority,
                                 UBaseType_t uxIndex )
    {
    2fdc:	df 93       	push	r29
    2fde:	cf 93       	push	r28
    2fe0:	cd b7       	in	r28, 0x3d	; 61
    2fe2:	de b7       	in	r29, 0x3e	; 62
    2fe4:	27 97       	sbiw	r28, 0x07	; 7
    2fe6:	0f b6       	in	r0, 0x3f	; 63
    2fe8:	f8 94       	cli
    2fea:	de bf       	out	0x3e, r29	; 62
    2fec:	0f be       	out	0x3f, r0	; 63
    2fee:	cd bf       	out	0x3d, r28	; 61
    2ff0:	9d 83       	std	Y+5, r25	; 0x05
    2ff2:	8c 83       	std	Y+4, r24	; 0x04
    2ff4:	6e 83       	std	Y+6, r22	; 0x06
    2ff6:	4f 83       	std	Y+7, r20	; 0x07
        BaseType_t xReturn;
        CRCB_t * pxCoRoutine;

        /* Allocate the memory that will store the co-routine control block. */
        pxCoRoutine = ( CRCB_t * ) pvPortMalloc( sizeof( CRCB_t ) );
    2ff8:	8a e1       	ldi	r24, 0x1A	; 26
    2ffa:	90 e0       	ldi	r25, 0x00	; 0
    2ffc:	0e 94 12 1e 	call	0x3c24	; 0x3c24 <pvPortMalloc>
    3000:	9a 83       	std	Y+2, r25	; 0x02
    3002:	89 83       	std	Y+1, r24	; 0x01

        if( pxCoRoutine )
    3004:	89 81       	ldd	r24, Y+1	; 0x01
    3006:	9a 81       	ldd	r25, Y+2	; 0x02
    3008:	00 97       	sbiw	r24, 0x00	; 0
    300a:	09 f4       	brne	.+2      	; 0x300e <xCoRoutineCreate+0x32>
    300c:	6f c0       	rjmp	.+222    	; 0x30ec <xCoRoutineCreate+0x110>
        {
            /* If pxCurrentCoRoutine is NULL then this is the first co-routine to
            * be created and the co-routine data structures need initialising. */
            if( pxCurrentCoRoutine == NULL )
    300e:	80 91 8a 01 	lds	r24, 0x018A
    3012:	90 91 8b 01 	lds	r25, 0x018B
    3016:	00 97       	sbiw	r24, 0x00	; 0
    3018:	41 f4       	brne	.+16     	; 0x302a <xCoRoutineCreate+0x4e>
            {
                pxCurrentCoRoutine = pxCoRoutine;
    301a:	89 81       	ldd	r24, Y+1	; 0x01
    301c:	9a 81       	ldd	r25, Y+2	; 0x02
    301e:	90 93 8b 01 	sts	0x018B, r25
    3022:	80 93 8a 01 	sts	0x018A, r24
                prvInitialiseCoRoutineLists();
    3026:	0e 94 5c 1a 	call	0x34b8	; 0x34b8 <prvInitialiseCoRoutineLists>
            }

            /* Check the priority is within limits. */
            if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
    302a:	8e 81       	ldd	r24, Y+6	; 0x06
    302c:	82 30       	cpi	r24, 0x02	; 2
    302e:	10 f0       	brcs	.+4      	; 0x3034 <xCoRoutineCreate+0x58>
            {
                uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
    3030:	81 e0       	ldi	r24, 0x01	; 1
    3032:	8e 83       	std	Y+6, r24	; 0x06
            }

            /* Fill out the co-routine control block from the function parameters. */
            pxCoRoutine->uxState = corINITIAL_STATE;
    3034:	e9 81       	ldd	r30, Y+1	; 0x01
    3036:	fa 81       	ldd	r31, Y+2	; 0x02
    3038:	11 8e       	std	Z+25, r1	; 0x19
    303a:	10 8e       	std	Z+24, r1	; 0x18
            pxCoRoutine->uxPriority = uxPriority;
    303c:	e9 81       	ldd	r30, Y+1	; 0x01
    303e:	fa 81       	ldd	r31, Y+2	; 0x02
    3040:	8e 81       	ldd	r24, Y+6	; 0x06
    3042:	86 8b       	std	Z+22, r24	; 0x16
            pxCoRoutine->uxIndex = uxIndex;
    3044:	e9 81       	ldd	r30, Y+1	; 0x01
    3046:	fa 81       	ldd	r31, Y+2	; 0x02
    3048:	8f 81       	ldd	r24, Y+7	; 0x07
    304a:	87 8b       	std	Z+23, r24	; 0x17
            pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    304c:	e9 81       	ldd	r30, Y+1	; 0x01
    304e:	fa 81       	ldd	r31, Y+2	; 0x02
    3050:	8c 81       	ldd	r24, Y+4	; 0x04
    3052:	9d 81       	ldd	r25, Y+5	; 0x05
    3054:	91 83       	std	Z+1, r25	; 0x01
    3056:	80 83       	st	Z, r24

            /* Initialise all the other co-routine control block parameters. */
            vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    3058:	89 81       	ldd	r24, Y+1	; 0x01
    305a:	9a 81       	ldd	r25, Y+2	; 0x02
    305c:	02 96       	adiw	r24, 0x02	; 2
    305e:	0e 94 bc 1e 	call	0x3d78	; 0x3d78 <vListInitialiseItem>
            vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    3062:	89 81       	ldd	r24, Y+1	; 0x01
    3064:	9a 81       	ldd	r25, Y+2	; 0x02
    3066:	0c 96       	adiw	r24, 0x0c	; 12
    3068:	0e 94 bc 1e 	call	0x3d78	; 0x3d78 <vListInitialiseItem>

            /* Set the co-routine control block as a link back from the ListItem_t.
             * This is so we can get back to the containing CRCB from a generic item
             * in a list. */
            listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    306c:	e9 81       	ldd	r30, Y+1	; 0x01
    306e:	fa 81       	ldd	r31, Y+2	; 0x02
    3070:	89 81       	ldd	r24, Y+1	; 0x01
    3072:	9a 81       	ldd	r25, Y+2	; 0x02
    3074:	91 87       	std	Z+9, r25	; 0x09
    3076:	80 87       	std	Z+8, r24	; 0x08
            listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    3078:	e9 81       	ldd	r30, Y+1	; 0x01
    307a:	fa 81       	ldd	r31, Y+2	; 0x02
    307c:	89 81       	ldd	r24, Y+1	; 0x01
    307e:	9a 81       	ldd	r25, Y+2	; 0x02
    3080:	93 8b       	std	Z+19, r25	; 0x13
    3082:	82 8b       	std	Z+18, r24	; 0x12

            /* Event lists are always in priority order. */
            listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), ( ( TickType_t ) configMAX_CO_ROUTINE_PRIORITIES - ( TickType_t ) uxPriority ) );
    3084:	8e 81       	ldd	r24, Y+6	; 0x06
    3086:	28 2f       	mov	r18, r24
    3088:	30 e0       	ldi	r19, 0x00	; 0
    308a:	82 e0       	ldi	r24, 0x02	; 2
    308c:	90 e0       	ldi	r25, 0x00	; 0
    308e:	82 1b       	sub	r24, r18
    3090:	93 0b       	sbc	r25, r19
    3092:	e9 81       	ldd	r30, Y+1	; 0x01
    3094:	fa 81       	ldd	r31, Y+2	; 0x02
    3096:	95 87       	std	Z+13, r25	; 0x0d
    3098:	84 87       	std	Z+12, r24	; 0x0c

            /* Now the co-routine has been initialised it can be added to the ready
             * list at the correct priority. */
            prvAddCoRoutineToReadyQueue( pxCoRoutine );
    309a:	e9 81       	ldd	r30, Y+1	; 0x01
    309c:	fa 81       	ldd	r31, Y+2	; 0x02
    309e:	96 89       	ldd	r25, Z+22	; 0x16
    30a0:	80 91 8c 01 	lds	r24, 0x018C
    30a4:	89 17       	cp	r24, r25
    30a6:	28 f4       	brcc	.+10     	; 0x30b2 <xCoRoutineCreate+0xd6>
    30a8:	e9 81       	ldd	r30, Y+1	; 0x01
    30aa:	fa 81       	ldd	r31, Y+2	; 0x02
    30ac:	86 89       	ldd	r24, Z+22	; 0x16
    30ae:	80 93 8c 01 	sts	0x018C, r24
    30b2:	e9 81       	ldd	r30, Y+1	; 0x01
    30b4:	fa 81       	ldd	r31, Y+2	; 0x02
    30b6:	86 89       	ldd	r24, Z+22	; 0x16
    30b8:	28 2f       	mov	r18, r24
    30ba:	30 e0       	ldi	r19, 0x00	; 0
    30bc:	c9 01       	movw	r24, r18
    30be:	88 0f       	add	r24, r24
    30c0:	99 1f       	adc	r25, r25
    30c2:	88 0f       	add	r24, r24
    30c4:	99 1f       	adc	r25, r25
    30c6:	88 0f       	add	r24, r24
    30c8:	99 1f       	adc	r25, r25
    30ca:	82 0f       	add	r24, r18
    30cc:	93 1f       	adc	r25, r19
    30ce:	ac 01       	movw	r20, r24
    30d0:	4d 56       	subi	r20, 0x6D	; 109
    30d2:	5e 4f       	sbci	r21, 0xFE	; 254
    30d4:	89 81       	ldd	r24, Y+1	; 0x01
    30d6:	9a 81       	ldd	r25, Y+2	; 0x02
    30d8:	9c 01       	movw	r18, r24
    30da:	2e 5f       	subi	r18, 0xFE	; 254
    30dc:	3f 4f       	sbci	r19, 0xFF	; 255
    30de:	ca 01       	movw	r24, r20
    30e0:	b9 01       	movw	r22, r18
    30e2:	0e 94 cc 1e 	call	0x3d98	; 0x3d98 <vListInsertEnd>

            xReturn = pdPASS;
    30e6:	81 e0       	ldi	r24, 0x01	; 1
    30e8:	8b 83       	std	Y+3, r24	; 0x03
    30ea:	02 c0       	rjmp	.+4      	; 0x30f0 <xCoRoutineCreate+0x114>
        }
        else
        {
            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    30ec:	8f ef       	ldi	r24, 0xFF	; 255
    30ee:	8b 83       	std	Y+3, r24	; 0x03
        }

        return xReturn;
    30f0:	8b 81       	ldd	r24, Y+3	; 0x03
    }
    30f2:	27 96       	adiw	r28, 0x07	; 7
    30f4:	0f b6       	in	r0, 0x3f	; 63
    30f6:	f8 94       	cli
    30f8:	de bf       	out	0x3e, r29	; 62
    30fa:	0f be       	out	0x3f, r0	; 63
    30fc:	cd bf       	out	0x3d, r28	; 61
    30fe:	cf 91       	pop	r28
    3100:	df 91       	pop	r29
    3102:	08 95       	ret

00003104 <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

    void vCoRoutineAddToDelayedList( TickType_t xTicksToDelay,
                                     List_t * pxEventList )
    {
    3104:	df 93       	push	r29
    3106:	cf 93       	push	r28
    3108:	00 d0       	rcall	.+0      	; 0x310a <vCoRoutineAddToDelayedList+0x6>
    310a:	00 d0       	rcall	.+0      	; 0x310c <vCoRoutineAddToDelayedList+0x8>
    310c:	00 d0       	rcall	.+0      	; 0x310e <vCoRoutineAddToDelayedList+0xa>
    310e:	cd b7       	in	r28, 0x3d	; 61
    3110:	de b7       	in	r29, 0x3e	; 62
    3112:	9c 83       	std	Y+4, r25	; 0x04
    3114:	8b 83       	std	Y+3, r24	; 0x03
    3116:	7e 83       	std	Y+6, r23	; 0x06
    3118:	6d 83       	std	Y+5, r22	; 0x05
        TickType_t xTimeToWake;

        /* Calculate the time to wake - this may overflow but this is
         * not a problem. */
        xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    311a:	20 91 8d 01 	lds	r18, 0x018D
    311e:	30 91 8e 01 	lds	r19, 0x018E
    3122:	8b 81       	ldd	r24, Y+3	; 0x03
    3124:	9c 81       	ldd	r25, Y+4	; 0x04
    3126:	82 0f       	add	r24, r18
    3128:	93 1f       	adc	r25, r19
    312a:	9a 83       	std	Y+2, r25	; 0x02
    312c:	89 83       	std	Y+1, r24	; 0x01

        /* We must remove ourselves from the ready list before adding
         * ourselves to the blocked list as the same list item is used for
         * both lists. */
        ( void ) uxListRemove( ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    312e:	80 91 8a 01 	lds	r24, 0x018A
    3132:	90 91 8b 01 	lds	r25, 0x018B
    3136:	02 96       	adiw	r24, 0x02	; 2
    3138:	0e 94 7c 1f 	call	0x3ef8	; 0x3ef8 <uxListRemove>

        /* The list item will be inserted in wake time order. */
        listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    313c:	e0 91 8a 01 	lds	r30, 0x018A
    3140:	f0 91 8b 01 	lds	r31, 0x018B
    3144:	89 81       	ldd	r24, Y+1	; 0x01
    3146:	9a 81       	ldd	r25, Y+2	; 0x02
    3148:	93 83       	std	Z+3, r25	; 0x03
    314a:	82 83       	std	Z+2, r24	; 0x02

        if( xTimeToWake < xCoRoutineTickCount )
    314c:	20 91 8d 01 	lds	r18, 0x018D
    3150:	30 91 8e 01 	lds	r19, 0x018E
    3154:	89 81       	ldd	r24, Y+1	; 0x01
    3156:	9a 81       	ldd	r25, Y+2	; 0x02
    3158:	82 17       	cp	r24, r18
    315a:	93 07       	cpc	r25, r19
    315c:	70 f4       	brcc	.+28     	; 0x317a <vCoRoutineAddToDelayedList+0x76>
        {
            /* Wake time has overflowed.  Place this item in the
             * overflow list. */
            vListInsert( ( List_t * ) pxOverflowDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    315e:	80 91 88 01 	lds	r24, 0x0188
    3162:	90 91 89 01 	lds	r25, 0x0189
    3166:	20 91 8a 01 	lds	r18, 0x018A
    316a:	30 91 8b 01 	lds	r19, 0x018B
    316e:	2e 5f       	subi	r18, 0xFE	; 254
    3170:	3f 4f       	sbci	r19, 0xFF	; 255
    3172:	b9 01       	movw	r22, r18
    3174:	0e 94 10 1f 	call	0x3e20	; 0x3e20 <vListInsert>
    3178:	0d c0       	rjmp	.+26     	; 0x3194 <vCoRoutineAddToDelayedList+0x90>
        }
        else
        {
            /* The wake time has not overflowed, so we can use the
             * current block list. */
            vListInsert( ( List_t * ) pxDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    317a:	80 91 86 01 	lds	r24, 0x0186
    317e:	90 91 87 01 	lds	r25, 0x0187
    3182:	20 91 8a 01 	lds	r18, 0x018A
    3186:	30 91 8b 01 	lds	r19, 0x018B
    318a:	2e 5f       	subi	r18, 0xFE	; 254
    318c:	3f 4f       	sbci	r19, 0xFF	; 255
    318e:	b9 01       	movw	r22, r18
    3190:	0e 94 10 1f 	call	0x3e20	; 0x3e20 <vListInsert>
        }

        if( pxEventList )
    3194:	8d 81       	ldd	r24, Y+5	; 0x05
    3196:	9e 81       	ldd	r25, Y+6	; 0x06
    3198:	00 97       	sbiw	r24, 0x00	; 0
    319a:	61 f0       	breq	.+24     	; 0x31b4 <vCoRoutineAddToDelayedList+0xb0>
        {
            /* Also add the co-routine to an event list.  If this is done then the
             * function must be called with interrupts disabled. */
            vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    319c:	80 91 8a 01 	lds	r24, 0x018A
    31a0:	90 91 8b 01 	lds	r25, 0x018B
    31a4:	9c 01       	movw	r18, r24
    31a6:	24 5f       	subi	r18, 0xF4	; 244
    31a8:	3f 4f       	sbci	r19, 0xFF	; 255
    31aa:	8d 81       	ldd	r24, Y+5	; 0x05
    31ac:	9e 81       	ldd	r25, Y+6	; 0x06
    31ae:	b9 01       	movw	r22, r18
    31b0:	0e 94 10 1f 	call	0x3e20	; 0x3e20 <vListInsert>
        }
    }
    31b4:	26 96       	adiw	r28, 0x06	; 6
    31b6:	0f b6       	in	r0, 0x3f	; 63
    31b8:	f8 94       	cli
    31ba:	de bf       	out	0x3e, r29	; 62
    31bc:	0f be       	out	0x3f, r0	; 63
    31be:	cd bf       	out	0x3d, r28	; 61
    31c0:	cf 91       	pop	r28
    31c2:	df 91       	pop	r29
    31c4:	08 95       	ret

000031c6 <prvCheckPendingReadyList>:
/*-----------------------------------------------------------*/

    static void prvCheckPendingReadyList( void )
    {
    31c6:	df 93       	push	r29
    31c8:	cf 93       	push	r28
    31ca:	00 d0       	rcall	.+0      	; 0x31cc <prvCheckPendingReadyList+0x6>
    31cc:	cd b7       	in	r28, 0x3d	; 61
    31ce:	de b7       	in	r29, 0x3e	; 62
    31d0:	3a c0       	rjmp	.+116    	; 0x3246 <prvCheckPendingReadyList+0x80>
        while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
        {
            CRCB_t * pxUnblockedCRCB;

            /* The pending ready list can be accessed by an ISR. */
            portDISABLE_INTERRUPTS();
    31d2:	f8 94       	cli
            {
                pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyCoRoutineList ) );
    31d4:	e0 91 bc 01 	lds	r30, 0x01BC
    31d8:	f0 91 bd 01 	lds	r31, 0x01BD
    31dc:	86 81       	ldd	r24, Z+6	; 0x06
    31de:	97 81       	ldd	r25, Z+7	; 0x07
    31e0:	9a 83       	std	Y+2, r25	; 0x02
    31e2:	89 83       	std	Y+1, r24	; 0x01
                ( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    31e4:	89 81       	ldd	r24, Y+1	; 0x01
    31e6:	9a 81       	ldd	r25, Y+2	; 0x02
    31e8:	0c 96       	adiw	r24, 0x0c	; 12
    31ea:	0e 94 7c 1f 	call	0x3ef8	; 0x3ef8 <uxListRemove>
            }
            portENABLE_INTERRUPTS();
    31ee:	78 94       	sei

            ( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    31f0:	89 81       	ldd	r24, Y+1	; 0x01
    31f2:	9a 81       	ldd	r25, Y+2	; 0x02
    31f4:	02 96       	adiw	r24, 0x02	; 2
    31f6:	0e 94 7c 1f 	call	0x3ef8	; 0x3ef8 <uxListRemove>
            prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
    31fa:	e9 81       	ldd	r30, Y+1	; 0x01
    31fc:	fa 81       	ldd	r31, Y+2	; 0x02
    31fe:	96 89       	ldd	r25, Z+22	; 0x16
    3200:	80 91 8c 01 	lds	r24, 0x018C
    3204:	89 17       	cp	r24, r25
    3206:	28 f4       	brcc	.+10     	; 0x3212 <prvCheckPendingReadyList+0x4c>
    3208:	e9 81       	ldd	r30, Y+1	; 0x01
    320a:	fa 81       	ldd	r31, Y+2	; 0x02
    320c:	86 89       	ldd	r24, Z+22	; 0x16
    320e:	80 93 8c 01 	sts	0x018C, r24
    3212:	e9 81       	ldd	r30, Y+1	; 0x01
    3214:	fa 81       	ldd	r31, Y+2	; 0x02
    3216:	86 89       	ldd	r24, Z+22	; 0x16
    3218:	28 2f       	mov	r18, r24
    321a:	30 e0       	ldi	r19, 0x00	; 0
    321c:	c9 01       	movw	r24, r18
    321e:	88 0f       	add	r24, r24
    3220:	99 1f       	adc	r25, r25
    3222:	88 0f       	add	r24, r24
    3224:	99 1f       	adc	r25, r25
    3226:	88 0f       	add	r24, r24
    3228:	99 1f       	adc	r25, r25
    322a:	82 0f       	add	r24, r18
    322c:	93 1f       	adc	r25, r19
    322e:	ac 01       	movw	r20, r24
    3230:	4d 56       	subi	r20, 0x6D	; 109
    3232:	5e 4f       	sbci	r21, 0xFE	; 254
    3234:	89 81       	ldd	r24, Y+1	; 0x01
    3236:	9a 81       	ldd	r25, Y+2	; 0x02
    3238:	9c 01       	movw	r18, r24
    323a:	2e 5f       	subi	r18, 0xFE	; 254
    323c:	3f 4f       	sbci	r19, 0xFF	; 255
    323e:	ca 01       	movw	r24, r20
    3240:	b9 01       	movw	r22, r18
    3242:	0e 94 cc 1e 	call	0x3d98	; 0x3d98 <vListInsertEnd>
    static void prvCheckPendingReadyList( void )
    {
        /* Are there any co-routines waiting to get moved to the ready list?  These
         * are co-routines that have been readied by an ISR.  The ISR cannot access
         * the ready lists itself. */
        while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    3246:	80 91 b7 01 	lds	r24, 0x01B7
    324a:	88 23       	and	r24, r24
    324c:	09 f0       	breq	.+2      	; 0x3250 <prvCheckPendingReadyList+0x8a>
    324e:	c1 cf       	rjmp	.-126    	; 0x31d2 <prvCheckPendingReadyList+0xc>
            portENABLE_INTERRUPTS();

            ( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
            prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
        }
    }
    3250:	0f 90       	pop	r0
    3252:	0f 90       	pop	r0
    3254:	cf 91       	pop	r28
    3256:	df 91       	pop	r29
    3258:	08 95       	ret

0000325a <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

    static void prvCheckDelayedList( void )
    {
    325a:	df 93       	push	r29
    325c:	cf 93       	push	r28
    325e:	00 d0       	rcall	.+0      	; 0x3260 <prvCheckDelayedList+0x6>
    3260:	00 d0       	rcall	.+0      	; 0x3262 <prvCheckDelayedList+0x8>
    3262:	cd b7       	in	r28, 0x3d	; 61
    3264:	de b7       	in	r29, 0x3e	; 62
        CRCB_t * pxCRCB;

        xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    3266:	0e 94 eb 38 	call	0x71d6	; 0x71d6 <xTaskGetTickCount>
    326a:	20 91 8f 01 	lds	r18, 0x018F
    326e:	30 91 90 01 	lds	r19, 0x0190
    3272:	82 1b       	sub	r24, r18
    3274:	93 0b       	sbc	r25, r19
    3276:	90 93 92 01 	sts	0x0192, r25
    327a:	80 93 91 01 	sts	0x0191, r24
    327e:	85 c0       	rjmp	.+266    	; 0x338a <prvCheckDelayedList+0x130>

        while( xPassedTicks )
        {
            xCoRoutineTickCount++;
    3280:	80 91 8d 01 	lds	r24, 0x018D
    3284:	90 91 8e 01 	lds	r25, 0x018E
    3288:	01 96       	adiw	r24, 0x01	; 1
    328a:	90 93 8e 01 	sts	0x018E, r25
    328e:	80 93 8d 01 	sts	0x018D, r24
            xPassedTicks--;
    3292:	80 91 91 01 	lds	r24, 0x0191
    3296:	90 91 92 01 	lds	r25, 0x0192
    329a:	01 97       	sbiw	r24, 0x01	; 1
    329c:	90 93 92 01 	sts	0x0192, r25
    32a0:	80 93 91 01 	sts	0x0191, r24

            /* If the tick count has overflowed we need to swap the ready lists. */
            if( xCoRoutineTickCount == 0 )
    32a4:	80 91 8d 01 	lds	r24, 0x018D
    32a8:	90 91 8e 01 	lds	r25, 0x018E
    32ac:	00 97       	sbiw	r24, 0x00	; 0
    32ae:	09 f0       	breq	.+2      	; 0x32b2 <prvCheckDelayedList+0x58>
    32b0:	64 c0       	rjmp	.+200    	; 0x337a <prvCheckDelayedList+0x120>
            {
                List_t * pxTemp;

                /* Tick count has overflowed so we need to swap the delay lists.  If there are
                 * any items in pxDelayedCoRoutineList here then there is an error! */
                pxTemp = pxDelayedCoRoutineList;
    32b2:	80 91 86 01 	lds	r24, 0x0186
    32b6:	90 91 87 01 	lds	r25, 0x0187
    32ba:	9a 83       	std	Y+2, r25	; 0x02
    32bc:	89 83       	std	Y+1, r24	; 0x01
                pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    32be:	80 91 88 01 	lds	r24, 0x0188
    32c2:	90 91 89 01 	lds	r25, 0x0189
    32c6:	90 93 87 01 	sts	0x0187, r25
    32ca:	80 93 86 01 	sts	0x0186, r24
                pxOverflowDelayedCoRoutineList = pxTemp;
    32ce:	89 81       	ldd	r24, Y+1	; 0x01
    32d0:	9a 81       	ldd	r25, Y+2	; 0x02
    32d2:	90 93 89 01 	sts	0x0189, r25
    32d6:	80 93 88 01 	sts	0x0188, r24
    32da:	4f c0       	rjmp	.+158    	; 0x337a <prvCheckDelayedList+0x120>
            }

            /* See if this tick has made a timeout expire. */
            while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
            {
                pxCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    32dc:	e0 91 86 01 	lds	r30, 0x0186
    32e0:	f0 91 87 01 	lds	r31, 0x0187
    32e4:	05 80       	ldd	r0, Z+5	; 0x05
    32e6:	f6 81       	ldd	r31, Z+6	; 0x06
    32e8:	e0 2d       	mov	r30, r0
    32ea:	86 81       	ldd	r24, Z+6	; 0x06
    32ec:	97 81       	ldd	r25, Z+7	; 0x07
    32ee:	9c 83       	std	Y+4, r25	; 0x04
    32f0:	8b 83       	std	Y+3, r24	; 0x03

                if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )
    32f2:	eb 81       	ldd	r30, Y+3	; 0x03
    32f4:	fc 81       	ldd	r31, Y+4	; 0x04
    32f6:	22 81       	ldd	r18, Z+2	; 0x02
    32f8:	33 81       	ldd	r19, Z+3	; 0x03
    32fa:	80 91 8d 01 	lds	r24, 0x018D
    32fe:	90 91 8e 01 	lds	r25, 0x018E
    3302:	82 17       	cp	r24, r18
    3304:	93 07       	cpc	r25, r19
    3306:	08 f4       	brcc	.+2      	; 0x330a <prvCheckDelayedList+0xb0>
    3308:	40 c0       	rjmp	.+128    	; 0x338a <prvCheckDelayedList+0x130>
                {
                    /* Timeout not yet expired. */
                    break;
                }

                portDISABLE_INTERRUPTS();
    330a:	f8 94       	cli
                    /* The event could have occurred just before this critical
                     *  section.  If this is the case then the generic list item will
                     *  have been moved to the pending ready list and the following
                     *  line is still valid.  Also the pvContainer parameter will have
                     *  been set to NULL so the following lines are also valid. */
                    ( void ) uxListRemove( &( pxCRCB->xGenericListItem ) );
    330c:	8b 81       	ldd	r24, Y+3	; 0x03
    330e:	9c 81       	ldd	r25, Y+4	; 0x04
    3310:	02 96       	adiw	r24, 0x02	; 2
    3312:	0e 94 7c 1f 	call	0x3ef8	; 0x3ef8 <uxListRemove>

                    /* Is the co-routine waiting on an event also? */
                    if( pxCRCB->xEventListItem.pxContainer )
    3316:	eb 81       	ldd	r30, Y+3	; 0x03
    3318:	fc 81       	ldd	r31, Y+4	; 0x04
    331a:	84 89       	ldd	r24, Z+20	; 0x14
    331c:	95 89       	ldd	r25, Z+21	; 0x15
    331e:	00 97       	sbiw	r24, 0x00	; 0
    3320:	29 f0       	breq	.+10     	; 0x332c <prvCheckDelayedList+0xd2>
                    {
                        ( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
    3322:	8b 81       	ldd	r24, Y+3	; 0x03
    3324:	9c 81       	ldd	r25, Y+4	; 0x04
    3326:	0c 96       	adiw	r24, 0x0c	; 12
    3328:	0e 94 7c 1f 	call	0x3ef8	; 0x3ef8 <uxListRemove>
                    }
                }
                portENABLE_INTERRUPTS();
    332c:	78 94       	sei

                prvAddCoRoutineToReadyQueue( pxCRCB );
    332e:	eb 81       	ldd	r30, Y+3	; 0x03
    3330:	fc 81       	ldd	r31, Y+4	; 0x04
    3332:	96 89       	ldd	r25, Z+22	; 0x16
    3334:	80 91 8c 01 	lds	r24, 0x018C
    3338:	89 17       	cp	r24, r25
    333a:	28 f4       	brcc	.+10     	; 0x3346 <prvCheckDelayedList+0xec>
    333c:	eb 81       	ldd	r30, Y+3	; 0x03
    333e:	fc 81       	ldd	r31, Y+4	; 0x04
    3340:	86 89       	ldd	r24, Z+22	; 0x16
    3342:	80 93 8c 01 	sts	0x018C, r24
    3346:	eb 81       	ldd	r30, Y+3	; 0x03
    3348:	fc 81       	ldd	r31, Y+4	; 0x04
    334a:	86 89       	ldd	r24, Z+22	; 0x16
    334c:	28 2f       	mov	r18, r24
    334e:	30 e0       	ldi	r19, 0x00	; 0
    3350:	c9 01       	movw	r24, r18
    3352:	88 0f       	add	r24, r24
    3354:	99 1f       	adc	r25, r25
    3356:	88 0f       	add	r24, r24
    3358:	99 1f       	adc	r25, r25
    335a:	88 0f       	add	r24, r24
    335c:	99 1f       	adc	r25, r25
    335e:	82 0f       	add	r24, r18
    3360:	93 1f       	adc	r25, r19
    3362:	ac 01       	movw	r20, r24
    3364:	4d 56       	subi	r20, 0x6D	; 109
    3366:	5e 4f       	sbci	r21, 0xFE	; 254
    3368:	8b 81       	ldd	r24, Y+3	; 0x03
    336a:	9c 81       	ldd	r25, Y+4	; 0x04
    336c:	9c 01       	movw	r18, r24
    336e:	2e 5f       	subi	r18, 0xFE	; 254
    3370:	3f 4f       	sbci	r19, 0xFF	; 255
    3372:	ca 01       	movw	r24, r20
    3374:	b9 01       	movw	r22, r18
    3376:	0e 94 cc 1e 	call	0x3d98	; 0x3d98 <vListInsertEnd>
                pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
                pxOverflowDelayedCoRoutineList = pxTemp;
            }

            /* See if this tick has made a timeout expire. */
            while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    337a:	e0 91 86 01 	lds	r30, 0x0186
    337e:	f0 91 87 01 	lds	r31, 0x0187
    3382:	80 81       	ld	r24, Z
    3384:	88 23       	and	r24, r24
    3386:	09 f0       	breq	.+2      	; 0x338a <prvCheckDelayedList+0x130>
    3388:	a9 cf       	rjmp	.-174    	; 0x32dc <prvCheckDelayedList+0x82>
    {
        CRCB_t * pxCRCB;

        xPassedTicks = xTaskGetTickCount() - xLastTickCount;

        while( xPassedTicks )
    338a:	80 91 91 01 	lds	r24, 0x0191
    338e:	90 91 92 01 	lds	r25, 0x0192
    3392:	00 97       	sbiw	r24, 0x00	; 0
    3394:	09 f0       	breq	.+2      	; 0x3398 <prvCheckDelayedList+0x13e>
    3396:	74 cf       	rjmp	.-280    	; 0x3280 <prvCheckDelayedList+0x26>

                prvAddCoRoutineToReadyQueue( pxCRCB );
            }
        }

        xLastTickCount = xCoRoutineTickCount;
    3398:	80 91 8d 01 	lds	r24, 0x018D
    339c:	90 91 8e 01 	lds	r25, 0x018E
    33a0:	90 93 90 01 	sts	0x0190, r25
    33a4:	80 93 8f 01 	sts	0x018F, r24
    }
    33a8:	0f 90       	pop	r0
    33aa:	0f 90       	pop	r0
    33ac:	0f 90       	pop	r0
    33ae:	0f 90       	pop	r0
    33b0:	cf 91       	pop	r28
    33b2:	df 91       	pop	r29
    33b4:	08 95       	ret

000033b6 <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

    void vCoRoutineSchedule( void )
    {
    33b6:	df 93       	push	r29
    33b8:	cf 93       	push	r28
    33ba:	00 d0       	rcall	.+0      	; 0x33bc <vCoRoutineSchedule+0x6>
    33bc:	cd b7       	in	r28, 0x3d	; 61
    33be:	de b7       	in	r29, 0x3e	; 62
        /* Only run a co-routine after prvInitialiseCoRoutineLists() has been
         * called.  prvInitialiseCoRoutineLists() is called automatically when a
         * co-routine is created. */
        if( pxDelayedCoRoutineList != NULL )
    33c0:	80 91 86 01 	lds	r24, 0x0186
    33c4:	90 91 87 01 	lds	r25, 0x0187
    33c8:	00 97       	sbiw	r24, 0x00	; 0
    33ca:	09 f4       	brne	.+2      	; 0x33ce <vCoRoutineSchedule+0x18>
    33cc:	70 c0       	rjmp	.+224    	; 0x34ae <vCoRoutineSchedule+0xf8>
        {
            /* See if any co-routines readied by events need moving to the ready lists. */
            prvCheckPendingReadyList();
    33ce:	0e 94 e3 18 	call	0x31c6	; 0x31c6 <prvCheckPendingReadyList>

            /* See if any delayed co-routines have timed out. */
            prvCheckDelayedList();
    33d2:	0e 94 2d 19 	call	0x325a	; 0x325a <prvCheckDelayedList>
    33d6:	0a c0       	rjmp	.+20     	; 0x33ec <vCoRoutineSchedule+0x36>

            /* Find the highest priority queue that contains ready co-routines. */
            while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
            {
                if( uxTopCoRoutineReadyPriority == 0 )
    33d8:	80 91 8c 01 	lds	r24, 0x018C
    33dc:	88 23       	and	r24, r24
    33de:	09 f4       	brne	.+2      	; 0x33e2 <vCoRoutineSchedule+0x2c>
    33e0:	66 c0       	rjmp	.+204    	; 0x34ae <vCoRoutineSchedule+0xf8>
                {
                    /* No more co-routines to check. */
                    return;
                }

                --uxTopCoRoutineReadyPriority;
    33e2:	80 91 8c 01 	lds	r24, 0x018C
    33e6:	81 50       	subi	r24, 0x01	; 1
    33e8:	80 93 8c 01 	sts	0x018C, r24

            /* See if any delayed co-routines have timed out. */
            prvCheckDelayedList();

            /* Find the highest priority queue that contains ready co-routines. */
            while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    33ec:	80 91 8c 01 	lds	r24, 0x018C
    33f0:	28 2f       	mov	r18, r24
    33f2:	30 e0       	ldi	r19, 0x00	; 0
    33f4:	c9 01       	movw	r24, r18
    33f6:	88 0f       	add	r24, r24
    33f8:	99 1f       	adc	r25, r25
    33fa:	88 0f       	add	r24, r24
    33fc:	99 1f       	adc	r25, r25
    33fe:	88 0f       	add	r24, r24
    3400:	99 1f       	adc	r25, r25
    3402:	82 0f       	add	r24, r18
    3404:	93 1f       	adc	r25, r19
    3406:	fc 01       	movw	r30, r24
    3408:	ed 56       	subi	r30, 0x6D	; 109
    340a:	fe 4f       	sbci	r31, 0xFE	; 254
    340c:	80 81       	ld	r24, Z
    340e:	88 23       	and	r24, r24
    3410:	19 f3       	breq	.-58     	; 0x33d8 <vCoRoutineSchedule+0x22>
                --uxTopCoRoutineReadyPriority;
            }

            /* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
             * of the same priority get an equal share of the processor time. */
            listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    3412:	80 91 8c 01 	lds	r24, 0x018C
    3416:	28 2f       	mov	r18, r24
    3418:	30 e0       	ldi	r19, 0x00	; 0
    341a:	c9 01       	movw	r24, r18
    341c:	88 0f       	add	r24, r24
    341e:	99 1f       	adc	r25, r25
    3420:	88 0f       	add	r24, r24
    3422:	99 1f       	adc	r25, r25
    3424:	88 0f       	add	r24, r24
    3426:	99 1f       	adc	r25, r25
    3428:	82 0f       	add	r24, r18
    342a:	93 1f       	adc	r25, r19
    342c:	8d 56       	subi	r24, 0x6D	; 109
    342e:	9e 4f       	sbci	r25, 0xFE	; 254
    3430:	9a 83       	std	Y+2, r25	; 0x02
    3432:	89 83       	std	Y+1, r24	; 0x01
    3434:	e9 81       	ldd	r30, Y+1	; 0x01
    3436:	fa 81       	ldd	r31, Y+2	; 0x02
    3438:	01 80       	ldd	r0, Z+1	; 0x01
    343a:	f2 81       	ldd	r31, Z+2	; 0x02
    343c:	e0 2d       	mov	r30, r0
    343e:	82 81       	ldd	r24, Z+2	; 0x02
    3440:	93 81       	ldd	r25, Z+3	; 0x03
    3442:	e9 81       	ldd	r30, Y+1	; 0x01
    3444:	fa 81       	ldd	r31, Y+2	; 0x02
    3446:	92 83       	std	Z+2, r25	; 0x02
    3448:	81 83       	std	Z+1, r24	; 0x01
    344a:	e9 81       	ldd	r30, Y+1	; 0x01
    344c:	fa 81       	ldd	r31, Y+2	; 0x02
    344e:	21 81       	ldd	r18, Z+1	; 0x01
    3450:	32 81       	ldd	r19, Z+2	; 0x02
    3452:	89 81       	ldd	r24, Y+1	; 0x01
    3454:	9a 81       	ldd	r25, Y+2	; 0x02
    3456:	03 96       	adiw	r24, 0x03	; 3
    3458:	28 17       	cp	r18, r24
    345a:	39 07       	cpc	r19, r25
    345c:	59 f4       	brne	.+22     	; 0x3474 <vCoRoutineSchedule+0xbe>
    345e:	e9 81       	ldd	r30, Y+1	; 0x01
    3460:	fa 81       	ldd	r31, Y+2	; 0x02
    3462:	01 80       	ldd	r0, Z+1	; 0x01
    3464:	f2 81       	ldd	r31, Z+2	; 0x02
    3466:	e0 2d       	mov	r30, r0
    3468:	82 81       	ldd	r24, Z+2	; 0x02
    346a:	93 81       	ldd	r25, Z+3	; 0x03
    346c:	e9 81       	ldd	r30, Y+1	; 0x01
    346e:	fa 81       	ldd	r31, Y+2	; 0x02
    3470:	92 83       	std	Z+2, r25	; 0x02
    3472:	81 83       	std	Z+1, r24	; 0x01
    3474:	e9 81       	ldd	r30, Y+1	; 0x01
    3476:	fa 81       	ldd	r31, Y+2	; 0x02
    3478:	01 80       	ldd	r0, Z+1	; 0x01
    347a:	f2 81       	ldd	r31, Z+2	; 0x02
    347c:	e0 2d       	mov	r30, r0
    347e:	86 81       	ldd	r24, Z+6	; 0x06
    3480:	97 81       	ldd	r25, Z+7	; 0x07
    3482:	90 93 8b 01 	sts	0x018B, r25
    3486:	80 93 8a 01 	sts	0x018A, r24

            /* Call the co-routine. */
            ( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    348a:	e0 91 8a 01 	lds	r30, 0x018A
    348e:	f0 91 8b 01 	lds	r31, 0x018B
    3492:	40 81       	ld	r20, Z
    3494:	51 81       	ldd	r21, Z+1	; 0x01
    3496:	80 91 8a 01 	lds	r24, 0x018A
    349a:	90 91 8b 01 	lds	r25, 0x018B
    349e:	e0 91 8a 01 	lds	r30, 0x018A
    34a2:	f0 91 8b 01 	lds	r31, 0x018B
    34a6:	27 89       	ldd	r18, Z+23	; 0x17
    34a8:	62 2f       	mov	r22, r18
    34aa:	fa 01       	movw	r30, r20
    34ac:	09 95       	icall
        }
    }
    34ae:	0f 90       	pop	r0
    34b0:	0f 90       	pop	r0
    34b2:	cf 91       	pop	r28
    34b4:	df 91       	pop	r29
    34b6:	08 95       	ret

000034b8 <prvInitialiseCoRoutineLists>:
/*-----------------------------------------------------------*/

    static void prvInitialiseCoRoutineLists( void )
    {
    34b8:	df 93       	push	r29
    34ba:	cf 93       	push	r28
    34bc:	0f 92       	push	r0
    34be:	cd b7       	in	r28, 0x3d	; 61
    34c0:	de b7       	in	r29, 0x3e	; 62
        UBaseType_t uxPriority;

        for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    34c2:	19 82       	std	Y+1, r1	; 0x01
    34c4:	13 c0       	rjmp	.+38     	; 0x34ec <prvInitialiseCoRoutineLists+0x34>
        {
            vListInitialise( ( List_t * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    34c6:	89 81       	ldd	r24, Y+1	; 0x01
    34c8:	28 2f       	mov	r18, r24
    34ca:	30 e0       	ldi	r19, 0x00	; 0
    34cc:	c9 01       	movw	r24, r18
    34ce:	88 0f       	add	r24, r24
    34d0:	99 1f       	adc	r25, r25
    34d2:	88 0f       	add	r24, r24
    34d4:	99 1f       	adc	r25, r25
    34d6:	88 0f       	add	r24, r24
    34d8:	99 1f       	adc	r25, r25
    34da:	82 0f       	add	r24, r18
    34dc:	93 1f       	adc	r25, r19
    34de:	8d 56       	subi	r24, 0x6D	; 109
    34e0:	9e 4f       	sbci	r25, 0xFE	; 254
    34e2:	0e 94 92 1e 	call	0x3d24	; 0x3d24 <vListInitialise>

    static void prvInitialiseCoRoutineLists( void )
    {
        UBaseType_t uxPriority;

        for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    34e6:	89 81       	ldd	r24, Y+1	; 0x01
    34e8:	8f 5f       	subi	r24, 0xFF	; 255
    34ea:	89 83       	std	Y+1, r24	; 0x01
    34ec:	89 81       	ldd	r24, Y+1	; 0x01
    34ee:	82 30       	cpi	r24, 0x02	; 2
    34f0:	50 f3       	brcs	.-44     	; 0x34c6 <prvInitialiseCoRoutineLists+0xe>
        {
            vListInitialise( ( List_t * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
        }

        vListInitialise( ( List_t * ) &xDelayedCoRoutineList1 );
    34f2:	85 ea       	ldi	r24, 0xA5	; 165
    34f4:	91 e0       	ldi	r25, 0x01	; 1
    34f6:	0e 94 92 1e 	call	0x3d24	; 0x3d24 <vListInitialise>
        vListInitialise( ( List_t * ) &xDelayedCoRoutineList2 );
    34fa:	8e ea       	ldi	r24, 0xAE	; 174
    34fc:	91 e0       	ldi	r25, 0x01	; 1
    34fe:	0e 94 92 1e 	call	0x3d24	; 0x3d24 <vListInitialise>
        vListInitialise( ( List_t * ) &xPendingReadyCoRoutineList );
    3502:	87 eb       	ldi	r24, 0xB7	; 183
    3504:	91 e0       	ldi	r25, 0x01	; 1
    3506:	0e 94 92 1e 	call	0x3d24	; 0x3d24 <vListInitialise>

        /* Start with pxDelayedCoRoutineList using list1 and the
         * pxOverflowDelayedCoRoutineList using list2. */
        pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    350a:	85 ea       	ldi	r24, 0xA5	; 165
    350c:	91 e0       	ldi	r25, 0x01	; 1
    350e:	90 93 87 01 	sts	0x0187, r25
    3512:	80 93 86 01 	sts	0x0186, r24
        pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    3516:	8e ea       	ldi	r24, 0xAE	; 174
    3518:	91 e0       	ldi	r25, 0x01	; 1
    351a:	90 93 89 01 	sts	0x0189, r25
    351e:	80 93 88 01 	sts	0x0188, r24
    }
    3522:	0f 90       	pop	r0
    3524:	cf 91       	pop	r28
    3526:	df 91       	pop	r29
    3528:	08 95       	ret

0000352a <xCoRoutineRemoveFromEventList>:
/*-----------------------------------------------------------*/

    BaseType_t xCoRoutineRemoveFromEventList( const List_t * pxEventList )
    {
    352a:	df 93       	push	r29
    352c:	cf 93       	push	r28
    352e:	00 d0       	rcall	.+0      	; 0x3530 <xCoRoutineRemoveFromEventList+0x6>
    3530:	00 d0       	rcall	.+0      	; 0x3532 <xCoRoutineRemoveFromEventList+0x8>
    3532:	0f 92       	push	r0
    3534:	cd b7       	in	r28, 0x3d	; 61
    3536:	de b7       	in	r29, 0x3e	; 62
    3538:	9d 83       	std	Y+5, r25	; 0x05
    353a:	8c 83       	std	Y+4, r24	; 0x04
        BaseType_t xReturn;

        /* This function is called from within an interrupt.  It can only access
         * event lists and the pending ready list.  This function assumes that a
         * check has already been made to ensure pxEventList is not empty. */
        pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    353c:	ec 81       	ldd	r30, Y+4	; 0x04
    353e:	fd 81       	ldd	r31, Y+5	; 0x05
    3540:	05 80       	ldd	r0, Z+5	; 0x05
    3542:	f6 81       	ldd	r31, Z+6	; 0x06
    3544:	e0 2d       	mov	r30, r0
    3546:	86 81       	ldd	r24, Z+6	; 0x06
    3548:	97 81       	ldd	r25, Z+7	; 0x07
    354a:	9b 83       	std	Y+3, r25	; 0x03
    354c:	8a 83       	std	Y+2, r24	; 0x02
        ( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    354e:	8a 81       	ldd	r24, Y+2	; 0x02
    3550:	9b 81       	ldd	r25, Y+3	; 0x03
    3552:	0c 96       	adiw	r24, 0x0c	; 12
    3554:	0e 94 7c 1f 	call	0x3ef8	; 0x3ef8 <uxListRemove>
        vListInsertEnd( ( List_t * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    3558:	8a 81       	ldd	r24, Y+2	; 0x02
    355a:	9b 81       	ldd	r25, Y+3	; 0x03
    355c:	9c 01       	movw	r18, r24
    355e:	24 5f       	subi	r18, 0xF4	; 244
    3560:	3f 4f       	sbci	r19, 0xFF	; 255
    3562:	87 eb       	ldi	r24, 0xB7	; 183
    3564:	91 e0       	ldi	r25, 0x01	; 1
    3566:	b9 01       	movw	r22, r18
    3568:	0e 94 cc 1e 	call	0x3d98	; 0x3d98 <vListInsertEnd>

        if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    356c:	ea 81       	ldd	r30, Y+2	; 0x02
    356e:	fb 81       	ldd	r31, Y+3	; 0x03
    3570:	96 89       	ldd	r25, Z+22	; 0x16
    3572:	e0 91 8a 01 	lds	r30, 0x018A
    3576:	f0 91 8b 01 	lds	r31, 0x018B
    357a:	86 89       	ldd	r24, Z+22	; 0x16
    357c:	98 17       	cp	r25, r24
    357e:	18 f0       	brcs	.+6      	; 0x3586 <xCoRoutineRemoveFromEventList+0x5c>
        {
            xReturn = pdTRUE;
    3580:	81 e0       	ldi	r24, 0x01	; 1
    3582:	89 83       	std	Y+1, r24	; 0x01
    3584:	01 c0       	rjmp	.+2      	; 0x3588 <xCoRoutineRemoveFromEventList+0x5e>
        }
        else
        {
            xReturn = pdFALSE;
    3586:	19 82       	std	Y+1, r1	; 0x01
        }

        return xReturn;
    3588:	89 81       	ldd	r24, Y+1	; 0x01
    }
    358a:	0f 90       	pop	r0
    358c:	0f 90       	pop	r0
    358e:	0f 90       	pop	r0
    3590:	0f 90       	pop	r0
    3592:	0f 90       	pop	r0
    3594:	cf 91       	pop	r28
    3596:	df 91       	pop	r29
    3598:	08 95       	ret

0000359a <xEventGroupCreate>:
/*-----------------------------------------------------------*/

#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

    EventGroupHandle_t xEventGroupCreate( void )
    {
    359a:	df 93       	push	r29
    359c:	cf 93       	push	r28
    359e:	00 d0       	rcall	.+0      	; 0x35a0 <xEventGroupCreate+0x6>
    35a0:	cd b7       	in	r28, 0x3d	; 61
    35a2:	de b7       	in	r29, 0x3e	; 62
         * TickType_t alignment requirements the cast is safe.  In other cases,
         * where the natural word size of the architecture is less than
         * sizeof( TickType_t ), the TickType_t variables will be accessed in two
         * or more reads operations, and the alignment requirements is only that
         * of each individual read. */
        pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) ); /*lint !e9087 !e9079 see comment above. */
    35a4:	8b e0       	ldi	r24, 0x0B	; 11
    35a6:	90 e0       	ldi	r25, 0x00	; 0
    35a8:	0e 94 12 1e 	call	0x3c24	; 0x3c24 <pvPortMalloc>
    35ac:	9a 83       	std	Y+2, r25	; 0x02
    35ae:	89 83       	std	Y+1, r24	; 0x01

        if( pxEventBits != NULL )
    35b0:	89 81       	ldd	r24, Y+1	; 0x01
    35b2:	9a 81       	ldd	r25, Y+2	; 0x02
    35b4:	00 97       	sbiw	r24, 0x00	; 0
    35b6:	49 f0       	breq	.+18     	; 0x35ca <xEventGroupCreate+0x30>
        {
            pxEventBits->uxEventBits = 0;
    35b8:	e9 81       	ldd	r30, Y+1	; 0x01
    35ba:	fa 81       	ldd	r31, Y+2	; 0x02
    35bc:	11 82       	std	Z+1, r1	; 0x01
    35be:	10 82       	st	Z, r1
            vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
    35c0:	89 81       	ldd	r24, Y+1	; 0x01
    35c2:	9a 81       	ldd	r25, Y+2	; 0x02
    35c4:	02 96       	adiw	r24, 0x02	; 2
    35c6:	0e 94 92 1e 	call	0x3d24	; 0x3d24 <vListInitialise>
        else
        {
            traceEVENT_GROUP_CREATE_FAILED(); /*lint !e9063 Else branch only exists to allow tracing and does not generate code if trace macros are not defined. */
        }

        return pxEventBits;
    35ca:	89 81       	ldd	r24, Y+1	; 0x01
    35cc:	9a 81       	ldd	r25, Y+2	; 0x02
    }
    35ce:	0f 90       	pop	r0
    35d0:	0f 90       	pop	r0
    35d2:	cf 91       	pop	r28
    35d4:	df 91       	pop	r29
    35d6:	08 95       	ret

000035d8 <xEventGroupSync>:

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup,
                             const EventBits_t uxBitsToSet,
                             const EventBits_t uxBitsToWaitFor,
                             TickType_t xTicksToWait )
{
    35d8:	df 93       	push	r29
    35da:	cf 93       	push	r28
    35dc:	cd b7       	in	r28, 0x3d	; 61
    35de:	de b7       	in	r29, 0x3e	; 62
    35e0:	60 97       	sbiw	r28, 0x10	; 16
    35e2:	0f b6       	in	r0, 0x3f	; 63
    35e4:	f8 94       	cli
    35e6:	de bf       	out	0x3e, r29	; 62
    35e8:	0f be       	out	0x3f, r0	; 63
    35ea:	cd bf       	out	0x3d, r28	; 61
    35ec:	9a 87       	std	Y+10, r25	; 0x0a
    35ee:	89 87       	std	Y+9, r24	; 0x09
    35f0:	7c 87       	std	Y+12, r23	; 0x0c
    35f2:	6b 87       	std	Y+11, r22	; 0x0b
    35f4:	5e 87       	std	Y+14, r21	; 0x0e
    35f6:	4d 87       	std	Y+13, r20	; 0x0d
    35f8:	38 8b       	std	Y+16, r19	; 0x10
    35fa:	2f 87       	std	Y+15, r18	; 0x0f
    EventBits_t uxOriginalBitValue, uxReturn;
    EventGroup_t * pxEventBits = xEventGroup;
    35fc:	89 85       	ldd	r24, Y+9	; 0x09
    35fe:	9a 85       	ldd	r25, Y+10	; 0x0a
    3600:	9c 83       	std	Y+4, r25	; 0x04
    3602:	8b 83       	std	Y+3, r24	; 0x03
    BaseType_t xAlreadyYielded;
    BaseType_t xTimeoutOccurred = pdFALSE;
    3604:	19 82       	std	Y+1, r1	; 0x01
        {
            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
        }
    #endif

    vTaskSuspendAll();
    3606:	0e 94 8f 37 	call	0x6f1e	; 0x6f1e <vTaskSuspendAll>
    {
        uxOriginalBitValue = pxEventBits->uxEventBits;
    360a:	eb 81       	ldd	r30, Y+3	; 0x03
    360c:	fc 81       	ldd	r31, Y+4	; 0x04
    360e:	80 81       	ld	r24, Z
    3610:	91 81       	ldd	r25, Z+1	; 0x01
    3612:	98 87       	std	Y+8, r25	; 0x08
    3614:	8f 83       	std	Y+7, r24	; 0x07

        ( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
    3616:	89 85       	ldd	r24, Y+9	; 0x09
    3618:	9a 85       	ldd	r25, Y+10	; 0x0a
    361a:	2b 85       	ldd	r18, Y+11	; 0x0b
    361c:	3c 85       	ldd	r19, Y+12	; 0x0c
    361e:	b9 01       	movw	r22, r18
    3620:	0e 94 c3 1c 	call	0x3986	; 0x3986 <xEventGroupSetBits>

        if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
    3624:	2f 81       	ldd	r18, Y+7	; 0x07
    3626:	38 85       	ldd	r19, Y+8	; 0x08
    3628:	8b 85       	ldd	r24, Y+11	; 0x0b
    362a:	9c 85       	ldd	r25, Y+12	; 0x0c
    362c:	28 2b       	or	r18, r24
    362e:	39 2b       	or	r19, r25
    3630:	8d 85       	ldd	r24, Y+13	; 0x0d
    3632:	9e 85       	ldd	r25, Y+14	; 0x0e
    3634:	28 23       	and	r18, r24
    3636:	39 23       	and	r19, r25
    3638:	8d 85       	ldd	r24, Y+13	; 0x0d
    363a:	9e 85       	ldd	r25, Y+14	; 0x0e
    363c:	28 17       	cp	r18, r24
    363e:	39 07       	cpc	r19, r25
    3640:	c9 f4       	brne	.+50     	; 0x3674 <xEventGroupSync+0x9c>
        {
            /* All the rendezvous bits are now set - no need to block. */
            uxReturn = ( uxOriginalBitValue | uxBitsToSet );
    3642:	2f 81       	ldd	r18, Y+7	; 0x07
    3644:	38 85       	ldd	r19, Y+8	; 0x08
    3646:	8b 85       	ldd	r24, Y+11	; 0x0b
    3648:	9c 85       	ldd	r25, Y+12	; 0x0c
    364a:	82 2b       	or	r24, r18
    364c:	93 2b       	or	r25, r19
    364e:	9e 83       	std	Y+6, r25	; 0x06
    3650:	8d 83       	std	Y+5, r24	; 0x05

            /* Rendezvous always clear the bits.  They will have been cleared
             * already unless this is the only task in the rendezvous. */
            pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    3652:	eb 81       	ldd	r30, Y+3	; 0x03
    3654:	fc 81       	ldd	r31, Y+4	; 0x04
    3656:	20 81       	ld	r18, Z
    3658:	31 81       	ldd	r19, Z+1	; 0x01
    365a:	8d 85       	ldd	r24, Y+13	; 0x0d
    365c:	9e 85       	ldd	r25, Y+14	; 0x0e
    365e:	80 95       	com	r24
    3660:	90 95       	com	r25
    3662:	82 23       	and	r24, r18
    3664:	93 23       	and	r25, r19
    3666:	eb 81       	ldd	r30, Y+3	; 0x03
    3668:	fc 81       	ldd	r31, Y+4	; 0x04
    366a:	91 83       	std	Z+1, r25	; 0x01
    366c:	80 83       	st	Z, r24

            xTicksToWait = 0;
    366e:	18 8a       	std	Y+16, r1	; 0x10
    3670:	1f 86       	std	Y+15, r1	; 0x0f
    3672:	1e c0       	rjmp	.+60     	; 0x36b0 <xEventGroupSync+0xd8>
        }
        else
        {
            if( xTicksToWait != ( TickType_t ) 0 )
    3674:	8f 85       	ldd	r24, Y+15	; 0x0f
    3676:	98 89       	ldd	r25, Y+16	; 0x10
    3678:	00 97       	sbiw	r24, 0x00	; 0
    367a:	91 f0       	breq	.+36     	; 0x36a0 <xEventGroupSync+0xc8>
                traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

                /* Store the bits that the calling task is waiting for in the
                 * task's event list item so the kernel knows when a match is
                 * found.  Then enter the blocked state. */
                vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
    367c:	8b 81       	ldd	r24, Y+3	; 0x03
    367e:	9c 81       	ldd	r25, Y+4	; 0x04
    3680:	bc 01       	movw	r22, r24
    3682:	6e 5f       	subi	r22, 0xFE	; 254
    3684:	7f 4f       	sbci	r23, 0xFF	; 255
    3686:	8d 85       	ldd	r24, Y+13	; 0x0d
    3688:	9e 85       	ldd	r25, Y+14	; 0x0e
    368a:	9c 01       	movw	r18, r24
    368c:	35 60       	ori	r19, 0x05	; 5
    368e:	4f 85       	ldd	r20, Y+15	; 0x0f
    3690:	58 89       	ldd	r21, Y+16	; 0x10
    3692:	cb 01       	movw	r24, r22
    3694:	b9 01       	movw	r22, r18
    3696:	0e 94 8e 3b 	call	0x771c	; 0x771c <vTaskPlaceOnUnorderedEventList>

                /* This assignment is obsolete as uxReturn will get set after
                 * the task unblocks, but some compilers mistakenly generate a
                 * warning about uxReturn being returned without being set if the
                 * assignment is omitted. */
                uxReturn = 0;
    369a:	1e 82       	std	Y+6, r1	; 0x06
    369c:	1d 82       	std	Y+5, r1	; 0x05
    369e:	08 c0       	rjmp	.+16     	; 0x36b0 <xEventGroupSync+0xd8>
            }
            else
            {
                /* The rendezvous bits were not set, but no block time was
                 * specified - just return the current event bit value. */
                uxReturn = pxEventBits->uxEventBits;
    36a0:	eb 81       	ldd	r30, Y+3	; 0x03
    36a2:	fc 81       	ldd	r31, Y+4	; 0x04
    36a4:	80 81       	ld	r24, Z
    36a6:	91 81       	ldd	r25, Z+1	; 0x01
    36a8:	9e 83       	std	Y+6, r25	; 0x06
    36aa:	8d 83       	std	Y+5, r24	; 0x05
                xTimeoutOccurred = pdTRUE;
    36ac:	81 e0       	ldi	r24, 0x01	; 1
    36ae:	89 83       	std	Y+1, r24	; 0x01
            }
        }
    }
    xAlreadyYielded = xTaskResumeAll();
    36b0:	0e 94 9b 37 	call	0x6f36	; 0x6f36 <xTaskResumeAll>
    36b4:	8a 83       	std	Y+2, r24	; 0x02

    if( xTicksToWait != ( TickType_t ) 0 )
    36b6:	8f 85       	ldd	r24, Y+15	; 0x0f
    36b8:	98 89       	ldd	r25, Y+16	; 0x10
    36ba:	00 97       	sbiw	r24, 0x00	; 0
    36bc:	09 f4       	brne	.+2      	; 0x36c0 <xEventGroupSync+0xe8>
    36be:	3a c0       	rjmp	.+116    	; 0x3734 <xEventGroupSync+0x15c>
    {
        if( xAlreadyYielded == pdFALSE )
    36c0:	8a 81       	ldd	r24, Y+2	; 0x02
    36c2:	88 23       	and	r24, r24
    36c4:	11 f4       	brne	.+4      	; 0x36ca <xEventGroupSync+0xf2>
        {
            portYIELD_WITHIN_API();
    36c6:	0e 94 87 21 	call	0x430e	; 0x430e <vPortYield>

        /* The task blocked to wait for its required bits to be set - at this
         * point either the required bits were set or the block time expired.  If
         * the required bits were set they will have been stored in the task's
         * event list item, and they should now be retrieved then cleared. */
        uxReturn = uxTaskResetEventItemValue();
    36ca:	0e 94 28 42 	call	0x8450	; 0x8450 <uxTaskResetEventItemValue>
    36ce:	9e 83       	std	Y+6, r25	; 0x06
    36d0:	8d 83       	std	Y+5, r24	; 0x05

        if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    36d2:	8d 81       	ldd	r24, Y+5	; 0x05
    36d4:	9e 81       	ldd	r25, Y+6	; 0x06
    36d6:	80 70       	andi	r24, 0x00	; 0
    36d8:	92 70       	andi	r25, 0x02	; 2
    36da:	00 97       	sbiw	r24, 0x00	; 0
    36dc:	31 f5       	brne	.+76     	; 0x372a <xEventGroupSync+0x152>
        {
            /* The task timed out, just return the current event bit value. */
            taskENTER_CRITICAL();
    36de:	0f b6       	in	r0, 0x3f	; 63
    36e0:	f8 94       	cli
    36e2:	0f 92       	push	r0
            {
                uxReturn = pxEventBits->uxEventBits;
    36e4:	eb 81       	ldd	r30, Y+3	; 0x03
    36e6:	fc 81       	ldd	r31, Y+4	; 0x04
    36e8:	80 81       	ld	r24, Z
    36ea:	91 81       	ldd	r25, Z+1	; 0x01
    36ec:	9e 83       	std	Y+6, r25	; 0x06
    36ee:	8d 83       	std	Y+5, r24	; 0x05

                /* Although the task got here because it timed out before the
                 * bits it was waiting for were set, it is possible that since it
                 * unblocked another task has set the bits.  If this is the case
                 * then it needs to clear the bits before exiting. */
                if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
    36f0:	2d 81       	ldd	r18, Y+5	; 0x05
    36f2:	3e 81       	ldd	r19, Y+6	; 0x06
    36f4:	8d 85       	ldd	r24, Y+13	; 0x0d
    36f6:	9e 85       	ldd	r25, Y+14	; 0x0e
    36f8:	28 23       	and	r18, r24
    36fa:	39 23       	and	r19, r25
    36fc:	8d 85       	ldd	r24, Y+13	; 0x0d
    36fe:	9e 85       	ldd	r25, Y+14	; 0x0e
    3700:	28 17       	cp	r18, r24
    3702:	39 07       	cpc	r19, r25
    3704:	71 f4       	brne	.+28     	; 0x3722 <xEventGroupSync+0x14a>
                {
                    pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    3706:	eb 81       	ldd	r30, Y+3	; 0x03
    3708:	fc 81       	ldd	r31, Y+4	; 0x04
    370a:	20 81       	ld	r18, Z
    370c:	31 81       	ldd	r19, Z+1	; 0x01
    370e:	8d 85       	ldd	r24, Y+13	; 0x0d
    3710:	9e 85       	ldd	r25, Y+14	; 0x0e
    3712:	80 95       	com	r24
    3714:	90 95       	com	r25
    3716:	82 23       	and	r24, r18
    3718:	93 23       	and	r25, r19
    371a:	eb 81       	ldd	r30, Y+3	; 0x03
    371c:	fc 81       	ldd	r31, Y+4	; 0x04
    371e:	91 83       	std	Z+1, r25	; 0x01
    3720:	80 83       	st	Z, r24
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            taskEXIT_CRITICAL();
    3722:	0f 90       	pop	r0
    3724:	0f be       	out	0x3f, r0	; 63

            xTimeoutOccurred = pdTRUE;
    3726:	81 e0       	ldi	r24, 0x01	; 1
    3728:	89 83       	std	Y+1, r24	; 0x01
            /* The task unblocked because the bits were set. */
        }

        /* Control bits might be set as the task had blocked should not be
         * returned. */
        uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    372a:	8d 81       	ldd	r24, Y+5	; 0x05
    372c:	9e 81       	ldd	r25, Y+6	; 0x06
    372e:	90 70       	andi	r25, 0x00	; 0
    3730:	9e 83       	std	Y+6, r25	; 0x06
    3732:	8d 83       	std	Y+5, r24	; 0x05
    traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

    /* Prevent compiler warnings when trace macros are not used. */
    ( void ) xTimeoutOccurred;

    return uxReturn;
    3734:	8d 81       	ldd	r24, Y+5	; 0x05
    3736:	9e 81       	ldd	r25, Y+6	; 0x06
}
    3738:	60 96       	adiw	r28, 0x10	; 16
    373a:	0f b6       	in	r0, 0x3f	; 63
    373c:	f8 94       	cli
    373e:	de bf       	out	0x3e, r29	; 62
    3740:	0f be       	out	0x3f, r0	; 63
    3742:	cd bf       	out	0x3d, r28	; 61
    3744:	cf 91       	pop	r28
    3746:	df 91       	pop	r29
    3748:	08 95       	ret

0000374a <xEventGroupWaitBits>:
EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup,
                                 const EventBits_t uxBitsToWaitFor,
                                 const BaseType_t xClearOnExit,
                                 const BaseType_t xWaitForAllBits,
                                 TickType_t xTicksToWait )
{
    374a:	0f 93       	push	r16
    374c:	1f 93       	push	r17
    374e:	df 93       	push	r29
    3750:	cf 93       	push	r28
    3752:	cd b7       	in	r28, 0x3d	; 61
    3754:	de b7       	in	r29, 0x3e	; 62
    3756:	63 97       	sbiw	r28, 0x13	; 19
    3758:	0f b6       	in	r0, 0x3f	; 63
    375a:	f8 94       	cli
    375c:	de bf       	out	0x3e, r29	; 62
    375e:	0f be       	out	0x3f, r0	; 63
    3760:	cd bf       	out	0x3d, r28	; 61
    3762:	9d 87       	std	Y+13, r25	; 0x0d
    3764:	8c 87       	std	Y+12, r24	; 0x0c
    3766:	7f 87       	std	Y+15, r23	; 0x0f
    3768:	6e 87       	std	Y+14, r22	; 0x0e
    376a:	48 8b       	std	Y+16, r20	; 0x10
    376c:	29 8b       	std	Y+17, r18	; 0x11
    376e:	1b 8b       	std	Y+19, r17	; 0x13
    3770:	0a 8b       	std	Y+18, r16	; 0x12
    EventGroup_t * pxEventBits = xEventGroup;
    3772:	8c 85       	ldd	r24, Y+12	; 0x0c
    3774:	9d 85       	ldd	r25, Y+13	; 0x0d
    3776:	9b 87       	std	Y+11, r25	; 0x0b
    3778:	8a 87       	std	Y+10, r24	; 0x0a
    EventBits_t uxReturn, uxControlBits = 0;
    377a:	1f 82       	std	Y+7, r1	; 0x07
    377c:	1e 82       	std	Y+6, r1	; 0x06
    BaseType_t xWaitConditionMet, xAlreadyYielded;
    BaseType_t xTimeoutOccurred = pdFALSE;
    377e:	1b 82       	std	Y+3, r1	; 0x03
        {
            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
        }
    #endif

    vTaskSuspendAll();
    3780:	0e 94 8f 37 	call	0x6f1e	; 0x6f1e <vTaskSuspendAll>
    {
        const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
    3784:	ea 85       	ldd	r30, Y+10	; 0x0a
    3786:	fb 85       	ldd	r31, Y+11	; 0x0b
    3788:	80 81       	ld	r24, Z
    378a:	91 81       	ldd	r25, Z+1	; 0x01
    378c:	9a 83       	std	Y+2, r25	; 0x02
    378e:	89 83       	std	Y+1, r24	; 0x01

        /* Check to see if the wait condition is already met or not. */
        xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
    3790:	89 81       	ldd	r24, Y+1	; 0x01
    3792:	9a 81       	ldd	r25, Y+2	; 0x02
    3794:	2e 85       	ldd	r18, Y+14	; 0x0e
    3796:	3f 85       	ldd	r19, Y+15	; 0x0f
    3798:	b9 01       	movw	r22, r18
    379a:	49 89       	ldd	r20, Y+17	; 0x11
    379c:	0e 94 e0 1d 	call	0x3bc0	; 0x3bc0 <prvTestWaitCondition>
    37a0:	8d 83       	std	Y+5, r24	; 0x05

        if( xWaitConditionMet != pdFALSE )
    37a2:	8d 81       	ldd	r24, Y+5	; 0x05
    37a4:	88 23       	and	r24, r24
    37a6:	c1 f0       	breq	.+48     	; 0x37d8 <xEventGroupWaitBits+0x8e>
        {
            /* The wait condition has already been met so there is no need to
             * block. */
            uxReturn = uxCurrentEventBits;
    37a8:	89 81       	ldd	r24, Y+1	; 0x01
    37aa:	9a 81       	ldd	r25, Y+2	; 0x02
    37ac:	99 87       	std	Y+9, r25	; 0x09
    37ae:	88 87       	std	Y+8, r24	; 0x08
            xTicksToWait = ( TickType_t ) 0;
    37b0:	1b 8a       	std	Y+19, r1	; 0x13
    37b2:	1a 8a       	std	Y+18, r1	; 0x12

            /* Clear the wait bits if requested to do so. */
            if( xClearOnExit != pdFALSE )
    37b4:	88 89       	ldd	r24, Y+16	; 0x10
    37b6:	88 23       	and	r24, r24
    37b8:	e9 f1       	breq	.+122    	; 0x3834 <xEventGroupWaitBits+0xea>
            {
                pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    37ba:	ea 85       	ldd	r30, Y+10	; 0x0a
    37bc:	fb 85       	ldd	r31, Y+11	; 0x0b
    37be:	20 81       	ld	r18, Z
    37c0:	31 81       	ldd	r19, Z+1	; 0x01
    37c2:	8e 85       	ldd	r24, Y+14	; 0x0e
    37c4:	9f 85       	ldd	r25, Y+15	; 0x0f
    37c6:	80 95       	com	r24
    37c8:	90 95       	com	r25
    37ca:	82 23       	and	r24, r18
    37cc:	93 23       	and	r25, r19
    37ce:	ea 85       	ldd	r30, Y+10	; 0x0a
    37d0:	fb 85       	ldd	r31, Y+11	; 0x0b
    37d2:	91 83       	std	Z+1, r25	; 0x01
    37d4:	80 83       	st	Z, r24
    37d6:	2e c0       	rjmp	.+92     	; 0x3834 <xEventGroupWaitBits+0xea>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        else if( xTicksToWait == ( TickType_t ) 0 )
    37d8:	8a 89       	ldd	r24, Y+18	; 0x12
    37da:	9b 89       	ldd	r25, Y+19	; 0x13
    37dc:	00 97       	sbiw	r24, 0x00	; 0
    37de:	39 f4       	brne	.+14     	; 0x37ee <xEventGroupWaitBits+0xa4>
        {
            /* The wait condition has not been met, but no block time was
             * specified, so just return the current value. */
            uxReturn = uxCurrentEventBits;
    37e0:	89 81       	ldd	r24, Y+1	; 0x01
    37e2:	9a 81       	ldd	r25, Y+2	; 0x02
    37e4:	99 87       	std	Y+9, r25	; 0x09
    37e6:	88 87       	std	Y+8, r24	; 0x08
            xTimeoutOccurred = pdTRUE;
    37e8:	81 e0       	ldi	r24, 0x01	; 1
    37ea:	8b 83       	std	Y+3, r24	; 0x03
    37ec:	23 c0       	rjmp	.+70     	; 0x3834 <xEventGroupWaitBits+0xea>
        {
            /* The task is going to block to wait for its required bits to be
             * set.  uxControlBits are used to remember the specified behaviour of
             * this call to xEventGroupWaitBits() - for use when the event bits
             * unblock the task. */
            if( xClearOnExit != pdFALSE )
    37ee:	88 89       	ldd	r24, Y+16	; 0x10
    37f0:	88 23       	and	r24, r24
    37f2:	29 f0       	breq	.+10     	; 0x37fe <xEventGroupWaitBits+0xb4>
            {
                uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
    37f4:	8e 81       	ldd	r24, Y+6	; 0x06
    37f6:	9f 81       	ldd	r25, Y+7	; 0x07
    37f8:	91 60       	ori	r25, 0x01	; 1
    37fa:	9f 83       	std	Y+7, r25	; 0x07
    37fc:	8e 83       	std	Y+6, r24	; 0x06
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            if( xWaitForAllBits != pdFALSE )
    37fe:	89 89       	ldd	r24, Y+17	; 0x11
    3800:	88 23       	and	r24, r24
    3802:	29 f0       	breq	.+10     	; 0x380e <xEventGroupWaitBits+0xc4>
            {
                uxControlBits |= eventWAIT_FOR_ALL_BITS;
    3804:	8e 81       	ldd	r24, Y+6	; 0x06
    3806:	9f 81       	ldd	r25, Y+7	; 0x07
    3808:	94 60       	ori	r25, 0x04	; 4
    380a:	9f 83       	std	Y+7, r25	; 0x07
    380c:	8e 83       	std	Y+6, r24	; 0x06
            }

            /* Store the bits that the calling task is waiting for in the
             * task's event list item so the kernel knows when a match is
             * found.  Then enter the blocked state. */
            vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
    380e:	8a 85       	ldd	r24, Y+10	; 0x0a
    3810:	9b 85       	ldd	r25, Y+11	; 0x0b
    3812:	bc 01       	movw	r22, r24
    3814:	6e 5f       	subi	r22, 0xFE	; 254
    3816:	7f 4f       	sbci	r23, 0xFF	; 255
    3818:	2e 85       	ldd	r18, Y+14	; 0x0e
    381a:	3f 85       	ldd	r19, Y+15	; 0x0f
    381c:	8e 81       	ldd	r24, Y+6	; 0x06
    381e:	9f 81       	ldd	r25, Y+7	; 0x07
    3820:	28 2b       	or	r18, r24
    3822:	39 2b       	or	r19, r25
    3824:	4a 89       	ldd	r20, Y+18	; 0x12
    3826:	5b 89       	ldd	r21, Y+19	; 0x13
    3828:	cb 01       	movw	r24, r22
    382a:	b9 01       	movw	r22, r18
    382c:	0e 94 8e 3b 	call	0x771c	; 0x771c <vTaskPlaceOnUnorderedEventList>

            /* This is obsolete as it will get set after the task unblocks, but
             * some compilers mistakenly generate a warning about the variable
             * being returned without being set if it is not done. */
            uxReturn = 0;
    3830:	19 86       	std	Y+9, r1	; 0x09
    3832:	18 86       	std	Y+8, r1	; 0x08

            traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
        }
    }
    xAlreadyYielded = xTaskResumeAll();
    3834:	0e 94 9b 37 	call	0x6f36	; 0x6f36 <xTaskResumeAll>
    3838:	8c 83       	std	Y+4, r24	; 0x04

    if( xTicksToWait != ( TickType_t ) 0 )
    383a:	8a 89       	ldd	r24, Y+18	; 0x12
    383c:	9b 89       	ldd	r25, Y+19	; 0x13
    383e:	00 97       	sbiw	r24, 0x00	; 0
    3840:	09 f4       	brne	.+2      	; 0x3844 <xEventGroupWaitBits+0xfa>
    3842:	3c c0       	rjmp	.+120    	; 0x38bc <xEventGroupWaitBits+0x172>
    {
        if( xAlreadyYielded == pdFALSE )
    3844:	8c 81       	ldd	r24, Y+4	; 0x04
    3846:	88 23       	and	r24, r24
    3848:	11 f4       	brne	.+4      	; 0x384e <xEventGroupWaitBits+0x104>
        {
            portYIELD_WITHIN_API();
    384a:	0e 94 87 21 	call	0x430e	; 0x430e <vPortYield>

        /* The task blocked to wait for its required bits to be set - at this
         * point either the required bits were set or the block time expired.  If
         * the required bits were set they will have been stored in the task's
         * event list item, and they should now be retrieved then cleared. */
        uxReturn = uxTaskResetEventItemValue();
    384e:	0e 94 28 42 	call	0x8450	; 0x8450 <uxTaskResetEventItemValue>
    3852:	99 87       	std	Y+9, r25	; 0x09
    3854:	88 87       	std	Y+8, r24	; 0x08

        if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    3856:	88 85       	ldd	r24, Y+8	; 0x08
    3858:	99 85       	ldd	r25, Y+9	; 0x09
    385a:	80 70       	andi	r24, 0x00	; 0
    385c:	92 70       	andi	r25, 0x02	; 2
    385e:	00 97       	sbiw	r24, 0x00	; 0
    3860:	41 f5       	brne	.+80     	; 0x38b2 <xEventGroupWaitBits+0x168>
        {
            taskENTER_CRITICAL();
    3862:	0f b6       	in	r0, 0x3f	; 63
    3864:	f8 94       	cli
    3866:	0f 92       	push	r0
            {
                /* The task timed out, just return the current event bit value. */
                uxReturn = pxEventBits->uxEventBits;
    3868:	ea 85       	ldd	r30, Y+10	; 0x0a
    386a:	fb 85       	ldd	r31, Y+11	; 0x0b
    386c:	80 81       	ld	r24, Z
    386e:	91 81       	ldd	r25, Z+1	; 0x01
    3870:	99 87       	std	Y+9, r25	; 0x09
    3872:	88 87       	std	Y+8, r24	; 0x08

                /* It is possible that the event bits were updated between this
                 * task leaving the Blocked state and running again. */
                if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
    3874:	88 85       	ldd	r24, Y+8	; 0x08
    3876:	99 85       	ldd	r25, Y+9	; 0x09
    3878:	2e 85       	ldd	r18, Y+14	; 0x0e
    387a:	3f 85       	ldd	r19, Y+15	; 0x0f
    387c:	b9 01       	movw	r22, r18
    387e:	49 89       	ldd	r20, Y+17	; 0x11
    3880:	0e 94 e0 1d 	call	0x3bc0	; 0x3bc0 <prvTestWaitCondition>
    3884:	88 23       	and	r24, r24
    3886:	89 f0       	breq	.+34     	; 0x38aa <xEventGroupWaitBits+0x160>
                {
                    if( xClearOnExit != pdFALSE )
    3888:	88 89       	ldd	r24, Y+16	; 0x10
    388a:	88 23       	and	r24, r24
    388c:	71 f0       	breq	.+28     	; 0x38aa <xEventGroupWaitBits+0x160>
                    {
                        pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    388e:	ea 85       	ldd	r30, Y+10	; 0x0a
    3890:	fb 85       	ldd	r31, Y+11	; 0x0b
    3892:	20 81       	ld	r18, Z
    3894:	31 81       	ldd	r19, Z+1	; 0x01
    3896:	8e 85       	ldd	r24, Y+14	; 0x0e
    3898:	9f 85       	ldd	r25, Y+15	; 0x0f
    389a:	80 95       	com	r24
    389c:	90 95       	com	r25
    389e:	82 23       	and	r24, r18
    38a0:	93 23       	and	r25, r19
    38a2:	ea 85       	ldd	r30, Y+10	; 0x0a
    38a4:	fb 85       	ldd	r31, Y+11	; 0x0b
    38a6:	91 83       	std	Z+1, r25	; 0x01
    38a8:	80 83       	st	Z, r24
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                xTimeoutOccurred = pdTRUE;
    38aa:	81 e0       	ldi	r24, 0x01	; 1
    38ac:	8b 83       	std	Y+3, r24	; 0x03
            }
            taskEXIT_CRITICAL();
    38ae:	0f 90       	pop	r0
    38b0:	0f be       	out	0x3f, r0	; 63
        {
            /* The task unblocked because the bits were set. */
        }

        /* The task blocked so control bits may have been set. */
        uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    38b2:	88 85       	ldd	r24, Y+8	; 0x08
    38b4:	99 85       	ldd	r25, Y+9	; 0x09
    38b6:	90 70       	andi	r25, 0x00	; 0
    38b8:	99 87       	std	Y+9, r25	; 0x09
    38ba:	88 87       	std	Y+8, r24	; 0x08
    traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

    /* Prevent compiler warnings when trace macros are not used. */
    ( void ) xTimeoutOccurred;

    return uxReturn;
    38bc:	88 85       	ldd	r24, Y+8	; 0x08
    38be:	99 85       	ldd	r25, Y+9	; 0x09
}
    38c0:	63 96       	adiw	r28, 0x13	; 19
    38c2:	0f b6       	in	r0, 0x3f	; 63
    38c4:	f8 94       	cli
    38c6:	de bf       	out	0x3e, r29	; 62
    38c8:	0f be       	out	0x3f, r0	; 63
    38ca:	cd bf       	out	0x3d, r28	; 61
    38cc:	cf 91       	pop	r28
    38ce:	df 91       	pop	r29
    38d0:	1f 91       	pop	r17
    38d2:	0f 91       	pop	r16
    38d4:	08 95       	ret

000038d6 <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup,
                                  const EventBits_t uxBitsToClear )
{
    38d6:	df 93       	push	r29
    38d8:	cf 93       	push	r28
    38da:	cd b7       	in	r28, 0x3d	; 61
    38dc:	de b7       	in	r29, 0x3e	; 62
    38de:	28 97       	sbiw	r28, 0x08	; 8
    38e0:	0f b6       	in	r0, 0x3f	; 63
    38e2:	f8 94       	cli
    38e4:	de bf       	out	0x3e, r29	; 62
    38e6:	0f be       	out	0x3f, r0	; 63
    38e8:	cd bf       	out	0x3d, r28	; 61
    38ea:	9e 83       	std	Y+6, r25	; 0x06
    38ec:	8d 83       	std	Y+5, r24	; 0x05
    38ee:	78 87       	std	Y+8, r23	; 0x08
    38f0:	6f 83       	std	Y+7, r22	; 0x07
    EventGroup_t * pxEventBits = xEventGroup;
    38f2:	8d 81       	ldd	r24, Y+5	; 0x05
    38f4:	9e 81       	ldd	r25, Y+6	; 0x06
    38f6:	9c 83       	std	Y+4, r25	; 0x04
    38f8:	8b 83       	std	Y+3, r24	; 0x03
    /* Check the user is not attempting to clear the bits used by the kernel
     * itself. */
    configASSERT( xEventGroup );
    configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

    taskENTER_CRITICAL();
    38fa:	0f b6       	in	r0, 0x3f	; 63
    38fc:	f8 94       	cli
    38fe:	0f 92       	push	r0
    {
        traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

        /* The value returned is the event group value prior to the bits being
         * cleared. */
        uxReturn = pxEventBits->uxEventBits;
    3900:	eb 81       	ldd	r30, Y+3	; 0x03
    3902:	fc 81       	ldd	r31, Y+4	; 0x04
    3904:	80 81       	ld	r24, Z
    3906:	91 81       	ldd	r25, Z+1	; 0x01
    3908:	9a 83       	std	Y+2, r25	; 0x02
    390a:	89 83       	std	Y+1, r24	; 0x01

        /* Clear the bits. */
        pxEventBits->uxEventBits &= ~uxBitsToClear;
    390c:	eb 81       	ldd	r30, Y+3	; 0x03
    390e:	fc 81       	ldd	r31, Y+4	; 0x04
    3910:	20 81       	ld	r18, Z
    3912:	31 81       	ldd	r19, Z+1	; 0x01
    3914:	8f 81       	ldd	r24, Y+7	; 0x07
    3916:	98 85       	ldd	r25, Y+8	; 0x08
    3918:	80 95       	com	r24
    391a:	90 95       	com	r25
    391c:	82 23       	and	r24, r18
    391e:	93 23       	and	r25, r19
    3920:	eb 81       	ldd	r30, Y+3	; 0x03
    3922:	fc 81       	ldd	r31, Y+4	; 0x04
    3924:	91 83       	std	Z+1, r25	; 0x01
    3926:	80 83       	st	Z, r24
    }
    taskEXIT_CRITICAL();
    3928:	0f 90       	pop	r0
    392a:	0f be       	out	0x3f, r0	; 63

    return uxReturn;
    392c:	89 81       	ldd	r24, Y+1	; 0x01
    392e:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3930:	28 96       	adiw	r28, 0x08	; 8
    3932:	0f b6       	in	r0, 0x3f	; 63
    3934:	f8 94       	cli
    3936:	de bf       	out	0x3e, r29	; 62
    3938:	0f be       	out	0x3f, r0	; 63
    393a:	cd bf       	out	0x3d, r28	; 61
    393c:	cf 91       	pop	r28
    393e:	df 91       	pop	r29
    3940:	08 95       	ret

00003942 <xEventGroupGetBitsFromISR>:

#endif /* if ( ( configUSE_TRACE_FACILITY == 1 ) && ( INCLUDE_xTimerPendFunctionCall == 1 ) && ( configUSE_TIMERS == 1 ) ) */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
    3942:	df 93       	push	r29
    3944:	cf 93       	push	r28
    3946:	cd b7       	in	r28, 0x3d	; 61
    3948:	de b7       	in	r29, 0x3e	; 62
    394a:	27 97       	sbiw	r28, 0x07	; 7
    394c:	0f b6       	in	r0, 0x3f	; 63
    394e:	f8 94       	cli
    3950:	de bf       	out	0x3e, r29	; 62
    3952:	0f be       	out	0x3f, r0	; 63
    3954:	cd bf       	out	0x3d, r28	; 61
    3956:	9f 83       	std	Y+7, r25	; 0x07
    3958:	8e 83       	std	Y+6, r24	; 0x06
    UBaseType_t uxSavedInterruptStatus;
    EventGroup_t const * const pxEventBits = xEventGroup;
    395a:	8e 81       	ldd	r24, Y+6	; 0x06
    395c:	9f 81       	ldd	r25, Y+7	; 0x07
    395e:	9c 83       	std	Y+4, r25	; 0x04
    3960:	8b 83       	std	Y+3, r24	; 0x03
    EventBits_t uxReturn;

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    3962:	1d 82       	std	Y+5, r1	; 0x05
    {
        uxReturn = pxEventBits->uxEventBits;
    3964:	eb 81       	ldd	r30, Y+3	; 0x03
    3966:	fc 81       	ldd	r31, Y+4	; 0x04
    3968:	80 81       	ld	r24, Z
    396a:	91 81       	ldd	r25, Z+1	; 0x01
    396c:	9a 83       	std	Y+2, r25	; 0x02
    396e:	89 83       	std	Y+1, r24	; 0x01
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return uxReturn;
    3970:	89 81       	ldd	r24, Y+1	; 0x01
    3972:	9a 81       	ldd	r25, Y+2	; 0x02
} /*lint !e818 EventGroupHandle_t is a typedef used in other functions to so can't be pointer to const. */
    3974:	27 96       	adiw	r28, 0x07	; 7
    3976:	0f b6       	in	r0, 0x3f	; 63
    3978:	f8 94       	cli
    397a:	de bf       	out	0x3e, r29	; 62
    397c:	0f be       	out	0x3f, r0	; 63
    397e:	cd bf       	out	0x3d, r28	; 61
    3980:	cf 91       	pop	r28
    3982:	df 91       	pop	r29
    3984:	08 95       	ret

00003986 <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup,
                                const EventBits_t uxBitsToSet )
{
    3986:	df 93       	push	r29
    3988:	cf 93       	push	r28
    398a:	cd b7       	in	r28, 0x3d	; 61
    398c:	de b7       	in	r29, 0x3e	; 62
    398e:	65 97       	sbiw	r28, 0x15	; 21
    3990:	0f b6       	in	r0, 0x3f	; 63
    3992:	f8 94       	cli
    3994:	de bf       	out	0x3e, r29	; 62
    3996:	0f be       	out	0x3f, r0	; 63
    3998:	cd bf       	out	0x3d, r28	; 61
    399a:	9b 8b       	std	Y+19, r25	; 0x13
    399c:	8a 8b       	std	Y+18, r24	; 0x12
    399e:	7d 8b       	std	Y+21, r23	; 0x15
    39a0:	6c 8b       	std	Y+20, r22	; 0x14
    ListItem_t * pxListItem, * pxNext;
    ListItem_t const * pxListEnd;
    List_t const * pxList;
    EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
    39a2:	19 86       	std	Y+9, r1	; 0x09
    39a4:	18 86       	std	Y+8, r1	; 0x08
    EventGroup_t * pxEventBits = xEventGroup;
    39a6:	8a 89       	ldd	r24, Y+18	; 0x12
    39a8:	9b 89       	ldd	r25, Y+19	; 0x13
    39aa:	9b 83       	std	Y+3, r25	; 0x03
    39ac:	8a 83       	std	Y+2, r24	; 0x02
    BaseType_t xMatchFound = pdFALSE;
    39ae:	19 82       	std	Y+1, r1	; 0x01
    /* Check the user is not attempting to set the bits used by the kernel
     * itself. */
    configASSERT( xEventGroup );
    configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

    pxList = &( pxEventBits->xTasksWaitingForBits );
    39b0:	8a 81       	ldd	r24, Y+2	; 0x02
    39b2:	9b 81       	ldd	r25, Y+3	; 0x03
    39b4:	02 96       	adiw	r24, 0x02	; 2
    39b6:	9b 87       	std	Y+11, r25	; 0x0b
    39b8:	8a 87       	std	Y+10, r24	; 0x0a
    pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    39ba:	8a 85       	ldd	r24, Y+10	; 0x0a
    39bc:	9b 85       	ldd	r25, Y+11	; 0x0b
    39be:	03 96       	adiw	r24, 0x03	; 3
    39c0:	9d 87       	std	Y+13, r25	; 0x0d
    39c2:	8c 87       	std	Y+12, r24	; 0x0c
    vTaskSuspendAll();
    39c4:	0e 94 8f 37 	call	0x6f1e	; 0x6f1e <vTaskSuspendAll>
    {
        traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

        pxListItem = listGET_HEAD_ENTRY( pxList );
    39c8:	ea 85       	ldd	r30, Y+10	; 0x0a
    39ca:	fb 85       	ldd	r31, Y+11	; 0x0b
    39cc:	85 81       	ldd	r24, Z+5	; 0x05
    39ce:	96 81       	ldd	r25, Z+6	; 0x06
    39d0:	99 8b       	std	Y+17, r25	; 0x11
    39d2:	88 8b       	std	Y+16, r24	; 0x10

        /* Set the bits. */
        pxEventBits->uxEventBits |= uxBitsToSet;
    39d4:	ea 81       	ldd	r30, Y+2	; 0x02
    39d6:	fb 81       	ldd	r31, Y+3	; 0x03
    39d8:	20 81       	ld	r18, Z
    39da:	31 81       	ldd	r19, Z+1	; 0x01
    39dc:	8c 89       	ldd	r24, Y+20	; 0x14
    39de:	9d 89       	ldd	r25, Y+21	; 0x15
    39e0:	82 2b       	or	r24, r18
    39e2:	93 2b       	or	r25, r19
    39e4:	ea 81       	ldd	r30, Y+2	; 0x02
    39e6:	fb 81       	ldd	r31, Y+3	; 0x03
    39e8:	91 83       	std	Z+1, r25	; 0x01
    39ea:	80 83       	st	Z, r24
    39ec:	59 c0       	rjmp	.+178    	; 0x3aa0 <xEventGroupSetBits+0x11a>

        /* See if the new bit value should unblock any tasks. */
        while( pxListItem != pxListEnd )
        {
            pxNext = listGET_NEXT( pxListItem );
    39ee:	e8 89       	ldd	r30, Y+16	; 0x10
    39f0:	f9 89       	ldd	r31, Y+17	; 0x11
    39f2:	82 81       	ldd	r24, Z+2	; 0x02
    39f4:	93 81       	ldd	r25, Z+3	; 0x03
    39f6:	9f 87       	std	Y+15, r25	; 0x0f
    39f8:	8e 87       	std	Y+14, r24	; 0x0e
            uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
    39fa:	e8 89       	ldd	r30, Y+16	; 0x10
    39fc:	f9 89       	ldd	r31, Y+17	; 0x11
    39fe:	80 81       	ld	r24, Z
    3a00:	91 81       	ldd	r25, Z+1	; 0x01
    3a02:	9f 83       	std	Y+7, r25	; 0x07
    3a04:	8e 83       	std	Y+6, r24	; 0x06
            xMatchFound = pdFALSE;
    3a06:	19 82       	std	Y+1, r1	; 0x01

            /* Split the bits waited for from the control bits. */
            uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
    3a08:	8e 81       	ldd	r24, Y+6	; 0x06
    3a0a:	9f 81       	ldd	r25, Y+7	; 0x07
    3a0c:	80 70       	andi	r24, 0x00	; 0
    3a0e:	9d 83       	std	Y+5, r25	; 0x05
    3a10:	8c 83       	std	Y+4, r24	; 0x04
            uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
    3a12:	8e 81       	ldd	r24, Y+6	; 0x06
    3a14:	9f 81       	ldd	r25, Y+7	; 0x07
    3a16:	90 70       	andi	r25, 0x00	; 0
    3a18:	9f 83       	std	Y+7, r25	; 0x07
    3a1a:	8e 83       	std	Y+6, r24	; 0x06

            if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
    3a1c:	8c 81       	ldd	r24, Y+4	; 0x04
    3a1e:	9d 81       	ldd	r25, Y+5	; 0x05
    3a20:	80 70       	andi	r24, 0x00	; 0
    3a22:	94 70       	andi	r25, 0x04	; 4
    3a24:	00 97       	sbiw	r24, 0x00	; 0
    3a26:	69 f4       	brne	.+26     	; 0x3a42 <xEventGroupSetBits+0xbc>
            {
                /* Just looking for single bit being set. */
                if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
    3a28:	ea 81       	ldd	r30, Y+2	; 0x02
    3a2a:	fb 81       	ldd	r31, Y+3	; 0x03
    3a2c:	20 81       	ld	r18, Z
    3a2e:	31 81       	ldd	r19, Z+1	; 0x01
    3a30:	8e 81       	ldd	r24, Y+6	; 0x06
    3a32:	9f 81       	ldd	r25, Y+7	; 0x07
    3a34:	82 23       	and	r24, r18
    3a36:	93 23       	and	r25, r19
    3a38:	00 97       	sbiw	r24, 0x00	; 0
    3a3a:	91 f0       	breq	.+36     	; 0x3a60 <xEventGroupSetBits+0xda>
                {
                    xMatchFound = pdTRUE;
    3a3c:	81 e0       	ldi	r24, 0x01	; 1
    3a3e:	89 83       	std	Y+1, r24	; 0x01
    3a40:	0f c0       	rjmp	.+30     	; 0x3a60 <xEventGroupSetBits+0xda>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
    3a42:	ea 81       	ldd	r30, Y+2	; 0x02
    3a44:	fb 81       	ldd	r31, Y+3	; 0x03
    3a46:	20 81       	ld	r18, Z
    3a48:	31 81       	ldd	r19, Z+1	; 0x01
    3a4a:	8e 81       	ldd	r24, Y+6	; 0x06
    3a4c:	9f 81       	ldd	r25, Y+7	; 0x07
    3a4e:	28 23       	and	r18, r24
    3a50:	39 23       	and	r19, r25
    3a52:	8e 81       	ldd	r24, Y+6	; 0x06
    3a54:	9f 81       	ldd	r25, Y+7	; 0x07
    3a56:	28 17       	cp	r18, r24
    3a58:	39 07       	cpc	r19, r25
    3a5a:	11 f4       	brne	.+4      	; 0x3a60 <xEventGroupSetBits+0xda>
            {
                /* All bits are set. */
                xMatchFound = pdTRUE;
    3a5c:	81 e0       	ldi	r24, 0x01	; 1
    3a5e:	89 83       	std	Y+1, r24	; 0x01
            else
            {
                /* Need all bits to be set, but not all the bits were set. */
            }

            if( xMatchFound != pdFALSE )
    3a60:	89 81       	ldd	r24, Y+1	; 0x01
    3a62:	88 23       	and	r24, r24
    3a64:	c9 f0       	breq	.+50     	; 0x3a98 <xEventGroupSetBits+0x112>
            {
                /* The bits match.  Should the bits be cleared on exit? */
                if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
    3a66:	8c 81       	ldd	r24, Y+4	; 0x04
    3a68:	9d 81       	ldd	r25, Y+5	; 0x05
    3a6a:	80 70       	andi	r24, 0x00	; 0
    3a6c:	91 70       	andi	r25, 0x01	; 1
    3a6e:	00 97       	sbiw	r24, 0x00	; 0
    3a70:	41 f0       	breq	.+16     	; 0x3a82 <xEventGroupSetBits+0xfc>
                {
                    uxBitsToClear |= uxBitsWaitedFor;
    3a72:	88 85       	ldd	r24, Y+8	; 0x08
    3a74:	99 85       	ldd	r25, Y+9	; 0x09
    3a76:	2e 81       	ldd	r18, Y+6	; 0x06
    3a78:	3f 81       	ldd	r19, Y+7	; 0x07
    3a7a:	82 2b       	or	r24, r18
    3a7c:	93 2b       	or	r25, r19
    3a7e:	99 87       	std	Y+9, r25	; 0x09
    3a80:	88 87       	std	Y+8, r24	; 0x08
                /* Store the actual event flag value in the task's event list
                 * item before removing the task from the event list.  The
                 * eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
                 * that is was unblocked due to its required bits matching, rather
                 * than because it timed out. */
                vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
    3a82:	ea 81       	ldd	r30, Y+2	; 0x02
    3a84:	fb 81       	ldd	r31, Y+3	; 0x03
    3a86:	80 81       	ld	r24, Z
    3a88:	91 81       	ldd	r25, Z+1	; 0x01
    3a8a:	9c 01       	movw	r18, r24
    3a8c:	32 60       	ori	r19, 0x02	; 2
    3a8e:	88 89       	ldd	r24, Y+16	; 0x10
    3a90:	99 89       	ldd	r25, Y+17	; 0x11
    3a92:	b9 01       	movw	r22, r18
    3a94:	0e 94 37 3d 	call	0x7a6e	; 0x7a6e <vTaskRemoveFromUnorderedEventList>
            }

            /* Move onto the next list item.  Note pxListItem->pxNext is not
             * used here as the list item may have been removed from the event list
             * and inserted into the ready/pending reading list. */
            pxListItem = pxNext;
    3a98:	8e 85       	ldd	r24, Y+14	; 0x0e
    3a9a:	9f 85       	ldd	r25, Y+15	; 0x0f
    3a9c:	99 8b       	std	Y+17, r25	; 0x11
    3a9e:	88 8b       	std	Y+16, r24	; 0x10

        /* Set the bits. */
        pxEventBits->uxEventBits |= uxBitsToSet;

        /* See if the new bit value should unblock any tasks. */
        while( pxListItem != pxListEnd )
    3aa0:	28 89       	ldd	r18, Y+16	; 0x10
    3aa2:	39 89       	ldd	r19, Y+17	; 0x11
    3aa4:	8c 85       	ldd	r24, Y+12	; 0x0c
    3aa6:	9d 85       	ldd	r25, Y+13	; 0x0d
    3aa8:	28 17       	cp	r18, r24
    3aaa:	39 07       	cpc	r19, r25
    3aac:	09 f0       	breq	.+2      	; 0x3ab0 <xEventGroupSetBits+0x12a>
    3aae:	9f cf       	rjmp	.-194    	; 0x39ee <xEventGroupSetBits+0x68>
            pxListItem = pxNext;
        }

        /* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
         * bit was set in the control word. */
        pxEventBits->uxEventBits &= ~uxBitsToClear;
    3ab0:	ea 81       	ldd	r30, Y+2	; 0x02
    3ab2:	fb 81       	ldd	r31, Y+3	; 0x03
    3ab4:	20 81       	ld	r18, Z
    3ab6:	31 81       	ldd	r19, Z+1	; 0x01
    3ab8:	88 85       	ldd	r24, Y+8	; 0x08
    3aba:	99 85       	ldd	r25, Y+9	; 0x09
    3abc:	80 95       	com	r24
    3abe:	90 95       	com	r25
    3ac0:	82 23       	and	r24, r18
    3ac2:	93 23       	and	r25, r19
    3ac4:	ea 81       	ldd	r30, Y+2	; 0x02
    3ac6:	fb 81       	ldd	r31, Y+3	; 0x03
    3ac8:	91 83       	std	Z+1, r25	; 0x01
    3aca:	80 83       	st	Z, r24
    }
    ( void ) xTaskResumeAll();
    3acc:	0e 94 9b 37 	call	0x6f36	; 0x6f36 <xTaskResumeAll>

    return pxEventBits->uxEventBits;
    3ad0:	ea 81       	ldd	r30, Y+2	; 0x02
    3ad2:	fb 81       	ldd	r31, Y+3	; 0x03
    3ad4:	80 81       	ld	r24, Z
    3ad6:	91 81       	ldd	r25, Z+1	; 0x01
}
    3ad8:	65 96       	adiw	r28, 0x15	; 21
    3ada:	0f b6       	in	r0, 0x3f	; 63
    3adc:	f8 94       	cli
    3ade:	de bf       	out	0x3e, r29	; 62
    3ae0:	0f be       	out	0x3f, r0	; 63
    3ae2:	cd bf       	out	0x3d, r28	; 61
    3ae4:	cf 91       	pop	r28
    3ae6:	df 91       	pop	r29
    3ae8:	08 95       	ret

00003aea <vEventGroupDelete>:
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
    3aea:	df 93       	push	r29
    3aec:	cf 93       	push	r28
    3aee:	00 d0       	rcall	.+0      	; 0x3af0 <vEventGroupDelete+0x6>
    3af0:	00 d0       	rcall	.+0      	; 0x3af2 <vEventGroupDelete+0x8>
    3af2:	00 d0       	rcall	.+0      	; 0x3af4 <vEventGroupDelete+0xa>
    3af4:	cd b7       	in	r28, 0x3d	; 61
    3af6:	de b7       	in	r29, 0x3e	; 62
    3af8:	9e 83       	std	Y+6, r25	; 0x06
    3afa:	8d 83       	std	Y+5, r24	; 0x05
    configASSERT( xEventGroup );

    EventGroup_t * pxEventBits = xEventGroup;
    3afc:	8d 81       	ldd	r24, Y+5	; 0x05
    3afe:	9e 81       	ldd	r25, Y+6	; 0x06
    3b00:	9c 83       	std	Y+4, r25	; 0x04
    3b02:	8b 83       	std	Y+3, r24	; 0x03
    const List_t * pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
    3b04:	8b 81       	ldd	r24, Y+3	; 0x03
    3b06:	9c 81       	ldd	r25, Y+4	; 0x04
    3b08:	02 96       	adiw	r24, 0x02	; 2
    3b0a:	9a 83       	std	Y+2, r25	; 0x02
    3b0c:	89 83       	std	Y+1, r24	; 0x01

    vTaskSuspendAll();
    3b0e:	0e 94 8f 37 	call	0x6f1e	; 0x6f1e <vTaskSuspendAll>
    3b12:	08 c0       	rjmp	.+16     	; 0x3b24 <vEventGroupDelete+0x3a>
        while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
        {
            /* Unblock the task, returning 0 as the event list is being deleted
             * and cannot therefore have any bits set. */
            configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
            vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
    3b14:	e9 81       	ldd	r30, Y+1	; 0x01
    3b16:	fa 81       	ldd	r31, Y+2	; 0x02
    3b18:	85 81       	ldd	r24, Z+5	; 0x05
    3b1a:	96 81       	ldd	r25, Z+6	; 0x06
    3b1c:	60 e0       	ldi	r22, 0x00	; 0
    3b1e:	72 e0       	ldi	r23, 0x02	; 2
    3b20:	0e 94 37 3d 	call	0x7a6e	; 0x7a6e <vTaskRemoveFromUnorderedEventList>

    vTaskSuspendAll();
    {
        traceEVENT_GROUP_DELETE( xEventGroup );

        while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
    3b24:	e9 81       	ldd	r30, Y+1	; 0x01
    3b26:	fa 81       	ldd	r31, Y+2	; 0x02
    3b28:	80 81       	ld	r24, Z
    3b2a:	88 23       	and	r24, r24
    3b2c:	99 f7       	brne	.-26     	; 0x3b14 <vEventGroupDelete+0x2a>

        #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
            {
                /* The event group can only have been allocated dynamically - free
                 * it again. */
                vPortFree( pxEventBits );
    3b2e:	8b 81       	ldd	r24, Y+3	; 0x03
    3b30:	9c 81       	ldd	r25, Y+4	; 0x04
    3b32:	0e 94 6c 1e 	call	0x3cd8	; 0x3cd8 <vPortFree>
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
    }
    ( void ) xTaskResumeAll();
    3b36:	0e 94 9b 37 	call	0x6f36	; 0x6f36 <xTaskResumeAll>
}
    3b3a:	26 96       	adiw	r28, 0x06	; 6
    3b3c:	0f b6       	in	r0, 0x3f	; 63
    3b3e:	f8 94       	cli
    3b40:	de bf       	out	0x3e, r29	; 62
    3b42:	0f be       	out	0x3f, r0	; 63
    3b44:	cd bf       	out	0x3d, r28	; 61
    3b46:	cf 91       	pop	r28
    3b48:	df 91       	pop	r29
    3b4a:	08 95       	ret

00003b4c <vEventGroupSetBitsCallback>:

/* For internal use only - execute a 'set bits' command that was pended from
 * an interrupt. */
void vEventGroupSetBitsCallback( void * pvEventGroup,
                                 const uint32_t ulBitsToSet )
{
    3b4c:	df 93       	push	r29
    3b4e:	cf 93       	push	r28
    3b50:	00 d0       	rcall	.+0      	; 0x3b52 <vEventGroupSetBitsCallback+0x6>
    3b52:	00 d0       	rcall	.+0      	; 0x3b54 <vEventGroupSetBitsCallback+0x8>
    3b54:	00 d0       	rcall	.+0      	; 0x3b56 <vEventGroupSetBitsCallback+0xa>
    3b56:	cd b7       	in	r28, 0x3d	; 61
    3b58:	de b7       	in	r29, 0x3e	; 62
    3b5a:	9a 83       	std	Y+2, r25	; 0x02
    3b5c:	89 83       	std	Y+1, r24	; 0x01
    3b5e:	4b 83       	std	Y+3, r20	; 0x03
    3b60:	5c 83       	std	Y+4, r21	; 0x04
    3b62:	6d 83       	std	Y+5, r22	; 0x05
    3b64:	7e 83       	std	Y+6, r23	; 0x06
    ( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
    3b66:	89 81       	ldd	r24, Y+1	; 0x01
    3b68:	9a 81       	ldd	r25, Y+2	; 0x02
    3b6a:	2b 81       	ldd	r18, Y+3	; 0x03
    3b6c:	3c 81       	ldd	r19, Y+4	; 0x04
    3b6e:	b9 01       	movw	r22, r18
    3b70:	0e 94 c3 1c 	call	0x3986	; 0x3986 <xEventGroupSetBits>
}
    3b74:	26 96       	adiw	r28, 0x06	; 6
    3b76:	0f b6       	in	r0, 0x3f	; 63
    3b78:	f8 94       	cli
    3b7a:	de bf       	out	0x3e, r29	; 62
    3b7c:	0f be       	out	0x3f, r0	; 63
    3b7e:	cd bf       	out	0x3d, r28	; 61
    3b80:	cf 91       	pop	r28
    3b82:	df 91       	pop	r29
    3b84:	08 95       	ret

00003b86 <vEventGroupClearBitsCallback>:

/* For internal use only - execute a 'clear bits' command that was pended from
 * an interrupt. */
void vEventGroupClearBitsCallback( void * pvEventGroup,
                                   const uint32_t ulBitsToClear )
{
    3b86:	df 93       	push	r29
    3b88:	cf 93       	push	r28
    3b8a:	00 d0       	rcall	.+0      	; 0x3b8c <vEventGroupClearBitsCallback+0x6>
    3b8c:	00 d0       	rcall	.+0      	; 0x3b8e <vEventGroupClearBitsCallback+0x8>
    3b8e:	00 d0       	rcall	.+0      	; 0x3b90 <vEventGroupClearBitsCallback+0xa>
    3b90:	cd b7       	in	r28, 0x3d	; 61
    3b92:	de b7       	in	r29, 0x3e	; 62
    3b94:	9a 83       	std	Y+2, r25	; 0x02
    3b96:	89 83       	std	Y+1, r24	; 0x01
    3b98:	4b 83       	std	Y+3, r20	; 0x03
    3b9a:	5c 83       	std	Y+4, r21	; 0x04
    3b9c:	6d 83       	std	Y+5, r22	; 0x05
    3b9e:	7e 83       	std	Y+6, r23	; 0x06
    ( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
    3ba0:	89 81       	ldd	r24, Y+1	; 0x01
    3ba2:	9a 81       	ldd	r25, Y+2	; 0x02
    3ba4:	2b 81       	ldd	r18, Y+3	; 0x03
    3ba6:	3c 81       	ldd	r19, Y+4	; 0x04
    3ba8:	b9 01       	movw	r22, r18
    3baa:	0e 94 6b 1c 	call	0x38d6	; 0x38d6 <xEventGroupClearBits>
}
    3bae:	26 96       	adiw	r28, 0x06	; 6
    3bb0:	0f b6       	in	r0, 0x3f	; 63
    3bb2:	f8 94       	cli
    3bb4:	de bf       	out	0x3e, r29	; 62
    3bb6:	0f be       	out	0x3f, r0	; 63
    3bb8:	cd bf       	out	0x3d, r28	; 61
    3bba:	cf 91       	pop	r28
    3bbc:	df 91       	pop	r29
    3bbe:	08 95       	ret

00003bc0 <prvTestWaitCondition>:
/*-----------------------------------------------------------*/

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits,
                                        const EventBits_t uxBitsToWaitFor,
                                        const BaseType_t xWaitForAllBits )
{
    3bc0:	df 93       	push	r29
    3bc2:	cf 93       	push	r28
    3bc4:	00 d0       	rcall	.+0      	; 0x3bc6 <prvTestWaitCondition+0x6>
    3bc6:	00 d0       	rcall	.+0      	; 0x3bc8 <prvTestWaitCondition+0x8>
    3bc8:	00 d0       	rcall	.+0      	; 0x3bca <prvTestWaitCondition+0xa>
    3bca:	cd b7       	in	r28, 0x3d	; 61
    3bcc:	de b7       	in	r29, 0x3e	; 62
    3bce:	9b 83       	std	Y+3, r25	; 0x03
    3bd0:	8a 83       	std	Y+2, r24	; 0x02
    3bd2:	7d 83       	std	Y+5, r23	; 0x05
    3bd4:	6c 83       	std	Y+4, r22	; 0x04
    3bd6:	4e 83       	std	Y+6, r20	; 0x06
    BaseType_t xWaitConditionMet = pdFALSE;
    3bd8:	19 82       	std	Y+1, r1	; 0x01

    if( xWaitForAllBits == pdFALSE )
    3bda:	8e 81       	ldd	r24, Y+6	; 0x06
    3bdc:	88 23       	and	r24, r24
    3bde:	59 f4       	brne	.+22     	; 0x3bf6 <prvTestWaitCondition+0x36>
    {
        /* Task only has to wait for one bit within uxBitsToWaitFor to be
         * set.  Is one already set? */
        if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
    3be0:	8a 81       	ldd	r24, Y+2	; 0x02
    3be2:	9b 81       	ldd	r25, Y+3	; 0x03
    3be4:	2c 81       	ldd	r18, Y+4	; 0x04
    3be6:	3d 81       	ldd	r19, Y+5	; 0x05
    3be8:	82 23       	and	r24, r18
    3bea:	93 23       	and	r25, r19
    3bec:	00 97       	sbiw	r24, 0x00	; 0
    3bee:	81 f0       	breq	.+32     	; 0x3c10 <prvTestWaitCondition+0x50>
        {
            xWaitConditionMet = pdTRUE;
    3bf0:	81 e0       	ldi	r24, 0x01	; 1
    3bf2:	89 83       	std	Y+1, r24	; 0x01
    3bf4:	0d c0       	rjmp	.+26     	; 0x3c10 <prvTestWaitCondition+0x50>
    }
    else
    {
        /* Task has to wait for all the bits in uxBitsToWaitFor to be set.
         * Are they set already? */
        if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
    3bf6:	2a 81       	ldd	r18, Y+2	; 0x02
    3bf8:	3b 81       	ldd	r19, Y+3	; 0x03
    3bfa:	8c 81       	ldd	r24, Y+4	; 0x04
    3bfc:	9d 81       	ldd	r25, Y+5	; 0x05
    3bfe:	28 23       	and	r18, r24
    3c00:	39 23       	and	r19, r25
    3c02:	8c 81       	ldd	r24, Y+4	; 0x04
    3c04:	9d 81       	ldd	r25, Y+5	; 0x05
    3c06:	28 17       	cp	r18, r24
    3c08:	39 07       	cpc	r19, r25
    3c0a:	11 f4       	brne	.+4      	; 0x3c10 <prvTestWaitCondition+0x50>
        {
            xWaitConditionMet = pdTRUE;
    3c0c:	81 e0       	ldi	r24, 0x01	; 1
    3c0e:	89 83       	std	Y+1, r24	; 0x01
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    return xWaitConditionMet;
    3c10:	89 81       	ldd	r24, Y+1	; 0x01
}
    3c12:	26 96       	adiw	r28, 0x06	; 6
    3c14:	0f b6       	in	r0, 0x3f	; 63
    3c16:	f8 94       	cli
    3c18:	de bf       	out	0x3e, r29	; 62
    3c1a:	0f be       	out	0x3f, r0	; 63
    3c1c:	cd bf       	out	0x3d, r28	; 61
    3c1e:	cf 91       	pop	r28
    3c20:	df 91       	pop	r29
    3c22:	08 95       	ret

00003c24 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void * pvPortMalloc( size_t xWantedSize )
{
    3c24:	df 93       	push	r29
    3c26:	cf 93       	push	r28
    3c28:	00 d0       	rcall	.+0      	; 0x3c2a <pvPortMalloc+0x6>
    3c2a:	00 d0       	rcall	.+0      	; 0x3c2c <pvPortMalloc+0x8>
    3c2c:	cd b7       	in	r28, 0x3d	; 61
    3c2e:	de b7       	in	r29, 0x3e	; 62
    3c30:	9c 83       	std	Y+4, r25	; 0x04
    3c32:	8b 83       	std	Y+3, r24	; 0x03
    void * pvReturn = NULL;
    3c34:	1a 82       	std	Y+2, r1	; 0x02
    3c36:	19 82       	std	Y+1, r1	; 0x01
                }
            }
        }
    #endif

    vTaskSuspendAll();
    3c38:	0e 94 8f 37 	call	0x6f1e	; 0x6f1e <vTaskSuspendAll>
    {
        if( pucAlignedHeap == NULL )
    3c3c:	80 91 c2 01 	lds	r24, 0x01C2
    3c40:	90 91 c3 01 	lds	r25, 0x01C3
    3c44:	00 97       	sbiw	r24, 0x00	; 0
    3c46:	31 f4       	brne	.+12     	; 0x3c54 <pvPortMalloc+0x30>
        {
            /* Ensure the heap starts on a correctly aligned boundary. */
            pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) & ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    3c48:	85 ec       	ldi	r24, 0xC5	; 197
    3c4a:	91 e0       	ldi	r25, 0x01	; 1
    3c4c:	90 93 c3 01 	sts	0x01C3, r25
    3c50:	80 93 c2 01 	sts	0x01C2, r24
        }

        /* Check there is enough room left for the allocation and. */
        if( ( xWantedSize > 0 ) && /* valid size */
    3c54:	8b 81       	ldd	r24, Y+3	; 0x03
    3c56:	9c 81       	ldd	r25, Y+4	; 0x04
    3c58:	00 97       	sbiw	r24, 0x00	; 0
    3c5a:	99 f1       	breq	.+102    	; 0x3cc2 <pvPortMalloc+0x9e>
    3c5c:	80 91 c0 01 	lds	r24, 0x01C0
    3c60:	90 91 c1 01 	lds	r25, 0x01C1
    3c64:	2b 81       	ldd	r18, Y+3	; 0x03
    3c66:	3c 81       	ldd	r19, Y+4	; 0x04
    3c68:	82 0f       	add	r24, r18
    3c6a:	93 1f       	adc	r25, r19
    3c6c:	25 e0       	ldi	r18, 0x05	; 5
    3c6e:	8b 3d       	cpi	r24, 0xDB	; 219
    3c70:	92 07       	cpc	r25, r18
    3c72:	38 f5       	brcc	.+78     	; 0x3cc2 <pvPortMalloc+0x9e>
    3c74:	20 91 c0 01 	lds	r18, 0x01C0
    3c78:	30 91 c1 01 	lds	r19, 0x01C1
    3c7c:	8b 81       	ldd	r24, Y+3	; 0x03
    3c7e:	9c 81       	ldd	r25, Y+4	; 0x04
    3c80:	28 0f       	add	r18, r24
    3c82:	39 1f       	adc	r19, r25
    3c84:	80 91 c0 01 	lds	r24, 0x01C0
    3c88:	90 91 c1 01 	lds	r25, 0x01C1
    3c8c:	82 17       	cp	r24, r18
    3c8e:	93 07       	cpc	r25, r19
    3c90:	c0 f4       	brcc	.+48     	; 0x3cc2 <pvPortMalloc+0x9e>
            ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
            ( ( xNextFreeByte + xWantedSize ) > xNextFreeByte ) ) /* Check for overflow. */
        {
            /* Return the next free byte then increment the index past this
             * block. */
            pvReturn = pucAlignedHeap + xNextFreeByte;
    3c92:	20 91 c2 01 	lds	r18, 0x01C2
    3c96:	30 91 c3 01 	lds	r19, 0x01C3
    3c9a:	80 91 c0 01 	lds	r24, 0x01C0
    3c9e:	90 91 c1 01 	lds	r25, 0x01C1
    3ca2:	82 0f       	add	r24, r18
    3ca4:	93 1f       	adc	r25, r19
    3ca6:	9a 83       	std	Y+2, r25	; 0x02
    3ca8:	89 83       	std	Y+1, r24	; 0x01
            xNextFreeByte += xWantedSize;
    3caa:	20 91 c0 01 	lds	r18, 0x01C0
    3cae:	30 91 c1 01 	lds	r19, 0x01C1
    3cb2:	8b 81       	ldd	r24, Y+3	; 0x03
    3cb4:	9c 81       	ldd	r25, Y+4	; 0x04
    3cb6:	82 0f       	add	r24, r18
    3cb8:	93 1f       	adc	r25, r19
    3cba:	90 93 c1 01 	sts	0x01C1, r25
    3cbe:	80 93 c0 01 	sts	0x01C0, r24
        }

        traceMALLOC( pvReturn, xWantedSize );
    }
    ( void ) xTaskResumeAll();
    3cc2:	0e 94 9b 37 	call	0x6f36	; 0x6f36 <xTaskResumeAll>
                vApplicationMallocFailedHook();
            }
        }
    #endif

    return pvReturn;
    3cc6:	89 81       	ldd	r24, Y+1	; 0x01
    3cc8:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3cca:	0f 90       	pop	r0
    3ccc:	0f 90       	pop	r0
    3cce:	0f 90       	pop	r0
    3cd0:	0f 90       	pop	r0
    3cd2:	cf 91       	pop	r28
    3cd4:	df 91       	pop	r29
    3cd6:	08 95       	ret

00003cd8 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void * pv )
{
    3cd8:	df 93       	push	r29
    3cda:	cf 93       	push	r28
    3cdc:	00 d0       	rcall	.+0      	; 0x3cde <vPortFree+0x6>
    3cde:	cd b7       	in	r28, 0x3d	; 61
    3ce0:	de b7       	in	r29, 0x3e	; 62
    3ce2:	9a 83       	std	Y+2, r25	; 0x02
    3ce4:	89 83       	std	Y+1, r24	; 0x01
     * https://www.FreeRTOS.org for more information. */
    ( void ) pv;

    /* Force an assert as it is invalid to call this function. */
    configASSERT( pv == NULL );
}
    3ce6:	0f 90       	pop	r0
    3ce8:	0f 90       	pop	r0
    3cea:	cf 91       	pop	r28
    3cec:	df 91       	pop	r29
    3cee:	08 95       	ret

00003cf0 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    3cf0:	df 93       	push	r29
    3cf2:	cf 93       	push	r28
    3cf4:	cd b7       	in	r28, 0x3d	; 61
    3cf6:	de b7       	in	r29, 0x3e	; 62
    /* Only required when static memory is not cleared. */
    xNextFreeByte = ( size_t ) 0;
    3cf8:	10 92 c1 01 	sts	0x01C1, r1
    3cfc:	10 92 c0 01 	sts	0x01C0, r1
}
    3d00:	cf 91       	pop	r28
    3d02:	df 91       	pop	r29
    3d04:	08 95       	ret

00003d06 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    3d06:	df 93       	push	r29
    3d08:	cf 93       	push	r28
    3d0a:	cd b7       	in	r28, 0x3d	; 61
    3d0c:	de b7       	in	r29, 0x3e	; 62
    return( configADJUSTED_HEAP_SIZE - xNextFreeByte );
    3d0e:	20 91 c0 01 	lds	r18, 0x01C0
    3d12:	30 91 c1 01 	lds	r19, 0x01C1
    3d16:	8b ed       	ldi	r24, 0xDB	; 219
    3d18:	95 e0       	ldi	r25, 0x05	; 5
    3d1a:	82 1b       	sub	r24, r18
    3d1c:	93 0b       	sbc	r25, r19
}
    3d1e:	cf 91       	pop	r28
    3d20:	df 91       	pop	r29
    3d22:	08 95       	ret

00003d24 <vListInitialise>:
/*-----------------------------------------------------------
* PUBLIC LIST API documented in list.h
*----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    3d24:	df 93       	push	r29
    3d26:	cf 93       	push	r28
    3d28:	00 d0       	rcall	.+0      	; 0x3d2a <vListInitialise+0x6>
    3d2a:	cd b7       	in	r28, 0x3d	; 61
    3d2c:	de b7       	in	r29, 0x3e	; 62
    3d2e:	9a 83       	std	Y+2, r25	; 0x02
    3d30:	89 83       	std	Y+1, r24	; 0x01
    /* The list structure contains a list item which is used to mark the
     * end of the list.  To initialise the list the list end is inserted
     * as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    3d32:	89 81       	ldd	r24, Y+1	; 0x01
    3d34:	9a 81       	ldd	r25, Y+2	; 0x02
    3d36:	03 96       	adiw	r24, 0x03	; 3
    3d38:	e9 81       	ldd	r30, Y+1	; 0x01
    3d3a:	fa 81       	ldd	r31, Y+2	; 0x02
    3d3c:	92 83       	std	Z+2, r25	; 0x02
    3d3e:	81 83       	std	Z+1, r24	; 0x01

    /* The list end value is the highest possible value in the list to
     * ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
    3d40:	e9 81       	ldd	r30, Y+1	; 0x01
    3d42:	fa 81       	ldd	r31, Y+2	; 0x02
    3d44:	8f ef       	ldi	r24, 0xFF	; 255
    3d46:	9f ef       	ldi	r25, 0xFF	; 255
    3d48:	94 83       	std	Z+4, r25	; 0x04
    3d4a:	83 83       	std	Z+3, r24	; 0x03

    /* The list end next and previous pointers point to itself so we know
     * when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );     /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    3d4c:	89 81       	ldd	r24, Y+1	; 0x01
    3d4e:	9a 81       	ldd	r25, Y+2	; 0x02
    3d50:	03 96       	adiw	r24, 0x03	; 3
    3d52:	e9 81       	ldd	r30, Y+1	; 0x01
    3d54:	fa 81       	ldd	r31, Y+2	; 0x02
    3d56:	96 83       	std	Z+6, r25	; 0x06
    3d58:	85 83       	std	Z+5, r24	; 0x05
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    3d5a:	89 81       	ldd	r24, Y+1	; 0x01
    3d5c:	9a 81       	ldd	r25, Y+2	; 0x02
    3d5e:	03 96       	adiw	r24, 0x03	; 3
    3d60:	e9 81       	ldd	r30, Y+1	; 0x01
    3d62:	fa 81       	ldd	r31, Y+2	; 0x02
    3d64:	90 87       	std	Z+8, r25	; 0x08
    3d66:	87 83       	std	Z+7, r24	; 0x07

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    3d68:	e9 81       	ldd	r30, Y+1	; 0x01
    3d6a:	fa 81       	ldd	r31, Y+2	; 0x02
    3d6c:	10 82       	st	Z, r1

    /* Write known values into the list if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
    listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
    3d6e:	0f 90       	pop	r0
    3d70:	0f 90       	pop	r0
    3d72:	cf 91       	pop	r28
    3d74:	df 91       	pop	r29
    3d76:	08 95       	ret

00003d78 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    3d78:	df 93       	push	r29
    3d7a:	cf 93       	push	r28
    3d7c:	00 d0       	rcall	.+0      	; 0x3d7e <vListInitialiseItem+0x6>
    3d7e:	cd b7       	in	r28, 0x3d	; 61
    3d80:	de b7       	in	r29, 0x3e	; 62
    3d82:	9a 83       	std	Y+2, r25	; 0x02
    3d84:	89 83       	std	Y+1, r24	; 0x01
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
    3d86:	e9 81       	ldd	r30, Y+1	; 0x01
    3d88:	fa 81       	ldd	r31, Y+2	; 0x02
    3d8a:	11 86       	std	Z+9, r1	; 0x09
    3d8c:	10 86       	std	Z+8, r1	; 0x08

    /* Write known values into the list item if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
    3d8e:	0f 90       	pop	r0
    3d90:	0f 90       	pop	r0
    3d92:	cf 91       	pop	r28
    3d94:	df 91       	pop	r29
    3d96:	08 95       	ret

00003d98 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList,
                     ListItem_t * const pxNewListItem )
{
    3d98:	df 93       	push	r29
    3d9a:	cf 93       	push	r28
    3d9c:	00 d0       	rcall	.+0      	; 0x3d9e <vListInsertEnd+0x6>
    3d9e:	00 d0       	rcall	.+0      	; 0x3da0 <vListInsertEnd+0x8>
    3da0:	00 d0       	rcall	.+0      	; 0x3da2 <vListInsertEnd+0xa>
    3da2:	cd b7       	in	r28, 0x3d	; 61
    3da4:	de b7       	in	r29, 0x3e	; 62
    3da6:	9c 83       	std	Y+4, r25	; 0x04
    3da8:	8b 83       	std	Y+3, r24	; 0x03
    3daa:	7e 83       	std	Y+6, r23	; 0x06
    3dac:	6d 83       	std	Y+5, r22	; 0x05
    ListItem_t * const pxIndex = pxList->pxIndex;
    3dae:	eb 81       	ldd	r30, Y+3	; 0x03
    3db0:	fc 81       	ldd	r31, Y+4	; 0x04
    3db2:	81 81       	ldd	r24, Z+1	; 0x01
    3db4:	92 81       	ldd	r25, Z+2	; 0x02
    3db6:	9a 83       	std	Y+2, r25	; 0x02
    3db8:	89 83       	std	Y+1, r24	; 0x01
    listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

    /* Insert a new list item into pxList, but rather than sort the list,
     * makes the new list item the last item to be removed by a call to
     * listGET_OWNER_OF_NEXT_ENTRY(). */
    pxNewListItem->pxNext = pxIndex;
    3dba:	ed 81       	ldd	r30, Y+5	; 0x05
    3dbc:	fe 81       	ldd	r31, Y+6	; 0x06
    3dbe:	89 81       	ldd	r24, Y+1	; 0x01
    3dc0:	9a 81       	ldd	r25, Y+2	; 0x02
    3dc2:	93 83       	std	Z+3, r25	; 0x03
    3dc4:	82 83       	std	Z+2, r24	; 0x02
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    3dc6:	e9 81       	ldd	r30, Y+1	; 0x01
    3dc8:	fa 81       	ldd	r31, Y+2	; 0x02
    3dca:	84 81       	ldd	r24, Z+4	; 0x04
    3dcc:	95 81       	ldd	r25, Z+5	; 0x05
    3dce:	ed 81       	ldd	r30, Y+5	; 0x05
    3dd0:	fe 81       	ldd	r31, Y+6	; 0x06
    3dd2:	95 83       	std	Z+5, r25	; 0x05
    3dd4:	84 83       	std	Z+4, r24	; 0x04

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    pxIndex->pxPrevious->pxNext = pxNewListItem;
    3dd6:	e9 81       	ldd	r30, Y+1	; 0x01
    3dd8:	fa 81       	ldd	r31, Y+2	; 0x02
    3dda:	04 80       	ldd	r0, Z+4	; 0x04
    3ddc:	f5 81       	ldd	r31, Z+5	; 0x05
    3dde:	e0 2d       	mov	r30, r0
    3de0:	8d 81       	ldd	r24, Y+5	; 0x05
    3de2:	9e 81       	ldd	r25, Y+6	; 0x06
    3de4:	93 83       	std	Z+3, r25	; 0x03
    3de6:	82 83       	std	Z+2, r24	; 0x02
    pxIndex->pxPrevious = pxNewListItem;
    3de8:	e9 81       	ldd	r30, Y+1	; 0x01
    3dea:	fa 81       	ldd	r31, Y+2	; 0x02
    3dec:	8d 81       	ldd	r24, Y+5	; 0x05
    3dee:	9e 81       	ldd	r25, Y+6	; 0x06
    3df0:	95 83       	std	Z+5, r25	; 0x05
    3df2:	84 83       	std	Z+4, r24	; 0x04

    /* Remember which list the item is in. */
    pxNewListItem->pxContainer = pxList;
    3df4:	ed 81       	ldd	r30, Y+5	; 0x05
    3df6:	fe 81       	ldd	r31, Y+6	; 0x06
    3df8:	8b 81       	ldd	r24, Y+3	; 0x03
    3dfa:	9c 81       	ldd	r25, Y+4	; 0x04
    3dfc:	91 87       	std	Z+9, r25	; 0x09
    3dfe:	80 87       	std	Z+8, r24	; 0x08

    ( pxList->uxNumberOfItems )++;
    3e00:	eb 81       	ldd	r30, Y+3	; 0x03
    3e02:	fc 81       	ldd	r31, Y+4	; 0x04
    3e04:	80 81       	ld	r24, Z
    3e06:	8f 5f       	subi	r24, 0xFF	; 255
    3e08:	eb 81       	ldd	r30, Y+3	; 0x03
    3e0a:	fc 81       	ldd	r31, Y+4	; 0x04
    3e0c:	80 83       	st	Z, r24
}
    3e0e:	26 96       	adiw	r28, 0x06	; 6
    3e10:	0f b6       	in	r0, 0x3f	; 63
    3e12:	f8 94       	cli
    3e14:	de bf       	out	0x3e, r29	; 62
    3e16:	0f be       	out	0x3f, r0	; 63
    3e18:	cd bf       	out	0x3d, r28	; 61
    3e1a:	cf 91       	pop	r28
    3e1c:	df 91       	pop	r29
    3e1e:	08 95       	ret

00003e20 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList,
                  ListItem_t * const pxNewListItem )
{
    3e20:	df 93       	push	r29
    3e22:	cf 93       	push	r28
    3e24:	cd b7       	in	r28, 0x3d	; 61
    3e26:	de b7       	in	r29, 0x3e	; 62
    3e28:	28 97       	sbiw	r28, 0x08	; 8
    3e2a:	0f b6       	in	r0, 0x3f	; 63
    3e2c:	f8 94       	cli
    3e2e:	de bf       	out	0x3e, r29	; 62
    3e30:	0f be       	out	0x3f, r0	; 63
    3e32:	cd bf       	out	0x3d, r28	; 61
    3e34:	9e 83       	std	Y+6, r25	; 0x06
    3e36:	8d 83       	std	Y+5, r24	; 0x05
    3e38:	78 87       	std	Y+8, r23	; 0x08
    3e3a:	6f 83       	std	Y+7, r22	; 0x07
    ListItem_t * pxIterator;
    const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    3e3c:	ef 81       	ldd	r30, Y+7	; 0x07
    3e3e:	f8 85       	ldd	r31, Y+8	; 0x08
    3e40:	80 81       	ld	r24, Z
    3e42:	91 81       	ldd	r25, Z+1	; 0x01
    3e44:	9a 83       	std	Y+2, r25	; 0x02
    3e46:	89 83       	std	Y+1, r24	; 0x01
     * new list item should be placed after it.  This ensures that TCBs which are
     * stored in ready lists (all of which have the same xItemValue value) get a
     * share of the CPU.  However, if the xItemValue is the same as the back marker
     * the iteration loop below will not end.  Therefore the value is checked
     * first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
    3e48:	89 81       	ldd	r24, Y+1	; 0x01
    3e4a:	9a 81       	ldd	r25, Y+2	; 0x02
    3e4c:	2f ef       	ldi	r18, 0xFF	; 255
    3e4e:	8f 3f       	cpi	r24, 0xFF	; 255
    3e50:	92 07       	cpc	r25, r18
    3e52:	39 f4       	brne	.+14     	; 0x3e62 <vListInsert+0x42>
    {
        pxIterator = pxList->xListEnd.pxPrevious;
    3e54:	ed 81       	ldd	r30, Y+5	; 0x05
    3e56:	fe 81       	ldd	r31, Y+6	; 0x06
    3e58:	87 81       	ldd	r24, Z+7	; 0x07
    3e5a:	90 85       	ldd	r25, Z+8	; 0x08
    3e5c:	9c 83       	std	Y+4, r25	; 0x04
    3e5e:	8b 83       	std	Y+3, r24	; 0x03
    3e60:	18 c0       	rjmp	.+48     	; 0x3e92 <vListInsert+0x72>
        *   5) If the FreeRTOS port supports interrupt nesting then ensure that
        *      the priority of the tick interrupt is at or below
        *      configMAX_SYSCALL_INTERRUPT_PRIORITY.
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    3e62:	8d 81       	ldd	r24, Y+5	; 0x05
    3e64:	9e 81       	ldd	r25, Y+6	; 0x06
    3e66:	03 96       	adiw	r24, 0x03	; 3
    3e68:	9c 83       	std	Y+4, r25	; 0x04
    3e6a:	8b 83       	std	Y+3, r24	; 0x03
    3e6c:	06 c0       	rjmp	.+12     	; 0x3e7a <vListInsert+0x5a>
    3e6e:	eb 81       	ldd	r30, Y+3	; 0x03
    3e70:	fc 81       	ldd	r31, Y+4	; 0x04
    3e72:	82 81       	ldd	r24, Z+2	; 0x02
    3e74:	93 81       	ldd	r25, Z+3	; 0x03
    3e76:	9c 83       	std	Y+4, r25	; 0x04
    3e78:	8b 83       	std	Y+3, r24	; 0x03
    3e7a:	eb 81       	ldd	r30, Y+3	; 0x03
    3e7c:	fc 81       	ldd	r31, Y+4	; 0x04
    3e7e:	02 80       	ldd	r0, Z+2	; 0x02
    3e80:	f3 81       	ldd	r31, Z+3	; 0x03
    3e82:	e0 2d       	mov	r30, r0
    3e84:	20 81       	ld	r18, Z
    3e86:	31 81       	ldd	r19, Z+1	; 0x01
    3e88:	89 81       	ldd	r24, Y+1	; 0x01
    3e8a:	9a 81       	ldd	r25, Y+2	; 0x02
    3e8c:	82 17       	cp	r24, r18
    3e8e:	93 07       	cpc	r25, r19
    3e90:	70 f7       	brcc	.-36     	; 0x3e6e <vListInsert+0x4e>
            /* There is nothing to do here, just iterating to the wanted
             * insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
    3e92:	eb 81       	ldd	r30, Y+3	; 0x03
    3e94:	fc 81       	ldd	r31, Y+4	; 0x04
    3e96:	82 81       	ldd	r24, Z+2	; 0x02
    3e98:	93 81       	ldd	r25, Z+3	; 0x03
    3e9a:	ef 81       	ldd	r30, Y+7	; 0x07
    3e9c:	f8 85       	ldd	r31, Y+8	; 0x08
    3e9e:	93 83       	std	Z+3, r25	; 0x03
    3ea0:	82 83       	std	Z+2, r24	; 0x02
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    3ea2:	ef 81       	ldd	r30, Y+7	; 0x07
    3ea4:	f8 85       	ldd	r31, Y+8	; 0x08
    3ea6:	02 80       	ldd	r0, Z+2	; 0x02
    3ea8:	f3 81       	ldd	r31, Z+3	; 0x03
    3eaa:	e0 2d       	mov	r30, r0
    3eac:	8f 81       	ldd	r24, Y+7	; 0x07
    3eae:	98 85       	ldd	r25, Y+8	; 0x08
    3eb0:	95 83       	std	Z+5, r25	; 0x05
    3eb2:	84 83       	std	Z+4, r24	; 0x04
    pxNewListItem->pxPrevious = pxIterator;
    3eb4:	ef 81       	ldd	r30, Y+7	; 0x07
    3eb6:	f8 85       	ldd	r31, Y+8	; 0x08
    3eb8:	8b 81       	ldd	r24, Y+3	; 0x03
    3eba:	9c 81       	ldd	r25, Y+4	; 0x04
    3ebc:	95 83       	std	Z+5, r25	; 0x05
    3ebe:	84 83       	std	Z+4, r24	; 0x04
    pxIterator->pxNext = pxNewListItem;
    3ec0:	eb 81       	ldd	r30, Y+3	; 0x03
    3ec2:	fc 81       	ldd	r31, Y+4	; 0x04
    3ec4:	8f 81       	ldd	r24, Y+7	; 0x07
    3ec6:	98 85       	ldd	r25, Y+8	; 0x08
    3ec8:	93 83       	std	Z+3, r25	; 0x03
    3eca:	82 83       	std	Z+2, r24	; 0x02

    /* Remember which list the item is in.  This allows fast removal of the
     * item later. */
    pxNewListItem->pxContainer = pxList;
    3ecc:	ef 81       	ldd	r30, Y+7	; 0x07
    3ece:	f8 85       	ldd	r31, Y+8	; 0x08
    3ed0:	8d 81       	ldd	r24, Y+5	; 0x05
    3ed2:	9e 81       	ldd	r25, Y+6	; 0x06
    3ed4:	91 87       	std	Z+9, r25	; 0x09
    3ed6:	80 87       	std	Z+8, r24	; 0x08

    ( pxList->uxNumberOfItems )++;
    3ed8:	ed 81       	ldd	r30, Y+5	; 0x05
    3eda:	fe 81       	ldd	r31, Y+6	; 0x06
    3edc:	80 81       	ld	r24, Z
    3ede:	8f 5f       	subi	r24, 0xFF	; 255
    3ee0:	ed 81       	ldd	r30, Y+5	; 0x05
    3ee2:	fe 81       	ldd	r31, Y+6	; 0x06
    3ee4:	80 83       	st	Z, r24
}
    3ee6:	28 96       	adiw	r28, 0x08	; 8
    3ee8:	0f b6       	in	r0, 0x3f	; 63
    3eea:	f8 94       	cli
    3eec:	de bf       	out	0x3e, r29	; 62
    3eee:	0f be       	out	0x3f, r0	; 63
    3ef0:	cd bf       	out	0x3d, r28	; 61
    3ef2:	cf 91       	pop	r28
    3ef4:	df 91       	pop	r29
    3ef6:	08 95       	ret

00003ef8 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    3ef8:	df 93       	push	r29
    3efa:	cf 93       	push	r28
    3efc:	00 d0       	rcall	.+0      	; 0x3efe <uxListRemove+0x6>
    3efe:	00 d0       	rcall	.+0      	; 0x3f00 <uxListRemove+0x8>
    3f00:	cd b7       	in	r28, 0x3d	; 61
    3f02:	de b7       	in	r29, 0x3e	; 62
    3f04:	9c 83       	std	Y+4, r25	; 0x04
    3f06:	8b 83       	std	Y+3, r24	; 0x03
/* The list item knows which list it is in.  Obtain the list from the list
 * item. */
    List_t * const pxList = pxItemToRemove->pxContainer;
    3f08:	eb 81       	ldd	r30, Y+3	; 0x03
    3f0a:	fc 81       	ldd	r31, Y+4	; 0x04
    3f0c:	80 85       	ldd	r24, Z+8	; 0x08
    3f0e:	91 85       	ldd	r25, Z+9	; 0x09
    3f10:	9a 83       	std	Y+2, r25	; 0x02
    3f12:	89 83       	std	Y+1, r24	; 0x01

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    3f14:	eb 81       	ldd	r30, Y+3	; 0x03
    3f16:	fc 81       	ldd	r31, Y+4	; 0x04
    3f18:	a2 81       	ldd	r26, Z+2	; 0x02
    3f1a:	b3 81       	ldd	r27, Z+3	; 0x03
    3f1c:	eb 81       	ldd	r30, Y+3	; 0x03
    3f1e:	fc 81       	ldd	r31, Y+4	; 0x04
    3f20:	84 81       	ldd	r24, Z+4	; 0x04
    3f22:	95 81       	ldd	r25, Z+5	; 0x05
    3f24:	15 96       	adiw	r26, 0x05	; 5
    3f26:	9c 93       	st	X, r25
    3f28:	8e 93       	st	-X, r24
    3f2a:	14 97       	sbiw	r26, 0x04	; 4
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    3f2c:	eb 81       	ldd	r30, Y+3	; 0x03
    3f2e:	fc 81       	ldd	r31, Y+4	; 0x04
    3f30:	a4 81       	ldd	r26, Z+4	; 0x04
    3f32:	b5 81       	ldd	r27, Z+5	; 0x05
    3f34:	eb 81       	ldd	r30, Y+3	; 0x03
    3f36:	fc 81       	ldd	r31, Y+4	; 0x04
    3f38:	82 81       	ldd	r24, Z+2	; 0x02
    3f3a:	93 81       	ldd	r25, Z+3	; 0x03
    3f3c:	13 96       	adiw	r26, 0x03	; 3
    3f3e:	9c 93       	st	X, r25
    3f40:	8e 93       	st	-X, r24
    3f42:	12 97       	sbiw	r26, 0x02	; 2

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
    3f44:	e9 81       	ldd	r30, Y+1	; 0x01
    3f46:	fa 81       	ldd	r31, Y+2	; 0x02
    3f48:	21 81       	ldd	r18, Z+1	; 0x01
    3f4a:	32 81       	ldd	r19, Z+2	; 0x02
    3f4c:	8b 81       	ldd	r24, Y+3	; 0x03
    3f4e:	9c 81       	ldd	r25, Y+4	; 0x04
    3f50:	28 17       	cp	r18, r24
    3f52:	39 07       	cpc	r19, r25
    3f54:	41 f4       	brne	.+16     	; 0x3f66 <uxListRemove+0x6e>
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
    3f56:	eb 81       	ldd	r30, Y+3	; 0x03
    3f58:	fc 81       	ldd	r31, Y+4	; 0x04
    3f5a:	84 81       	ldd	r24, Z+4	; 0x04
    3f5c:	95 81       	ldd	r25, Z+5	; 0x05
    3f5e:	e9 81       	ldd	r30, Y+1	; 0x01
    3f60:	fa 81       	ldd	r31, Y+2	; 0x02
    3f62:	92 83       	std	Z+2, r25	; 0x02
    3f64:	81 83       	std	Z+1, r24	; 0x01
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
    3f66:	eb 81       	ldd	r30, Y+3	; 0x03
    3f68:	fc 81       	ldd	r31, Y+4	; 0x04
    3f6a:	11 86       	std	Z+9, r1	; 0x09
    3f6c:	10 86       	std	Z+8, r1	; 0x08
    ( pxList->uxNumberOfItems )--;
    3f6e:	e9 81       	ldd	r30, Y+1	; 0x01
    3f70:	fa 81       	ldd	r31, Y+2	; 0x02
    3f72:	80 81       	ld	r24, Z
    3f74:	81 50       	subi	r24, 0x01	; 1
    3f76:	e9 81       	ldd	r30, Y+1	; 0x01
    3f78:	fa 81       	ldd	r31, Y+2	; 0x02
    3f7a:	80 83       	st	Z, r24

    return pxList->uxNumberOfItems;
    3f7c:	e9 81       	ldd	r30, Y+1	; 0x01
    3f7e:	fa 81       	ldd	r31, Y+2	; 0x02
    3f80:	80 81       	ld	r24, Z
}
    3f82:	0f 90       	pop	r0
    3f84:	0f 90       	pop	r0
    3f86:	0f 90       	pop	r0
    3f88:	0f 90       	pop	r0
    3f8a:	cf 91       	pop	r28
    3f8c:	df 91       	pop	r29
    3f8e:	08 95       	ret

00003f90 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    3f90:	df 93       	push	r29
    3f92:	cf 93       	push	r28
    3f94:	cd b7       	in	r28, 0x3d	; 61
    3f96:	de b7       	in	r29, 0x3e	; 62
    3f98:	28 97       	sbiw	r28, 0x08	; 8
    3f9a:	0f b6       	in	r0, 0x3f	; 63
    3f9c:	f8 94       	cli
    3f9e:	de bf       	out	0x3e, r29	; 62
    3fa0:	0f be       	out	0x3f, r0	; 63
    3fa2:	cd bf       	out	0x3d, r28	; 61
    3fa4:	9c 83       	std	Y+4, r25	; 0x04
    3fa6:	8b 83       	std	Y+3, r24	; 0x03
    3fa8:	7e 83       	std	Y+6, r23	; 0x06
    3faa:	6d 83       	std	Y+5, r22	; 0x05
    3fac:	58 87       	std	Y+8, r21	; 0x08
    3fae:	4f 83       	std	Y+7, r20	; 0x07
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    3fb0:	eb 81       	ldd	r30, Y+3	; 0x03
    3fb2:	fc 81       	ldd	r31, Y+4	; 0x04
    3fb4:	81 e1       	ldi	r24, 0x11	; 17
    3fb6:	80 83       	st	Z, r24
	pxTopOfStack--;
    3fb8:	8b 81       	ldd	r24, Y+3	; 0x03
    3fba:	9c 81       	ldd	r25, Y+4	; 0x04
    3fbc:	01 97       	sbiw	r24, 0x01	; 1
    3fbe:	9c 83       	std	Y+4, r25	; 0x04
    3fc0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    3fc2:	eb 81       	ldd	r30, Y+3	; 0x03
    3fc4:	fc 81       	ldd	r31, Y+4	; 0x04
    3fc6:	82 e2       	ldi	r24, 0x22	; 34
    3fc8:	80 83       	st	Z, r24
	pxTopOfStack--;
    3fca:	8b 81       	ldd	r24, Y+3	; 0x03
    3fcc:	9c 81       	ldd	r25, Y+4	; 0x04
    3fce:	01 97       	sbiw	r24, 0x01	; 1
    3fd0:	9c 83       	std	Y+4, r25	; 0x04
    3fd2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    3fd4:	eb 81       	ldd	r30, Y+3	; 0x03
    3fd6:	fc 81       	ldd	r31, Y+4	; 0x04
    3fd8:	83 e3       	ldi	r24, 0x33	; 51
    3fda:	80 83       	st	Z, r24
	pxTopOfStack--;
    3fdc:	8b 81       	ldd	r24, Y+3	; 0x03
    3fde:	9c 81       	ldd	r25, Y+4	; 0x04
    3fe0:	01 97       	sbiw	r24, 0x01	; 1
    3fe2:	9c 83       	std	Y+4, r25	; 0x04
    3fe4:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
    3fe6:	8d 81       	ldd	r24, Y+5	; 0x05
    3fe8:	9e 81       	ldd	r25, Y+6	; 0x06
    3fea:	9a 83       	std	Y+2, r25	; 0x02
    3fec:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    3fee:	89 81       	ldd	r24, Y+1	; 0x01
    3ff0:	eb 81       	ldd	r30, Y+3	; 0x03
    3ff2:	fc 81       	ldd	r31, Y+4	; 0x04
    3ff4:	80 83       	st	Z, r24
	pxTopOfStack--;
    3ff6:	8b 81       	ldd	r24, Y+3	; 0x03
    3ff8:	9c 81       	ldd	r25, Y+4	; 0x04
    3ffa:	01 97       	sbiw	r24, 0x01	; 1
    3ffc:	9c 83       	std	Y+4, r25	; 0x04
    3ffe:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    4000:	89 81       	ldd	r24, Y+1	; 0x01
    4002:	9a 81       	ldd	r25, Y+2	; 0x02
    4004:	89 2f       	mov	r24, r25
    4006:	99 27       	eor	r25, r25
    4008:	9a 83       	std	Y+2, r25	; 0x02
    400a:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    400c:	89 81       	ldd	r24, Y+1	; 0x01
    400e:	eb 81       	ldd	r30, Y+3	; 0x03
    4010:	fc 81       	ldd	r31, Y+4	; 0x04
    4012:	80 83       	st	Z, r24
	pxTopOfStack--;
    4014:	8b 81       	ldd	r24, Y+3	; 0x03
    4016:	9c 81       	ldd	r25, Y+4	; 0x04
    4018:	01 97       	sbiw	r24, 0x01	; 1
    401a:	9c 83       	std	Y+4, r25	; 0x04
    401c:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    401e:	eb 81       	ldd	r30, Y+3	; 0x03
    4020:	fc 81       	ldd	r31, Y+4	; 0x04
    4022:	10 82       	st	Z, r1
	pxTopOfStack--;
    4024:	8b 81       	ldd	r24, Y+3	; 0x03
    4026:	9c 81       	ldd	r25, Y+4	; 0x04
    4028:	01 97       	sbiw	r24, 0x01	; 1
    402a:	9c 83       	std	Y+4, r25	; 0x04
    402c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    402e:	eb 81       	ldd	r30, Y+3	; 0x03
    4030:	fc 81       	ldd	r31, Y+4	; 0x04
    4032:	80 e8       	ldi	r24, 0x80	; 128
    4034:	80 83       	st	Z, r24
	pxTopOfStack--;
    4036:	8b 81       	ldd	r24, Y+3	; 0x03
    4038:	9c 81       	ldd	r25, Y+4	; 0x04
    403a:	01 97       	sbiw	r24, 0x01	; 1
    403c:	9c 83       	std	Y+4, r25	; 0x04
    403e:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    4040:	eb 81       	ldd	r30, Y+3	; 0x03
    4042:	fc 81       	ldd	r31, Y+4	; 0x04
    4044:	10 82       	st	Z, r1
	pxTopOfStack--;
    4046:	8b 81       	ldd	r24, Y+3	; 0x03
    4048:	9c 81       	ldd	r25, Y+4	; 0x04
    404a:	01 97       	sbiw	r24, 0x01	; 1
    404c:	9c 83       	std	Y+4, r25	; 0x04
    404e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    4050:	eb 81       	ldd	r30, Y+3	; 0x03
    4052:	fc 81       	ldd	r31, Y+4	; 0x04
    4054:	82 e0       	ldi	r24, 0x02	; 2
    4056:	80 83       	st	Z, r24
	pxTopOfStack--;
    4058:	8b 81       	ldd	r24, Y+3	; 0x03
    405a:	9c 81       	ldd	r25, Y+4	; 0x04
    405c:	01 97       	sbiw	r24, 0x01	; 1
    405e:	9c 83       	std	Y+4, r25	; 0x04
    4060:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    4062:	eb 81       	ldd	r30, Y+3	; 0x03
    4064:	fc 81       	ldd	r31, Y+4	; 0x04
    4066:	83 e0       	ldi	r24, 0x03	; 3
    4068:	80 83       	st	Z, r24
	pxTopOfStack--;
    406a:	8b 81       	ldd	r24, Y+3	; 0x03
    406c:	9c 81       	ldd	r25, Y+4	; 0x04
    406e:	01 97       	sbiw	r24, 0x01	; 1
    4070:	9c 83       	std	Y+4, r25	; 0x04
    4072:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    4074:	eb 81       	ldd	r30, Y+3	; 0x03
    4076:	fc 81       	ldd	r31, Y+4	; 0x04
    4078:	84 e0       	ldi	r24, 0x04	; 4
    407a:	80 83       	st	Z, r24
	pxTopOfStack--;
    407c:	8b 81       	ldd	r24, Y+3	; 0x03
    407e:	9c 81       	ldd	r25, Y+4	; 0x04
    4080:	01 97       	sbiw	r24, 0x01	; 1
    4082:	9c 83       	std	Y+4, r25	; 0x04
    4084:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    4086:	eb 81       	ldd	r30, Y+3	; 0x03
    4088:	fc 81       	ldd	r31, Y+4	; 0x04
    408a:	85 e0       	ldi	r24, 0x05	; 5
    408c:	80 83       	st	Z, r24
	pxTopOfStack--;
    408e:	8b 81       	ldd	r24, Y+3	; 0x03
    4090:	9c 81       	ldd	r25, Y+4	; 0x04
    4092:	01 97       	sbiw	r24, 0x01	; 1
    4094:	9c 83       	std	Y+4, r25	; 0x04
    4096:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    4098:	eb 81       	ldd	r30, Y+3	; 0x03
    409a:	fc 81       	ldd	r31, Y+4	; 0x04
    409c:	86 e0       	ldi	r24, 0x06	; 6
    409e:	80 83       	st	Z, r24
	pxTopOfStack--;
    40a0:	8b 81       	ldd	r24, Y+3	; 0x03
    40a2:	9c 81       	ldd	r25, Y+4	; 0x04
    40a4:	01 97       	sbiw	r24, 0x01	; 1
    40a6:	9c 83       	std	Y+4, r25	; 0x04
    40a8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    40aa:	eb 81       	ldd	r30, Y+3	; 0x03
    40ac:	fc 81       	ldd	r31, Y+4	; 0x04
    40ae:	87 e0       	ldi	r24, 0x07	; 7
    40b0:	80 83       	st	Z, r24
	pxTopOfStack--;
    40b2:	8b 81       	ldd	r24, Y+3	; 0x03
    40b4:	9c 81       	ldd	r25, Y+4	; 0x04
    40b6:	01 97       	sbiw	r24, 0x01	; 1
    40b8:	9c 83       	std	Y+4, r25	; 0x04
    40ba:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    40bc:	eb 81       	ldd	r30, Y+3	; 0x03
    40be:	fc 81       	ldd	r31, Y+4	; 0x04
    40c0:	88 e0       	ldi	r24, 0x08	; 8
    40c2:	80 83       	st	Z, r24
	pxTopOfStack--;
    40c4:	8b 81       	ldd	r24, Y+3	; 0x03
    40c6:	9c 81       	ldd	r25, Y+4	; 0x04
    40c8:	01 97       	sbiw	r24, 0x01	; 1
    40ca:	9c 83       	std	Y+4, r25	; 0x04
    40cc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    40ce:	eb 81       	ldd	r30, Y+3	; 0x03
    40d0:	fc 81       	ldd	r31, Y+4	; 0x04
    40d2:	89 e0       	ldi	r24, 0x09	; 9
    40d4:	80 83       	st	Z, r24
	pxTopOfStack--;
    40d6:	8b 81       	ldd	r24, Y+3	; 0x03
    40d8:	9c 81       	ldd	r25, Y+4	; 0x04
    40da:	01 97       	sbiw	r24, 0x01	; 1
    40dc:	9c 83       	std	Y+4, r25	; 0x04
    40de:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    40e0:	eb 81       	ldd	r30, Y+3	; 0x03
    40e2:	fc 81       	ldd	r31, Y+4	; 0x04
    40e4:	80 e1       	ldi	r24, 0x10	; 16
    40e6:	80 83       	st	Z, r24
	pxTopOfStack--;
    40e8:	8b 81       	ldd	r24, Y+3	; 0x03
    40ea:	9c 81       	ldd	r25, Y+4	; 0x04
    40ec:	01 97       	sbiw	r24, 0x01	; 1
    40ee:	9c 83       	std	Y+4, r25	; 0x04
    40f0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    40f2:	eb 81       	ldd	r30, Y+3	; 0x03
    40f4:	fc 81       	ldd	r31, Y+4	; 0x04
    40f6:	81 e1       	ldi	r24, 0x11	; 17
    40f8:	80 83       	st	Z, r24
	pxTopOfStack--;
    40fa:	8b 81       	ldd	r24, Y+3	; 0x03
    40fc:	9c 81       	ldd	r25, Y+4	; 0x04
    40fe:	01 97       	sbiw	r24, 0x01	; 1
    4100:	9c 83       	std	Y+4, r25	; 0x04
    4102:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    4104:	eb 81       	ldd	r30, Y+3	; 0x03
    4106:	fc 81       	ldd	r31, Y+4	; 0x04
    4108:	82 e1       	ldi	r24, 0x12	; 18
    410a:	80 83       	st	Z, r24
	pxTopOfStack--;
    410c:	8b 81       	ldd	r24, Y+3	; 0x03
    410e:	9c 81       	ldd	r25, Y+4	; 0x04
    4110:	01 97       	sbiw	r24, 0x01	; 1
    4112:	9c 83       	std	Y+4, r25	; 0x04
    4114:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    4116:	eb 81       	ldd	r30, Y+3	; 0x03
    4118:	fc 81       	ldd	r31, Y+4	; 0x04
    411a:	83 e1       	ldi	r24, 0x13	; 19
    411c:	80 83       	st	Z, r24
	pxTopOfStack--;
    411e:	8b 81       	ldd	r24, Y+3	; 0x03
    4120:	9c 81       	ldd	r25, Y+4	; 0x04
    4122:	01 97       	sbiw	r24, 0x01	; 1
    4124:	9c 83       	std	Y+4, r25	; 0x04
    4126:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    4128:	eb 81       	ldd	r30, Y+3	; 0x03
    412a:	fc 81       	ldd	r31, Y+4	; 0x04
    412c:	84 e1       	ldi	r24, 0x14	; 20
    412e:	80 83       	st	Z, r24
	pxTopOfStack--;
    4130:	8b 81       	ldd	r24, Y+3	; 0x03
    4132:	9c 81       	ldd	r25, Y+4	; 0x04
    4134:	01 97       	sbiw	r24, 0x01	; 1
    4136:	9c 83       	std	Y+4, r25	; 0x04
    4138:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    413a:	eb 81       	ldd	r30, Y+3	; 0x03
    413c:	fc 81       	ldd	r31, Y+4	; 0x04
    413e:	85 e1       	ldi	r24, 0x15	; 21
    4140:	80 83       	st	Z, r24
	pxTopOfStack--;
    4142:	8b 81       	ldd	r24, Y+3	; 0x03
    4144:	9c 81       	ldd	r25, Y+4	; 0x04
    4146:	01 97       	sbiw	r24, 0x01	; 1
    4148:	9c 83       	std	Y+4, r25	; 0x04
    414a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    414c:	eb 81       	ldd	r30, Y+3	; 0x03
    414e:	fc 81       	ldd	r31, Y+4	; 0x04
    4150:	86 e1       	ldi	r24, 0x16	; 22
    4152:	80 83       	st	Z, r24
	pxTopOfStack--;
    4154:	8b 81       	ldd	r24, Y+3	; 0x03
    4156:	9c 81       	ldd	r25, Y+4	; 0x04
    4158:	01 97       	sbiw	r24, 0x01	; 1
    415a:	9c 83       	std	Y+4, r25	; 0x04
    415c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    415e:	eb 81       	ldd	r30, Y+3	; 0x03
    4160:	fc 81       	ldd	r31, Y+4	; 0x04
    4162:	87 e1       	ldi	r24, 0x17	; 23
    4164:	80 83       	st	Z, r24
	pxTopOfStack--;
    4166:	8b 81       	ldd	r24, Y+3	; 0x03
    4168:	9c 81       	ldd	r25, Y+4	; 0x04
    416a:	01 97       	sbiw	r24, 0x01	; 1
    416c:	9c 83       	std	Y+4, r25	; 0x04
    416e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    4170:	eb 81       	ldd	r30, Y+3	; 0x03
    4172:	fc 81       	ldd	r31, Y+4	; 0x04
    4174:	88 e1       	ldi	r24, 0x18	; 24
    4176:	80 83       	st	Z, r24
	pxTopOfStack--;
    4178:	8b 81       	ldd	r24, Y+3	; 0x03
    417a:	9c 81       	ldd	r25, Y+4	; 0x04
    417c:	01 97       	sbiw	r24, 0x01	; 1
    417e:	9c 83       	std	Y+4, r25	; 0x04
    4180:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    4182:	eb 81       	ldd	r30, Y+3	; 0x03
    4184:	fc 81       	ldd	r31, Y+4	; 0x04
    4186:	89 e1       	ldi	r24, 0x19	; 25
    4188:	80 83       	st	Z, r24
	pxTopOfStack--;
    418a:	8b 81       	ldd	r24, Y+3	; 0x03
    418c:	9c 81       	ldd	r25, Y+4	; 0x04
    418e:	01 97       	sbiw	r24, 0x01	; 1
    4190:	9c 83       	std	Y+4, r25	; 0x04
    4192:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    4194:	eb 81       	ldd	r30, Y+3	; 0x03
    4196:	fc 81       	ldd	r31, Y+4	; 0x04
    4198:	80 e2       	ldi	r24, 0x20	; 32
    419a:	80 83       	st	Z, r24
	pxTopOfStack--;
    419c:	8b 81       	ldd	r24, Y+3	; 0x03
    419e:	9c 81       	ldd	r25, Y+4	; 0x04
    41a0:	01 97       	sbiw	r24, 0x01	; 1
    41a2:	9c 83       	std	Y+4, r25	; 0x04
    41a4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    41a6:	eb 81       	ldd	r30, Y+3	; 0x03
    41a8:	fc 81       	ldd	r31, Y+4	; 0x04
    41aa:	81 e2       	ldi	r24, 0x21	; 33
    41ac:	80 83       	st	Z, r24
	pxTopOfStack--;
    41ae:	8b 81       	ldd	r24, Y+3	; 0x03
    41b0:	9c 81       	ldd	r25, Y+4	; 0x04
    41b2:	01 97       	sbiw	r24, 0x01	; 1
    41b4:	9c 83       	std	Y+4, r25	; 0x04
    41b6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    41b8:	eb 81       	ldd	r30, Y+3	; 0x03
    41ba:	fc 81       	ldd	r31, Y+4	; 0x04
    41bc:	82 e2       	ldi	r24, 0x22	; 34
    41be:	80 83       	st	Z, r24
	pxTopOfStack--;
    41c0:	8b 81       	ldd	r24, Y+3	; 0x03
    41c2:	9c 81       	ldd	r25, Y+4	; 0x04
    41c4:	01 97       	sbiw	r24, 0x01	; 1
    41c6:	9c 83       	std	Y+4, r25	; 0x04
    41c8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    41ca:	eb 81       	ldd	r30, Y+3	; 0x03
    41cc:	fc 81       	ldd	r31, Y+4	; 0x04
    41ce:	83 e2       	ldi	r24, 0x23	; 35
    41d0:	80 83       	st	Z, r24
	pxTopOfStack--;
    41d2:	8b 81       	ldd	r24, Y+3	; 0x03
    41d4:	9c 81       	ldd	r25, Y+4	; 0x04
    41d6:	01 97       	sbiw	r24, 0x01	; 1
    41d8:	9c 83       	std	Y+4, r25	; 0x04
    41da:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
    41dc:	8f 81       	ldd	r24, Y+7	; 0x07
    41de:	98 85       	ldd	r25, Y+8	; 0x08
    41e0:	9a 83       	std	Y+2, r25	; 0x02
    41e2:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    41e4:	89 81       	ldd	r24, Y+1	; 0x01
    41e6:	eb 81       	ldd	r30, Y+3	; 0x03
    41e8:	fc 81       	ldd	r31, Y+4	; 0x04
    41ea:	80 83       	st	Z, r24
	pxTopOfStack--;
    41ec:	8b 81       	ldd	r24, Y+3	; 0x03
    41ee:	9c 81       	ldd	r25, Y+4	; 0x04
    41f0:	01 97       	sbiw	r24, 0x01	; 1
    41f2:	9c 83       	std	Y+4, r25	; 0x04
    41f4:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    41f6:	89 81       	ldd	r24, Y+1	; 0x01
    41f8:	9a 81       	ldd	r25, Y+2	; 0x02
    41fa:	89 2f       	mov	r24, r25
    41fc:	99 27       	eor	r25, r25
    41fe:	9a 83       	std	Y+2, r25	; 0x02
    4200:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    4202:	89 81       	ldd	r24, Y+1	; 0x01
    4204:	eb 81       	ldd	r30, Y+3	; 0x03
    4206:	fc 81       	ldd	r31, Y+4	; 0x04
    4208:	80 83       	st	Z, r24
	pxTopOfStack--;
    420a:	8b 81       	ldd	r24, Y+3	; 0x03
    420c:	9c 81       	ldd	r25, Y+4	; 0x04
    420e:	01 97       	sbiw	r24, 0x01	; 1
    4210:	9c 83       	std	Y+4, r25	; 0x04
    4212:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    4214:	eb 81       	ldd	r30, Y+3	; 0x03
    4216:	fc 81       	ldd	r31, Y+4	; 0x04
    4218:	86 e2       	ldi	r24, 0x26	; 38
    421a:	80 83       	st	Z, r24
	pxTopOfStack--;
    421c:	8b 81       	ldd	r24, Y+3	; 0x03
    421e:	9c 81       	ldd	r25, Y+4	; 0x04
    4220:	01 97       	sbiw	r24, 0x01	; 1
    4222:	9c 83       	std	Y+4, r25	; 0x04
    4224:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    4226:	eb 81       	ldd	r30, Y+3	; 0x03
    4228:	fc 81       	ldd	r31, Y+4	; 0x04
    422a:	87 e2       	ldi	r24, 0x27	; 39
    422c:	80 83       	st	Z, r24
	pxTopOfStack--;
    422e:	8b 81       	ldd	r24, Y+3	; 0x03
    4230:	9c 81       	ldd	r25, Y+4	; 0x04
    4232:	01 97       	sbiw	r24, 0x01	; 1
    4234:	9c 83       	std	Y+4, r25	; 0x04
    4236:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    4238:	eb 81       	ldd	r30, Y+3	; 0x03
    423a:	fc 81       	ldd	r31, Y+4	; 0x04
    423c:	88 e2       	ldi	r24, 0x28	; 40
    423e:	80 83       	st	Z, r24
	pxTopOfStack--;
    4240:	8b 81       	ldd	r24, Y+3	; 0x03
    4242:	9c 81       	ldd	r25, Y+4	; 0x04
    4244:	01 97       	sbiw	r24, 0x01	; 1
    4246:	9c 83       	std	Y+4, r25	; 0x04
    4248:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    424a:	eb 81       	ldd	r30, Y+3	; 0x03
    424c:	fc 81       	ldd	r31, Y+4	; 0x04
    424e:	89 e2       	ldi	r24, 0x29	; 41
    4250:	80 83       	st	Z, r24
	pxTopOfStack--;
    4252:	8b 81       	ldd	r24, Y+3	; 0x03
    4254:	9c 81       	ldd	r25, Y+4	; 0x04
    4256:	01 97       	sbiw	r24, 0x01	; 1
    4258:	9c 83       	std	Y+4, r25	; 0x04
    425a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    425c:	eb 81       	ldd	r30, Y+3	; 0x03
    425e:	fc 81       	ldd	r31, Y+4	; 0x04
    4260:	80 e3       	ldi	r24, 0x30	; 48
    4262:	80 83       	st	Z, r24
	pxTopOfStack--;
    4264:	8b 81       	ldd	r24, Y+3	; 0x03
    4266:	9c 81       	ldd	r25, Y+4	; 0x04
    4268:	01 97       	sbiw	r24, 0x01	; 1
    426a:	9c 83       	std	Y+4, r25	; 0x04
    426c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    426e:	eb 81       	ldd	r30, Y+3	; 0x03
    4270:	fc 81       	ldd	r31, Y+4	; 0x04
    4272:	81 e3       	ldi	r24, 0x31	; 49
    4274:	80 83       	st	Z, r24
	pxTopOfStack--;
    4276:	8b 81       	ldd	r24, Y+3	; 0x03
    4278:	9c 81       	ldd	r25, Y+4	; 0x04
    427a:	01 97       	sbiw	r24, 0x01	; 1
    427c:	9c 83       	std	Y+4, r25	; 0x04
    427e:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    4280:	8b 81       	ldd	r24, Y+3	; 0x03
    4282:	9c 81       	ldd	r25, Y+4	; 0x04
}
    4284:	28 96       	adiw	r28, 0x08	; 8
    4286:	0f b6       	in	r0, 0x3f	; 63
    4288:	f8 94       	cli
    428a:	de bf       	out	0x3e, r29	; 62
    428c:	0f be       	out	0x3f, r0	; 63
    428e:	cd bf       	out	0x3d, r28	; 61
    4290:	cf 91       	pop	r28
    4292:	df 91       	pop	r29
    4294:	08 95       	ret

00004296 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
    4296:	df 93       	push	r29
    4298:	cf 93       	push	r28
    429a:	cd b7       	in	r28, 0x3d	; 61
    429c:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    429e:	0e 94 3d 22 	call	0x447a	; 0x447a <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    42a2:	a0 91 a0 07 	lds	r26, 0x07A0
    42a6:	b0 91 a1 07 	lds	r27, 0x07A1
    42aa:	cd 91       	ld	r28, X+
    42ac:	cd bf       	out	0x3d, r28	; 61
    42ae:	dd 91       	ld	r29, X+
    42b0:	de bf       	out	0x3e, r29	; 62
    42b2:	ff 91       	pop	r31
    42b4:	ef 91       	pop	r30
    42b6:	df 91       	pop	r29
    42b8:	cf 91       	pop	r28
    42ba:	bf 91       	pop	r27
    42bc:	af 91       	pop	r26
    42be:	9f 91       	pop	r25
    42c0:	8f 91       	pop	r24
    42c2:	7f 91       	pop	r23
    42c4:	6f 91       	pop	r22
    42c6:	5f 91       	pop	r21
    42c8:	4f 91       	pop	r20
    42ca:	3f 91       	pop	r19
    42cc:	2f 91       	pop	r18
    42ce:	1f 91       	pop	r17
    42d0:	0f 91       	pop	r16
    42d2:	ff 90       	pop	r15
    42d4:	ef 90       	pop	r14
    42d6:	df 90       	pop	r13
    42d8:	cf 90       	pop	r12
    42da:	bf 90       	pop	r11
    42dc:	af 90       	pop	r10
    42de:	9f 90       	pop	r9
    42e0:	8f 90       	pop	r8
    42e2:	7f 90       	pop	r7
    42e4:	6f 90       	pop	r6
    42e6:	5f 90       	pop	r5
    42e8:	4f 90       	pop	r4
    42ea:	3f 90       	pop	r3
    42ec:	2f 90       	pop	r2
    42ee:	1f 90       	pop	r1
    42f0:	0f 90       	pop	r0
    42f2:	0f be       	out	0x3f, r0	; 63
    42f4:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    42f6:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    42f8:	81 e0       	ldi	r24, 0x01	; 1
}
    42fa:	cf 91       	pop	r28
    42fc:	df 91       	pop	r29
    42fe:	08 95       	ret

00004300 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    4300:	df 93       	push	r29
    4302:	cf 93       	push	r28
    4304:	cd b7       	in	r28, 0x3d	; 61
    4306:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    4308:	cf 91       	pop	r28
    430a:	df 91       	pop	r29
    430c:	08 95       	ret

0000430e <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    430e:	0f 92       	push	r0
    4310:	0f b6       	in	r0, 0x3f	; 63
    4312:	f8 94       	cli
    4314:	0f 92       	push	r0
    4316:	1f 92       	push	r1
    4318:	11 24       	eor	r1, r1
    431a:	2f 92       	push	r2
    431c:	3f 92       	push	r3
    431e:	4f 92       	push	r4
    4320:	5f 92       	push	r5
    4322:	6f 92       	push	r6
    4324:	7f 92       	push	r7
    4326:	8f 92       	push	r8
    4328:	9f 92       	push	r9
    432a:	af 92       	push	r10
    432c:	bf 92       	push	r11
    432e:	cf 92       	push	r12
    4330:	df 92       	push	r13
    4332:	ef 92       	push	r14
    4334:	ff 92       	push	r15
    4336:	0f 93       	push	r16
    4338:	1f 93       	push	r17
    433a:	2f 93       	push	r18
    433c:	3f 93       	push	r19
    433e:	4f 93       	push	r20
    4340:	5f 93       	push	r21
    4342:	6f 93       	push	r22
    4344:	7f 93       	push	r23
    4346:	8f 93       	push	r24
    4348:	9f 93       	push	r25
    434a:	af 93       	push	r26
    434c:	bf 93       	push	r27
    434e:	cf 93       	push	r28
    4350:	df 93       	push	r29
    4352:	ef 93       	push	r30
    4354:	ff 93       	push	r31
    4356:	a0 91 a0 07 	lds	r26, 0x07A0
    435a:	b0 91 a1 07 	lds	r27, 0x07A1
    435e:	0d b6       	in	r0, 0x3d	; 61
    4360:	0d 92       	st	X+, r0
    4362:	0e b6       	in	r0, 0x3e	; 62
    4364:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    4366:	0e 94 ff 3a 	call	0x75fe	; 0x75fe <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    436a:	a0 91 a0 07 	lds	r26, 0x07A0
    436e:	b0 91 a1 07 	lds	r27, 0x07A1
    4372:	cd 91       	ld	r28, X+
    4374:	cd bf       	out	0x3d, r28	; 61
    4376:	dd 91       	ld	r29, X+
    4378:	de bf       	out	0x3e, r29	; 62
    437a:	ff 91       	pop	r31
    437c:	ef 91       	pop	r30
    437e:	df 91       	pop	r29
    4380:	cf 91       	pop	r28
    4382:	bf 91       	pop	r27
    4384:	af 91       	pop	r26
    4386:	9f 91       	pop	r25
    4388:	8f 91       	pop	r24
    438a:	7f 91       	pop	r23
    438c:	6f 91       	pop	r22
    438e:	5f 91       	pop	r21
    4390:	4f 91       	pop	r20
    4392:	3f 91       	pop	r19
    4394:	2f 91       	pop	r18
    4396:	1f 91       	pop	r17
    4398:	0f 91       	pop	r16
    439a:	ff 90       	pop	r15
    439c:	ef 90       	pop	r14
    439e:	df 90       	pop	r13
    43a0:	cf 90       	pop	r12
    43a2:	bf 90       	pop	r11
    43a4:	af 90       	pop	r10
    43a6:	9f 90       	pop	r9
    43a8:	8f 90       	pop	r8
    43aa:	7f 90       	pop	r7
    43ac:	6f 90       	pop	r6
    43ae:	5f 90       	pop	r5
    43b0:	4f 90       	pop	r4
    43b2:	3f 90       	pop	r3
    43b4:	2f 90       	pop	r2
    43b6:	1f 90       	pop	r1
    43b8:	0f 90       	pop	r0
    43ba:	0f be       	out	0x3f, r0	; 63
    43bc:	0f 90       	pop	r0

	asm volatile ( "ret" );
    43be:	08 95       	ret

000043c0 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    43c0:	0f 92       	push	r0
    43c2:	0f b6       	in	r0, 0x3f	; 63
    43c4:	f8 94       	cli
    43c6:	0f 92       	push	r0
    43c8:	1f 92       	push	r1
    43ca:	11 24       	eor	r1, r1
    43cc:	2f 92       	push	r2
    43ce:	3f 92       	push	r3
    43d0:	4f 92       	push	r4
    43d2:	5f 92       	push	r5
    43d4:	6f 92       	push	r6
    43d6:	7f 92       	push	r7
    43d8:	8f 92       	push	r8
    43da:	9f 92       	push	r9
    43dc:	af 92       	push	r10
    43de:	bf 92       	push	r11
    43e0:	cf 92       	push	r12
    43e2:	df 92       	push	r13
    43e4:	ef 92       	push	r14
    43e6:	ff 92       	push	r15
    43e8:	0f 93       	push	r16
    43ea:	1f 93       	push	r17
    43ec:	2f 93       	push	r18
    43ee:	3f 93       	push	r19
    43f0:	4f 93       	push	r20
    43f2:	5f 93       	push	r21
    43f4:	6f 93       	push	r22
    43f6:	7f 93       	push	r23
    43f8:	8f 93       	push	r24
    43fa:	9f 93       	push	r25
    43fc:	af 93       	push	r26
    43fe:	bf 93       	push	r27
    4400:	cf 93       	push	r28
    4402:	df 93       	push	r29
    4404:	ef 93       	push	r30
    4406:	ff 93       	push	r31
    4408:	a0 91 a0 07 	lds	r26, 0x07A0
    440c:	b0 91 a1 07 	lds	r27, 0x07A1
    4410:	0d b6       	in	r0, 0x3d	; 61
    4412:	0d 92       	st	X+, r0
    4414:	0e b6       	in	r0, 0x3e	; 62
    4416:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    4418:	0e 94 68 39 	call	0x72d0	; 0x72d0 <xTaskIncrementTick>
    441c:	88 23       	and	r24, r24
    441e:	11 f0       	breq	.+4      	; 0x4424 <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
    4420:	0e 94 ff 3a 	call	0x75fe	; 0x75fe <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    4424:	a0 91 a0 07 	lds	r26, 0x07A0
    4428:	b0 91 a1 07 	lds	r27, 0x07A1
    442c:	cd 91       	ld	r28, X+
    442e:	cd bf       	out	0x3d, r28	; 61
    4430:	dd 91       	ld	r29, X+
    4432:	de bf       	out	0x3e, r29	; 62
    4434:	ff 91       	pop	r31
    4436:	ef 91       	pop	r30
    4438:	df 91       	pop	r29
    443a:	cf 91       	pop	r28
    443c:	bf 91       	pop	r27
    443e:	af 91       	pop	r26
    4440:	9f 91       	pop	r25
    4442:	8f 91       	pop	r24
    4444:	7f 91       	pop	r23
    4446:	6f 91       	pop	r22
    4448:	5f 91       	pop	r21
    444a:	4f 91       	pop	r20
    444c:	3f 91       	pop	r19
    444e:	2f 91       	pop	r18
    4450:	1f 91       	pop	r17
    4452:	0f 91       	pop	r16
    4454:	ff 90       	pop	r15
    4456:	ef 90       	pop	r14
    4458:	df 90       	pop	r13
    445a:	cf 90       	pop	r12
    445c:	bf 90       	pop	r11
    445e:	af 90       	pop	r10
    4460:	9f 90       	pop	r9
    4462:	8f 90       	pop	r8
    4464:	7f 90       	pop	r7
    4466:	6f 90       	pop	r6
    4468:	5f 90       	pop	r5
    446a:	4f 90       	pop	r4
    446c:	3f 90       	pop	r3
    446e:	2f 90       	pop	r2
    4470:	1f 90       	pop	r1
    4472:	0f 90       	pop	r0
    4474:	0f be       	out	0x3f, r0	; 63
    4476:	0f 90       	pop	r0

	asm volatile ( "ret" );
    4478:	08 95       	ret

0000447a <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    447a:	df 93       	push	r29
    447c:	cf 93       	push	r28
    447e:	00 d0       	rcall	.+0      	; 0x4480 <prvSetupTimerInterrupt+0x6>
    4480:	00 d0       	rcall	.+0      	; 0x4482 <prvSetupTimerInterrupt+0x8>
    4482:	00 d0       	rcall	.+0      	; 0x4484 <prvSetupTimerInterrupt+0xa>
    4484:	cd b7       	in	r28, 0x3d	; 61
    4486:	de b7       	in	r29, 0x3e	; 62
uint8_t ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    4488:	88 ee       	ldi	r24, 0xE8	; 232
    448a:	93 e0       	ldi	r25, 0x03	; 3
    448c:	a0 e0       	ldi	r26, 0x00	; 0
    448e:	b0 e0       	ldi	r27, 0x00	; 0
    4490:	8b 83       	std	Y+3, r24	; 0x03
    4492:	9c 83       	std	Y+4, r25	; 0x04
    4494:	ad 83       	std	Y+5, r26	; 0x05
    4496:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    4498:	8b 81       	ldd	r24, Y+3	; 0x03
    449a:	9c 81       	ldd	r25, Y+4	; 0x04
    449c:	ad 81       	ldd	r26, Y+5	; 0x05
    449e:	be 81       	ldd	r27, Y+6	; 0x06
    44a0:	68 94       	set
    44a2:	15 f8       	bld	r1, 5
    44a4:	b6 95       	lsr	r27
    44a6:	a7 95       	ror	r26
    44a8:	97 95       	ror	r25
    44aa:	87 95       	ror	r24
    44ac:	16 94       	lsr	r1
    44ae:	d1 f7       	brne	.-12     	; 0x44a4 <prvSetupTimerInterrupt+0x2a>
    44b0:	8b 83       	std	Y+3, r24	; 0x03
    44b2:	9c 83       	std	Y+4, r25	; 0x04
    44b4:	ad 83       	std	Y+5, r26	; 0x05
    44b6:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;
    44b8:	8b 81       	ldd	r24, Y+3	; 0x03
    44ba:	9c 81       	ldd	r25, Y+4	; 0x04
    44bc:	ad 81       	ldd	r26, Y+5	; 0x05
    44be:	be 81       	ldd	r27, Y+6	; 0x06
    44c0:	01 97       	sbiw	r24, 0x01	; 1
    44c2:	a1 09       	sbc	r26, r1
    44c4:	b1 09       	sbc	r27, r1
    44c6:	8b 83       	std	Y+3, r24	; 0x03
    44c8:	9c 83       	std	Y+4, r25	; 0x04
    44ca:	ad 83       	std	Y+5, r26	; 0x05
    44cc:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    44ce:	8b 81       	ldd	r24, Y+3	; 0x03
    44d0:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    44d2:	8b 81       	ldd	r24, Y+3	; 0x03
    44d4:	9c 81       	ldd	r25, Y+4	; 0x04
    44d6:	ad 81       	ldd	r26, Y+5	; 0x05
    44d8:	be 81       	ldd	r27, Y+6	; 0x06
    44da:	89 2f       	mov	r24, r25
    44dc:	9a 2f       	mov	r25, r26
    44de:	ab 2f       	mov	r26, r27
    44e0:	bb 27       	eor	r27, r27
    44e2:	8b 83       	std	Y+3, r24	; 0x03
    44e4:	9c 83       	std	Y+4, r25	; 0x04
    44e6:	ad 83       	std	Y+5, r26	; 0x05
    44e8:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    44ea:	8b 81       	ldd	r24, Y+3	; 0x03
    44ec:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    44ee:	eb e4       	ldi	r30, 0x4B	; 75
    44f0:	f0 e0       	ldi	r31, 0x00	; 0
    44f2:	8a 81       	ldd	r24, Y+2	; 0x02
    44f4:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    44f6:	ea e4       	ldi	r30, 0x4A	; 74
    44f8:	f0 e0       	ldi	r31, 0x00	; 0
    44fa:	89 81       	ldd	r24, Y+1	; 0x01
    44fc:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    44fe:	8b e0       	ldi	r24, 0x0B	; 11
    4500:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    4502:	ee e4       	ldi	r30, 0x4E	; 78
    4504:	f0 e0       	ldi	r31, 0x00	; 0
    4506:	89 81       	ldd	r24, Y+1	; 0x01
    4508:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    450a:	e9 e5       	ldi	r30, 0x59	; 89
    450c:	f0 e0       	ldi	r31, 0x00	; 0
    450e:	80 81       	ld	r24, Z
    4510:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    4512:	89 81       	ldd	r24, Y+1	; 0x01
    4514:	80 61       	ori	r24, 0x10	; 16
    4516:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    4518:	e9 e5       	ldi	r30, 0x59	; 89
    451a:	f0 e0       	ldi	r31, 0x00	; 0
    451c:	89 81       	ldd	r24, Y+1	; 0x01
    451e:	80 83       	st	Z, r24
}
    4520:	26 96       	adiw	r28, 0x06	; 6
    4522:	0f b6       	in	r0, 0x3f	; 63
    4524:	f8 94       	cli
    4526:	de bf       	out	0x3e, r29	; 62
    4528:	0f be       	out	0x3f, r0	; 63
    452a:	cd bf       	out	0x3d, r28	; 61
    452c:	cf 91       	pop	r28
    452e:	df 91       	pop	r29
    4530:	08 95       	ret

00004532 <__vector_6>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
    4532:	0e 94 e0 21 	call	0x43c0	; 0x43c0 <vPortYieldFromTick>
		asm volatile ( "reti" );
    4536:	18 95       	reti

00004538 <xQueueGenericReset>:
    taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue,
                               BaseType_t xNewQueue )
{
    4538:	df 93       	push	r29
    453a:	cf 93       	push	r28
    453c:	00 d0       	rcall	.+0      	; 0x453e <xQueueGenericReset+0x6>
    453e:	00 d0       	rcall	.+0      	; 0x4540 <xQueueGenericReset+0x8>
    4540:	00 d0       	rcall	.+0      	; 0x4542 <xQueueGenericReset+0xa>
    4542:	cd b7       	in	r28, 0x3d	; 61
    4544:	de b7       	in	r29, 0x3e	; 62
    4546:	9d 83       	std	Y+5, r25	; 0x05
    4548:	8c 83       	std	Y+4, r24	; 0x04
    454a:	6e 83       	std	Y+6, r22	; 0x06
    BaseType_t xReturn = pdPASS;
    454c:	81 e0       	ldi	r24, 0x01	; 1
    454e:	8b 83       	std	Y+3, r24	; 0x03
    Queue_t * const pxQueue = xQueue;
    4550:	8c 81       	ldd	r24, Y+4	; 0x04
    4552:	9d 81       	ldd	r25, Y+5	; 0x05
    4554:	9a 83       	std	Y+2, r25	; 0x02
    4556:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );

    if( ( pxQueue != NULL ) &&
    4558:	89 81       	ldd	r24, Y+1	; 0x01
    455a:	9a 81       	ldd	r25, Y+2	; 0x02
    455c:	00 97       	sbiw	r24, 0x00	; 0
    455e:	09 f4       	brne	.+2      	; 0x4562 <xQueueGenericReset+0x2a>
    4560:	8b c0       	rjmp	.+278    	; 0x4678 <xQueueGenericReset+0x140>
    4562:	e9 81       	ldd	r30, Y+1	; 0x01
    4564:	fa 81       	ldd	r31, Y+2	; 0x02
    4566:	83 8d       	ldd	r24, Z+27	; 0x1b
    4568:	88 23       	and	r24, r24
    456a:	09 f4       	brne	.+2      	; 0x456e <xQueueGenericReset+0x36>
    456c:	85 c0       	rjmp	.+266    	; 0x4678 <xQueueGenericReset+0x140>
    456e:	e9 81       	ldd	r30, Y+1	; 0x01
    4570:	fa 81       	ldd	r31, Y+2	; 0x02
    4572:	83 8d       	ldd	r24, Z+27	; 0x1b
    4574:	28 2f       	mov	r18, r24
    4576:	30 e0       	ldi	r19, 0x00	; 0
    4578:	8f ef       	ldi	r24, 0xFF	; 255
    457a:	9f e7       	ldi	r25, 0x7F	; 127
    457c:	b9 01       	movw	r22, r18
    457e:	0e 94 13 4c 	call	0x9826	; 0x9826 <__udivmodhi4>
    4582:	cb 01       	movw	r24, r22
    4584:	9c 01       	movw	r18, r24
    4586:	e9 81       	ldd	r30, Y+1	; 0x01
    4588:	fa 81       	ldd	r31, Y+2	; 0x02
    458a:	84 8d       	ldd	r24, Z+28	; 0x1c
    458c:	88 2f       	mov	r24, r24
    458e:	90 e0       	ldi	r25, 0x00	; 0
    4590:	28 17       	cp	r18, r24
    4592:	39 07       	cpc	r19, r25
    4594:	08 f4       	brcc	.+2      	; 0x4598 <xQueueGenericReset+0x60>
    4596:	70 c0       	rjmp	.+224    	; 0x4678 <xQueueGenericReset+0x140>
        ( pxQueue->uxLength >= 1U ) &&
        /* Check for multiplication overflow. */
        ( ( SIZE_MAX / pxQueue->uxLength ) >= pxQueue->uxItemSize ) )
    {
        taskENTER_CRITICAL();
    4598:	0f b6       	in	r0, 0x3f	; 63
    459a:	f8 94       	cli
    459c:	0f 92       	push	r0

        pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    459e:	e9 81       	ldd	r30, Y+1	; 0x01
    45a0:	fa 81       	ldd	r31, Y+2	; 0x02
    45a2:	40 81       	ld	r20, Z
    45a4:	51 81       	ldd	r21, Z+1	; 0x01
    45a6:	e9 81       	ldd	r30, Y+1	; 0x01
    45a8:	fa 81       	ldd	r31, Y+2	; 0x02
    45aa:	83 8d       	ldd	r24, Z+27	; 0x1b
    45ac:	28 2f       	mov	r18, r24
    45ae:	30 e0       	ldi	r19, 0x00	; 0
    45b0:	e9 81       	ldd	r30, Y+1	; 0x01
    45b2:	fa 81       	ldd	r31, Y+2	; 0x02
    45b4:	84 8d       	ldd	r24, Z+28	; 0x1c
    45b6:	88 2f       	mov	r24, r24
    45b8:	90 e0       	ldi	r25, 0x00	; 0
    45ba:	bc 01       	movw	r22, r24
    45bc:	26 9f       	mul	r18, r22
    45be:	c0 01       	movw	r24, r0
    45c0:	27 9f       	mul	r18, r23
    45c2:	90 0d       	add	r25, r0
    45c4:	36 9f       	mul	r19, r22
    45c6:	90 0d       	add	r25, r0
    45c8:	11 24       	eor	r1, r1
    45ca:	84 0f       	add	r24, r20
    45cc:	95 1f       	adc	r25, r21
    45ce:	e9 81       	ldd	r30, Y+1	; 0x01
    45d0:	fa 81       	ldd	r31, Y+2	; 0x02
    45d2:	95 83       	std	Z+5, r25	; 0x05
    45d4:	84 83       	std	Z+4, r24	; 0x04
        pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    45d6:	e9 81       	ldd	r30, Y+1	; 0x01
    45d8:	fa 81       	ldd	r31, Y+2	; 0x02
    45da:	12 8e       	std	Z+26, r1	; 0x1a
        pxQueue->pcWriteTo = pxQueue->pcHead;
    45dc:	e9 81       	ldd	r30, Y+1	; 0x01
    45de:	fa 81       	ldd	r31, Y+2	; 0x02
    45e0:	80 81       	ld	r24, Z
    45e2:	91 81       	ldd	r25, Z+1	; 0x01
    45e4:	e9 81       	ldd	r30, Y+1	; 0x01
    45e6:	fa 81       	ldd	r31, Y+2	; 0x02
    45e8:	93 83       	std	Z+3, r25	; 0x03
    45ea:	82 83       	std	Z+2, r24	; 0x02
        pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    45ec:	e9 81       	ldd	r30, Y+1	; 0x01
    45ee:	fa 81       	ldd	r31, Y+2	; 0x02
    45f0:	40 81       	ld	r20, Z
    45f2:	51 81       	ldd	r21, Z+1	; 0x01
    45f4:	e9 81       	ldd	r30, Y+1	; 0x01
    45f6:	fa 81       	ldd	r31, Y+2	; 0x02
    45f8:	83 8d       	ldd	r24, Z+27	; 0x1b
    45fa:	88 2f       	mov	r24, r24
    45fc:	90 e0       	ldi	r25, 0x00	; 0
    45fe:	9c 01       	movw	r18, r24
    4600:	21 50       	subi	r18, 0x01	; 1
    4602:	30 40       	sbci	r19, 0x00	; 0
    4604:	e9 81       	ldd	r30, Y+1	; 0x01
    4606:	fa 81       	ldd	r31, Y+2	; 0x02
    4608:	84 8d       	ldd	r24, Z+28	; 0x1c
    460a:	88 2f       	mov	r24, r24
    460c:	90 e0       	ldi	r25, 0x00	; 0
    460e:	bc 01       	movw	r22, r24
    4610:	26 9f       	mul	r18, r22
    4612:	c0 01       	movw	r24, r0
    4614:	27 9f       	mul	r18, r23
    4616:	90 0d       	add	r25, r0
    4618:	36 9f       	mul	r19, r22
    461a:	90 0d       	add	r25, r0
    461c:	11 24       	eor	r1, r1
    461e:	84 0f       	add	r24, r20
    4620:	95 1f       	adc	r25, r21
    4622:	e9 81       	ldd	r30, Y+1	; 0x01
    4624:	fa 81       	ldd	r31, Y+2	; 0x02
    4626:	97 83       	std	Z+7, r25	; 0x07
    4628:	86 83       	std	Z+6, r24	; 0x06
        pxQueue->cRxLock = queueUNLOCKED;
    462a:	e9 81       	ldd	r30, Y+1	; 0x01
    462c:	fa 81       	ldd	r31, Y+2	; 0x02
    462e:	8f ef       	ldi	r24, 0xFF	; 255
    4630:	85 8f       	std	Z+29, r24	; 0x1d
        pxQueue->cTxLock = queueUNLOCKED;
    4632:	e9 81       	ldd	r30, Y+1	; 0x01
    4634:	fa 81       	ldd	r31, Y+2	; 0x02
    4636:	8f ef       	ldi	r24, 0xFF	; 255
    4638:	86 8f       	std	Z+30, r24	; 0x1e

        if( xNewQueue == pdFALSE )
    463a:	8e 81       	ldd	r24, Y+6	; 0x06
    463c:	88 23       	and	r24, r24
    463e:	79 f4       	brne	.+30     	; 0x465e <xQueueGenericReset+0x126>
            /* If there are tasks blocked waiting to read from the queue, then
             * the tasks will remain blocked as after this function exits the queue
             * will still be empty.  If there are tasks blocked waiting to write to
             * the queue, then one should be unblocked as after this function exits
             * it will be possible to write to it. */
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    4640:	e9 81       	ldd	r30, Y+1	; 0x01
    4642:	fa 81       	ldd	r31, Y+2	; 0x02
    4644:	80 85       	ldd	r24, Z+8	; 0x08
    4646:	88 23       	and	r24, r24
    4648:	a1 f0       	breq	.+40     	; 0x4672 <xQueueGenericReset+0x13a>
            {
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    464a:	89 81       	ldd	r24, Y+1	; 0x01
    464c:	9a 81       	ldd	r25, Y+2	; 0x02
    464e:	08 96       	adiw	r24, 0x08	; 8
    4650:	0e 94 f3 3b 	call	0x77e6	; 0x77e6 <xTaskRemoveFromEventList>
    4654:	88 23       	and	r24, r24
    4656:	69 f0       	breq	.+26     	; 0x4672 <xQueueGenericReset+0x13a>
                {
                    queueYIELD_IF_USING_PREEMPTION();
    4658:	0e 94 87 21 	call	0x430e	; 0x430e <vPortYield>
    465c:	0a c0       	rjmp	.+20     	; 0x4672 <xQueueGenericReset+0x13a>
            }
        }
        else
        {
            /* Ensure the event queues start in the correct state. */
            vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    465e:	89 81       	ldd	r24, Y+1	; 0x01
    4660:	9a 81       	ldd	r25, Y+2	; 0x02
    4662:	08 96       	adiw	r24, 0x08	; 8
    4664:	0e 94 92 1e 	call	0x3d24	; 0x3d24 <vListInitialise>
            vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    4668:	89 81       	ldd	r24, Y+1	; 0x01
    466a:	9a 81       	ldd	r25, Y+2	; 0x02
    466c:	41 96       	adiw	r24, 0x11	; 17
    466e:	0e 94 92 1e 	call	0x3d24	; 0x3d24 <vListInitialise>
        }
        taskEXIT_CRITICAL();
    4672:	0f 90       	pop	r0
    4674:	0f be       	out	0x3f, r0	; 63
    4676:	01 c0       	rjmp	.+2      	; 0x467a <xQueueGenericReset+0x142>
    }
    else
    {
        xReturn = pdFAIL;
    4678:	1b 82       	std	Y+3, r1	; 0x03

    configASSERT( xReturn != pdFAIL );

    /* A value is returned for calling semantic consistency with previous
     * versions. */
    return xReturn;
    467a:	8b 81       	ldd	r24, Y+3	; 0x03
}
    467c:	26 96       	adiw	r28, 0x06	; 6
    467e:	0f b6       	in	r0, 0x3f	; 63
    4680:	f8 94       	cli
    4682:	de bf       	out	0x3e, r29	; 62
    4684:	0f be       	out	0x3f, r0	; 63
    4686:	cd bf       	out	0x3d, r28	; 61
    4688:	cf 91       	pop	r28
    468a:	df 91       	pop	r29
    468c:	08 95       	ret

0000468e <xQueueGenericCreate>:
#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

    QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength,
                                       const UBaseType_t uxItemSize,
                                       const uint8_t ucQueueType )
    {
    468e:	0f 93       	push	r16
    4690:	1f 93       	push	r17
    4692:	df 93       	push	r29
    4694:	cf 93       	push	r28
    4696:	cd b7       	in	r28, 0x3d	; 61
    4698:	de b7       	in	r29, 0x3e	; 62
    469a:	29 97       	sbiw	r28, 0x09	; 9
    469c:	0f b6       	in	r0, 0x3f	; 63
    469e:	f8 94       	cli
    46a0:	de bf       	out	0x3e, r29	; 62
    46a2:	0f be       	out	0x3f, r0	; 63
    46a4:	cd bf       	out	0x3d, r28	; 61
    46a6:	8f 83       	std	Y+7, r24	; 0x07
    46a8:	68 87       	std	Y+8, r22	; 0x08
    46aa:	49 87       	std	Y+9, r20	; 0x09
        Queue_t * pxNewQueue = NULL;
    46ac:	1e 82       	std	Y+6, r1	; 0x06
    46ae:	1d 82       	std	Y+5, r1	; 0x05
        size_t xQueueSizeInBytes;
        uint8_t * pucQueueStorage;

        if( ( uxQueueLength > ( UBaseType_t ) 0 ) &&
    46b0:	8f 81       	ldd	r24, Y+7	; 0x07
    46b2:	88 23       	and	r24, r24
    46b4:	09 f4       	brne	.+2      	; 0x46b8 <xQueueGenericCreate+0x2a>
    46b6:	52 c0       	rjmp	.+164    	; 0x475c <xQueueGenericCreate+0xce>
    46b8:	8f 81       	ldd	r24, Y+7	; 0x07
    46ba:	28 2f       	mov	r18, r24
    46bc:	30 e0       	ldi	r19, 0x00	; 0
    46be:	8f ef       	ldi	r24, 0xFF	; 255
    46c0:	9f e7       	ldi	r25, 0x7F	; 127
    46c2:	b9 01       	movw	r22, r18
    46c4:	0e 94 13 4c 	call	0x9826	; 0x9826 <__udivmodhi4>
    46c8:	cb 01       	movw	r24, r22
    46ca:	9c 01       	movw	r18, r24
    46cc:	88 85       	ldd	r24, Y+8	; 0x08
    46ce:	88 2f       	mov	r24, r24
    46d0:	90 e0       	ldi	r25, 0x00	; 0
    46d2:	28 17       	cp	r18, r24
    46d4:	39 07       	cpc	r19, r25
    46d6:	08 f4       	brcc	.+2      	; 0x46da <xQueueGenericCreate+0x4c>
    46d8:	41 c0       	rjmp	.+130    	; 0x475c <xQueueGenericCreate+0xce>
    46da:	8f 81       	ldd	r24, Y+7	; 0x07
    46dc:	28 2f       	mov	r18, r24
    46de:	30 e0       	ldi	r19, 0x00	; 0
    46e0:	88 85       	ldd	r24, Y+8	; 0x08
    46e2:	88 2f       	mov	r24, r24
    46e4:	90 e0       	ldi	r25, 0x00	; 0
    46e6:	ac 01       	movw	r20, r24
    46e8:	24 9f       	mul	r18, r20
    46ea:	c0 01       	movw	r24, r0
    46ec:	25 9f       	mul	r18, r21
    46ee:	90 0d       	add	r25, r0
    46f0:	34 9f       	mul	r19, r20
    46f2:	90 0d       	add	r25, r0
    46f4:	11 24       	eor	r1, r1
    46f6:	5f e7       	ldi	r21, 0x7F	; 127
    46f8:	81 3e       	cpi	r24, 0xE1	; 225
    46fa:	95 07       	cpc	r25, r21
    46fc:	78 f5       	brcc	.+94     	; 0x475c <xQueueGenericCreate+0xce>
            ( ( SIZE_MAX - sizeof( Queue_t ) ) >= ( uxQueueLength * uxItemSize ) ) )
        {
            /* Allocate enough space to hold the maximum number of items that
             * can be in the queue at any time.  It is valid for uxItemSize to be
             * zero in the case the queue is used as a semaphore. */
            xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    46fe:	8f 81       	ldd	r24, Y+7	; 0x07
    4700:	28 2f       	mov	r18, r24
    4702:	30 e0       	ldi	r19, 0x00	; 0
    4704:	88 85       	ldd	r24, Y+8	; 0x08
    4706:	88 2f       	mov	r24, r24
    4708:	90 e0       	ldi	r25, 0x00	; 0
    470a:	ac 01       	movw	r20, r24
    470c:	24 9f       	mul	r18, r20
    470e:	c0 01       	movw	r24, r0
    4710:	25 9f       	mul	r18, r21
    4712:	90 0d       	add	r25, r0
    4714:	34 9f       	mul	r19, r20
    4716:	90 0d       	add	r25, r0
    4718:	11 24       	eor	r1, r1
    471a:	9c 83       	std	Y+4, r25	; 0x04
    471c:	8b 83       	std	Y+3, r24	; 0x03
             * alignment requirements of the Queue_t structure - which in this case
             * is an int8_t *.  Therefore, whenever the stack alignment requirements
             * are greater than or equal to the pointer to char requirements the cast
             * is safe.  In other cases alignment requirements are not strict (one or
             * two bytes). */
            pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    471e:	8b 81       	ldd	r24, Y+3	; 0x03
    4720:	9c 81       	ldd	r25, Y+4	; 0x04
    4722:	4f 96       	adiw	r24, 0x1f	; 31
    4724:	0e 94 12 1e 	call	0x3c24	; 0x3c24 <pvPortMalloc>
    4728:	9e 83       	std	Y+6, r25	; 0x06
    472a:	8d 83       	std	Y+5, r24	; 0x05

            if( pxNewQueue != NULL )
    472c:	8d 81       	ldd	r24, Y+5	; 0x05
    472e:	9e 81       	ldd	r25, Y+6	; 0x06
    4730:	00 97       	sbiw	r24, 0x00	; 0
    4732:	a1 f0       	breq	.+40     	; 0x475c <xQueueGenericCreate+0xce>
            {
                /* Jump past the queue structure to find the location of the queue
                 * storage area. */
                pucQueueStorage = ( uint8_t * ) pxNewQueue;
    4734:	8d 81       	ldd	r24, Y+5	; 0x05
    4736:	9e 81       	ldd	r25, Y+6	; 0x06
    4738:	9a 83       	std	Y+2, r25	; 0x02
    473a:	89 83       	std	Y+1, r24	; 0x01
                pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    473c:	89 81       	ldd	r24, Y+1	; 0x01
    473e:	9a 81       	ldd	r25, Y+2	; 0x02
    4740:	4f 96       	adiw	r24, 0x1f	; 31
    4742:	9a 83       	std	Y+2, r25	; 0x02
    4744:	89 83       	std	Y+1, r24	; 0x01
                         * deleted. */
                        pxNewQueue->ucStaticallyAllocated = pdFALSE;
                    }
                #endif /* configSUPPORT_STATIC_ALLOCATION */

                prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
    4746:	29 81       	ldd	r18, Y+1	; 0x01
    4748:	3a 81       	ldd	r19, Y+2	; 0x02
    474a:	ed 81       	ldd	r30, Y+5	; 0x05
    474c:	fe 81       	ldd	r31, Y+6	; 0x06
    474e:	8f 81       	ldd	r24, Y+7	; 0x07
    4750:	68 85       	ldd	r22, Y+8	; 0x08
    4752:	a9 01       	movw	r20, r18
    4754:	29 85       	ldd	r18, Y+9	; 0x09
    4756:	8f 01       	movw	r16, r30
    4758:	0e 94 bb 23 	call	0x4776	; 0x4776 <prvInitialiseNewQueue>
        {
            configASSERT( pxNewQueue );
            mtCOVERAGE_TEST_MARKER();
        }

        return pxNewQueue;
    475c:	8d 81       	ldd	r24, Y+5	; 0x05
    475e:	9e 81       	ldd	r25, Y+6	; 0x06
    }
    4760:	29 96       	adiw	r28, 0x09	; 9
    4762:	0f b6       	in	r0, 0x3f	; 63
    4764:	f8 94       	cli
    4766:	de bf       	out	0x3e, r29	; 62
    4768:	0f be       	out	0x3f, r0	; 63
    476a:	cd bf       	out	0x3d, r28	; 61
    476c:	cf 91       	pop	r28
    476e:	df 91       	pop	r29
    4770:	1f 91       	pop	r17
    4772:	0f 91       	pop	r16
    4774:	08 95       	ret

00004776 <prvInitialiseNewQueue>:
static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength,
                                   const UBaseType_t uxItemSize,
                                   uint8_t * pucQueueStorage,
                                   const uint8_t ucQueueType,
                                   Queue_t * pxNewQueue )
{
    4776:	0f 93       	push	r16
    4778:	1f 93       	push	r17
    477a:	df 93       	push	r29
    477c:	cf 93       	push	r28
    477e:	cd b7       	in	r28, 0x3d	; 61
    4780:	de b7       	in	r29, 0x3e	; 62
    4782:	27 97       	sbiw	r28, 0x07	; 7
    4784:	0f b6       	in	r0, 0x3f	; 63
    4786:	f8 94       	cli
    4788:	de bf       	out	0x3e, r29	; 62
    478a:	0f be       	out	0x3f, r0	; 63
    478c:	cd bf       	out	0x3d, r28	; 61
    478e:	89 83       	std	Y+1, r24	; 0x01
    4790:	6a 83       	std	Y+2, r22	; 0x02
    4792:	5c 83       	std	Y+4, r21	; 0x04
    4794:	4b 83       	std	Y+3, r20	; 0x03
    4796:	2d 83       	std	Y+5, r18	; 0x05
    4798:	1f 83       	std	Y+7, r17	; 0x07
    479a:	0e 83       	std	Y+6, r16	; 0x06
    /* Remove compiler warnings about unused parameters should
     * configUSE_TRACE_FACILITY not be set to 1. */
    ( void ) ucQueueType;

    if( uxItemSize == ( UBaseType_t ) 0 )
    479c:	8a 81       	ldd	r24, Y+2	; 0x02
    479e:	88 23       	and	r24, r24
    47a0:	39 f4       	brne	.+14     	; 0x47b0 <prvInitialiseNewQueue+0x3a>
    {
        /* No RAM was allocated for the queue storage area, but PC head cannot
         * be set to NULL because NULL is used as a key to say the queue is used as
         * a mutex.  Therefore just set pcHead to point to the queue as a benign
         * value that is known to be within the memory map. */
        pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    47a2:	8e 81       	ldd	r24, Y+6	; 0x06
    47a4:	9f 81       	ldd	r25, Y+7	; 0x07
    47a6:	ee 81       	ldd	r30, Y+6	; 0x06
    47a8:	ff 81       	ldd	r31, Y+7	; 0x07
    47aa:	91 83       	std	Z+1, r25	; 0x01
    47ac:	80 83       	st	Z, r24
    47ae:	06 c0       	rjmp	.+12     	; 0x47bc <prvInitialiseNewQueue+0x46>
    }
    else
    {
        /* Set the head to the start of the queue storage area. */
        pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    47b0:	8b 81       	ldd	r24, Y+3	; 0x03
    47b2:	9c 81       	ldd	r25, Y+4	; 0x04
    47b4:	ee 81       	ldd	r30, Y+6	; 0x06
    47b6:	ff 81       	ldd	r31, Y+7	; 0x07
    47b8:	91 83       	std	Z+1, r25	; 0x01
    47ba:	80 83       	st	Z, r24
    }

    /* Initialise the queue members as described where the queue type is
     * defined. */
    pxNewQueue->uxLength = uxQueueLength;
    47bc:	ee 81       	ldd	r30, Y+6	; 0x06
    47be:	ff 81       	ldd	r31, Y+7	; 0x07
    47c0:	89 81       	ldd	r24, Y+1	; 0x01
    47c2:	83 8f       	std	Z+27, r24	; 0x1b
    pxNewQueue->uxItemSize = uxItemSize;
    47c4:	ee 81       	ldd	r30, Y+6	; 0x06
    47c6:	ff 81       	ldd	r31, Y+7	; 0x07
    47c8:	8a 81       	ldd	r24, Y+2	; 0x02
    47ca:	84 8f       	std	Z+28, r24	; 0x1c
    ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    47cc:	8e 81       	ldd	r24, Y+6	; 0x06
    47ce:	9f 81       	ldd	r25, Y+7	; 0x07
    47d0:	61 e0       	ldi	r22, 0x01	; 1
    47d2:	0e 94 9c 22 	call	0x4538	; 0x4538 <xQueueGenericReset>
            pxNewQueue->pxQueueSetContainer = NULL;
        }
    #endif /* configUSE_QUEUE_SETS */

    traceQUEUE_CREATE( pxNewQueue );
}
    47d6:	27 96       	adiw	r28, 0x07	; 7
    47d8:	0f b6       	in	r0, 0x3f	; 63
    47da:	f8 94       	cli
    47dc:	de bf       	out	0x3e, r29	; 62
    47de:	0f be       	out	0x3f, r0	; 63
    47e0:	cd bf       	out	0x3d, r28	; 61
    47e2:	cf 91       	pop	r28
    47e4:	df 91       	pop	r29
    47e6:	1f 91       	pop	r17
    47e8:	0f 91       	pop	r16
    47ea:	08 95       	ret

000047ec <prvInitialiseMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

    static void prvInitialiseMutex( Queue_t * pxNewQueue )
    {
    47ec:	df 93       	push	r29
    47ee:	cf 93       	push	r28
    47f0:	00 d0       	rcall	.+0      	; 0x47f2 <prvInitialiseMutex+0x6>
    47f2:	cd b7       	in	r28, 0x3d	; 61
    47f4:	de b7       	in	r29, 0x3e	; 62
    47f6:	9a 83       	std	Y+2, r25	; 0x02
    47f8:	89 83       	std	Y+1, r24	; 0x01
        if( pxNewQueue != NULL )
    47fa:	89 81       	ldd	r24, Y+1	; 0x01
    47fc:	9a 81       	ldd	r25, Y+2	; 0x02
    47fe:	00 97       	sbiw	r24, 0x00	; 0
    4800:	a1 f0       	breq	.+40     	; 0x482a <prvInitialiseMutex+0x3e>
        {
            /* The queue create function will set all the queue structure members
            * correctly for a generic queue, but this function is creating a
            * mutex.  Overwrite those members that need to be set differently -
            * in particular the information required for priority inheritance. */
            pxNewQueue->u.xSemaphore.xMutexHolder = NULL;
    4802:	e9 81       	ldd	r30, Y+1	; 0x01
    4804:	fa 81       	ldd	r31, Y+2	; 0x02
    4806:	15 82       	std	Z+5, r1	; 0x05
    4808:	14 82       	std	Z+4, r1	; 0x04
            pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    480a:	e9 81       	ldd	r30, Y+1	; 0x01
    480c:	fa 81       	ldd	r31, Y+2	; 0x02
    480e:	11 82       	std	Z+1, r1	; 0x01
    4810:	10 82       	st	Z, r1

            /* In case this is a recursive mutex. */
            pxNewQueue->u.xSemaphore.uxRecursiveCallCount = 0;
    4812:	e9 81       	ldd	r30, Y+1	; 0x01
    4814:	fa 81       	ldd	r31, Y+2	; 0x02
    4816:	16 82       	std	Z+6, r1	; 0x06

            traceCREATE_MUTEX( pxNewQueue );

            /* Start with the semaphore in the expected state. */
            ( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
    4818:	89 81       	ldd	r24, Y+1	; 0x01
    481a:	9a 81       	ldd	r25, Y+2	; 0x02
    481c:	60 e0       	ldi	r22, 0x00	; 0
    481e:	70 e0       	ldi	r23, 0x00	; 0
    4820:	40 e0       	ldi	r20, 0x00	; 0
    4822:	50 e0       	ldi	r21, 0x00	; 0
    4824:	20 e0       	ldi	r18, 0x00	; 0
    4826:	0e 94 63 24 	call	0x48c6	; 0x48c6 <xQueueGenericSend>
        }
        else
        {
            traceCREATE_MUTEX_FAILED();
        }
    }
    482a:	0f 90       	pop	r0
    482c:	0f 90       	pop	r0
    482e:	cf 91       	pop	r28
    4830:	df 91       	pop	r29
    4832:	08 95       	ret

00004834 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

    QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
    {
    4834:	df 93       	push	r29
    4836:	cf 93       	push	r28
    4838:	00 d0       	rcall	.+0      	; 0x483a <xQueueCreateMutex+0x6>
    483a:	00 d0       	rcall	.+0      	; 0x483c <xQueueCreateMutex+0x8>
    483c:	0f 92       	push	r0
    483e:	cd b7       	in	r28, 0x3d	; 61
    4840:	de b7       	in	r29, 0x3e	; 62
    4842:	8d 83       	std	Y+5, r24	; 0x05
        QueueHandle_t xNewQueue;
        const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
    4844:	81 e0       	ldi	r24, 0x01	; 1
    4846:	8a 83       	std	Y+2, r24	; 0x02
    4848:	19 82       	std	Y+1, r1	; 0x01

        xNewQueue = xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
    484a:	8a 81       	ldd	r24, Y+2	; 0x02
    484c:	69 81       	ldd	r22, Y+1	; 0x01
    484e:	4d 81       	ldd	r20, Y+5	; 0x05
    4850:	0e 94 47 23 	call	0x468e	; 0x468e <xQueueGenericCreate>
    4854:	9c 83       	std	Y+4, r25	; 0x04
    4856:	8b 83       	std	Y+3, r24	; 0x03
        prvInitialiseMutex( ( Queue_t * ) xNewQueue );
    4858:	8b 81       	ldd	r24, Y+3	; 0x03
    485a:	9c 81       	ldd	r25, Y+4	; 0x04
    485c:	0e 94 f6 23 	call	0x47ec	; 0x47ec <prvInitialiseMutex>

        return xNewQueue;
    4860:	8b 81       	ldd	r24, Y+3	; 0x03
    4862:	9c 81       	ldd	r25, Y+4	; 0x04
    }
    4864:	0f 90       	pop	r0
    4866:	0f 90       	pop	r0
    4868:	0f 90       	pop	r0
    486a:	0f 90       	pop	r0
    486c:	0f 90       	pop	r0
    486e:	cf 91       	pop	r28
    4870:	df 91       	pop	r29
    4872:	08 95       	ret

00004874 <xQueueCreateCountingSemaphore>:

#if ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

    QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount,
                                                 const UBaseType_t uxInitialCount )
    {
    4874:	df 93       	push	r29
    4876:	cf 93       	push	r28
    4878:	00 d0       	rcall	.+0      	; 0x487a <xQueueCreateCountingSemaphore+0x6>
    487a:	00 d0       	rcall	.+0      	; 0x487c <xQueueCreateCountingSemaphore+0x8>
    487c:	cd b7       	in	r28, 0x3d	; 61
    487e:	de b7       	in	r29, 0x3e	; 62
    4880:	8b 83       	std	Y+3, r24	; 0x03
    4882:	6c 83       	std	Y+4, r22	; 0x04
        QueueHandle_t xHandle = NULL;
    4884:	1a 82       	std	Y+2, r1	; 0x02
    4886:	19 82       	std	Y+1, r1	; 0x01

        if( ( uxMaxCount != 0 ) &&
    4888:	8b 81       	ldd	r24, Y+3	; 0x03
    488a:	88 23       	and	r24, r24
    488c:	99 f0       	breq	.+38     	; 0x48b4 <xQueueCreateCountingSemaphore+0x40>
    488e:	9c 81       	ldd	r25, Y+4	; 0x04
    4890:	8b 81       	ldd	r24, Y+3	; 0x03
    4892:	89 17       	cp	r24, r25
    4894:	78 f0       	brcs	.+30     	; 0x48b4 <xQueueCreateCountingSemaphore+0x40>
            ( uxInitialCount <= uxMaxCount ) )
        {
            xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
    4896:	8b 81       	ldd	r24, Y+3	; 0x03
    4898:	60 e0       	ldi	r22, 0x00	; 0
    489a:	42 e0       	ldi	r20, 0x02	; 2
    489c:	0e 94 47 23 	call	0x468e	; 0x468e <xQueueGenericCreate>
    48a0:	9a 83       	std	Y+2, r25	; 0x02
    48a2:	89 83       	std	Y+1, r24	; 0x01

            if( xHandle != NULL )
    48a4:	89 81       	ldd	r24, Y+1	; 0x01
    48a6:	9a 81       	ldd	r25, Y+2	; 0x02
    48a8:	00 97       	sbiw	r24, 0x00	; 0
    48aa:	21 f0       	breq	.+8      	; 0x48b4 <xQueueCreateCountingSemaphore+0x40>
            {
                ( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
    48ac:	e9 81       	ldd	r30, Y+1	; 0x01
    48ae:	fa 81       	ldd	r31, Y+2	; 0x02
    48b0:	8c 81       	ldd	r24, Y+4	; 0x04
    48b2:	82 8f       	std	Z+26, r24	; 0x1a
        {
            configASSERT( xHandle );
            mtCOVERAGE_TEST_MARKER();
        }

        return xHandle;
    48b4:	89 81       	ldd	r24, Y+1	; 0x01
    48b6:	9a 81       	ldd	r25, Y+2	; 0x02
    }
    48b8:	0f 90       	pop	r0
    48ba:	0f 90       	pop	r0
    48bc:	0f 90       	pop	r0
    48be:	0f 90       	pop	r0
    48c0:	cf 91       	pop	r28
    48c2:	df 91       	pop	r29
    48c4:	08 95       	ret

000048c6 <xQueueGenericSend>:

BaseType_t xQueueGenericSend( QueueHandle_t xQueue,
                              const void * const pvItemToQueue,
                              TickType_t xTicksToWait,
                              const BaseType_t xCopyPosition )
{
    48c6:	df 93       	push	r29
    48c8:	cf 93       	push	r28
    48ca:	cd b7       	in	r28, 0x3d	; 61
    48cc:	de b7       	in	r29, 0x3e	; 62
    48ce:	2f 97       	sbiw	r28, 0x0f	; 15
    48d0:	0f b6       	in	r0, 0x3f	; 63
    48d2:	f8 94       	cli
    48d4:	de bf       	out	0x3e, r29	; 62
    48d6:	0f be       	out	0x3f, r0	; 63
    48d8:	cd bf       	out	0x3d, r28	; 61
    48da:	99 87       	std	Y+9, r25	; 0x09
    48dc:	88 87       	std	Y+8, r24	; 0x08
    48de:	7b 87       	std	Y+11, r23	; 0x0b
    48e0:	6a 87       	std	Y+10, r22	; 0x0a
    48e2:	5d 87       	std	Y+13, r21	; 0x0d
    48e4:	4c 87       	std	Y+12, r20	; 0x0c
    48e6:	2e 87       	std	Y+14, r18	; 0x0e
    BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    48e8:	1c 82       	std	Y+4, r1	; 0x04
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
    48ea:	88 85       	ldd	r24, Y+8	; 0x08
    48ec:	99 85       	ldd	r25, Y+9	; 0x09
    48ee:	9a 83       	std	Y+2, r25	; 0x02
    48f0:	89 83       	std	Y+1, r24	; 0x01
    /*lint -save -e904 This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    48f2:	0f b6       	in	r0, 0x3f	; 63
    48f4:	f8 94       	cli
    48f6:	0f 92       	push	r0
        {
            /* Is there room on the queue now?  The running task must be the
             * highest priority task wanting to access the queue.  If the head item
             * in the queue is to be overwritten then it does not matter if the
             * queue is full. */
            if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    48f8:	e9 81       	ldd	r30, Y+1	; 0x01
    48fa:	fa 81       	ldd	r31, Y+2	; 0x02
    48fc:	92 8d       	ldd	r25, Z+26	; 0x1a
    48fe:	e9 81       	ldd	r30, Y+1	; 0x01
    4900:	fa 81       	ldd	r31, Y+2	; 0x02
    4902:	83 8d       	ldd	r24, Z+27	; 0x1b
    4904:	98 17       	cp	r25, r24
    4906:	18 f0       	brcs	.+6      	; 0x490e <xQueueGenericSend+0x48>
    4908:	8e 85       	ldd	r24, Y+14	; 0x0e
    490a:	82 30       	cpi	r24, 0x02	; 2
    490c:	11 f5       	brne	.+68     	; 0x4952 <xQueueGenericSend+0x8c>
                            }
                        }
                    }
                #else /* configUSE_QUEUE_SETS */
                    {
                        xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    490e:	89 81       	ldd	r24, Y+1	; 0x01
    4910:	9a 81       	ldd	r25, Y+2	; 0x02
    4912:	2a 85       	ldd	r18, Y+10	; 0x0a
    4914:	3b 85       	ldd	r19, Y+11	; 0x0b
    4916:	b9 01       	movw	r22, r18
    4918:	4e 85       	ldd	r20, Y+14	; 0x0e
    491a:	0e 94 0d 29 	call	0x521a	; 0x521a <prvCopyDataToQueue>
    491e:	8b 83       	std	Y+3, r24	; 0x03

                        /* If there was a task waiting for data to arrive on the
                         * queue then unblock it now. */
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    4920:	e9 81       	ldd	r30, Y+1	; 0x01
    4922:	fa 81       	ldd	r31, Y+2	; 0x02
    4924:	81 89       	ldd	r24, Z+17	; 0x11
    4926:	88 23       	and	r24, r24
    4928:	51 f0       	breq	.+20     	; 0x493e <xQueueGenericSend+0x78>
                        {
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    492a:	89 81       	ldd	r24, Y+1	; 0x01
    492c:	9a 81       	ldd	r25, Y+2	; 0x02
    492e:	41 96       	adiw	r24, 0x11	; 17
    4930:	0e 94 f3 3b 	call	0x77e6	; 0x77e6 <xTaskRemoveFromEventList>
    4934:	88 23       	and	r24, r24
    4936:	41 f0       	breq	.+16     	; 0x4948 <xQueueGenericSend+0x82>
                            {
                                /* The unblocked task has a priority higher than
                                 * our own so yield immediately.  Yes it is ok to do
                                 * this from within the critical section - the kernel
                                 * takes care of that. */
                                queueYIELD_IF_USING_PREEMPTION();
    4938:	0e 94 87 21 	call	0x430e	; 0x430e <vPortYield>
    493c:	05 c0       	rjmp	.+10     	; 0x4948 <xQueueGenericSend+0x82>
                            else
                            {
                                mtCOVERAGE_TEST_MARKER();
                            }
                        }
                        else if( xYieldRequired != pdFALSE )
    493e:	8b 81       	ldd	r24, Y+3	; 0x03
    4940:	88 23       	and	r24, r24
    4942:	11 f0       	breq	.+4      	; 0x4948 <xQueueGenericSend+0x82>
                        {
                            /* This path is a special case that will only get
                             * executed if the task was holding multiple mutexes and
                             * the mutexes were given back in an order that is
                             * different to that in which they were taken. */
                            queueYIELD_IF_USING_PREEMPTION();
    4944:	0e 94 87 21 	call	0x430e	; 0x430e <vPortYield>
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                #endif /* configUSE_QUEUE_SETS */

                taskEXIT_CRITICAL();
    4948:	0f 90       	pop	r0
    494a:	0f be       	out	0x3f, r0	; 63
                return pdPASS;
    494c:	81 e0       	ldi	r24, 0x01	; 1
    494e:	8f 87       	std	Y+15, r24	; 0x0f
    4950:	5c c0       	rjmp	.+184    	; 0x4a0a <xQueueGenericSend+0x144>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    4952:	8c 85       	ldd	r24, Y+12	; 0x0c
    4954:	9d 85       	ldd	r25, Y+13	; 0x0d
    4956:	00 97       	sbiw	r24, 0x00	; 0
    4958:	21 f4       	brne	.+8      	; 0x4962 <xQueueGenericSend+0x9c>
                {
                    /* The queue was full and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    495a:	0f 90       	pop	r0
    495c:	0f be       	out	0x3f, r0	; 63

                    /* Return to the original privilege level before exiting
                     * the function. */
                    traceQUEUE_SEND_FAILED( pxQueue );
                    return errQUEUE_FULL;
    495e:	1f 86       	std	Y+15, r1	; 0x0f
    4960:	54 c0       	rjmp	.+168    	; 0x4a0a <xQueueGenericSend+0x144>
                }
                else if( xEntryTimeSet == pdFALSE )
    4962:	8c 81       	ldd	r24, Y+4	; 0x04
    4964:	88 23       	and	r24, r24
    4966:	31 f4       	brne	.+12     	; 0x4974 <xQueueGenericSend+0xae>
                {
                    /* The queue was full and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    4968:	ce 01       	movw	r24, r28
    496a:	05 96       	adiw	r24, 0x05	; 5
    496c:	0e 94 63 3e 	call	0x7cc6	; 0x7cc6 <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
    4970:	81 e0       	ldi	r24, 0x01	; 1
    4972:	8c 83       	std	Y+4, r24	; 0x04
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    4974:	0f 90       	pop	r0
    4976:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
    4978:	0e 94 8f 37 	call	0x6f1e	; 0x6f1e <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    497c:	0f b6       	in	r0, 0x3f	; 63
    497e:	f8 94       	cli
    4980:	0f 92       	push	r0
    4982:	e9 81       	ldd	r30, Y+1	; 0x01
    4984:	fa 81       	ldd	r31, Y+2	; 0x02
    4986:	85 8d       	ldd	r24, Z+29	; 0x1d
    4988:	8f 3f       	cpi	r24, 0xFF	; 255
    498a:	19 f4       	brne	.+6      	; 0x4992 <xQueueGenericSend+0xcc>
    498c:	e9 81       	ldd	r30, Y+1	; 0x01
    498e:	fa 81       	ldd	r31, Y+2	; 0x02
    4990:	15 8e       	std	Z+29, r1	; 0x1d
    4992:	e9 81       	ldd	r30, Y+1	; 0x01
    4994:	fa 81       	ldd	r31, Y+2	; 0x02
    4996:	86 8d       	ldd	r24, Z+30	; 0x1e
    4998:	8f 3f       	cpi	r24, 0xFF	; 255
    499a:	19 f4       	brne	.+6      	; 0x49a2 <xQueueGenericSend+0xdc>
    499c:	e9 81       	ldd	r30, Y+1	; 0x01
    499e:	fa 81       	ldd	r31, Y+2	; 0x02
    49a0:	16 8e       	std	Z+30, r1	; 0x1e
    49a2:	0f 90       	pop	r0
    49a4:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    49a6:	ce 01       	movw	r24, r28
    49a8:	05 96       	adiw	r24, 0x05	; 5
    49aa:	9e 01       	movw	r18, r28
    49ac:	24 5f       	subi	r18, 0xF4	; 244
    49ae:	3f 4f       	sbci	r19, 0xFF	; 255
    49b0:	b9 01       	movw	r22, r18
    49b2:	0e 94 7c 3e 	call	0x7cf8	; 0x7cf8 <xTaskCheckForTimeOut>
    49b6:	88 23       	and	r24, r24
    49b8:	09 f5       	brne	.+66     	; 0x49fc <xQueueGenericSend+0x136>
        {
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
    49ba:	89 81       	ldd	r24, Y+1	; 0x01
    49bc:	9a 81       	ldd	r25, Y+2	; 0x02
    49be:	0e 94 9b 2a 	call	0x5536	; 0x5536 <prvIsQueueFull>
    49c2:	88 23       	and	r24, r24
    49c4:	a1 f0       	breq	.+40     	; 0x49ee <xQueueGenericSend+0x128>
            {
                traceBLOCKING_ON_QUEUE_SEND( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    49c6:	89 81       	ldd	r24, Y+1	; 0x01
    49c8:	9a 81       	ldd	r25, Y+2	; 0x02
    49ca:	08 96       	adiw	r24, 0x08	; 8
    49cc:	2c 85       	ldd	r18, Y+12	; 0x0c
    49ce:	3d 85       	ldd	r19, Y+13	; 0x0d
    49d0:	b9 01       	movw	r22, r18
    49d2:	0e 94 6c 3b 	call	0x76d8	; 0x76d8 <vTaskPlaceOnEventList>
                /* Unlocking the queue means queue events can effect the
                 * event list. It is possible that interrupts occurring now
                 * remove this task from the event list again - but as the
                 * scheduler is suspended the task will go onto the pending
                 * ready list instead of the actual ready list. */
                prvUnlockQueue( pxQueue );
    49d6:	89 81       	ldd	r24, Y+1	; 0x01
    49d8:	9a 81       	ldd	r25, Y+2	; 0x02
    49da:	0e 94 0c 2a 	call	0x5418	; 0x5418 <prvUnlockQueue>
                /* Resuming the scheduler will move tasks from the pending
                 * ready list into the ready list - so it is feasible that this
                 * task is already in the ready list before it yields - in which
                 * case the yield will not cause a context switch unless there
                 * is also a higher priority task in the pending ready list. */
                if( xTaskResumeAll() == pdFALSE )
    49de:	0e 94 9b 37 	call	0x6f36	; 0x6f36 <xTaskResumeAll>
    49e2:	88 23       	and	r24, r24
    49e4:	09 f0       	breq	.+2      	; 0x49e8 <xQueueGenericSend+0x122>
    49e6:	85 cf       	rjmp	.-246    	; 0x48f2 <xQueueGenericSend+0x2c>
                {
                    portYIELD_WITHIN_API();
    49e8:	0e 94 87 21 	call	0x430e	; 0x430e <vPortYield>
    49ec:	82 cf       	rjmp	.-252    	; 0x48f2 <xQueueGenericSend+0x2c>
                }
            }
            else
            {
                /* Try again. */
                prvUnlockQueue( pxQueue );
    49ee:	89 81       	ldd	r24, Y+1	; 0x01
    49f0:	9a 81       	ldd	r25, Y+2	; 0x02
    49f2:	0e 94 0c 2a 	call	0x5418	; 0x5418 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    49f6:	0e 94 9b 37 	call	0x6f36	; 0x6f36 <xTaskResumeAll>
    49fa:	7b cf       	rjmp	.-266    	; 0x48f2 <xQueueGenericSend+0x2c>
            }
        }
        else
        {
            /* The timeout has expired. */
            prvUnlockQueue( pxQueue );
    49fc:	89 81       	ldd	r24, Y+1	; 0x01
    49fe:	9a 81       	ldd	r25, Y+2	; 0x02
    4a00:	0e 94 0c 2a 	call	0x5418	; 0x5418 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    4a04:	0e 94 9b 37 	call	0x6f36	; 0x6f36 <xTaskResumeAll>

            traceQUEUE_SEND_FAILED( pxQueue );
            return errQUEUE_FULL;
    4a08:	1f 86       	std	Y+15, r1	; 0x0f
    4a0a:	8f 85       	ldd	r24, Y+15	; 0x0f
        }
    } /*lint -restore */
}
    4a0c:	2f 96       	adiw	r28, 0x0f	; 15
    4a0e:	0f b6       	in	r0, 0x3f	; 63
    4a10:	f8 94       	cli
    4a12:	de bf       	out	0x3e, r29	; 62
    4a14:	0f be       	out	0x3f, r0	; 63
    4a16:	cd bf       	out	0x3d, r28	; 61
    4a18:	cf 91       	pop	r28
    4a1a:	df 91       	pop	r29
    4a1c:	08 95       	ret

00004a1e <xQueueGenericSendFromISR>:

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue,
                                     const void * const pvItemToQueue,
                                     BaseType_t * const pxHigherPriorityTaskWoken,
                                     const BaseType_t xCopyPosition )
{
    4a1e:	df 93       	push	r29
    4a20:	cf 93       	push	r28
    4a22:	cd b7       	in	r28, 0x3d	; 61
    4a24:	de b7       	in	r29, 0x3e	; 62
    4a26:	2d 97       	sbiw	r28, 0x0d	; 13
    4a28:	0f b6       	in	r0, 0x3f	; 63
    4a2a:	f8 94       	cli
    4a2c:	de bf       	out	0x3e, r29	; 62
    4a2e:	0f be       	out	0x3f, r0	; 63
    4a30:	cd bf       	out	0x3d, r28	; 61
    4a32:	98 87       	std	Y+8, r25	; 0x08
    4a34:	8f 83       	std	Y+7, r24	; 0x07
    4a36:	7a 87       	std	Y+10, r23	; 0x0a
    4a38:	69 87       	std	Y+9, r22	; 0x09
    4a3a:	5c 87       	std	Y+12, r21	; 0x0c
    4a3c:	4b 87       	std	Y+11, r20	; 0x0b
    4a3e:	2d 87       	std	Y+13, r18	; 0x0d
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    Queue_t * const pxQueue = xQueue;
    4a40:	8f 81       	ldd	r24, Y+7	; 0x07
    4a42:	98 85       	ldd	r25, Y+8	; 0x08
    4a44:	9c 83       	std	Y+4, r25	; 0x04
    4a46:	8b 83       	std	Y+3, r24	; 0x03
    /* Similar to xQueueGenericSend, except without blocking if there is no room
     * in the queue.  Also don't directly wake a task that was blocked on a queue
     * read, instead return a flag to say whether a context switch is required or
     * not (i.e. has a task with a higher priority than us been woken by this
     * post). */
    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    4a48:	1d 82       	std	Y+5, r1	; 0x05
    {
        if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    4a4a:	eb 81       	ldd	r30, Y+3	; 0x03
    4a4c:	fc 81       	ldd	r31, Y+4	; 0x04
    4a4e:	92 8d       	ldd	r25, Z+26	; 0x1a
    4a50:	eb 81       	ldd	r30, Y+3	; 0x03
    4a52:	fc 81       	ldd	r31, Y+4	; 0x04
    4a54:	83 8d       	ldd	r24, Z+27	; 0x1b
    4a56:	98 17       	cp	r25, r24
    4a58:	18 f0       	brcs	.+6      	; 0x4a60 <xQueueGenericSendFromISR+0x42>
    4a5a:	8d 85       	ldd	r24, Y+13	; 0x0d
    4a5c:	82 30       	cpi	r24, 0x02	; 2
    4a5e:	81 f5       	brne	.+96     	; 0x4ac0 <xQueueGenericSendFromISR+0xa2>
        {
            const int8_t cTxLock = pxQueue->cTxLock;
    4a60:	eb 81       	ldd	r30, Y+3	; 0x03
    4a62:	fc 81       	ldd	r31, Y+4	; 0x04
    4a64:	86 8d       	ldd	r24, Z+30	; 0x1e
    4a66:	8a 83       	std	Y+2, r24	; 0x02
            const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
    4a68:	eb 81       	ldd	r30, Y+3	; 0x03
    4a6a:	fc 81       	ldd	r31, Y+4	; 0x04
    4a6c:	82 8d       	ldd	r24, Z+26	; 0x1a
    4a6e:	89 83       	std	Y+1, r24	; 0x01
            /* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
             *  semaphore or mutex.  That means prvCopyDataToQueue() cannot result
             *  in a task disinheriting a priority and prvCopyDataToQueue() can be
             *  called here even though the disinherit function does not check if
             *  the scheduler is suspended before accessing the ready lists. */
            ( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    4a70:	8b 81       	ldd	r24, Y+3	; 0x03
    4a72:	9c 81       	ldd	r25, Y+4	; 0x04
    4a74:	29 85       	ldd	r18, Y+9	; 0x09
    4a76:	3a 85       	ldd	r19, Y+10	; 0x0a
    4a78:	b9 01       	movw	r22, r18
    4a7a:	4d 85       	ldd	r20, Y+13	; 0x0d
    4a7c:	0e 94 0d 29 	call	0x521a	; 0x521a <prvCopyDataToQueue>

            /* The event list is not altered if the queue is locked.  This will
             * be done when the queue is unlocked later. */
            if( cTxLock == queueUNLOCKED )
    4a80:	8a 81       	ldd	r24, Y+2	; 0x02
    4a82:	8f 3f       	cpi	r24, 0xFF	; 255
    4a84:	a9 f4       	brne	.+42     	; 0x4ab0 <xQueueGenericSendFromISR+0x92>
                            }
                        }
                    }
                #else /* configUSE_QUEUE_SETS */
                    {
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    4a86:	eb 81       	ldd	r30, Y+3	; 0x03
    4a88:	fc 81       	ldd	r31, Y+4	; 0x04
    4a8a:	81 89       	ldd	r24, Z+17	; 0x11
    4a8c:	88 23       	and	r24, r24
    4a8e:	a9 f0       	breq	.+42     	; 0x4aba <xQueueGenericSendFromISR+0x9c>
                        {
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    4a90:	8b 81       	ldd	r24, Y+3	; 0x03
    4a92:	9c 81       	ldd	r25, Y+4	; 0x04
    4a94:	41 96       	adiw	r24, 0x11	; 17
    4a96:	0e 94 f3 3b 	call	0x77e6	; 0x77e6 <xTaskRemoveFromEventList>
    4a9a:	88 23       	and	r24, r24
    4a9c:	71 f0       	breq	.+28     	; 0x4aba <xQueueGenericSendFromISR+0x9c>
                            {
                                /* The task waiting has a higher priority so record that a
                                 * context switch is required. */
                                if( pxHigherPriorityTaskWoken != NULL )
    4a9e:	8b 85       	ldd	r24, Y+11	; 0x0b
    4aa0:	9c 85       	ldd	r25, Y+12	; 0x0c
    4aa2:	00 97       	sbiw	r24, 0x00	; 0
    4aa4:	51 f0       	breq	.+20     	; 0x4aba <xQueueGenericSendFromISR+0x9c>
                                {
                                    *pxHigherPriorityTaskWoken = pdTRUE;
    4aa6:	eb 85       	ldd	r30, Y+11	; 0x0b
    4aa8:	fc 85       	ldd	r31, Y+12	; 0x0c
    4aaa:	81 e0       	ldi	r24, 0x01	; 1
    4aac:	80 83       	st	Z, r24
    4aae:	05 c0       	rjmp	.+10     	; 0x4aba <xQueueGenericSendFromISR+0x9c>
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was posted while it was locked. */
                configASSERT( cTxLock != queueINT8_MAX );

                pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    4ab0:	8a 81       	ldd	r24, Y+2	; 0x02
    4ab2:	8f 5f       	subi	r24, 0xFF	; 255
    4ab4:	eb 81       	ldd	r30, Y+3	; 0x03
    4ab6:	fc 81       	ldd	r31, Y+4	; 0x04
    4ab8:	86 8f       	std	Z+30, r24	; 0x1e
            }

            xReturn = pdPASS;
    4aba:	81 e0       	ldi	r24, 0x01	; 1
    4abc:	8e 83       	std	Y+6, r24	; 0x06
    4abe:	01 c0       	rjmp	.+2      	; 0x4ac2 <xQueueGenericSendFromISR+0xa4>
        }
        else
        {
            traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
            xReturn = errQUEUE_FULL;
    4ac0:	1e 82       	std	Y+6, r1	; 0x06
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    4ac2:	8e 81       	ldd	r24, Y+6	; 0x06
}
    4ac4:	2d 96       	adiw	r28, 0x0d	; 13
    4ac6:	0f b6       	in	r0, 0x3f	; 63
    4ac8:	f8 94       	cli
    4aca:	de bf       	out	0x3e, r29	; 62
    4acc:	0f be       	out	0x3f, r0	; 63
    4ace:	cd bf       	out	0x3d, r28	; 61
    4ad0:	cf 91       	pop	r28
    4ad2:	df 91       	pop	r29
    4ad4:	08 95       	ret

00004ad6 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue,
                              BaseType_t * const pxHigherPriorityTaskWoken )
{
    4ad6:	df 93       	push	r29
    4ad8:	cf 93       	push	r28
    4ada:	cd b7       	in	r28, 0x3d	; 61
    4adc:	de b7       	in	r29, 0x3e	; 62
    4ade:	2a 97       	sbiw	r28, 0x0a	; 10
    4ae0:	0f b6       	in	r0, 0x3f	; 63
    4ae2:	f8 94       	cli
    4ae4:	de bf       	out	0x3e, r29	; 62
    4ae6:	0f be       	out	0x3f, r0	; 63
    4ae8:	cd bf       	out	0x3d, r28	; 61
    4aea:	98 87       	std	Y+8, r25	; 0x08
    4aec:	8f 83       	std	Y+7, r24	; 0x07
    4aee:	7a 87       	std	Y+10, r23	; 0x0a
    4af0:	69 87       	std	Y+9, r22	; 0x09
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    Queue_t * const pxQueue = xQueue;
    4af2:	8f 81       	ldd	r24, Y+7	; 0x07
    4af4:	98 85       	ldd	r25, Y+8	; 0x08
    4af6:	9c 83       	std	Y+4, r25	; 0x04
    4af8:	8b 83       	std	Y+3, r24	; 0x03
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    4afa:	1d 82       	std	Y+5, r1	; 0x05
    {
        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    4afc:	eb 81       	ldd	r30, Y+3	; 0x03
    4afe:	fc 81       	ldd	r31, Y+4	; 0x04
    4b00:	82 8d       	ldd	r24, Z+26	; 0x1a
    4b02:	8a 83       	std	Y+2, r24	; 0x02

        /* When the queue is used to implement a semaphore no data is ever
         * moved through the queue but it is still valid to see if the queue 'has
         * space'. */
        if( uxMessagesWaiting < pxQueue->uxLength )
    4b04:	eb 81       	ldd	r30, Y+3	; 0x03
    4b06:	fc 81       	ldd	r31, Y+4	; 0x04
    4b08:	93 8d       	ldd	r25, Z+27	; 0x1b
    4b0a:	8a 81       	ldd	r24, Y+2	; 0x02
    4b0c:	89 17       	cp	r24, r25
    4b0e:	48 f5       	brcc	.+82     	; 0x4b62 <xQueueGiveFromISR+0x8c>
        {
            const int8_t cTxLock = pxQueue->cTxLock;
    4b10:	eb 81       	ldd	r30, Y+3	; 0x03
    4b12:	fc 81       	ldd	r31, Y+4	; 0x04
    4b14:	86 8d       	ldd	r24, Z+30	; 0x1e
    4b16:	89 83       	std	Y+1, r24	; 0x01
             * holder - and if there is a mutex holder then the mutex cannot be
             * given from an ISR.  As this is the ISR version of the function it
             * can be assumed there is no mutex holder and no need to determine if
             * priority disinheritance is needed.  Simply increase the count of
             * messages (semaphores) available. */
            pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    4b18:	8a 81       	ldd	r24, Y+2	; 0x02
    4b1a:	8f 5f       	subi	r24, 0xFF	; 255
    4b1c:	eb 81       	ldd	r30, Y+3	; 0x03
    4b1e:	fc 81       	ldd	r31, Y+4	; 0x04
    4b20:	82 8f       	std	Z+26, r24	; 0x1a

            /* The event list is not altered if the queue is locked.  This will
             * be done when the queue is unlocked later. */
            if( cTxLock == queueUNLOCKED )
    4b22:	89 81       	ldd	r24, Y+1	; 0x01
    4b24:	8f 3f       	cpi	r24, 0xFF	; 255
    4b26:	a9 f4       	brne	.+42     	; 0x4b52 <xQueueGiveFromISR+0x7c>
                            }
                        }
                    }
                #else /* configUSE_QUEUE_SETS */
                    {
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    4b28:	eb 81       	ldd	r30, Y+3	; 0x03
    4b2a:	fc 81       	ldd	r31, Y+4	; 0x04
    4b2c:	81 89       	ldd	r24, Z+17	; 0x11
    4b2e:	88 23       	and	r24, r24
    4b30:	a9 f0       	breq	.+42     	; 0x4b5c <xQueueGiveFromISR+0x86>
                        {
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    4b32:	8b 81       	ldd	r24, Y+3	; 0x03
    4b34:	9c 81       	ldd	r25, Y+4	; 0x04
    4b36:	41 96       	adiw	r24, 0x11	; 17
    4b38:	0e 94 f3 3b 	call	0x77e6	; 0x77e6 <xTaskRemoveFromEventList>
    4b3c:	88 23       	and	r24, r24
    4b3e:	71 f0       	breq	.+28     	; 0x4b5c <xQueueGiveFromISR+0x86>
                            {
                                /* The task waiting has a higher priority so record that a
                                 * context switch is required. */
                                if( pxHigherPriorityTaskWoken != NULL )
    4b40:	89 85       	ldd	r24, Y+9	; 0x09
    4b42:	9a 85       	ldd	r25, Y+10	; 0x0a
    4b44:	00 97       	sbiw	r24, 0x00	; 0
    4b46:	51 f0       	breq	.+20     	; 0x4b5c <xQueueGiveFromISR+0x86>
                                {
                                    *pxHigherPriorityTaskWoken = pdTRUE;
    4b48:	e9 85       	ldd	r30, Y+9	; 0x09
    4b4a:	fa 85       	ldd	r31, Y+10	; 0x0a
    4b4c:	81 e0       	ldi	r24, 0x01	; 1
    4b4e:	80 83       	st	Z, r24
    4b50:	05 c0       	rjmp	.+10     	; 0x4b5c <xQueueGiveFromISR+0x86>
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was posted while it was locked. */
                configASSERT( cTxLock != queueINT8_MAX );

                pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    4b52:	89 81       	ldd	r24, Y+1	; 0x01
    4b54:	8f 5f       	subi	r24, 0xFF	; 255
    4b56:	eb 81       	ldd	r30, Y+3	; 0x03
    4b58:	fc 81       	ldd	r31, Y+4	; 0x04
    4b5a:	86 8f       	std	Z+30, r24	; 0x1e
            }

            xReturn = pdPASS;
    4b5c:	81 e0       	ldi	r24, 0x01	; 1
    4b5e:	8e 83       	std	Y+6, r24	; 0x06
    4b60:	01 c0       	rjmp	.+2      	; 0x4b64 <xQueueGiveFromISR+0x8e>
        }
        else
        {
            traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
            xReturn = errQUEUE_FULL;
    4b62:	1e 82       	std	Y+6, r1	; 0x06
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    4b64:	8e 81       	ldd	r24, Y+6	; 0x06
}
    4b66:	2a 96       	adiw	r28, 0x0a	; 10
    4b68:	0f b6       	in	r0, 0x3f	; 63
    4b6a:	f8 94       	cli
    4b6c:	de bf       	out	0x3e, r29	; 62
    4b6e:	0f be       	out	0x3f, r0	; 63
    4b70:	cd bf       	out	0x3d, r28	; 61
    4b72:	cf 91       	pop	r28
    4b74:	df 91       	pop	r29
    4b76:	08 95       	ret

00004b78 <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue,
                          void * const pvBuffer,
                          TickType_t xTicksToWait )
{
    4b78:	df 93       	push	r29
    4b7a:	cf 93       	push	r28
    4b7c:	cd b7       	in	r28, 0x3d	; 61
    4b7e:	de b7       	in	r29, 0x3e	; 62
    4b80:	2e 97       	sbiw	r28, 0x0e	; 14
    4b82:	0f b6       	in	r0, 0x3f	; 63
    4b84:	f8 94       	cli
    4b86:	de bf       	out	0x3e, r29	; 62
    4b88:	0f be       	out	0x3f, r0	; 63
    4b8a:	cd bf       	out	0x3d, r28	; 61
    4b8c:	99 87       	std	Y+9, r25	; 0x09
    4b8e:	88 87       	std	Y+8, r24	; 0x08
    4b90:	7b 87       	std	Y+11, r23	; 0x0b
    4b92:	6a 87       	std	Y+10, r22	; 0x0a
    4b94:	5d 87       	std	Y+13, r21	; 0x0d
    4b96:	4c 87       	std	Y+12, r20	; 0x0c
    BaseType_t xEntryTimeSet = pdFALSE;
    4b98:	1c 82       	std	Y+4, r1	; 0x04
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
    4b9a:	88 85       	ldd	r24, Y+8	; 0x08
    4b9c:	99 85       	ldd	r25, Y+9	; 0x09
    4b9e:	9b 83       	std	Y+3, r25	; 0x03
    4ba0:	8a 83       	std	Y+2, r24	; 0x02
    /*lint -save -e904  This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    4ba2:	0f b6       	in	r0, 0x3f	; 63
    4ba4:	f8 94       	cli
    4ba6:	0f 92       	push	r0
        {
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    4ba8:	ea 81       	ldd	r30, Y+2	; 0x02
    4baa:	fb 81       	ldd	r31, Y+3	; 0x03
    4bac:	82 8d       	ldd	r24, Z+26	; 0x1a
    4bae:	89 83       	std	Y+1, r24	; 0x01

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    4bb0:	89 81       	ldd	r24, Y+1	; 0x01
    4bb2:	88 23       	and	r24, r24
    4bb4:	f9 f0       	breq	.+62     	; 0x4bf4 <xQueueReceive+0x7c>
            {
                /* Data available, remove one item. */
                prvCopyDataFromQueue( pxQueue, pvBuffer );
    4bb6:	8a 81       	ldd	r24, Y+2	; 0x02
    4bb8:	9b 81       	ldd	r25, Y+3	; 0x03
    4bba:	2a 85       	ldd	r18, Y+10	; 0x0a
    4bbc:	3b 85       	ldd	r19, Y+11	; 0x0b
    4bbe:	b9 01       	movw	r22, r18
    4bc0:	0e 94 c5 29 	call	0x538a	; 0x538a <prvCopyDataFromQueue>
                traceQUEUE_RECEIVE( pxQueue );
                pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    4bc4:	89 81       	ldd	r24, Y+1	; 0x01
    4bc6:	81 50       	subi	r24, 0x01	; 1
    4bc8:	ea 81       	ldd	r30, Y+2	; 0x02
    4bca:	fb 81       	ldd	r31, Y+3	; 0x03
    4bcc:	82 8f       	std	Z+26, r24	; 0x1a

                /* There is now space in the queue, were any tasks waiting to
                 * post to the queue?  If so, unblock the highest priority waiting
                 * task. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    4bce:	ea 81       	ldd	r30, Y+2	; 0x02
    4bd0:	fb 81       	ldd	r31, Y+3	; 0x03
    4bd2:	80 85       	ldd	r24, Z+8	; 0x08
    4bd4:	88 23       	and	r24, r24
    4bd6:	49 f0       	breq	.+18     	; 0x4bea <xQueueReceive+0x72>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    4bd8:	8a 81       	ldd	r24, Y+2	; 0x02
    4bda:	9b 81       	ldd	r25, Y+3	; 0x03
    4bdc:	08 96       	adiw	r24, 0x08	; 8
    4bde:	0e 94 f3 3b 	call	0x77e6	; 0x77e6 <xTaskRemoveFromEventList>
    4be2:	88 23       	and	r24, r24
    4be4:	11 f0       	breq	.+4      	; 0x4bea <xQueueReceive+0x72>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
    4be6:	0e 94 87 21 	call	0x430e	; 0x430e <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
    4bea:	0f 90       	pop	r0
    4bec:	0f be       	out	0x3f, r0	; 63
                return pdPASS;
    4bee:	81 e0       	ldi	r24, 0x01	; 1
    4bf0:	8e 87       	std	Y+14, r24	; 0x0e
    4bf2:	63 c0       	rjmp	.+198    	; 0x4cba <xQueueReceive+0x142>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    4bf4:	8c 85       	ldd	r24, Y+12	; 0x0c
    4bf6:	9d 85       	ldd	r25, Y+13	; 0x0d
    4bf8:	00 97       	sbiw	r24, 0x00	; 0
    4bfa:	21 f4       	brne	.+8      	; 0x4c04 <xQueueReceive+0x8c>
                {
                    /* The queue was empty and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    4bfc:	0f 90       	pop	r0
    4bfe:	0f be       	out	0x3f, r0	; 63
                    traceQUEUE_RECEIVE_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
    4c00:	1e 86       	std	Y+14, r1	; 0x0e
    4c02:	5b c0       	rjmp	.+182    	; 0x4cba <xQueueReceive+0x142>
                }
                else if( xEntryTimeSet == pdFALSE )
    4c04:	8c 81       	ldd	r24, Y+4	; 0x04
    4c06:	88 23       	and	r24, r24
    4c08:	31 f4       	brne	.+12     	; 0x4c16 <xQueueReceive+0x9e>
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    4c0a:	ce 01       	movw	r24, r28
    4c0c:	05 96       	adiw	r24, 0x05	; 5
    4c0e:	0e 94 63 3e 	call	0x7cc6	; 0x7cc6 <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
    4c12:	81 e0       	ldi	r24, 0x01	; 1
    4c14:	8c 83       	std	Y+4, r24	; 0x04
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    4c16:	0f 90       	pop	r0
    4c18:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
    4c1a:	0e 94 8f 37 	call	0x6f1e	; 0x6f1e <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    4c1e:	0f b6       	in	r0, 0x3f	; 63
    4c20:	f8 94       	cli
    4c22:	0f 92       	push	r0
    4c24:	ea 81       	ldd	r30, Y+2	; 0x02
    4c26:	fb 81       	ldd	r31, Y+3	; 0x03
    4c28:	85 8d       	ldd	r24, Z+29	; 0x1d
    4c2a:	8f 3f       	cpi	r24, 0xFF	; 255
    4c2c:	19 f4       	brne	.+6      	; 0x4c34 <xQueueReceive+0xbc>
    4c2e:	ea 81       	ldd	r30, Y+2	; 0x02
    4c30:	fb 81       	ldd	r31, Y+3	; 0x03
    4c32:	15 8e       	std	Z+29, r1	; 0x1d
    4c34:	ea 81       	ldd	r30, Y+2	; 0x02
    4c36:	fb 81       	ldd	r31, Y+3	; 0x03
    4c38:	86 8d       	ldd	r24, Z+30	; 0x1e
    4c3a:	8f 3f       	cpi	r24, 0xFF	; 255
    4c3c:	19 f4       	brne	.+6      	; 0x4c44 <xQueueReceive+0xcc>
    4c3e:	ea 81       	ldd	r30, Y+2	; 0x02
    4c40:	fb 81       	ldd	r31, Y+3	; 0x03
    4c42:	16 8e       	std	Z+30, r1	; 0x1e
    4c44:	0f 90       	pop	r0
    4c46:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    4c48:	ce 01       	movw	r24, r28
    4c4a:	05 96       	adiw	r24, 0x05	; 5
    4c4c:	9e 01       	movw	r18, r28
    4c4e:	24 5f       	subi	r18, 0xF4	; 244
    4c50:	3f 4f       	sbci	r19, 0xFF	; 255
    4c52:	b9 01       	movw	r22, r18
    4c54:	0e 94 7c 3e 	call	0x7cf8	; 0x7cf8 <xTaskCheckForTimeOut>
    4c58:	88 23       	and	r24, r24
    4c5a:	09 f5       	brne	.+66     	; 0x4c9e <xQueueReceive+0x126>
        {
            /* The timeout has not expired.  If the queue is still empty place
             * the task on the list of tasks waiting to receive from the queue. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    4c5c:	8a 81       	ldd	r24, Y+2	; 0x02
    4c5e:	9b 81       	ldd	r25, Y+3	; 0x03
    4c60:	0e 94 5f 2a 	call	0x54be	; 0x54be <prvIsQueueEmpty>
    4c64:	88 23       	and	r24, r24
    4c66:	a1 f0       	breq	.+40     	; 0x4c90 <xQueueReceive+0x118>
            {
                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    4c68:	8a 81       	ldd	r24, Y+2	; 0x02
    4c6a:	9b 81       	ldd	r25, Y+3	; 0x03
    4c6c:	41 96       	adiw	r24, 0x11	; 17
    4c6e:	2c 85       	ldd	r18, Y+12	; 0x0c
    4c70:	3d 85       	ldd	r19, Y+13	; 0x0d
    4c72:	b9 01       	movw	r22, r18
    4c74:	0e 94 6c 3b 	call	0x76d8	; 0x76d8 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
    4c78:	8a 81       	ldd	r24, Y+2	; 0x02
    4c7a:	9b 81       	ldd	r25, Y+3	; 0x03
    4c7c:	0e 94 0c 2a 	call	0x5418	; 0x5418 <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
    4c80:	0e 94 9b 37 	call	0x6f36	; 0x6f36 <xTaskResumeAll>
    4c84:	88 23       	and	r24, r24
    4c86:	09 f0       	breq	.+2      	; 0x4c8a <xQueueReceive+0x112>
    4c88:	8c cf       	rjmp	.-232    	; 0x4ba2 <xQueueReceive+0x2a>
                {
                    portYIELD_WITHIN_API();
    4c8a:	0e 94 87 21 	call	0x430e	; 0x430e <vPortYield>
    4c8e:	89 cf       	rjmp	.-238    	; 0x4ba2 <xQueueReceive+0x2a>
            }
            else
            {
                /* The queue contains data again.  Loop back to try and read the
                 * data. */
                prvUnlockQueue( pxQueue );
    4c90:	8a 81       	ldd	r24, Y+2	; 0x02
    4c92:	9b 81       	ldd	r25, Y+3	; 0x03
    4c94:	0e 94 0c 2a 	call	0x5418	; 0x5418 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    4c98:	0e 94 9b 37 	call	0x6f36	; 0x6f36 <xTaskResumeAll>
    4c9c:	82 cf       	rjmp	.-252    	; 0x4ba2 <xQueueReceive+0x2a>
        }
        else
        {
            /* Timed out.  If there is no data in the queue exit, otherwise loop
             * back and attempt to read the data. */
            prvUnlockQueue( pxQueue );
    4c9e:	8a 81       	ldd	r24, Y+2	; 0x02
    4ca0:	9b 81       	ldd	r25, Y+3	; 0x03
    4ca2:	0e 94 0c 2a 	call	0x5418	; 0x5418 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    4ca6:	0e 94 9b 37 	call	0x6f36	; 0x6f36 <xTaskResumeAll>

            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    4caa:	8a 81       	ldd	r24, Y+2	; 0x02
    4cac:	9b 81       	ldd	r25, Y+3	; 0x03
    4cae:	0e 94 5f 2a 	call	0x54be	; 0x54be <prvIsQueueEmpty>
    4cb2:	88 23       	and	r24, r24
    4cb4:	09 f4       	brne	.+2      	; 0x4cb8 <xQueueReceive+0x140>
    4cb6:	75 cf       	rjmp	.-278    	; 0x4ba2 <xQueueReceive+0x2a>
            {
                traceQUEUE_RECEIVE_FAILED( pxQueue );
                return errQUEUE_EMPTY;
    4cb8:	1e 86       	std	Y+14, r1	; 0x0e
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
    4cba:	8e 85       	ldd	r24, Y+14	; 0x0e
}
    4cbc:	2e 96       	adiw	r28, 0x0e	; 14
    4cbe:	0f b6       	in	r0, 0x3f	; 63
    4cc0:	f8 94       	cli
    4cc2:	de bf       	out	0x3e, r29	; 62
    4cc4:	0f be       	out	0x3f, r0	; 63
    4cc6:	cd bf       	out	0x3d, r28	; 61
    4cc8:	cf 91       	pop	r28
    4cca:	df 91       	pop	r29
    4ccc:	08 95       	ret

00004cce <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue,
                                TickType_t xTicksToWait )
{
    4cce:	df 93       	push	r29
    4cd0:	cf 93       	push	r28
    4cd2:	cd b7       	in	r28, 0x3d	; 61
    4cd4:	de b7       	in	r29, 0x3e	; 62
    4cd6:	2e 97       	sbiw	r28, 0x0e	; 14
    4cd8:	0f b6       	in	r0, 0x3f	; 63
    4cda:	f8 94       	cli
    4cdc:	de bf       	out	0x3e, r29	; 62
    4cde:	0f be       	out	0x3f, r0	; 63
    4ce0:	cd bf       	out	0x3d, r28	; 61
    4ce2:	9b 87       	std	Y+11, r25	; 0x0b
    4ce4:	8a 87       	std	Y+10, r24	; 0x0a
    4ce6:	7d 87       	std	Y+13, r23	; 0x0d
    4ce8:	6c 87       	std	Y+12, r22	; 0x0c
    BaseType_t xEntryTimeSet = pdFALSE;
    4cea:	1e 82       	std	Y+6, r1	; 0x06
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
    4cec:	8a 85       	ldd	r24, Y+10	; 0x0a
    4cee:	9b 85       	ldd	r25, Y+11	; 0x0b
    4cf0:	9d 83       	std	Y+5, r25	; 0x05
    4cf2:	8c 83       	std	Y+4, r24	; 0x04

    #if ( configUSE_MUTEXES == 1 )
        BaseType_t xInheritanceOccurred = pdFALSE;
    4cf4:	1b 82       	std	Y+3, r1	; 0x03
    /*lint -save -e904 This function relaxes the coding standard somewhat to allow return
     * statements within the function itself.  This is done in the interest
     * of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    4cf6:	0f b6       	in	r0, 0x3f	; 63
    4cf8:	f8 94       	cli
    4cfa:	0f 92       	push	r0
        {
            /* Semaphores are queues with an item size of 0, and where the
             * number of messages in the queue is the semaphore's count value. */
            const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    4cfc:	ec 81       	ldd	r30, Y+4	; 0x04
    4cfe:	fd 81       	ldd	r31, Y+5	; 0x05
    4d00:	82 8d       	ldd	r24, Z+26	; 0x1a
    4d02:	8a 83       	std	Y+2, r24	; 0x02

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    4d04:	8a 81       	ldd	r24, Y+2	; 0x02
    4d06:	88 23       	and	r24, r24
    4d08:	21 f1       	breq	.+72     	; 0x4d52 <xQueueSemaphoreTake+0x84>
            {
                traceQUEUE_RECEIVE( pxQueue );

                /* Semaphores are queues with a data size of zero and where the
                 * messages waiting is the semaphore's count.  Reduce the count. */
                pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    4d0a:	8a 81       	ldd	r24, Y+2	; 0x02
    4d0c:	81 50       	subi	r24, 0x01	; 1
    4d0e:	ec 81       	ldd	r30, Y+4	; 0x04
    4d10:	fd 81       	ldd	r31, Y+5	; 0x05
    4d12:	82 8f       	std	Z+26, r24	; 0x1a

                #if ( configUSE_MUTEXES == 1 )
                    {
                        if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    4d14:	ec 81       	ldd	r30, Y+4	; 0x04
    4d16:	fd 81       	ldd	r31, Y+5	; 0x05
    4d18:	80 81       	ld	r24, Z
    4d1a:	91 81       	ldd	r25, Z+1	; 0x01
    4d1c:	00 97       	sbiw	r24, 0x00	; 0
    4d1e:	31 f4       	brne	.+12     	; 0x4d2c <xQueueSemaphoreTake+0x5e>
                        {
                            /* Record the information required to implement
                             * priority inheritance should it become necessary. */
                            pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
    4d20:	0e 94 4f 42 	call	0x849e	; 0x849e <pvTaskIncrementMutexHeldCount>
    4d24:	ec 81       	ldd	r30, Y+4	; 0x04
    4d26:	fd 81       	ldd	r31, Y+5	; 0x05
    4d28:	95 83       	std	Z+5, r25	; 0x05
    4d2a:	84 83       	std	Z+4, r24	; 0x04
                    }
                #endif /* configUSE_MUTEXES */

                /* Check to see if other tasks are blocked waiting to give the
                 * semaphore, and if so, unblock the highest priority such task. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    4d2c:	ec 81       	ldd	r30, Y+4	; 0x04
    4d2e:	fd 81       	ldd	r31, Y+5	; 0x05
    4d30:	80 85       	ldd	r24, Z+8	; 0x08
    4d32:	88 23       	and	r24, r24
    4d34:	49 f0       	breq	.+18     	; 0x4d48 <xQueueSemaphoreTake+0x7a>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    4d36:	8c 81       	ldd	r24, Y+4	; 0x04
    4d38:	9d 81       	ldd	r25, Y+5	; 0x05
    4d3a:	08 96       	adiw	r24, 0x08	; 8
    4d3c:	0e 94 f3 3b 	call	0x77e6	; 0x77e6 <xTaskRemoveFromEventList>
    4d40:	88 23       	and	r24, r24
    4d42:	11 f0       	breq	.+4      	; 0x4d48 <xQueueSemaphoreTake+0x7a>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
    4d44:	0e 94 87 21 	call	0x430e	; 0x430e <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
    4d48:	0f 90       	pop	r0
    4d4a:	0f be       	out	0x3f, r0	; 63
                return pdPASS;
    4d4c:	81 e0       	ldi	r24, 0x01	; 1
    4d4e:	8e 87       	std	Y+14, r24	; 0x0e
    4d50:	89 c0       	rjmp	.+274    	; 0x4e64 <xQueueSemaphoreTake+0x196>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    4d52:	8c 85       	ldd	r24, Y+12	; 0x0c
    4d54:	9d 85       	ldd	r25, Y+13	; 0x0d
    4d56:	00 97       	sbiw	r24, 0x00	; 0
    4d58:	21 f4       	brne	.+8      	; 0x4d62 <xQueueSemaphoreTake+0x94>
                        }
                    #endif /* configUSE_MUTEXES */

                    /* The semaphore count was 0 and no block time is specified
                     * (or the block time has expired) so exit now. */
                    taskEXIT_CRITICAL();
    4d5a:	0f 90       	pop	r0
    4d5c:	0f be       	out	0x3f, r0	; 63
                    traceQUEUE_RECEIVE_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
    4d5e:	1e 86       	std	Y+14, r1	; 0x0e
    4d60:	81 c0       	rjmp	.+258    	; 0x4e64 <xQueueSemaphoreTake+0x196>
                }
                else if( xEntryTimeSet == pdFALSE )
    4d62:	8e 81       	ldd	r24, Y+6	; 0x06
    4d64:	88 23       	and	r24, r24
    4d66:	31 f4       	brne	.+12     	; 0x4d74 <xQueueSemaphoreTake+0xa6>
                {
                    /* The semaphore count was 0 and a block time was specified
                     * so configure the timeout structure ready to block. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    4d68:	ce 01       	movw	r24, r28
    4d6a:	07 96       	adiw	r24, 0x07	; 7
    4d6c:	0e 94 63 3e 	call	0x7cc6	; 0x7cc6 <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
    4d70:	81 e0       	ldi	r24, 0x01	; 1
    4d72:	8e 83       	std	Y+6, r24	; 0x06
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    4d74:	0f 90       	pop	r0
    4d76:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can give to and take from the semaphore
         * now the critical section has been exited. */

        vTaskSuspendAll();
    4d78:	0e 94 8f 37 	call	0x6f1e	; 0x6f1e <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    4d7c:	0f b6       	in	r0, 0x3f	; 63
    4d7e:	f8 94       	cli
    4d80:	0f 92       	push	r0
    4d82:	ec 81       	ldd	r30, Y+4	; 0x04
    4d84:	fd 81       	ldd	r31, Y+5	; 0x05
    4d86:	85 8d       	ldd	r24, Z+29	; 0x1d
    4d88:	8f 3f       	cpi	r24, 0xFF	; 255
    4d8a:	19 f4       	brne	.+6      	; 0x4d92 <xQueueSemaphoreTake+0xc4>
    4d8c:	ec 81       	ldd	r30, Y+4	; 0x04
    4d8e:	fd 81       	ldd	r31, Y+5	; 0x05
    4d90:	15 8e       	std	Z+29, r1	; 0x1d
    4d92:	ec 81       	ldd	r30, Y+4	; 0x04
    4d94:	fd 81       	ldd	r31, Y+5	; 0x05
    4d96:	86 8d       	ldd	r24, Z+30	; 0x1e
    4d98:	8f 3f       	cpi	r24, 0xFF	; 255
    4d9a:	19 f4       	brne	.+6      	; 0x4da2 <xQueueSemaphoreTake+0xd4>
    4d9c:	ec 81       	ldd	r30, Y+4	; 0x04
    4d9e:	fd 81       	ldd	r31, Y+5	; 0x05
    4da0:	16 8e       	std	Z+30, r1	; 0x1e
    4da2:	0f 90       	pop	r0
    4da4:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    4da6:	ce 01       	movw	r24, r28
    4da8:	07 96       	adiw	r24, 0x07	; 7
    4daa:	9e 01       	movw	r18, r28
    4dac:	24 5f       	subi	r18, 0xF4	; 244
    4dae:	3f 4f       	sbci	r19, 0xFF	; 255
    4db0:	b9 01       	movw	r22, r18
    4db2:	0e 94 7c 3e 	call	0x7cf8	; 0x7cf8 <xTaskCheckForTimeOut>
    4db6:	88 23       	and	r24, r24
    4db8:	99 f5       	brne	.+102    	; 0x4e20 <xQueueSemaphoreTake+0x152>
        {
            /* A block time is specified and not expired.  If the semaphore
             * count is 0 then enter the Blocked state to wait for a semaphore to
             * become available.  As semaphores are implemented with queues the
             * queue being empty is equivalent to the semaphore count being 0. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    4dba:	8c 81       	ldd	r24, Y+4	; 0x04
    4dbc:	9d 81       	ldd	r25, Y+5	; 0x05
    4dbe:	0e 94 5f 2a 	call	0x54be	; 0x54be <prvIsQueueEmpty>
    4dc2:	88 23       	and	r24, r24
    4dc4:	31 f1       	breq	.+76     	; 0x4e12 <xQueueSemaphoreTake+0x144>
            {
                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

                #if ( configUSE_MUTEXES == 1 )
                    {
                        if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    4dc6:	ec 81       	ldd	r30, Y+4	; 0x04
    4dc8:	fd 81       	ldd	r31, Y+5	; 0x05
    4dca:	80 81       	ld	r24, Z
    4dcc:	91 81       	ldd	r25, Z+1	; 0x01
    4dce:	00 97       	sbiw	r24, 0x00	; 0
    4dd0:	61 f4       	brne	.+24     	; 0x4dea <xQueueSemaphoreTake+0x11c>
                        {
                            taskENTER_CRITICAL();
    4dd2:	0f b6       	in	r0, 0x3f	; 63
    4dd4:	f8 94       	cli
    4dd6:	0f 92       	push	r0
                            {
                                xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMutexHolder );
    4dd8:	ec 81       	ldd	r30, Y+4	; 0x04
    4dda:	fd 81       	ldd	r31, Y+5	; 0x05
    4ddc:	84 81       	ldd	r24, Z+4	; 0x04
    4dde:	95 81       	ldd	r25, Z+5	; 0x05
    4de0:	0e 94 b3 3f 	call	0x7f66	; 0x7f66 <xTaskPriorityInherit>
    4de4:	8b 83       	std	Y+3, r24	; 0x03
                            }
                            taskEXIT_CRITICAL();
    4de6:	0f 90       	pop	r0
    4de8:	0f be       	out	0x3f, r0	; 63
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                #endif /* if ( configUSE_MUTEXES == 1 ) */

                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    4dea:	8c 81       	ldd	r24, Y+4	; 0x04
    4dec:	9d 81       	ldd	r25, Y+5	; 0x05
    4dee:	41 96       	adiw	r24, 0x11	; 17
    4df0:	2c 85       	ldd	r18, Y+12	; 0x0c
    4df2:	3d 85       	ldd	r19, Y+13	; 0x0d
    4df4:	b9 01       	movw	r22, r18
    4df6:	0e 94 6c 3b 	call	0x76d8	; 0x76d8 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
    4dfa:	8c 81       	ldd	r24, Y+4	; 0x04
    4dfc:	9d 81       	ldd	r25, Y+5	; 0x05
    4dfe:	0e 94 0c 2a 	call	0x5418	; 0x5418 <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
    4e02:	0e 94 9b 37 	call	0x6f36	; 0x6f36 <xTaskResumeAll>
    4e06:	88 23       	and	r24, r24
    4e08:	09 f0       	breq	.+2      	; 0x4e0c <xQueueSemaphoreTake+0x13e>
    4e0a:	75 cf       	rjmp	.-278    	; 0x4cf6 <xQueueSemaphoreTake+0x28>
                {
                    portYIELD_WITHIN_API();
    4e0c:	0e 94 87 21 	call	0x430e	; 0x430e <vPortYield>
    4e10:	72 cf       	rjmp	.-284    	; 0x4cf6 <xQueueSemaphoreTake+0x28>
            }
            else
            {
                /* There was no timeout and the semaphore count was not 0, so
                 * attempt to take the semaphore again. */
                prvUnlockQueue( pxQueue );
    4e12:	8c 81       	ldd	r24, Y+4	; 0x04
    4e14:	9d 81       	ldd	r25, Y+5	; 0x05
    4e16:	0e 94 0c 2a 	call	0x5418	; 0x5418 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    4e1a:	0e 94 9b 37 	call	0x6f36	; 0x6f36 <xTaskResumeAll>
    4e1e:	6b cf       	rjmp	.-298    	; 0x4cf6 <xQueueSemaphoreTake+0x28>
            }
        }
        else
        {
            /* Timed out. */
            prvUnlockQueue( pxQueue );
    4e20:	8c 81       	ldd	r24, Y+4	; 0x04
    4e22:	9d 81       	ldd	r25, Y+5	; 0x05
    4e24:	0e 94 0c 2a 	call	0x5418	; 0x5418 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    4e28:	0e 94 9b 37 	call	0x6f36	; 0x6f36 <xTaskResumeAll>

            /* If the semaphore count is 0 exit now as the timeout has
             * expired.  Otherwise return to attempt to take the semaphore that is
             * known to be available.  As semaphores are implemented by queues the
             * queue being empty is equivalent to the semaphore count being 0. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    4e2c:	8c 81       	ldd	r24, Y+4	; 0x04
    4e2e:	9d 81       	ldd	r25, Y+5	; 0x05
    4e30:	0e 94 5f 2a 	call	0x54be	; 0x54be <prvIsQueueEmpty>
    4e34:	88 23       	and	r24, r24
    4e36:	09 f4       	brne	.+2      	; 0x4e3a <xQueueSemaphoreTake+0x16c>
    4e38:	5e cf       	rjmp	.-324    	; 0x4cf6 <xQueueSemaphoreTake+0x28>
                #if ( configUSE_MUTEXES == 1 )
                    {
                        /* xInheritanceOccurred could only have be set if
                         * pxQueue->uxQueueType == queueQUEUE_IS_MUTEX so no need to
                         * test the mutex type again to check it is actually a mutex. */
                        if( xInheritanceOccurred != pdFALSE )
    4e3a:	8b 81       	ldd	r24, Y+3	; 0x03
    4e3c:	88 23       	and	r24, r24
    4e3e:	89 f0       	breq	.+34     	; 0x4e62 <xQueueSemaphoreTake+0x194>
                        {
                            taskENTER_CRITICAL();
    4e40:	0f b6       	in	r0, 0x3f	; 63
    4e42:	f8 94       	cli
    4e44:	0f 92       	push	r0
                                /* This task blocking on the mutex caused another
                                 * task to inherit this task's priority.  Now this task
                                 * has timed out the priority should be disinherited
                                 * again, but only as low as the next highest priority
                                 * task that is waiting for the same mutex. */
                                uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );
    4e46:	8c 81       	ldd	r24, Y+4	; 0x04
    4e48:	9d 81       	ldd	r25, Y+5	; 0x05
    4e4a:	0e 94 ec 28 	call	0x51d8	; 0x51d8 <prvGetDisinheritPriorityAfterTimeout>
    4e4e:	89 83       	std	Y+1, r24	; 0x01
                                vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );
    4e50:	ec 81       	ldd	r30, Y+4	; 0x04
    4e52:	fd 81       	ldd	r31, Y+5	; 0x05
    4e54:	84 81       	ldd	r24, Z+4	; 0x04
    4e56:	95 81       	ldd	r25, Z+5	; 0x05
    4e58:	69 81       	ldd	r22, Y+1	; 0x01
    4e5a:	0e 94 50 41 	call	0x82a0	; 0x82a0 <vTaskPriorityDisinheritAfterTimeout>
                            }
                            taskEXIT_CRITICAL();
    4e5e:	0f 90       	pop	r0
    4e60:	0f be       	out	0x3f, r0	; 63
                        }
                    }
                #endif /* configUSE_MUTEXES */

                traceQUEUE_RECEIVE_FAILED( pxQueue );
                return errQUEUE_EMPTY;
    4e62:	1e 86       	std	Y+14, r1	; 0x0e
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
    4e64:	8e 85       	ldd	r24, Y+14	; 0x0e
}
    4e66:	2e 96       	adiw	r28, 0x0e	; 14
    4e68:	0f b6       	in	r0, 0x3f	; 63
    4e6a:	f8 94       	cli
    4e6c:	de bf       	out	0x3e, r29	; 62
    4e6e:	0f be       	out	0x3f, r0	; 63
    4e70:	cd bf       	out	0x3d, r28	; 61
    4e72:	cf 91       	pop	r28
    4e74:	df 91       	pop	r29
    4e76:	08 95       	ret

00004e78 <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue,
                       void * const pvBuffer,
                       TickType_t xTicksToWait )
{
    4e78:	df 93       	push	r29
    4e7a:	cf 93       	push	r28
    4e7c:	cd b7       	in	r28, 0x3d	; 61
    4e7e:	de b7       	in	r29, 0x3e	; 62
    4e80:	60 97       	sbiw	r28, 0x10	; 16
    4e82:	0f b6       	in	r0, 0x3f	; 63
    4e84:	f8 94       	cli
    4e86:	de bf       	out	0x3e, r29	; 62
    4e88:	0f be       	out	0x3f, r0	; 63
    4e8a:	cd bf       	out	0x3d, r28	; 61
    4e8c:	9b 87       	std	Y+11, r25	; 0x0b
    4e8e:	8a 87       	std	Y+10, r24	; 0x0a
    4e90:	7d 87       	std	Y+13, r23	; 0x0d
    4e92:	6c 87       	std	Y+12, r22	; 0x0c
    4e94:	5f 87       	std	Y+15, r21	; 0x0f
    4e96:	4e 87       	std	Y+14, r20	; 0x0e
    BaseType_t xEntryTimeSet = pdFALSE;
    4e98:	1e 82       	std	Y+6, r1	; 0x06
    TimeOut_t xTimeOut;
    int8_t * pcOriginalReadPosition;
    Queue_t * const pxQueue = xQueue;
    4e9a:	8a 85       	ldd	r24, Y+10	; 0x0a
    4e9c:	9b 85       	ldd	r25, Y+11	; 0x0b
    4e9e:	9b 83       	std	Y+3, r25	; 0x03
    4ea0:	8a 83       	std	Y+2, r24	; 0x02
    /*lint -save -e904  This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    4ea2:	0f b6       	in	r0, 0x3f	; 63
    4ea4:	f8 94       	cli
    4ea6:	0f 92       	push	r0
        {
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    4ea8:	ea 81       	ldd	r30, Y+2	; 0x02
    4eaa:	fb 81       	ldd	r31, Y+3	; 0x03
    4eac:	82 8d       	ldd	r24, Z+26	; 0x1a
    4eae:	89 83       	std	Y+1, r24	; 0x01

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    4eb0:	89 81       	ldd	r24, Y+1	; 0x01
    4eb2:	88 23       	and	r24, r24
    4eb4:	31 f1       	breq	.+76     	; 0x4f02 <xQueuePeek+0x8a>
            {
                /* Remember the read position so it can be reset after the data
                 * is read from the queue as this function is only peeking the
                 * data, not removing it. */
                pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    4eb6:	ea 81       	ldd	r30, Y+2	; 0x02
    4eb8:	fb 81       	ldd	r31, Y+3	; 0x03
    4eba:	86 81       	ldd	r24, Z+6	; 0x06
    4ebc:	97 81       	ldd	r25, Z+7	; 0x07
    4ebe:	9d 83       	std	Y+5, r25	; 0x05
    4ec0:	8c 83       	std	Y+4, r24	; 0x04

                prvCopyDataFromQueue( pxQueue, pvBuffer );
    4ec2:	8a 81       	ldd	r24, Y+2	; 0x02
    4ec4:	9b 81       	ldd	r25, Y+3	; 0x03
    4ec6:	2c 85       	ldd	r18, Y+12	; 0x0c
    4ec8:	3d 85       	ldd	r19, Y+13	; 0x0d
    4eca:	b9 01       	movw	r22, r18
    4ecc:	0e 94 c5 29 	call	0x538a	; 0x538a <prvCopyDataFromQueue>
                traceQUEUE_PEEK( pxQueue );

                /* The data is not being removed, so reset the read pointer. */
                pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    4ed0:	ea 81       	ldd	r30, Y+2	; 0x02
    4ed2:	fb 81       	ldd	r31, Y+3	; 0x03
    4ed4:	8c 81       	ldd	r24, Y+4	; 0x04
    4ed6:	9d 81       	ldd	r25, Y+5	; 0x05
    4ed8:	97 83       	std	Z+7, r25	; 0x07
    4eda:	86 83       	std	Z+6, r24	; 0x06

                /* The data is being left in the queue, so see if there are
                 * any other tasks waiting for the data. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    4edc:	ea 81       	ldd	r30, Y+2	; 0x02
    4ede:	fb 81       	ldd	r31, Y+3	; 0x03
    4ee0:	81 89       	ldd	r24, Z+17	; 0x11
    4ee2:	88 23       	and	r24, r24
    4ee4:	49 f0       	breq	.+18     	; 0x4ef8 <xQueuePeek+0x80>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    4ee6:	8a 81       	ldd	r24, Y+2	; 0x02
    4ee8:	9b 81       	ldd	r25, Y+3	; 0x03
    4eea:	41 96       	adiw	r24, 0x11	; 17
    4eec:	0e 94 f3 3b 	call	0x77e6	; 0x77e6 <xTaskRemoveFromEventList>
    4ef0:	88 23       	and	r24, r24
    4ef2:	11 f0       	breq	.+4      	; 0x4ef8 <xQueuePeek+0x80>
                    {
                        /* The task waiting has a higher priority than this task. */
                        queueYIELD_IF_USING_PREEMPTION();
    4ef4:	0e 94 87 21 	call	0x430e	; 0x430e <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
    4ef8:	0f 90       	pop	r0
    4efa:	0f be       	out	0x3f, r0	; 63
                return pdPASS;
    4efc:	81 e0       	ldi	r24, 0x01	; 1
    4efe:	88 8b       	std	Y+16, r24	; 0x10
    4f00:	63 c0       	rjmp	.+198    	; 0x4fc8 <xQueuePeek+0x150>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    4f02:	8e 85       	ldd	r24, Y+14	; 0x0e
    4f04:	9f 85       	ldd	r25, Y+15	; 0x0f
    4f06:	00 97       	sbiw	r24, 0x00	; 0
    4f08:	21 f4       	brne	.+8      	; 0x4f12 <xQueuePeek+0x9a>
                {
                    /* The queue was empty and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    4f0a:	0f 90       	pop	r0
    4f0c:	0f be       	out	0x3f, r0	; 63
                    traceQUEUE_PEEK_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
    4f0e:	18 8a       	std	Y+16, r1	; 0x10
    4f10:	5b c0       	rjmp	.+182    	; 0x4fc8 <xQueuePeek+0x150>
                }
                else if( xEntryTimeSet == pdFALSE )
    4f12:	8e 81       	ldd	r24, Y+6	; 0x06
    4f14:	88 23       	and	r24, r24
    4f16:	31 f4       	brne	.+12     	; 0x4f24 <xQueuePeek+0xac>
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure ready to enter the blocked
                     * state. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    4f18:	ce 01       	movw	r24, r28
    4f1a:	07 96       	adiw	r24, 0x07	; 7
    4f1c:	0e 94 63 3e 	call	0x7cc6	; 0x7cc6 <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
    4f20:	81 e0       	ldi	r24, 0x01	; 1
    4f22:	8e 83       	std	Y+6, r24	; 0x06
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    4f24:	0f 90       	pop	r0
    4f26:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can send to and receive from the queue
         * now that the critical section has been exited. */

        vTaskSuspendAll();
    4f28:	0e 94 8f 37 	call	0x6f1e	; 0x6f1e <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    4f2c:	0f b6       	in	r0, 0x3f	; 63
    4f2e:	f8 94       	cli
    4f30:	0f 92       	push	r0
    4f32:	ea 81       	ldd	r30, Y+2	; 0x02
    4f34:	fb 81       	ldd	r31, Y+3	; 0x03
    4f36:	85 8d       	ldd	r24, Z+29	; 0x1d
    4f38:	8f 3f       	cpi	r24, 0xFF	; 255
    4f3a:	19 f4       	brne	.+6      	; 0x4f42 <xQueuePeek+0xca>
    4f3c:	ea 81       	ldd	r30, Y+2	; 0x02
    4f3e:	fb 81       	ldd	r31, Y+3	; 0x03
    4f40:	15 8e       	std	Z+29, r1	; 0x1d
    4f42:	ea 81       	ldd	r30, Y+2	; 0x02
    4f44:	fb 81       	ldd	r31, Y+3	; 0x03
    4f46:	86 8d       	ldd	r24, Z+30	; 0x1e
    4f48:	8f 3f       	cpi	r24, 0xFF	; 255
    4f4a:	19 f4       	brne	.+6      	; 0x4f52 <xQueuePeek+0xda>
    4f4c:	ea 81       	ldd	r30, Y+2	; 0x02
    4f4e:	fb 81       	ldd	r31, Y+3	; 0x03
    4f50:	16 8e       	std	Z+30, r1	; 0x1e
    4f52:	0f 90       	pop	r0
    4f54:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    4f56:	ce 01       	movw	r24, r28
    4f58:	07 96       	adiw	r24, 0x07	; 7
    4f5a:	9e 01       	movw	r18, r28
    4f5c:	22 5f       	subi	r18, 0xF2	; 242
    4f5e:	3f 4f       	sbci	r19, 0xFF	; 255
    4f60:	b9 01       	movw	r22, r18
    4f62:	0e 94 7c 3e 	call	0x7cf8	; 0x7cf8 <xTaskCheckForTimeOut>
    4f66:	88 23       	and	r24, r24
    4f68:	09 f5       	brne	.+66     	; 0x4fac <xQueuePeek+0x134>
        {
            /* Timeout has not expired yet, check to see if there is data in the
            * queue now, and if not enter the Blocked state to wait for data. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    4f6a:	8a 81       	ldd	r24, Y+2	; 0x02
    4f6c:	9b 81       	ldd	r25, Y+3	; 0x03
    4f6e:	0e 94 5f 2a 	call	0x54be	; 0x54be <prvIsQueueEmpty>
    4f72:	88 23       	and	r24, r24
    4f74:	a1 f0       	breq	.+40     	; 0x4f9e <xQueuePeek+0x126>
            {
                traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    4f76:	8a 81       	ldd	r24, Y+2	; 0x02
    4f78:	9b 81       	ldd	r25, Y+3	; 0x03
    4f7a:	41 96       	adiw	r24, 0x11	; 17
    4f7c:	2e 85       	ldd	r18, Y+14	; 0x0e
    4f7e:	3f 85       	ldd	r19, Y+15	; 0x0f
    4f80:	b9 01       	movw	r22, r18
    4f82:	0e 94 6c 3b 	call	0x76d8	; 0x76d8 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
    4f86:	8a 81       	ldd	r24, Y+2	; 0x02
    4f88:	9b 81       	ldd	r25, Y+3	; 0x03
    4f8a:	0e 94 0c 2a 	call	0x5418	; 0x5418 <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
    4f8e:	0e 94 9b 37 	call	0x6f36	; 0x6f36 <xTaskResumeAll>
    4f92:	88 23       	and	r24, r24
    4f94:	09 f0       	breq	.+2      	; 0x4f98 <xQueuePeek+0x120>
    4f96:	85 cf       	rjmp	.-246    	; 0x4ea2 <xQueuePeek+0x2a>
                {
                    portYIELD_WITHIN_API();
    4f98:	0e 94 87 21 	call	0x430e	; 0x430e <vPortYield>
    4f9c:	82 cf       	rjmp	.-252    	; 0x4ea2 <xQueuePeek+0x2a>
            }
            else
            {
                /* There is data in the queue now, so don't enter the blocked
                 * state, instead return to try and obtain the data. */
                prvUnlockQueue( pxQueue );
    4f9e:	8a 81       	ldd	r24, Y+2	; 0x02
    4fa0:	9b 81       	ldd	r25, Y+3	; 0x03
    4fa2:	0e 94 0c 2a 	call	0x5418	; 0x5418 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    4fa6:	0e 94 9b 37 	call	0x6f36	; 0x6f36 <xTaskResumeAll>
    4faa:	7b cf       	rjmp	.-266    	; 0x4ea2 <xQueuePeek+0x2a>
        }
        else
        {
            /* The timeout has expired.  If there is still no data in the queue
             * exit, otherwise go back and try to read the data again. */
            prvUnlockQueue( pxQueue );
    4fac:	8a 81       	ldd	r24, Y+2	; 0x02
    4fae:	9b 81       	ldd	r25, Y+3	; 0x03
    4fb0:	0e 94 0c 2a 	call	0x5418	; 0x5418 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    4fb4:	0e 94 9b 37 	call	0x6f36	; 0x6f36 <xTaskResumeAll>

            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    4fb8:	8a 81       	ldd	r24, Y+2	; 0x02
    4fba:	9b 81       	ldd	r25, Y+3	; 0x03
    4fbc:	0e 94 5f 2a 	call	0x54be	; 0x54be <prvIsQueueEmpty>
    4fc0:	88 23       	and	r24, r24
    4fc2:	09 f4       	brne	.+2      	; 0x4fc6 <xQueuePeek+0x14e>
    4fc4:	6e cf       	rjmp	.-292    	; 0x4ea2 <xQueuePeek+0x2a>
            {
                traceQUEUE_PEEK_FAILED( pxQueue );
                return errQUEUE_EMPTY;
    4fc6:	18 8a       	std	Y+16, r1	; 0x10
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
    4fc8:	88 89       	ldd	r24, Y+16	; 0x10
}
    4fca:	60 96       	adiw	r28, 0x10	; 16
    4fcc:	0f b6       	in	r0, 0x3f	; 63
    4fce:	f8 94       	cli
    4fd0:	de bf       	out	0x3e, r29	; 62
    4fd2:	0f be       	out	0x3f, r0	; 63
    4fd4:	cd bf       	out	0x3d, r28	; 61
    4fd6:	cf 91       	pop	r28
    4fd8:	df 91       	pop	r29
    4fda:	08 95       	ret

00004fdc <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue,
                                 void * const pvBuffer,
                                 BaseType_t * const pxHigherPriorityTaskWoken )
{
    4fdc:	df 93       	push	r29
    4fde:	cf 93       	push	r28
    4fe0:	cd b7       	in	r28, 0x3d	; 61
    4fe2:	de b7       	in	r29, 0x3e	; 62
    4fe4:	2c 97       	sbiw	r28, 0x0c	; 12
    4fe6:	0f b6       	in	r0, 0x3f	; 63
    4fe8:	f8 94       	cli
    4fea:	de bf       	out	0x3e, r29	; 62
    4fec:	0f be       	out	0x3f, r0	; 63
    4fee:	cd bf       	out	0x3d, r28	; 61
    4ff0:	98 87       	std	Y+8, r25	; 0x08
    4ff2:	8f 83       	std	Y+7, r24	; 0x07
    4ff4:	7a 87       	std	Y+10, r23	; 0x0a
    4ff6:	69 87       	std	Y+9, r22	; 0x09
    4ff8:	5c 87       	std	Y+12, r21	; 0x0c
    4ffa:	4b 87       	std	Y+11, r20	; 0x0b
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    Queue_t * const pxQueue = xQueue;
    4ffc:	8f 81       	ldd	r24, Y+7	; 0x07
    4ffe:	98 85       	ldd	r25, Y+8	; 0x08
    5000:	9c 83       	std	Y+4, r25	; 0x04
    5002:	8b 83       	std	Y+3, r24	; 0x03
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    5004:	1d 82       	std	Y+5, r1	; 0x05
    {
        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    5006:	eb 81       	ldd	r30, Y+3	; 0x03
    5008:	fc 81       	ldd	r31, Y+4	; 0x04
    500a:	82 8d       	ldd	r24, Z+26	; 0x1a
    500c:	8a 83       	std	Y+2, r24	; 0x02

        /* Cannot block in an ISR, so check there is data available. */
        if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    500e:	8a 81       	ldd	r24, Y+2	; 0x02
    5010:	88 23       	and	r24, r24
    5012:	81 f1       	breq	.+96     	; 0x5074 <xQueueReceiveFromISR+0x98>
        {
            const int8_t cRxLock = pxQueue->cRxLock;
    5014:	eb 81       	ldd	r30, Y+3	; 0x03
    5016:	fc 81       	ldd	r31, Y+4	; 0x04
    5018:	85 8d       	ldd	r24, Z+29	; 0x1d
    501a:	89 83       	std	Y+1, r24	; 0x01

            traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

            prvCopyDataFromQueue( pxQueue, pvBuffer );
    501c:	8b 81       	ldd	r24, Y+3	; 0x03
    501e:	9c 81       	ldd	r25, Y+4	; 0x04
    5020:	29 85       	ldd	r18, Y+9	; 0x09
    5022:	3a 85       	ldd	r19, Y+10	; 0x0a
    5024:	b9 01       	movw	r22, r18
    5026:	0e 94 c5 29 	call	0x538a	; 0x538a <prvCopyDataFromQueue>
            pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    502a:	8a 81       	ldd	r24, Y+2	; 0x02
    502c:	81 50       	subi	r24, 0x01	; 1
    502e:	eb 81       	ldd	r30, Y+3	; 0x03
    5030:	fc 81       	ldd	r31, Y+4	; 0x04
    5032:	82 8f       	std	Z+26, r24	; 0x1a

            /* If the queue is locked the event list will not be modified.
             * Instead update the lock count so the task that unlocks the queue
             * will know that an ISR has removed data while the queue was
             * locked. */
            if( cRxLock == queueUNLOCKED )
    5034:	89 81       	ldd	r24, Y+1	; 0x01
    5036:	8f 3f       	cpi	r24, 0xFF	; 255
    5038:	a9 f4       	brne	.+42     	; 0x5064 <xQueueReceiveFromISR+0x88>
            {
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    503a:	eb 81       	ldd	r30, Y+3	; 0x03
    503c:	fc 81       	ldd	r31, Y+4	; 0x04
    503e:	80 85       	ldd	r24, Z+8	; 0x08
    5040:	88 23       	and	r24, r24
    5042:	a9 f0       	breq	.+42     	; 0x506e <xQueueReceiveFromISR+0x92>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    5044:	8b 81       	ldd	r24, Y+3	; 0x03
    5046:	9c 81       	ldd	r25, Y+4	; 0x04
    5048:	08 96       	adiw	r24, 0x08	; 8
    504a:	0e 94 f3 3b 	call	0x77e6	; 0x77e6 <xTaskRemoveFromEventList>
    504e:	88 23       	and	r24, r24
    5050:	71 f0       	breq	.+28     	; 0x506e <xQueueReceiveFromISR+0x92>
                    {
                        /* The task waiting has a higher priority than us so
                         * force a context switch. */
                        if( pxHigherPriorityTaskWoken != NULL )
    5052:	8b 85       	ldd	r24, Y+11	; 0x0b
    5054:	9c 85       	ldd	r25, Y+12	; 0x0c
    5056:	00 97       	sbiw	r24, 0x00	; 0
    5058:	51 f0       	breq	.+20     	; 0x506e <xQueueReceiveFromISR+0x92>
                        {
                            *pxHigherPriorityTaskWoken = pdTRUE;
    505a:	eb 85       	ldd	r30, Y+11	; 0x0b
    505c:	fc 85       	ldd	r31, Y+12	; 0x0c
    505e:	81 e0       	ldi	r24, 0x01	; 1
    5060:	80 83       	st	Z, r24
    5062:	05 c0       	rjmp	.+10     	; 0x506e <xQueueReceiveFromISR+0x92>
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was removed while it was locked. */
                configASSERT( cRxLock != queueINT8_MAX );

                pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    5064:	89 81       	ldd	r24, Y+1	; 0x01
    5066:	8f 5f       	subi	r24, 0xFF	; 255
    5068:	eb 81       	ldd	r30, Y+3	; 0x03
    506a:	fc 81       	ldd	r31, Y+4	; 0x04
    506c:	85 8f       	std	Z+29, r24	; 0x1d
            }

            xReturn = pdPASS;
    506e:	81 e0       	ldi	r24, 0x01	; 1
    5070:	8e 83       	std	Y+6, r24	; 0x06
    5072:	01 c0       	rjmp	.+2      	; 0x5076 <xQueueReceiveFromISR+0x9a>
        }
        else
        {
            xReturn = pdFAIL;
    5074:	1e 82       	std	Y+6, r1	; 0x06
            traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    5076:	8e 81       	ldd	r24, Y+6	; 0x06
}
    5078:	2c 96       	adiw	r28, 0x0c	; 12
    507a:	0f b6       	in	r0, 0x3f	; 63
    507c:	f8 94       	cli
    507e:	de bf       	out	0x3e, r29	; 62
    5080:	0f be       	out	0x3f, r0	; 63
    5082:	cd bf       	out	0x3d, r28	; 61
    5084:	cf 91       	pop	r28
    5086:	df 91       	pop	r29
    5088:	08 95       	ret

0000508a <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,
                              void * const pvBuffer )
{
    508a:	df 93       	push	r29
    508c:	cf 93       	push	r28
    508e:	cd b7       	in	r28, 0x3d	; 61
    5090:	de b7       	in	r29, 0x3e	; 62
    5092:	2a 97       	sbiw	r28, 0x0a	; 10
    5094:	0f b6       	in	r0, 0x3f	; 63
    5096:	f8 94       	cli
    5098:	de bf       	out	0x3e, r29	; 62
    509a:	0f be       	out	0x3f, r0	; 63
    509c:	cd bf       	out	0x3d, r28	; 61
    509e:	98 87       	std	Y+8, r25	; 0x08
    50a0:	8f 83       	std	Y+7, r24	; 0x07
    50a2:	7a 87       	std	Y+10, r23	; 0x0a
    50a4:	69 87       	std	Y+9, r22	; 0x09
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    int8_t * pcOriginalReadPosition;
    Queue_t * const pxQueue = xQueue;
    50a6:	8f 81       	ldd	r24, Y+7	; 0x07
    50a8:	98 85       	ldd	r25, Y+8	; 0x08
    50aa:	9a 83       	std	Y+2, r25	; 0x02
    50ac:	89 83       	std	Y+1, r24	; 0x01
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    50ae:	1d 82       	std	Y+5, r1	; 0x05
    {
        /* Cannot block in an ISR, so check there is data available. */
        if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    50b0:	e9 81       	ldd	r30, Y+1	; 0x01
    50b2:	fa 81       	ldd	r31, Y+2	; 0x02
    50b4:	82 8d       	ldd	r24, Z+26	; 0x1a
    50b6:	88 23       	and	r24, r24
    50b8:	b1 f0       	breq	.+44     	; 0x50e6 <xQueuePeekFromISR+0x5c>
        {
            traceQUEUE_PEEK_FROM_ISR( pxQueue );

            /* Remember the read position so it can be reset as nothing is
             * actually being removed from the queue. */
            pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    50ba:	e9 81       	ldd	r30, Y+1	; 0x01
    50bc:	fa 81       	ldd	r31, Y+2	; 0x02
    50be:	86 81       	ldd	r24, Z+6	; 0x06
    50c0:	97 81       	ldd	r25, Z+7	; 0x07
    50c2:	9c 83       	std	Y+4, r25	; 0x04
    50c4:	8b 83       	std	Y+3, r24	; 0x03
            prvCopyDataFromQueue( pxQueue, pvBuffer );
    50c6:	89 81       	ldd	r24, Y+1	; 0x01
    50c8:	9a 81       	ldd	r25, Y+2	; 0x02
    50ca:	29 85       	ldd	r18, Y+9	; 0x09
    50cc:	3a 85       	ldd	r19, Y+10	; 0x0a
    50ce:	b9 01       	movw	r22, r18
    50d0:	0e 94 c5 29 	call	0x538a	; 0x538a <prvCopyDataFromQueue>
            pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    50d4:	e9 81       	ldd	r30, Y+1	; 0x01
    50d6:	fa 81       	ldd	r31, Y+2	; 0x02
    50d8:	8b 81       	ldd	r24, Y+3	; 0x03
    50da:	9c 81       	ldd	r25, Y+4	; 0x04
    50dc:	97 83       	std	Z+7, r25	; 0x07
    50de:	86 83       	std	Z+6, r24	; 0x06

            xReturn = pdPASS;
    50e0:	81 e0       	ldi	r24, 0x01	; 1
    50e2:	8e 83       	std	Y+6, r24	; 0x06
    50e4:	01 c0       	rjmp	.+2      	; 0x50e8 <xQueuePeekFromISR+0x5e>
        }
        else
        {
            xReturn = pdFAIL;
    50e6:	1e 82       	std	Y+6, r1	; 0x06
            traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    50e8:	8e 81       	ldd	r24, Y+6	; 0x06
}
    50ea:	2a 96       	adiw	r28, 0x0a	; 10
    50ec:	0f b6       	in	r0, 0x3f	; 63
    50ee:	f8 94       	cli
    50f0:	de bf       	out	0x3e, r29	; 62
    50f2:	0f be       	out	0x3f, r0	; 63
    50f4:	cd bf       	out	0x3d, r28	; 61
    50f6:	cf 91       	pop	r28
    50f8:	df 91       	pop	r29
    50fa:	08 95       	ret

000050fc <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    50fc:	df 93       	push	r29
    50fe:	cf 93       	push	r28
    5100:	00 d0       	rcall	.+0      	; 0x5102 <uxQueueMessagesWaiting+0x6>
    5102:	0f 92       	push	r0
    5104:	cd b7       	in	r28, 0x3d	; 61
    5106:	de b7       	in	r29, 0x3e	; 62
    5108:	9b 83       	std	Y+3, r25	; 0x03
    510a:	8a 83       	std	Y+2, r24	; 0x02
    UBaseType_t uxReturn;

    configASSERT( xQueue );

    taskENTER_CRITICAL();
    510c:	0f b6       	in	r0, 0x3f	; 63
    510e:	f8 94       	cli
    5110:	0f 92       	push	r0
    {
        uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    5112:	ea 81       	ldd	r30, Y+2	; 0x02
    5114:	fb 81       	ldd	r31, Y+3	; 0x03
    5116:	82 8d       	ldd	r24, Z+26	; 0x1a
    5118:	89 83       	std	Y+1, r24	; 0x01
    }
    taskEXIT_CRITICAL();
    511a:	0f 90       	pop	r0
    511c:	0f be       	out	0x3f, r0	; 63

    return uxReturn;
    511e:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    5120:	0f 90       	pop	r0
    5122:	0f 90       	pop	r0
    5124:	0f 90       	pop	r0
    5126:	cf 91       	pop	r28
    5128:	df 91       	pop	r29
    512a:	08 95       	ret

0000512c <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    512c:	df 93       	push	r29
    512e:	cf 93       	push	r28
    5130:	00 d0       	rcall	.+0      	; 0x5132 <uxQueueSpacesAvailable+0x6>
    5132:	00 d0       	rcall	.+0      	; 0x5134 <uxQueueSpacesAvailable+0x8>
    5134:	0f 92       	push	r0
    5136:	cd b7       	in	r28, 0x3d	; 61
    5138:	de b7       	in	r29, 0x3e	; 62
    513a:	9d 83       	std	Y+5, r25	; 0x05
    513c:	8c 83       	std	Y+4, r24	; 0x04
    UBaseType_t uxReturn;
    Queue_t * const pxQueue = xQueue;
    513e:	8c 81       	ldd	r24, Y+4	; 0x04
    5140:	9d 81       	ldd	r25, Y+5	; 0x05
    5142:	9a 83       	std	Y+2, r25	; 0x02
    5144:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );

    taskENTER_CRITICAL();
    5146:	0f b6       	in	r0, 0x3f	; 63
    5148:	f8 94       	cli
    514a:	0f 92       	push	r0
    {
        uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    514c:	e9 81       	ldd	r30, Y+1	; 0x01
    514e:	fa 81       	ldd	r31, Y+2	; 0x02
    5150:	93 8d       	ldd	r25, Z+27	; 0x1b
    5152:	e9 81       	ldd	r30, Y+1	; 0x01
    5154:	fa 81       	ldd	r31, Y+2	; 0x02
    5156:	82 8d       	ldd	r24, Z+26	; 0x1a
    5158:	29 2f       	mov	r18, r25
    515a:	28 1b       	sub	r18, r24
    515c:	82 2f       	mov	r24, r18
    515e:	8b 83       	std	Y+3, r24	; 0x03
    }
    taskEXIT_CRITICAL();
    5160:	0f 90       	pop	r0
    5162:	0f be       	out	0x3f, r0	; 63

    return uxReturn;
    5164:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    5166:	0f 90       	pop	r0
    5168:	0f 90       	pop	r0
    516a:	0f 90       	pop	r0
    516c:	0f 90       	pop	r0
    516e:	0f 90       	pop	r0
    5170:	cf 91       	pop	r28
    5172:	df 91       	pop	r29
    5174:	08 95       	ret

00005176 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
    5176:	df 93       	push	r29
    5178:	cf 93       	push	r28
    517a:	00 d0       	rcall	.+0      	; 0x517c <uxQueueMessagesWaitingFromISR+0x6>
    517c:	00 d0       	rcall	.+0      	; 0x517e <uxQueueMessagesWaitingFromISR+0x8>
    517e:	0f 92       	push	r0
    5180:	cd b7       	in	r28, 0x3d	; 61
    5182:	de b7       	in	r29, 0x3e	; 62
    5184:	9d 83       	std	Y+5, r25	; 0x05
    5186:	8c 83       	std	Y+4, r24	; 0x04
    UBaseType_t uxReturn;
    Queue_t * const pxQueue = xQueue;
    5188:	8c 81       	ldd	r24, Y+4	; 0x04
    518a:	9d 81       	ldd	r25, Y+5	; 0x05
    518c:	9a 83       	std	Y+2, r25	; 0x02
    518e:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );
    uxReturn = pxQueue->uxMessagesWaiting;
    5190:	e9 81       	ldd	r30, Y+1	; 0x01
    5192:	fa 81       	ldd	r31, Y+2	; 0x02
    5194:	82 8d       	ldd	r24, Z+26	; 0x1a
    5196:	8b 83       	std	Y+3, r24	; 0x03

    return uxReturn;
    5198:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    519a:	0f 90       	pop	r0
    519c:	0f 90       	pop	r0
    519e:	0f 90       	pop	r0
    51a0:	0f 90       	pop	r0
    51a2:	0f 90       	pop	r0
    51a4:	cf 91       	pop	r28
    51a6:	df 91       	pop	r29
    51a8:	08 95       	ret

000051aa <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    51aa:	df 93       	push	r29
    51ac:	cf 93       	push	r28
    51ae:	00 d0       	rcall	.+0      	; 0x51b0 <vQueueDelete+0x6>
    51b0:	00 d0       	rcall	.+0      	; 0x51b2 <vQueueDelete+0x8>
    51b2:	cd b7       	in	r28, 0x3d	; 61
    51b4:	de b7       	in	r29, 0x3e	; 62
    51b6:	9c 83       	std	Y+4, r25	; 0x04
    51b8:	8b 83       	std	Y+3, r24	; 0x03
    Queue_t * const pxQueue = xQueue;
    51ba:	8b 81       	ldd	r24, Y+3	; 0x03
    51bc:	9c 81       	ldd	r25, Y+4	; 0x04
    51be:	9a 83       	std	Y+2, r25	; 0x02
    51c0:	89 83       	std	Y+1, r24	; 0x01

    #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
        {
            /* The queue can only have been allocated dynamically - free it
             * again. */
            vPortFree( pxQueue );
    51c2:	89 81       	ldd	r24, Y+1	; 0x01
    51c4:	9a 81       	ldd	r25, Y+2	; 0x02
    51c6:	0e 94 6c 1e 	call	0x3cd8	; 0x3cd8 <vPortFree>
            /* The queue must have been statically allocated, so is not going to be
             * deleted.  Avoid compiler warnings about the unused parameter. */
            ( void ) pxQueue;
        }
    #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
    51ca:	0f 90       	pop	r0
    51cc:	0f 90       	pop	r0
    51ce:	0f 90       	pop	r0
    51d0:	0f 90       	pop	r0
    51d2:	cf 91       	pop	r28
    51d4:	df 91       	pop	r29
    51d6:	08 95       	ret

000051d8 <prvGetDisinheritPriorityAfterTimeout>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

    static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue )
    {
    51d8:	df 93       	push	r29
    51da:	cf 93       	push	r28
    51dc:	00 d0       	rcall	.+0      	; 0x51de <prvGetDisinheritPriorityAfterTimeout+0x6>
    51de:	0f 92       	push	r0
    51e0:	cd b7       	in	r28, 0x3d	; 61
    51e2:	de b7       	in	r29, 0x3e	; 62
    51e4:	9b 83       	std	Y+3, r25	; 0x03
    51e6:	8a 83       	std	Y+2, r24	; 0x02
         * priority, but the waiting task times out, then the holder should
         * disinherit the priority - but only down to the highest priority of any
         * other tasks that are waiting for the same mutex.  For this purpose,
         * return the priority of the highest priority task that is waiting for the
         * mutex. */
        if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
    51e8:	ea 81       	ldd	r30, Y+2	; 0x02
    51ea:	fb 81       	ldd	r31, Y+3	; 0x03
    51ec:	81 89       	ldd	r24, Z+17	; 0x11
    51ee:	88 23       	and	r24, r24
    51f0:	61 f0       	breq	.+24     	; 0x520a <prvGetDisinheritPriorityAfterTimeout+0x32>
        {
            uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );
    51f2:	ea 81       	ldd	r30, Y+2	; 0x02
    51f4:	fb 81       	ldd	r31, Y+3	; 0x03
    51f6:	06 88       	ldd	r0, Z+22	; 0x16
    51f8:	f7 89       	ldd	r31, Z+23	; 0x17
    51fa:	e0 2d       	mov	r30, r0
    51fc:	80 81       	ld	r24, Z
    51fe:	91 81       	ldd	r25, Z+1	; 0x01
    5200:	98 2f       	mov	r25, r24
    5202:	84 e0       	ldi	r24, 0x04	; 4
    5204:	89 1b       	sub	r24, r25
    5206:	89 83       	std	Y+1, r24	; 0x01
    5208:	01 c0       	rjmp	.+2      	; 0x520c <prvGetDisinheritPriorityAfterTimeout+0x34>
        }
        else
        {
            uxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;
    520a:	19 82       	std	Y+1, r1	; 0x01
        }

        return uxHighestPriorityOfWaitingTasks;
    520c:	89 81       	ldd	r24, Y+1	; 0x01
    }
    520e:	0f 90       	pop	r0
    5210:	0f 90       	pop	r0
    5212:	0f 90       	pop	r0
    5214:	cf 91       	pop	r28
    5216:	df 91       	pop	r29
    5218:	08 95       	ret

0000521a <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue,
                                      const void * pvItemToQueue,
                                      const BaseType_t xPosition )
{
    521a:	df 93       	push	r29
    521c:	cf 93       	push	r28
    521e:	cd b7       	in	r28, 0x3d	; 61
    5220:	de b7       	in	r29, 0x3e	; 62
    5222:	27 97       	sbiw	r28, 0x07	; 7
    5224:	0f b6       	in	r0, 0x3f	; 63
    5226:	f8 94       	cli
    5228:	de bf       	out	0x3e, r29	; 62
    522a:	0f be       	out	0x3f, r0	; 63
    522c:	cd bf       	out	0x3d, r28	; 61
    522e:	9c 83       	std	Y+4, r25	; 0x04
    5230:	8b 83       	std	Y+3, r24	; 0x03
    5232:	7e 83       	std	Y+6, r23	; 0x06
    5234:	6d 83       	std	Y+5, r22	; 0x05
    5236:	4f 83       	std	Y+7, r20	; 0x07
    BaseType_t xReturn = pdFALSE;
    5238:	1a 82       	std	Y+2, r1	; 0x02
    UBaseType_t uxMessagesWaiting;

    /* This function is called from a critical section. */

    uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    523a:	eb 81       	ldd	r30, Y+3	; 0x03
    523c:	fc 81       	ldd	r31, Y+4	; 0x04
    523e:	82 8d       	ldd	r24, Z+26	; 0x1a
    5240:	89 83       	std	Y+1, r24	; 0x01

    if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    5242:	eb 81       	ldd	r30, Y+3	; 0x03
    5244:	fc 81       	ldd	r31, Y+4	; 0x04
    5246:	84 8d       	ldd	r24, Z+28	; 0x1c
    5248:	88 23       	and	r24, r24
    524a:	99 f4       	brne	.+38     	; 0x5272 <prvCopyDataToQueue+0x58>
    {
        #if ( configUSE_MUTEXES == 1 )
            {
                if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    524c:	eb 81       	ldd	r30, Y+3	; 0x03
    524e:	fc 81       	ldd	r31, Y+4	; 0x04
    5250:	80 81       	ld	r24, Z
    5252:	91 81       	ldd	r25, Z+1	; 0x01
    5254:	00 97       	sbiw	r24, 0x00	; 0
    5256:	09 f0       	breq	.+2      	; 0x525a <prvCopyDataToQueue+0x40>
    5258:	89 c0       	rjmp	.+274    	; 0x536c <prvCopyDataToQueue+0x152>
                {
                    /* The mutex is no longer being held. */
                    xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
    525a:	eb 81       	ldd	r30, Y+3	; 0x03
    525c:	fc 81       	ldd	r31, Y+4	; 0x04
    525e:	84 81       	ldd	r24, Z+4	; 0x04
    5260:	95 81       	ldd	r25, Z+5	; 0x05
    5262:	0e 94 98 40 	call	0x8130	; 0x8130 <xTaskPriorityDisinherit>
    5266:	8a 83       	std	Y+2, r24	; 0x02
                    pxQueue->u.xSemaphore.xMutexHolder = NULL;
    5268:	eb 81       	ldd	r30, Y+3	; 0x03
    526a:	fc 81       	ldd	r31, Y+4	; 0x04
    526c:	15 82       	std	Z+5, r1	; 0x05
    526e:	14 82       	std	Z+4, r1	; 0x04
    5270:	7d c0       	rjmp	.+250    	; 0x536c <prvCopyDataToQueue+0x152>
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        #endif /* configUSE_MUTEXES */
    }
    else if( xPosition == queueSEND_TO_BACK )
    5272:	8f 81       	ldd	r24, Y+7	; 0x07
    5274:	88 23       	and	r24, r24
    5276:	99 f5       	brne	.+102    	; 0x52de <prvCopyDataToQueue+0xc4>
    {
        ( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    5278:	eb 81       	ldd	r30, Y+3	; 0x03
    527a:	fc 81       	ldd	r31, Y+4	; 0x04
    527c:	62 81       	ldd	r22, Z+2	; 0x02
    527e:	73 81       	ldd	r23, Z+3	; 0x03
    5280:	eb 81       	ldd	r30, Y+3	; 0x03
    5282:	fc 81       	ldd	r31, Y+4	; 0x04
    5284:	84 8d       	ldd	r24, Z+28	; 0x1c
    5286:	48 2f       	mov	r20, r24
    5288:	50 e0       	ldi	r21, 0x00	; 0
    528a:	2d 81       	ldd	r18, Y+5	; 0x05
    528c:	3e 81       	ldd	r19, Y+6	; 0x06
    528e:	cb 01       	movw	r24, r22
    5290:	b9 01       	movw	r22, r18
    5292:	0e 94 80 4c 	call	0x9900	; 0x9900 <memcpy>
        pxQueue->pcWriteTo += pxQueue->uxItemSize;                                                       /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    5296:	eb 81       	ldd	r30, Y+3	; 0x03
    5298:	fc 81       	ldd	r31, Y+4	; 0x04
    529a:	22 81       	ldd	r18, Z+2	; 0x02
    529c:	33 81       	ldd	r19, Z+3	; 0x03
    529e:	eb 81       	ldd	r30, Y+3	; 0x03
    52a0:	fc 81       	ldd	r31, Y+4	; 0x04
    52a2:	84 8d       	ldd	r24, Z+28	; 0x1c
    52a4:	88 2f       	mov	r24, r24
    52a6:	90 e0       	ldi	r25, 0x00	; 0
    52a8:	82 0f       	add	r24, r18
    52aa:	93 1f       	adc	r25, r19
    52ac:	eb 81       	ldd	r30, Y+3	; 0x03
    52ae:	fc 81       	ldd	r31, Y+4	; 0x04
    52b0:	93 83       	std	Z+3, r25	; 0x03
    52b2:	82 83       	std	Z+2, r24	; 0x02

        if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail )                                             /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    52b4:	eb 81       	ldd	r30, Y+3	; 0x03
    52b6:	fc 81       	ldd	r31, Y+4	; 0x04
    52b8:	22 81       	ldd	r18, Z+2	; 0x02
    52ba:	33 81       	ldd	r19, Z+3	; 0x03
    52bc:	eb 81       	ldd	r30, Y+3	; 0x03
    52be:	fc 81       	ldd	r31, Y+4	; 0x04
    52c0:	84 81       	ldd	r24, Z+4	; 0x04
    52c2:	95 81       	ldd	r25, Z+5	; 0x05
    52c4:	28 17       	cp	r18, r24
    52c6:	39 07       	cpc	r19, r25
    52c8:	08 f4       	brcc	.+2      	; 0x52cc <prvCopyDataToQueue+0xb2>
    52ca:	50 c0       	rjmp	.+160    	; 0x536c <prvCopyDataToQueue+0x152>
        {
            pxQueue->pcWriteTo = pxQueue->pcHead;
    52cc:	eb 81       	ldd	r30, Y+3	; 0x03
    52ce:	fc 81       	ldd	r31, Y+4	; 0x04
    52d0:	80 81       	ld	r24, Z
    52d2:	91 81       	ldd	r25, Z+1	; 0x01
    52d4:	eb 81       	ldd	r30, Y+3	; 0x03
    52d6:	fc 81       	ldd	r31, Y+4	; 0x04
    52d8:	93 83       	std	Z+3, r25	; 0x03
    52da:	82 83       	std	Z+2, r24	; 0x02
    52dc:	47 c0       	rjmp	.+142    	; 0x536c <prvCopyDataToQueue+0x152>
            mtCOVERAGE_TEST_MARKER();
        }
    }
    else
    {
        ( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    52de:	eb 81       	ldd	r30, Y+3	; 0x03
    52e0:	fc 81       	ldd	r31, Y+4	; 0x04
    52e2:	66 81       	ldd	r22, Z+6	; 0x06
    52e4:	77 81       	ldd	r23, Z+7	; 0x07
    52e6:	eb 81       	ldd	r30, Y+3	; 0x03
    52e8:	fc 81       	ldd	r31, Y+4	; 0x04
    52ea:	84 8d       	ldd	r24, Z+28	; 0x1c
    52ec:	48 2f       	mov	r20, r24
    52ee:	50 e0       	ldi	r21, 0x00	; 0
    52f0:	2d 81       	ldd	r18, Y+5	; 0x05
    52f2:	3e 81       	ldd	r19, Y+6	; 0x06
    52f4:	cb 01       	movw	r24, r22
    52f6:	b9 01       	movw	r22, r18
    52f8:	0e 94 80 4c 	call	0x9900	; 0x9900 <memcpy>
        pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    52fc:	eb 81       	ldd	r30, Y+3	; 0x03
    52fe:	fc 81       	ldd	r31, Y+4	; 0x04
    5300:	26 81       	ldd	r18, Z+6	; 0x06
    5302:	37 81       	ldd	r19, Z+7	; 0x07
    5304:	eb 81       	ldd	r30, Y+3	; 0x03
    5306:	fc 81       	ldd	r31, Y+4	; 0x04
    5308:	84 8d       	ldd	r24, Z+28	; 0x1c
    530a:	88 2f       	mov	r24, r24
    530c:	90 e0       	ldi	r25, 0x00	; 0
    530e:	90 95       	com	r25
    5310:	81 95       	neg	r24
    5312:	9f 4f       	sbci	r25, 0xFF	; 255
    5314:	82 0f       	add	r24, r18
    5316:	93 1f       	adc	r25, r19
    5318:	eb 81       	ldd	r30, Y+3	; 0x03
    531a:	fc 81       	ldd	r31, Y+4	; 0x04
    531c:	97 83       	std	Z+7, r25	; 0x07
    531e:	86 83       	std	Z+6, r24	; 0x06

        if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    5320:	eb 81       	ldd	r30, Y+3	; 0x03
    5322:	fc 81       	ldd	r31, Y+4	; 0x04
    5324:	26 81       	ldd	r18, Z+6	; 0x06
    5326:	37 81       	ldd	r19, Z+7	; 0x07
    5328:	eb 81       	ldd	r30, Y+3	; 0x03
    532a:	fc 81       	ldd	r31, Y+4	; 0x04
    532c:	80 81       	ld	r24, Z
    532e:	91 81       	ldd	r25, Z+1	; 0x01
    5330:	28 17       	cp	r18, r24
    5332:	39 07       	cpc	r19, r25
    5334:	90 f4       	brcc	.+36     	; 0x535a <prvCopyDataToQueue+0x140>
        {
            pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    5336:	eb 81       	ldd	r30, Y+3	; 0x03
    5338:	fc 81       	ldd	r31, Y+4	; 0x04
    533a:	24 81       	ldd	r18, Z+4	; 0x04
    533c:	35 81       	ldd	r19, Z+5	; 0x05
    533e:	eb 81       	ldd	r30, Y+3	; 0x03
    5340:	fc 81       	ldd	r31, Y+4	; 0x04
    5342:	84 8d       	ldd	r24, Z+28	; 0x1c
    5344:	88 2f       	mov	r24, r24
    5346:	90 e0       	ldi	r25, 0x00	; 0
    5348:	90 95       	com	r25
    534a:	81 95       	neg	r24
    534c:	9f 4f       	sbci	r25, 0xFF	; 255
    534e:	82 0f       	add	r24, r18
    5350:	93 1f       	adc	r25, r19
    5352:	eb 81       	ldd	r30, Y+3	; 0x03
    5354:	fc 81       	ldd	r31, Y+4	; 0x04
    5356:	97 83       	std	Z+7, r25	; 0x07
    5358:	86 83       	std	Z+6, r24	; 0x06
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        if( xPosition == queueOVERWRITE )
    535a:	8f 81       	ldd	r24, Y+7	; 0x07
    535c:	82 30       	cpi	r24, 0x02	; 2
    535e:	31 f4       	brne	.+12     	; 0x536c <prvCopyDataToQueue+0x152>
        {
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    5360:	89 81       	ldd	r24, Y+1	; 0x01
    5362:	88 23       	and	r24, r24
    5364:	19 f0       	breq	.+6      	; 0x536c <prvCopyDataToQueue+0x152>
            {
                /* An item is not being added but overwritten, so subtract
                 * one from the recorded number of items in the queue so when
                 * one is added again below the number of recorded items remains
                 * correct. */
                --uxMessagesWaiting;
    5366:	89 81       	ldd	r24, Y+1	; 0x01
    5368:	81 50       	subi	r24, 0x01	; 1
    536a:	89 83       	std	Y+1, r24	; 0x01
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    536c:	89 81       	ldd	r24, Y+1	; 0x01
    536e:	8f 5f       	subi	r24, 0xFF	; 255
    5370:	eb 81       	ldd	r30, Y+3	; 0x03
    5372:	fc 81       	ldd	r31, Y+4	; 0x04
    5374:	82 8f       	std	Z+26, r24	; 0x1a

    return xReturn;
    5376:	8a 81       	ldd	r24, Y+2	; 0x02
}
    5378:	27 96       	adiw	r28, 0x07	; 7
    537a:	0f b6       	in	r0, 0x3f	; 63
    537c:	f8 94       	cli
    537e:	de bf       	out	0x3e, r29	; 62
    5380:	0f be       	out	0x3f, r0	; 63
    5382:	cd bf       	out	0x3d, r28	; 61
    5384:	cf 91       	pop	r28
    5386:	df 91       	pop	r29
    5388:	08 95       	ret

0000538a <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue,
                                  void * const pvBuffer )
{
    538a:	df 93       	push	r29
    538c:	cf 93       	push	r28
    538e:	00 d0       	rcall	.+0      	; 0x5390 <prvCopyDataFromQueue+0x6>
    5390:	00 d0       	rcall	.+0      	; 0x5392 <prvCopyDataFromQueue+0x8>
    5392:	cd b7       	in	r28, 0x3d	; 61
    5394:	de b7       	in	r29, 0x3e	; 62
    5396:	9a 83       	std	Y+2, r25	; 0x02
    5398:	89 83       	std	Y+1, r24	; 0x01
    539a:	7c 83       	std	Y+4, r23	; 0x04
    539c:	6b 83       	std	Y+3, r22	; 0x03
    if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    539e:	e9 81       	ldd	r30, Y+1	; 0x01
    53a0:	fa 81       	ldd	r31, Y+2	; 0x02
    53a2:	84 8d       	ldd	r24, Z+28	; 0x1c
    53a4:	88 23       	and	r24, r24
    53a6:	89 f1       	breq	.+98     	; 0x540a <prvCopyDataFromQueue+0x80>
    {
        pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;           /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    53a8:	e9 81       	ldd	r30, Y+1	; 0x01
    53aa:	fa 81       	ldd	r31, Y+2	; 0x02
    53ac:	26 81       	ldd	r18, Z+6	; 0x06
    53ae:	37 81       	ldd	r19, Z+7	; 0x07
    53b0:	e9 81       	ldd	r30, Y+1	; 0x01
    53b2:	fa 81       	ldd	r31, Y+2	; 0x02
    53b4:	84 8d       	ldd	r24, Z+28	; 0x1c
    53b6:	88 2f       	mov	r24, r24
    53b8:	90 e0       	ldi	r25, 0x00	; 0
    53ba:	82 0f       	add	r24, r18
    53bc:	93 1f       	adc	r25, r19
    53be:	e9 81       	ldd	r30, Y+1	; 0x01
    53c0:	fa 81       	ldd	r31, Y+2	; 0x02
    53c2:	97 83       	std	Z+7, r25	; 0x07
    53c4:	86 83       	std	Z+6, r24	; 0x06

        if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    53c6:	e9 81       	ldd	r30, Y+1	; 0x01
    53c8:	fa 81       	ldd	r31, Y+2	; 0x02
    53ca:	26 81       	ldd	r18, Z+6	; 0x06
    53cc:	37 81       	ldd	r19, Z+7	; 0x07
    53ce:	e9 81       	ldd	r30, Y+1	; 0x01
    53d0:	fa 81       	ldd	r31, Y+2	; 0x02
    53d2:	84 81       	ldd	r24, Z+4	; 0x04
    53d4:	95 81       	ldd	r25, Z+5	; 0x05
    53d6:	28 17       	cp	r18, r24
    53d8:	39 07       	cpc	r19, r25
    53da:	40 f0       	brcs	.+16     	; 0x53ec <prvCopyDataFromQueue+0x62>
        {
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    53dc:	e9 81       	ldd	r30, Y+1	; 0x01
    53de:	fa 81       	ldd	r31, Y+2	; 0x02
    53e0:	80 81       	ld	r24, Z
    53e2:	91 81       	ldd	r25, Z+1	; 0x01
    53e4:	e9 81       	ldd	r30, Y+1	; 0x01
    53e6:	fa 81       	ldd	r31, Y+2	; 0x02
    53e8:	97 83       	std	Z+7, r25	; 0x07
    53ea:	86 83       	std	Z+6, r24	; 0x06
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    53ec:	e9 81       	ldd	r30, Y+1	; 0x01
    53ee:	fa 81       	ldd	r31, Y+2	; 0x02
    53f0:	46 81       	ldd	r20, Z+6	; 0x06
    53f2:	57 81       	ldd	r21, Z+7	; 0x07
    53f4:	e9 81       	ldd	r30, Y+1	; 0x01
    53f6:	fa 81       	ldd	r31, Y+2	; 0x02
    53f8:	84 8d       	ldd	r24, Z+28	; 0x1c
    53fa:	28 2f       	mov	r18, r24
    53fc:	30 e0       	ldi	r19, 0x00	; 0
    53fe:	8b 81       	ldd	r24, Y+3	; 0x03
    5400:	9c 81       	ldd	r25, Y+4	; 0x04
    5402:	ba 01       	movw	r22, r20
    5404:	a9 01       	movw	r20, r18
    5406:	0e 94 80 4c 	call	0x9900	; 0x9900 <memcpy>
    }
}
    540a:	0f 90       	pop	r0
    540c:	0f 90       	pop	r0
    540e:	0f 90       	pop	r0
    5410:	0f 90       	pop	r0
    5412:	cf 91       	pop	r28
    5414:	df 91       	pop	r29
    5416:	08 95       	ret

00005418 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    5418:	df 93       	push	r29
    541a:	cf 93       	push	r28
    541c:	00 d0       	rcall	.+0      	; 0x541e <prvUnlockQueue+0x6>
    541e:	00 d0       	rcall	.+0      	; 0x5420 <prvUnlockQueue+0x8>
    5420:	cd b7       	in	r28, 0x3d	; 61
    5422:	de b7       	in	r29, 0x3e	; 62
    5424:	9c 83       	std	Y+4, r25	; 0x04
    5426:	8b 83       	std	Y+3, r24	; 0x03

    /* The lock counts contains the number of extra data items placed or
     * removed from the queue while the queue was locked.  When a queue is
     * locked items can be added or removed, but the event lists cannot be
     * updated. */
    taskENTER_CRITICAL();
    5428:	0f b6       	in	r0, 0x3f	; 63
    542a:	f8 94       	cli
    542c:	0f 92       	push	r0
    {
        int8_t cTxLock = pxQueue->cTxLock;
    542e:	eb 81       	ldd	r30, Y+3	; 0x03
    5430:	fc 81       	ldd	r31, Y+4	; 0x04
    5432:	86 8d       	ldd	r24, Z+30	; 0x1e
    5434:	8a 83       	std	Y+2, r24	; 0x02
    5436:	11 c0       	rjmp	.+34     	; 0x545a <prvUnlockQueue+0x42>
                }
            #else /* configUSE_QUEUE_SETS */
                {
                    /* Tasks that are removed from the event list will get added to
                     * the pending ready list as the scheduler is still suspended. */
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    5438:	eb 81       	ldd	r30, Y+3	; 0x03
    543a:	fc 81       	ldd	r31, Y+4	; 0x04
    543c:	81 89       	ldd	r24, Z+17	; 0x11
    543e:	88 23       	and	r24, r24
    5440:	79 f0       	breq	.+30     	; 0x5460 <prvUnlockQueue+0x48>
                    {
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    5442:	8b 81       	ldd	r24, Y+3	; 0x03
    5444:	9c 81       	ldd	r25, Y+4	; 0x04
    5446:	41 96       	adiw	r24, 0x11	; 17
    5448:	0e 94 f3 3b 	call	0x77e6	; 0x77e6 <xTaskRemoveFromEventList>
    544c:	88 23       	and	r24, r24
    544e:	11 f0       	breq	.+4      	; 0x5454 <prvUnlockQueue+0x3c>
                        {
                            /* The task waiting has a higher priority so record that
                             * a context switch is required. */
                            vTaskMissedYield();
    5450:	0e 94 e3 3e 	call	0x7dc6	; 0x7dc6 <vTaskMissedYield>
                        break;
                    }
                }
            #endif /* configUSE_QUEUE_SETS */

            --cTxLock;
    5454:	8a 81       	ldd	r24, Y+2	; 0x02
    5456:	81 50       	subi	r24, 0x01	; 1
    5458:	8a 83       	std	Y+2, r24	; 0x02
    taskENTER_CRITICAL();
    {
        int8_t cTxLock = pxQueue->cTxLock;

        /* See if data was added to the queue while it was locked. */
        while( cTxLock > queueLOCKED_UNMODIFIED )
    545a:	8a 81       	ldd	r24, Y+2	; 0x02
    545c:	18 16       	cp	r1, r24
    545e:	64 f3       	brlt	.-40     	; 0x5438 <prvUnlockQueue+0x20>
            #endif /* configUSE_QUEUE_SETS */

            --cTxLock;
        }

        pxQueue->cTxLock = queueUNLOCKED;
    5460:	eb 81       	ldd	r30, Y+3	; 0x03
    5462:	fc 81       	ldd	r31, Y+4	; 0x04
    5464:	8f ef       	ldi	r24, 0xFF	; 255
    5466:	86 8f       	std	Z+30, r24	; 0x1e
    }
    taskEXIT_CRITICAL();
    5468:	0f 90       	pop	r0
    546a:	0f be       	out	0x3f, r0	; 63

    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
    546c:	0f b6       	in	r0, 0x3f	; 63
    546e:	f8 94       	cli
    5470:	0f 92       	push	r0
    {
        int8_t cRxLock = pxQueue->cRxLock;
    5472:	eb 81       	ldd	r30, Y+3	; 0x03
    5474:	fc 81       	ldd	r31, Y+4	; 0x04
    5476:	85 8d       	ldd	r24, Z+29	; 0x1d
    5478:	89 83       	std	Y+1, r24	; 0x01
    547a:	11 c0       	rjmp	.+34     	; 0x549e <prvUnlockQueue+0x86>

        while( cRxLock > queueLOCKED_UNMODIFIED )
        {
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    547c:	eb 81       	ldd	r30, Y+3	; 0x03
    547e:	fc 81       	ldd	r31, Y+4	; 0x04
    5480:	80 85       	ldd	r24, Z+8	; 0x08
    5482:	88 23       	and	r24, r24
    5484:	79 f0       	breq	.+30     	; 0x54a4 <prvUnlockQueue+0x8c>
            {
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    5486:	8b 81       	ldd	r24, Y+3	; 0x03
    5488:	9c 81       	ldd	r25, Y+4	; 0x04
    548a:	08 96       	adiw	r24, 0x08	; 8
    548c:	0e 94 f3 3b 	call	0x77e6	; 0x77e6 <xTaskRemoveFromEventList>
    5490:	88 23       	and	r24, r24
    5492:	11 f0       	breq	.+4      	; 0x5498 <prvUnlockQueue+0x80>
                {
                    vTaskMissedYield();
    5494:	0e 94 e3 3e 	call	0x7dc6	; 0x7dc6 <vTaskMissedYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                --cRxLock;
    5498:	89 81       	ldd	r24, Y+1	; 0x01
    549a:	81 50       	subi	r24, 0x01	; 1
    549c:	89 83       	std	Y+1, r24	; 0x01
    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
    {
        int8_t cRxLock = pxQueue->cRxLock;

        while( cRxLock > queueLOCKED_UNMODIFIED )
    549e:	89 81       	ldd	r24, Y+1	; 0x01
    54a0:	18 16       	cp	r1, r24
    54a2:	64 f3       	brlt	.-40     	; 0x547c <prvUnlockQueue+0x64>
            {
                break;
            }
        }

        pxQueue->cRxLock = queueUNLOCKED;
    54a4:	eb 81       	ldd	r30, Y+3	; 0x03
    54a6:	fc 81       	ldd	r31, Y+4	; 0x04
    54a8:	8f ef       	ldi	r24, 0xFF	; 255
    54aa:	85 8f       	std	Z+29, r24	; 0x1d
    }
    taskEXIT_CRITICAL();
    54ac:	0f 90       	pop	r0
    54ae:	0f be       	out	0x3f, r0	; 63
}
    54b0:	0f 90       	pop	r0
    54b2:	0f 90       	pop	r0
    54b4:	0f 90       	pop	r0
    54b6:	0f 90       	pop	r0
    54b8:	cf 91       	pop	r28
    54ba:	df 91       	pop	r29
    54bc:	08 95       	ret

000054be <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
{
    54be:	df 93       	push	r29
    54c0:	cf 93       	push	r28
    54c2:	00 d0       	rcall	.+0      	; 0x54c4 <prvIsQueueEmpty+0x6>
    54c4:	0f 92       	push	r0
    54c6:	cd b7       	in	r28, 0x3d	; 61
    54c8:	de b7       	in	r29, 0x3e	; 62
    54ca:	9b 83       	std	Y+3, r25	; 0x03
    54cc:	8a 83       	std	Y+2, r24	; 0x02
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    54ce:	0f b6       	in	r0, 0x3f	; 63
    54d0:	f8 94       	cli
    54d2:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    54d4:	ea 81       	ldd	r30, Y+2	; 0x02
    54d6:	fb 81       	ldd	r31, Y+3	; 0x03
    54d8:	82 8d       	ldd	r24, Z+26	; 0x1a
    54da:	88 23       	and	r24, r24
    54dc:	19 f4       	brne	.+6      	; 0x54e4 <prvIsQueueEmpty+0x26>
        {
            xReturn = pdTRUE;
    54de:	81 e0       	ldi	r24, 0x01	; 1
    54e0:	89 83       	std	Y+1, r24	; 0x01
    54e2:	01 c0       	rjmp	.+2      	; 0x54e6 <prvIsQueueEmpty+0x28>
        }
        else
        {
            xReturn = pdFALSE;
    54e4:	19 82       	std	Y+1, r1	; 0x01
        }
    }
    taskEXIT_CRITICAL();
    54e6:	0f 90       	pop	r0
    54e8:	0f be       	out	0x3f, r0	; 63

    return xReturn;
    54ea:	89 81       	ldd	r24, Y+1	; 0x01
}
    54ec:	0f 90       	pop	r0
    54ee:	0f 90       	pop	r0
    54f0:	0f 90       	pop	r0
    54f2:	cf 91       	pop	r28
    54f4:	df 91       	pop	r29
    54f6:	08 95       	ret

000054f8 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
    54f8:	df 93       	push	r29
    54fa:	cf 93       	push	r28
    54fc:	00 d0       	rcall	.+0      	; 0x54fe <xQueueIsQueueEmptyFromISR+0x6>
    54fe:	00 d0       	rcall	.+0      	; 0x5500 <xQueueIsQueueEmptyFromISR+0x8>
    5500:	0f 92       	push	r0
    5502:	cd b7       	in	r28, 0x3d	; 61
    5504:	de b7       	in	r29, 0x3e	; 62
    5506:	9d 83       	std	Y+5, r25	; 0x05
    5508:	8c 83       	std	Y+4, r24	; 0x04
    BaseType_t xReturn;
    Queue_t * const pxQueue = xQueue;
    550a:	8c 81       	ldd	r24, Y+4	; 0x04
    550c:	9d 81       	ldd	r25, Y+5	; 0x05
    550e:	9a 83       	std	Y+2, r25	; 0x02
    5510:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );

    if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    5512:	e9 81       	ldd	r30, Y+1	; 0x01
    5514:	fa 81       	ldd	r31, Y+2	; 0x02
    5516:	82 8d       	ldd	r24, Z+26	; 0x1a
    5518:	88 23       	and	r24, r24
    551a:	19 f4       	brne	.+6      	; 0x5522 <xQueueIsQueueEmptyFromISR+0x2a>
    {
        xReturn = pdTRUE;
    551c:	81 e0       	ldi	r24, 0x01	; 1
    551e:	8b 83       	std	Y+3, r24	; 0x03
    5520:	01 c0       	rjmp	.+2      	; 0x5524 <xQueueIsQueueEmptyFromISR+0x2c>
    }
    else
    {
        xReturn = pdFALSE;
    5522:	1b 82       	std	Y+3, r1	; 0x03
    }

    return xReturn;
    5524:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    5526:	0f 90       	pop	r0
    5528:	0f 90       	pop	r0
    552a:	0f 90       	pop	r0
    552c:	0f 90       	pop	r0
    552e:	0f 90       	pop	r0
    5530:	cf 91       	pop	r28
    5532:	df 91       	pop	r29
    5534:	08 95       	ret

00005536 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t * pxQueue )
{
    5536:	df 93       	push	r29
    5538:	cf 93       	push	r28
    553a:	00 d0       	rcall	.+0      	; 0x553c <prvIsQueueFull+0x6>
    553c:	0f 92       	push	r0
    553e:	cd b7       	in	r28, 0x3d	; 61
    5540:	de b7       	in	r29, 0x3e	; 62
    5542:	9b 83       	std	Y+3, r25	; 0x03
    5544:	8a 83       	std	Y+2, r24	; 0x02
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    5546:	0f b6       	in	r0, 0x3f	; 63
    5548:	f8 94       	cli
    554a:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    554c:	ea 81       	ldd	r30, Y+2	; 0x02
    554e:	fb 81       	ldd	r31, Y+3	; 0x03
    5550:	92 8d       	ldd	r25, Z+26	; 0x1a
    5552:	ea 81       	ldd	r30, Y+2	; 0x02
    5554:	fb 81       	ldd	r31, Y+3	; 0x03
    5556:	83 8d       	ldd	r24, Z+27	; 0x1b
    5558:	98 17       	cp	r25, r24
    555a:	19 f4       	brne	.+6      	; 0x5562 <prvIsQueueFull+0x2c>
        {
            xReturn = pdTRUE;
    555c:	81 e0       	ldi	r24, 0x01	; 1
    555e:	89 83       	std	Y+1, r24	; 0x01
    5560:	01 c0       	rjmp	.+2      	; 0x5564 <prvIsQueueFull+0x2e>
        }
        else
        {
            xReturn = pdFALSE;
    5562:	19 82       	std	Y+1, r1	; 0x01
        }
    }
    taskEXIT_CRITICAL();
    5564:	0f 90       	pop	r0
    5566:	0f be       	out	0x3f, r0	; 63

    return xReturn;
    5568:	89 81       	ldd	r24, Y+1	; 0x01
}
    556a:	0f 90       	pop	r0
    556c:	0f 90       	pop	r0
    556e:	0f 90       	pop	r0
    5570:	cf 91       	pop	r28
    5572:	df 91       	pop	r29
    5574:	08 95       	ret

00005576 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    5576:	df 93       	push	r29
    5578:	cf 93       	push	r28
    557a:	00 d0       	rcall	.+0      	; 0x557c <xQueueIsQueueFullFromISR+0x6>
    557c:	00 d0       	rcall	.+0      	; 0x557e <xQueueIsQueueFullFromISR+0x8>
    557e:	0f 92       	push	r0
    5580:	cd b7       	in	r28, 0x3d	; 61
    5582:	de b7       	in	r29, 0x3e	; 62
    5584:	9d 83       	std	Y+5, r25	; 0x05
    5586:	8c 83       	std	Y+4, r24	; 0x04
    BaseType_t xReturn;
    Queue_t * const pxQueue = xQueue;
    5588:	8c 81       	ldd	r24, Y+4	; 0x04
    558a:	9d 81       	ldd	r25, Y+5	; 0x05
    558c:	9a 83       	std	Y+2, r25	; 0x02
    558e:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );

    if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    5590:	e9 81       	ldd	r30, Y+1	; 0x01
    5592:	fa 81       	ldd	r31, Y+2	; 0x02
    5594:	92 8d       	ldd	r25, Z+26	; 0x1a
    5596:	e9 81       	ldd	r30, Y+1	; 0x01
    5598:	fa 81       	ldd	r31, Y+2	; 0x02
    559a:	83 8d       	ldd	r24, Z+27	; 0x1b
    559c:	98 17       	cp	r25, r24
    559e:	19 f4       	brne	.+6      	; 0x55a6 <xQueueIsQueueFullFromISR+0x30>
    {
        xReturn = pdTRUE;
    55a0:	81 e0       	ldi	r24, 0x01	; 1
    55a2:	8b 83       	std	Y+3, r24	; 0x03
    55a4:	01 c0       	rjmp	.+2      	; 0x55a8 <xQueueIsQueueFullFromISR+0x32>
    }
    else
    {
        xReturn = pdFALSE;
    55a6:	1b 82       	std	Y+3, r1	; 0x03
    }

    return xReturn;
    55a8:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    55aa:	0f 90       	pop	r0
    55ac:	0f 90       	pop	r0
    55ae:	0f 90       	pop	r0
    55b0:	0f 90       	pop	r0
    55b2:	0f 90       	pop	r0
    55b4:	cf 91       	pop	r28
    55b6:	df 91       	pop	r29
    55b8:	08 95       	ret

000055ba <xQueueCRSend>:
#if ( configUSE_CO_ROUTINES == 1 )

    BaseType_t xQueueCRSend( QueueHandle_t xQueue,
                             const void * pvItemToQueue,
                             TickType_t xTicksToWait )
    {
    55ba:	df 93       	push	r29
    55bc:	cf 93       	push	r28
    55be:	cd b7       	in	r28, 0x3d	; 61
    55c0:	de b7       	in	r29, 0x3e	; 62
    55c2:	2a 97       	sbiw	r28, 0x0a	; 10
    55c4:	0f b6       	in	r0, 0x3f	; 63
    55c6:	f8 94       	cli
    55c8:	de bf       	out	0x3e, r29	; 62
    55ca:	0f be       	out	0x3f, r0	; 63
    55cc:	cd bf       	out	0x3d, r28	; 61
    55ce:	9d 83       	std	Y+5, r25	; 0x05
    55d0:	8c 83       	std	Y+4, r24	; 0x04
    55d2:	7f 83       	std	Y+7, r23	; 0x07
    55d4:	6e 83       	std	Y+6, r22	; 0x06
    55d6:	59 87       	std	Y+9, r21	; 0x09
    55d8:	48 87       	std	Y+8, r20	; 0x08
        BaseType_t xReturn;
        Queue_t * const pxQueue = xQueue;
    55da:	8c 81       	ldd	r24, Y+4	; 0x04
    55dc:	9d 81       	ldd	r25, Y+5	; 0x05
    55de:	9a 83       	std	Y+2, r25	; 0x02
    55e0:	89 83       	std	Y+1, r24	; 0x01

        /* If the queue is already full we may have to block.  A critical section
         * is required to prevent an interrupt removing something from the queue
         * between the check to see if the queue is full and blocking on the queue. */
        portDISABLE_INTERRUPTS();
    55e2:	f8 94       	cli
        {
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
    55e4:	89 81       	ldd	r24, Y+1	; 0x01
    55e6:	9a 81       	ldd	r25, Y+2	; 0x02
    55e8:	0e 94 9b 2a 	call	0x5536	; 0x5536 <prvIsQueueFull>
    55ec:	88 23       	and	r24, r24
    55ee:	a9 f0       	breq	.+42     	; 0x561a <xQueueCRSend+0x60>
            {
                /* The queue is full - do we want to block or just leave without
                 * posting? */
                if( xTicksToWait > ( TickType_t ) 0 )
    55f0:	88 85       	ldd	r24, Y+8	; 0x08
    55f2:	99 85       	ldd	r25, Y+9	; 0x09
    55f4:	00 97       	sbiw	r24, 0x00	; 0
    55f6:	71 f0       	breq	.+28     	; 0x5614 <xQueueCRSend+0x5a>
                {
                    /* As this is called from a coroutine we cannot block directly, but
                     * return indicating that we need to block. */
                    vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
    55f8:	89 81       	ldd	r24, Y+1	; 0x01
    55fa:	9a 81       	ldd	r25, Y+2	; 0x02
    55fc:	9c 01       	movw	r18, r24
    55fe:	28 5f       	subi	r18, 0xF8	; 248
    5600:	3f 4f       	sbci	r19, 0xFF	; 255
    5602:	88 85       	ldd	r24, Y+8	; 0x08
    5604:	99 85       	ldd	r25, Y+9	; 0x09
    5606:	b9 01       	movw	r22, r18
    5608:	0e 94 82 18 	call	0x3104	; 0x3104 <vCoRoutineAddToDelayedList>
                    portENABLE_INTERRUPTS();
    560c:	78 94       	sei
                    return errQUEUE_BLOCKED;
    560e:	8c ef       	ldi	r24, 0xFC	; 252
    5610:	8a 87       	std	Y+10, r24	; 0x0a
    5612:	2a c0       	rjmp	.+84     	; 0x5668 <xQueueCRSend+0xae>
                }
                else
                {
                    portENABLE_INTERRUPTS();
    5614:	78 94       	sei
                    return errQUEUE_FULL;
    5616:	1a 86       	std	Y+10, r1	; 0x0a
    5618:	27 c0       	rjmp	.+78     	; 0x5668 <xQueueCRSend+0xae>
                }
            }
        }
        portENABLE_INTERRUPTS();
    561a:	78 94       	sei

        portDISABLE_INTERRUPTS();
    561c:	f8 94       	cli
        {
            if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    561e:	e9 81       	ldd	r30, Y+1	; 0x01
    5620:	fa 81       	ldd	r31, Y+2	; 0x02
    5622:	92 8d       	ldd	r25, Z+26	; 0x1a
    5624:	e9 81       	ldd	r30, Y+1	; 0x01
    5626:	fa 81       	ldd	r31, Y+2	; 0x02
    5628:	83 8d       	ldd	r24, Z+27	; 0x1b
    562a:	98 17       	cp	r25, r24
    562c:	c8 f4       	brcc	.+50     	; 0x5660 <xQueueCRSend+0xa6>
            {
                /* There is room in the queue, copy the data into the queue. */
                prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    562e:	89 81       	ldd	r24, Y+1	; 0x01
    5630:	9a 81       	ldd	r25, Y+2	; 0x02
    5632:	2e 81       	ldd	r18, Y+6	; 0x06
    5634:	3f 81       	ldd	r19, Y+7	; 0x07
    5636:	b9 01       	movw	r22, r18
    5638:	40 e0       	ldi	r20, 0x00	; 0
    563a:	0e 94 0d 29 	call	0x521a	; 0x521a <prvCopyDataToQueue>
                xReturn = pdPASS;
    563e:	81 e0       	ldi	r24, 0x01	; 1
    5640:	8b 83       	std	Y+3, r24	; 0x03

                /* Were any co-routines waiting for data to become available? */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    5642:	e9 81       	ldd	r30, Y+1	; 0x01
    5644:	fa 81       	ldd	r31, Y+2	; 0x02
    5646:	81 89       	ldd	r24, Z+17	; 0x11
    5648:	88 23       	and	r24, r24
    564a:	59 f0       	breq	.+22     	; 0x5662 <xQueueCRSend+0xa8>
                {
                    /* In this instance the co-routine could be placed directly
                     * into the ready list as we are within a critical section.
                     * Instead the same pending ready list mechanism is used as if
                     * the event were caused from within an interrupt. */
                    if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    564c:	89 81       	ldd	r24, Y+1	; 0x01
    564e:	9a 81       	ldd	r25, Y+2	; 0x02
    5650:	41 96       	adiw	r24, 0x11	; 17
    5652:	0e 94 95 1a 	call	0x352a	; 0x352a <xCoRoutineRemoveFromEventList>
    5656:	88 23       	and	r24, r24
    5658:	21 f0       	breq	.+8      	; 0x5662 <xQueueCRSend+0xa8>
                    {
                        /* The co-routine waiting has a higher priority so record
                         * that a yield might be appropriate. */
                        xReturn = errQUEUE_YIELD;
    565a:	8b ef       	ldi	r24, 0xFB	; 251
    565c:	8b 83       	std	Y+3, r24	; 0x03
    565e:	01 c0       	rjmp	.+2      	; 0x5662 <xQueueCRSend+0xa8>
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            else
            {
                xReturn = errQUEUE_FULL;
    5660:	1b 82       	std	Y+3, r1	; 0x03
            }
        }
        portENABLE_INTERRUPTS();
    5662:	78 94       	sei

        return xReturn;
    5664:	8b 81       	ldd	r24, Y+3	; 0x03
    5666:	8a 87       	std	Y+10, r24	; 0x0a
    5668:	8a 85       	ldd	r24, Y+10	; 0x0a
    }
    566a:	2a 96       	adiw	r28, 0x0a	; 10
    566c:	0f b6       	in	r0, 0x3f	; 63
    566e:	f8 94       	cli
    5670:	de bf       	out	0x3e, r29	; 62
    5672:	0f be       	out	0x3f, r0	; 63
    5674:	cd bf       	out	0x3d, r28	; 61
    5676:	cf 91       	pop	r28
    5678:	df 91       	pop	r29
    567a:	08 95       	ret

0000567c <xQueueCRReceive>:
#if ( configUSE_CO_ROUTINES == 1 )

    BaseType_t xQueueCRReceive( QueueHandle_t xQueue,
                                void * pvBuffer,
                                TickType_t xTicksToWait )
    {
    567c:	df 93       	push	r29
    567e:	cf 93       	push	r28
    5680:	cd b7       	in	r28, 0x3d	; 61
    5682:	de b7       	in	r29, 0x3e	; 62
    5684:	2a 97       	sbiw	r28, 0x0a	; 10
    5686:	0f b6       	in	r0, 0x3f	; 63
    5688:	f8 94       	cli
    568a:	de bf       	out	0x3e, r29	; 62
    568c:	0f be       	out	0x3f, r0	; 63
    568e:	cd bf       	out	0x3d, r28	; 61
    5690:	9d 83       	std	Y+5, r25	; 0x05
    5692:	8c 83       	std	Y+4, r24	; 0x04
    5694:	7f 83       	std	Y+7, r23	; 0x07
    5696:	6e 83       	std	Y+6, r22	; 0x06
    5698:	59 87       	std	Y+9, r21	; 0x09
    569a:	48 87       	std	Y+8, r20	; 0x08
        BaseType_t xReturn;
        Queue_t * const pxQueue = xQueue;
    569c:	8c 81       	ldd	r24, Y+4	; 0x04
    569e:	9d 81       	ldd	r25, Y+5	; 0x05
    56a0:	9a 83       	std	Y+2, r25	; 0x02
    56a2:	89 83       	std	Y+1, r24	; 0x01

        /* If the queue is already empty we may have to block.  A critical section
         * is required to prevent an interrupt adding something to the queue
         * between the check to see if the queue is empty and blocking on the queue. */
        portDISABLE_INTERRUPTS();
    56a4:	f8 94       	cli
        {
            if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    56a6:	e9 81       	ldd	r30, Y+1	; 0x01
    56a8:	fa 81       	ldd	r31, Y+2	; 0x02
    56aa:	82 8d       	ldd	r24, Z+26	; 0x1a
    56ac:	88 23       	and	r24, r24
    56ae:	a9 f4       	brne	.+42     	; 0x56da <xQueueCRReceive+0x5e>
            {
                /* There are no messages in the queue, do we want to block or just
                 * leave with nothing? */
                if( xTicksToWait > ( TickType_t ) 0 )
    56b0:	88 85       	ldd	r24, Y+8	; 0x08
    56b2:	99 85       	ldd	r25, Y+9	; 0x09
    56b4:	00 97       	sbiw	r24, 0x00	; 0
    56b6:	71 f0       	breq	.+28     	; 0x56d4 <xQueueCRReceive+0x58>
                {
                    /* As this is a co-routine we cannot block directly, but return
                     * indicating that we need to block. */
                    vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
    56b8:	89 81       	ldd	r24, Y+1	; 0x01
    56ba:	9a 81       	ldd	r25, Y+2	; 0x02
    56bc:	9c 01       	movw	r18, r24
    56be:	2f 5e       	subi	r18, 0xEF	; 239
    56c0:	3f 4f       	sbci	r19, 0xFF	; 255
    56c2:	88 85       	ldd	r24, Y+8	; 0x08
    56c4:	99 85       	ldd	r25, Y+9	; 0x09
    56c6:	b9 01       	movw	r22, r18
    56c8:	0e 94 82 18 	call	0x3104	; 0x3104 <vCoRoutineAddToDelayedList>
                    portENABLE_INTERRUPTS();
    56cc:	78 94       	sei
                    return errQUEUE_BLOCKED;
    56ce:	8c ef       	ldi	r24, 0xFC	; 252
    56d0:	8a 87       	std	Y+10, r24	; 0x0a
    56d2:	58 c0       	rjmp	.+176    	; 0x5784 <xQueueCRReceive+0x108>
                }
                else
                {
                    portENABLE_INTERRUPTS();
    56d4:	78 94       	sei
                    return errQUEUE_FULL;
    56d6:	1a 86       	std	Y+10, r1	; 0x0a
    56d8:	55 c0       	rjmp	.+170    	; 0x5784 <xQueueCRReceive+0x108>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        portENABLE_INTERRUPTS();
    56da:	78 94       	sei

        portDISABLE_INTERRUPTS();
    56dc:	f8 94       	cli
        {
            if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    56de:	e9 81       	ldd	r30, Y+1	; 0x01
    56e0:	fa 81       	ldd	r31, Y+2	; 0x02
    56e2:	82 8d       	ldd	r24, Z+26	; 0x1a
    56e4:	88 23       	and	r24, r24
    56e6:	09 f4       	brne	.+2      	; 0x56ea <xQueueCRReceive+0x6e>
    56e8:	49 c0       	rjmp	.+146    	; 0x577c <xQueueCRReceive+0x100>
            {
                /* Data is available from the queue. */
                pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
    56ea:	e9 81       	ldd	r30, Y+1	; 0x01
    56ec:	fa 81       	ldd	r31, Y+2	; 0x02
    56ee:	26 81       	ldd	r18, Z+6	; 0x06
    56f0:	37 81       	ldd	r19, Z+7	; 0x07
    56f2:	e9 81       	ldd	r30, Y+1	; 0x01
    56f4:	fa 81       	ldd	r31, Y+2	; 0x02
    56f6:	84 8d       	ldd	r24, Z+28	; 0x1c
    56f8:	88 2f       	mov	r24, r24
    56fa:	90 e0       	ldi	r25, 0x00	; 0
    56fc:	82 0f       	add	r24, r18
    56fe:	93 1f       	adc	r25, r19
    5700:	e9 81       	ldd	r30, Y+1	; 0x01
    5702:	fa 81       	ldd	r31, Y+2	; 0x02
    5704:	97 83       	std	Z+7, r25	; 0x07
    5706:	86 83       	std	Z+6, r24	; 0x06

                if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
    5708:	e9 81       	ldd	r30, Y+1	; 0x01
    570a:	fa 81       	ldd	r31, Y+2	; 0x02
    570c:	26 81       	ldd	r18, Z+6	; 0x06
    570e:	37 81       	ldd	r19, Z+7	; 0x07
    5710:	e9 81       	ldd	r30, Y+1	; 0x01
    5712:	fa 81       	ldd	r31, Y+2	; 0x02
    5714:	84 81       	ldd	r24, Z+4	; 0x04
    5716:	95 81       	ldd	r25, Z+5	; 0x05
    5718:	28 17       	cp	r18, r24
    571a:	39 07       	cpc	r19, r25
    571c:	40 f0       	brcs	.+16     	; 0x572e <xQueueCRReceive+0xb2>
                {
                    pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    571e:	e9 81       	ldd	r30, Y+1	; 0x01
    5720:	fa 81       	ldd	r31, Y+2	; 0x02
    5722:	80 81       	ld	r24, Z
    5724:	91 81       	ldd	r25, Z+1	; 0x01
    5726:	e9 81       	ldd	r30, Y+1	; 0x01
    5728:	fa 81       	ldd	r31, Y+2	; 0x02
    572a:	97 83       	std	Z+7, r25	; 0x07
    572c:	86 83       	std	Z+6, r24	; 0x06
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                --( pxQueue->uxMessagesWaiting );
    572e:	e9 81       	ldd	r30, Y+1	; 0x01
    5730:	fa 81       	ldd	r31, Y+2	; 0x02
    5732:	82 8d       	ldd	r24, Z+26	; 0x1a
    5734:	81 50       	subi	r24, 0x01	; 1
    5736:	e9 81       	ldd	r30, Y+1	; 0x01
    5738:	fa 81       	ldd	r31, Y+2	; 0x02
    573a:	82 8f       	std	Z+26, r24	; 0x1a
                ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    573c:	e9 81       	ldd	r30, Y+1	; 0x01
    573e:	fa 81       	ldd	r31, Y+2	; 0x02
    5740:	46 81       	ldd	r20, Z+6	; 0x06
    5742:	57 81       	ldd	r21, Z+7	; 0x07
    5744:	e9 81       	ldd	r30, Y+1	; 0x01
    5746:	fa 81       	ldd	r31, Y+2	; 0x02
    5748:	84 8d       	ldd	r24, Z+28	; 0x1c
    574a:	28 2f       	mov	r18, r24
    574c:	30 e0       	ldi	r19, 0x00	; 0
    574e:	8e 81       	ldd	r24, Y+6	; 0x06
    5750:	9f 81       	ldd	r25, Y+7	; 0x07
    5752:	ba 01       	movw	r22, r20
    5754:	a9 01       	movw	r20, r18
    5756:	0e 94 80 4c 	call	0x9900	; 0x9900 <memcpy>

                xReturn = pdPASS;
    575a:	81 e0       	ldi	r24, 0x01	; 1
    575c:	8b 83       	std	Y+3, r24	; 0x03

                /* Were any co-routines waiting for space to become available? */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    575e:	e9 81       	ldd	r30, Y+1	; 0x01
    5760:	fa 81       	ldd	r31, Y+2	; 0x02
    5762:	80 85       	ldd	r24, Z+8	; 0x08
    5764:	88 23       	and	r24, r24
    5766:	59 f0       	breq	.+22     	; 0x577e <xQueueCRReceive+0x102>
                {
                    /* In this instance the co-routine could be placed directly
                     * into the ready list as we are within a critical section.
                     * Instead the same pending ready list mechanism is used as if
                     * the event were caused from within an interrupt. */
                    if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    5768:	89 81       	ldd	r24, Y+1	; 0x01
    576a:	9a 81       	ldd	r25, Y+2	; 0x02
    576c:	08 96       	adiw	r24, 0x08	; 8
    576e:	0e 94 95 1a 	call	0x352a	; 0x352a <xCoRoutineRemoveFromEventList>
    5772:	88 23       	and	r24, r24
    5774:	21 f0       	breq	.+8      	; 0x577e <xQueueCRReceive+0x102>
                    {
                        xReturn = errQUEUE_YIELD;
    5776:	8b ef       	ldi	r24, 0xFB	; 251
    5778:	8b 83       	std	Y+3, r24	; 0x03
    577a:	01 c0       	rjmp	.+2      	; 0x577e <xQueueCRReceive+0x102>
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            else
            {
                xReturn = pdFAIL;
    577c:	1b 82       	std	Y+3, r1	; 0x03
            }
        }
        portENABLE_INTERRUPTS();
    577e:	78 94       	sei

        return xReturn;
    5780:	8b 81       	ldd	r24, Y+3	; 0x03
    5782:	8a 87       	std	Y+10, r24	; 0x0a
    5784:	8a 85       	ldd	r24, Y+10	; 0x0a
    }
    5786:	2a 96       	adiw	r28, 0x0a	; 10
    5788:	0f b6       	in	r0, 0x3f	; 63
    578a:	f8 94       	cli
    578c:	de bf       	out	0x3e, r29	; 62
    578e:	0f be       	out	0x3f, r0	; 63
    5790:	cd bf       	out	0x3d, r28	; 61
    5792:	cf 91       	pop	r28
    5794:	df 91       	pop	r29
    5796:	08 95       	ret

00005798 <xQueueCRSendFromISR>:
#if ( configUSE_CO_ROUTINES == 1 )

    BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue,
                                    const void * pvItemToQueue,
                                    BaseType_t xCoRoutinePreviouslyWoken )
    {
    5798:	df 93       	push	r29
    579a:	cf 93       	push	r28
    579c:	cd b7       	in	r28, 0x3d	; 61
    579e:	de b7       	in	r29, 0x3e	; 62
    57a0:	28 97       	sbiw	r28, 0x08	; 8
    57a2:	0f b6       	in	r0, 0x3f	; 63
    57a4:	f8 94       	cli
    57a6:	de bf       	out	0x3e, r29	; 62
    57a8:	0f be       	out	0x3f, r0	; 63
    57aa:	cd bf       	out	0x3d, r28	; 61
    57ac:	9c 83       	std	Y+4, r25	; 0x04
    57ae:	8b 83       	std	Y+3, r24	; 0x03
    57b0:	7e 83       	std	Y+6, r23	; 0x06
    57b2:	6d 83       	std	Y+5, r22	; 0x05
    57b4:	4f 83       	std	Y+7, r20	; 0x07
        Queue_t * const pxQueue = xQueue;
    57b6:	8b 81       	ldd	r24, Y+3	; 0x03
    57b8:	9c 81       	ldd	r25, Y+4	; 0x04
    57ba:	9a 83       	std	Y+2, r25	; 0x02
    57bc:	89 83       	std	Y+1, r24	; 0x01

        /* Cannot block within an ISR so if there is no space on the queue then
         * exit without doing anything. */
        if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    57be:	e9 81       	ldd	r30, Y+1	; 0x01
    57c0:	fa 81       	ldd	r31, Y+2	; 0x02
    57c2:	92 8d       	ldd	r25, Z+26	; 0x1a
    57c4:	e9 81       	ldd	r30, Y+1	; 0x01
    57c6:	fa 81       	ldd	r31, Y+2	; 0x02
    57c8:	83 8d       	ldd	r24, Z+27	; 0x1b
    57ca:	98 17       	cp	r25, r24
    57cc:	d0 f4       	brcc	.+52     	; 0x5802 <xQueueCRSendFromISR+0x6a>
        {
            prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    57ce:	89 81       	ldd	r24, Y+1	; 0x01
    57d0:	9a 81       	ldd	r25, Y+2	; 0x02
    57d2:	2d 81       	ldd	r18, Y+5	; 0x05
    57d4:	3e 81       	ldd	r19, Y+6	; 0x06
    57d6:	b9 01       	movw	r22, r18
    57d8:	40 e0       	ldi	r20, 0x00	; 0
    57da:	0e 94 0d 29 	call	0x521a	; 0x521a <prvCopyDataToQueue>

            /* We only want to wake one co-routine per ISR, so check that a
             * co-routine has not already been woken. */
            if( xCoRoutinePreviouslyWoken == pdFALSE )
    57de:	8f 81       	ldd	r24, Y+7	; 0x07
    57e0:	88 23       	and	r24, r24
    57e2:	79 f4       	brne	.+30     	; 0x5802 <xQueueCRSendFromISR+0x6a>
            {
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    57e4:	e9 81       	ldd	r30, Y+1	; 0x01
    57e6:	fa 81       	ldd	r31, Y+2	; 0x02
    57e8:	81 89       	ldd	r24, Z+17	; 0x11
    57ea:	88 23       	and	r24, r24
    57ec:	51 f0       	breq	.+20     	; 0x5802 <xQueueCRSendFromISR+0x6a>
                {
                    if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    57ee:	89 81       	ldd	r24, Y+1	; 0x01
    57f0:	9a 81       	ldd	r25, Y+2	; 0x02
    57f2:	41 96       	adiw	r24, 0x11	; 17
    57f4:	0e 94 95 1a 	call	0x352a	; 0x352a <xCoRoutineRemoveFromEventList>
    57f8:	88 23       	and	r24, r24
    57fa:	19 f0       	breq	.+6      	; 0x5802 <xQueueCRSendFromISR+0x6a>
                    {
                        return pdTRUE;
    57fc:	81 e0       	ldi	r24, 0x01	; 1
    57fe:	88 87       	std	Y+8, r24	; 0x08
    5800:	02 c0       	rjmp	.+4      	; 0x5806 <xQueueCRSendFromISR+0x6e>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xCoRoutinePreviouslyWoken;
    5802:	8f 81       	ldd	r24, Y+7	; 0x07
    5804:	88 87       	std	Y+8, r24	; 0x08
    5806:	88 85       	ldd	r24, Y+8	; 0x08
    }
    5808:	28 96       	adiw	r28, 0x08	; 8
    580a:	0f b6       	in	r0, 0x3f	; 63
    580c:	f8 94       	cli
    580e:	de bf       	out	0x3e, r29	; 62
    5810:	0f be       	out	0x3f, r0	; 63
    5812:	cd bf       	out	0x3d, r28	; 61
    5814:	cf 91       	pop	r28
    5816:	df 91       	pop	r29
    5818:	08 95       	ret

0000581a <xQueueCRReceiveFromISR>:
#if ( configUSE_CO_ROUTINES == 1 )

    BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue,
                                       void * pvBuffer,
                                       BaseType_t * pxCoRoutineWoken )
    {
    581a:	df 93       	push	r29
    581c:	cf 93       	push	r28
    581e:	cd b7       	in	r28, 0x3d	; 61
    5820:	de b7       	in	r29, 0x3e	; 62
    5822:	29 97       	sbiw	r28, 0x09	; 9
    5824:	0f b6       	in	r0, 0x3f	; 63
    5826:	f8 94       	cli
    5828:	de bf       	out	0x3e, r29	; 62
    582a:	0f be       	out	0x3f, r0	; 63
    582c:	cd bf       	out	0x3d, r28	; 61
    582e:	9d 83       	std	Y+5, r25	; 0x05
    5830:	8c 83       	std	Y+4, r24	; 0x04
    5832:	7f 83       	std	Y+7, r23	; 0x07
    5834:	6e 83       	std	Y+6, r22	; 0x06
    5836:	59 87       	std	Y+9, r21	; 0x09
    5838:	48 87       	std	Y+8, r20	; 0x08
        BaseType_t xReturn;
        Queue_t * const pxQueue = xQueue;
    583a:	8c 81       	ldd	r24, Y+4	; 0x04
    583c:	9d 81       	ldd	r25, Y+5	; 0x05
    583e:	9a 83       	std	Y+2, r25	; 0x02
    5840:	89 83       	std	Y+1, r24	; 0x01

        /* We cannot block from an ISR, so check there is data available. If
         * not then just leave without doing anything. */
        if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    5842:	e9 81       	ldd	r30, Y+1	; 0x01
    5844:	fa 81       	ldd	r31, Y+2	; 0x02
    5846:	82 8d       	ldd	r24, Z+26	; 0x1a
    5848:	88 23       	and	r24, r24
    584a:	09 f4       	brne	.+2      	; 0x584e <xQueueCRReceiveFromISR+0x34>
    584c:	50 c0       	rjmp	.+160    	; 0x58ee <xQueueCRReceiveFromISR+0xd4>
        {
            /* Copy the data from the queue. */
            pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
    584e:	e9 81       	ldd	r30, Y+1	; 0x01
    5850:	fa 81       	ldd	r31, Y+2	; 0x02
    5852:	26 81       	ldd	r18, Z+6	; 0x06
    5854:	37 81       	ldd	r19, Z+7	; 0x07
    5856:	e9 81       	ldd	r30, Y+1	; 0x01
    5858:	fa 81       	ldd	r31, Y+2	; 0x02
    585a:	84 8d       	ldd	r24, Z+28	; 0x1c
    585c:	88 2f       	mov	r24, r24
    585e:	90 e0       	ldi	r25, 0x00	; 0
    5860:	82 0f       	add	r24, r18
    5862:	93 1f       	adc	r25, r19
    5864:	e9 81       	ldd	r30, Y+1	; 0x01
    5866:	fa 81       	ldd	r31, Y+2	; 0x02
    5868:	97 83       	std	Z+7, r25	; 0x07
    586a:	86 83       	std	Z+6, r24	; 0x06

            if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
    586c:	e9 81       	ldd	r30, Y+1	; 0x01
    586e:	fa 81       	ldd	r31, Y+2	; 0x02
    5870:	26 81       	ldd	r18, Z+6	; 0x06
    5872:	37 81       	ldd	r19, Z+7	; 0x07
    5874:	e9 81       	ldd	r30, Y+1	; 0x01
    5876:	fa 81       	ldd	r31, Y+2	; 0x02
    5878:	84 81       	ldd	r24, Z+4	; 0x04
    587a:	95 81       	ldd	r25, Z+5	; 0x05
    587c:	28 17       	cp	r18, r24
    587e:	39 07       	cpc	r19, r25
    5880:	40 f0       	brcs	.+16     	; 0x5892 <xQueueCRReceiveFromISR+0x78>
            {
                pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    5882:	e9 81       	ldd	r30, Y+1	; 0x01
    5884:	fa 81       	ldd	r31, Y+2	; 0x02
    5886:	80 81       	ld	r24, Z
    5888:	91 81       	ldd	r25, Z+1	; 0x01
    588a:	e9 81       	ldd	r30, Y+1	; 0x01
    588c:	fa 81       	ldd	r31, Y+2	; 0x02
    588e:	97 83       	std	Z+7, r25	; 0x07
    5890:	86 83       	std	Z+6, r24	; 0x06
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            --( pxQueue->uxMessagesWaiting );
    5892:	e9 81       	ldd	r30, Y+1	; 0x01
    5894:	fa 81       	ldd	r31, Y+2	; 0x02
    5896:	82 8d       	ldd	r24, Z+26	; 0x1a
    5898:	81 50       	subi	r24, 0x01	; 1
    589a:	e9 81       	ldd	r30, Y+1	; 0x01
    589c:	fa 81       	ldd	r31, Y+2	; 0x02
    589e:	82 8f       	std	Z+26, r24	; 0x1a
            ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    58a0:	e9 81       	ldd	r30, Y+1	; 0x01
    58a2:	fa 81       	ldd	r31, Y+2	; 0x02
    58a4:	46 81       	ldd	r20, Z+6	; 0x06
    58a6:	57 81       	ldd	r21, Z+7	; 0x07
    58a8:	e9 81       	ldd	r30, Y+1	; 0x01
    58aa:	fa 81       	ldd	r31, Y+2	; 0x02
    58ac:	84 8d       	ldd	r24, Z+28	; 0x1c
    58ae:	28 2f       	mov	r18, r24
    58b0:	30 e0       	ldi	r19, 0x00	; 0
    58b2:	8e 81       	ldd	r24, Y+6	; 0x06
    58b4:	9f 81       	ldd	r25, Y+7	; 0x07
    58b6:	ba 01       	movw	r22, r20
    58b8:	a9 01       	movw	r20, r18
    58ba:	0e 94 80 4c 	call	0x9900	; 0x9900 <memcpy>

            if( ( *pxCoRoutineWoken ) == pdFALSE )
    58be:	e8 85       	ldd	r30, Y+8	; 0x08
    58c0:	f9 85       	ldd	r31, Y+9	; 0x09
    58c2:	80 81       	ld	r24, Z
    58c4:	88 23       	and	r24, r24
    58c6:	81 f4       	brne	.+32     	; 0x58e8 <xQueueCRReceiveFromISR+0xce>
            {
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    58c8:	e9 81       	ldd	r30, Y+1	; 0x01
    58ca:	fa 81       	ldd	r31, Y+2	; 0x02
    58cc:	80 85       	ldd	r24, Z+8	; 0x08
    58ce:	88 23       	and	r24, r24
    58d0:	59 f0       	breq	.+22     	; 0x58e8 <xQueueCRReceiveFromISR+0xce>
                {
                    if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    58d2:	89 81       	ldd	r24, Y+1	; 0x01
    58d4:	9a 81       	ldd	r25, Y+2	; 0x02
    58d6:	08 96       	adiw	r24, 0x08	; 8
    58d8:	0e 94 95 1a 	call	0x352a	; 0x352a <xCoRoutineRemoveFromEventList>
    58dc:	88 23       	and	r24, r24
    58de:	21 f0       	breq	.+8      	; 0x58e8 <xQueueCRReceiveFromISR+0xce>
                    {
                        *pxCoRoutineWoken = pdTRUE;
    58e0:	e8 85       	ldd	r30, Y+8	; 0x08
    58e2:	f9 85       	ldd	r31, Y+9	; 0x09
    58e4:	81 e0       	ldi	r24, 0x01	; 1
    58e6:	80 83       	st	Z, r24
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            xReturn = pdPASS;
    58e8:	81 e0       	ldi	r24, 0x01	; 1
    58ea:	8b 83       	std	Y+3, r24	; 0x03
    58ec:	01 c0       	rjmp	.+2      	; 0x58f0 <xQueueCRReceiveFromISR+0xd6>
        }
        else
        {
            xReturn = pdFAIL;
    58ee:	1b 82       	std	Y+3, r1	; 0x03
        }

        return xReturn;
    58f0:	8b 81       	ldd	r24, Y+3	; 0x03
    }
    58f2:	29 96       	adiw	r28, 0x09	; 9
    58f4:	0f b6       	in	r0, 0x3f	; 63
    58f6:	f8 94       	cli
    58f8:	de bf       	out	0x3e, r29	; 62
    58fa:	0f be       	out	0x3f, r0	; 63
    58fc:	cd bf       	out	0x3d, r28	; 61
    58fe:	cf 91       	pop	r28
    5900:	df 91       	pop	r29
    5902:	08 95       	ret

00005904 <xStreamBufferGenericCreate>:
#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

    StreamBufferHandle_t xStreamBufferGenericCreate( size_t xBufferSizeBytes,
                                                     size_t xTriggerLevelBytes,
                                                     BaseType_t xIsMessageBuffer )
    {
    5904:	0f 93       	push	r16
    5906:	df 93       	push	r29
    5908:	cf 93       	push	r28
    590a:	cd b7       	in	r28, 0x3d	; 61
    590c:	de b7       	in	r29, 0x3e	; 62
    590e:	28 97       	sbiw	r28, 0x08	; 8
    5910:	0f b6       	in	r0, 0x3f	; 63
    5912:	f8 94       	cli
    5914:	de bf       	out	0x3e, r29	; 62
    5916:	0f be       	out	0x3f, r0	; 63
    5918:	cd bf       	out	0x3d, r28	; 61
    591a:	9d 83       	std	Y+5, r25	; 0x05
    591c:	8c 83       	std	Y+4, r24	; 0x04
    591e:	7f 83       	std	Y+7, r23	; 0x07
    5920:	6e 83       	std	Y+6, r22	; 0x06
    5922:	48 87       	std	Y+8, r20	; 0x08

        /* In case the stream buffer is going to be used as a message buffer
         * (that is, it will hold discrete messages with a little meta data that
         * says how big the next message is) check the buffer will be large enough
         * to hold at least one message. */
        if( xIsMessageBuffer == pdTRUE )
    5924:	88 85       	ldd	r24, Y+8	; 0x08
    5926:	81 30       	cpi	r24, 0x01	; 1
    5928:	19 f4       	brne	.+6      	; 0x5930 <xStreamBufferGenericCreate+0x2c>
        {
            /* Is a message buffer but not statically allocated. */
            ucFlags = sbFLAGS_IS_MESSAGE_BUFFER;
    592a:	81 e0       	ldi	r24, 0x01	; 1
    592c:	89 83       	std	Y+1, r24	; 0x01
    592e:	01 c0       	rjmp	.+2      	; 0x5932 <xStreamBufferGenericCreate+0x2e>
            configASSERT( xBufferSizeBytes > sbBYTES_TO_STORE_MESSAGE_LENGTH );
        }
        else
        {
            /* Not a message buffer and not statically allocated. */
            ucFlags = 0;
    5930:	19 82       	std	Y+1, r1	; 0x01

        configASSERT( xTriggerLevelBytes <= xBufferSizeBytes );

        /* A trigger level of 0 would cause a waiting task to unblock even when
         * the buffer was empty. */
        if( xTriggerLevelBytes == ( size_t ) 0 )
    5932:	8e 81       	ldd	r24, Y+6	; 0x06
    5934:	9f 81       	ldd	r25, Y+7	; 0x07
    5936:	00 97       	sbiw	r24, 0x00	; 0
    5938:	21 f4       	brne	.+8      	; 0x5942 <xStreamBufferGenericCreate+0x3e>
        {
            xTriggerLevelBytes = ( size_t ) 1;
    593a:	81 e0       	ldi	r24, 0x01	; 1
    593c:	90 e0       	ldi	r25, 0x00	; 0
    593e:	9f 83       	std	Y+7, r25	; 0x07
    5940:	8e 83       	std	Y+6, r24	; 0x06
         * and the buffer follows immediately after.  The requested size is
         * incremented so the free space is returned as the user would expect -
         * this is a quirk of the implementation that means otherwise the free
         * space would be reported as one byte smaller than would be logically
         * expected. */
        if( xBufferSizeBytes < ( xBufferSizeBytes + 1 + sizeof( StreamBuffer_t ) ) )
    5942:	8c 81       	ldd	r24, Y+4	; 0x04
    5944:	9d 81       	ldd	r25, Y+5	; 0x05
    5946:	9c 01       	movw	r18, r24
    5948:	20 5f       	subi	r18, 0xF0	; 240
    594a:	3f 4f       	sbci	r19, 0xFF	; 255
    594c:	8c 81       	ldd	r24, Y+4	; 0x04
    594e:	9d 81       	ldd	r25, Y+5	; 0x05
    5950:	82 17       	cp	r24, r18
    5952:	93 07       	cpc	r25, r19
    5954:	68 f4       	brcc	.+26     	; 0x5970 <xStreamBufferGenericCreate+0x6c>
        {
            xBufferSizeBytes++;
    5956:	8c 81       	ldd	r24, Y+4	; 0x04
    5958:	9d 81       	ldd	r25, Y+5	; 0x05
    595a:	01 96       	adiw	r24, 0x01	; 1
    595c:	9d 83       	std	Y+5, r25	; 0x05
    595e:	8c 83       	std	Y+4, r24	; 0x04
            pucAllocatedMemory = ( uint8_t * ) pvPortMalloc( xBufferSizeBytes + sizeof( StreamBuffer_t ) ); /*lint !e9079 malloc() only returns void*. */
    5960:	8c 81       	ldd	r24, Y+4	; 0x04
    5962:	9d 81       	ldd	r25, Y+5	; 0x05
    5964:	0f 96       	adiw	r24, 0x0f	; 15
    5966:	0e 94 12 1e 	call	0x3c24	; 0x3c24 <pvPortMalloc>
    596a:	9b 83       	std	Y+3, r25	; 0x03
    596c:	8a 83       	std	Y+2, r24	; 0x02
    596e:	02 c0       	rjmp	.+4      	; 0x5974 <xStreamBufferGenericCreate+0x70>
        }
        else
        {
            pucAllocatedMemory = NULL;
    5970:	1b 82       	std	Y+3, r1	; 0x03
    5972:	1a 82       	std	Y+2, r1	; 0x02
        }

        if( pucAllocatedMemory != NULL )
    5974:	8a 81       	ldd	r24, Y+2	; 0x02
    5976:	9b 81       	ldd	r25, Y+3	; 0x03
    5978:	00 97       	sbiw	r24, 0x00	; 0
    597a:	89 f0       	breq	.+34     	; 0x599e <xStreamBufferGenericCreate+0x9a>
        {
            prvInitialiseNewStreamBuffer( ( StreamBuffer_t * ) pucAllocatedMemory,       /* Structure at the start of the allocated memory. */ /*lint !e9087 Safe cast as allocated memory is aligned. */ /*lint !e826 Area is not too small and alignment is guaranteed provided malloc() behaves as expected and returns aligned buffer. */
    597c:	6a 81       	ldd	r22, Y+2	; 0x02
    597e:	7b 81       	ldd	r23, Y+3	; 0x03
    5980:	8a 81       	ldd	r24, Y+2	; 0x02
    5982:	9b 81       	ldd	r25, Y+3	; 0x03
    5984:	9c 01       	movw	r18, r24
    5986:	21 5f       	subi	r18, 0xF1	; 241
    5988:	3f 4f       	sbci	r19, 0xFF	; 255
    598a:	4c 81       	ldd	r20, Y+4	; 0x04
    598c:	5d 81       	ldd	r21, Y+5	; 0x05
    598e:	ee 81       	ldd	r30, Y+6	; 0x06
    5990:	ff 81       	ldd	r31, Y+7	; 0x07
    5992:	cb 01       	movw	r24, r22
    5994:	b9 01       	movw	r22, r18
    5996:	9f 01       	movw	r18, r30
    5998:	09 81       	ldd	r16, Y+1	; 0x01
    599a:	0e 94 0a 34 	call	0x6814	; 0x6814 <prvInitialiseNewStreamBuffer>
        else
        {
            traceSTREAM_BUFFER_CREATE_FAILED( xIsMessageBuffer );
        }

        return ( StreamBufferHandle_t ) pucAllocatedMemory; /*lint !e9087 !e826 Safe cast as allocated memory is aligned. */
    599e:	8a 81       	ldd	r24, Y+2	; 0x02
    59a0:	9b 81       	ldd	r25, Y+3	; 0x03
    }
    59a2:	28 96       	adiw	r28, 0x08	; 8
    59a4:	0f b6       	in	r0, 0x3f	; 63
    59a6:	f8 94       	cli
    59a8:	de bf       	out	0x3e, r29	; 62
    59aa:	0f be       	out	0x3f, r0	; 63
    59ac:	cd bf       	out	0x3d, r28	; 61
    59ae:	cf 91       	pop	r28
    59b0:	df 91       	pop	r29
    59b2:	0f 91       	pop	r16
    59b4:	08 95       	ret

000059b6 <vStreamBufferDelete>:

#endif /* ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
/*-----------------------------------------------------------*/

void vStreamBufferDelete( StreamBufferHandle_t xStreamBuffer )
{
    59b6:	df 93       	push	r29
    59b8:	cf 93       	push	r28
    59ba:	00 d0       	rcall	.+0      	; 0x59bc <vStreamBufferDelete+0x6>
    59bc:	00 d0       	rcall	.+0      	; 0x59be <vStreamBufferDelete+0x8>
    59be:	cd b7       	in	r28, 0x3d	; 61
    59c0:	de b7       	in	r29, 0x3e	; 62
    59c2:	9c 83       	std	Y+4, r25	; 0x04
    59c4:	8b 83       	std	Y+3, r24	; 0x03
    StreamBuffer_t * pxStreamBuffer = xStreamBuffer;
    59c6:	8b 81       	ldd	r24, Y+3	; 0x03
    59c8:	9c 81       	ldd	r25, Y+4	; 0x04
    59ca:	9a 83       	std	Y+2, r25	; 0x02
    59cc:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxStreamBuffer );

    traceSTREAM_BUFFER_DELETE( xStreamBuffer );

    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) pdFALSE )
    59ce:	e9 81       	ldd	r30, Y+1	; 0x01
    59d0:	fa 81       	ldd	r31, Y+2	; 0x02
    59d2:	86 85       	ldd	r24, Z+14	; 0x0e
    59d4:	88 2f       	mov	r24, r24
    59d6:	90 e0       	ldi	r25, 0x00	; 0
    59d8:	82 70       	andi	r24, 0x02	; 2
    59da:	90 70       	andi	r25, 0x00	; 0
    59dc:	00 97       	sbiw	r24, 0x00	; 0
    59de:	29 f4       	brne	.+10     	; 0x59ea <vStreamBufferDelete+0x34>
    {
        #if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
            {
                /* Both the structure and the buffer were allocated using a single call
                * to pvPortMalloc(), hence only one call to vPortFree() is required. */
                vPortFree( ( void * ) pxStreamBuffer ); /*lint !e9087 Standard free() semantics require void *, plus pxStreamBuffer was allocated by pvPortMalloc(). */
    59e0:	89 81       	ldd	r24, Y+1	; 0x01
    59e2:	9a 81       	ldd	r25, Y+2	; 0x02
    59e4:	0e 94 6c 1e 	call	0x3cd8	; 0x3cd8 <vPortFree>
    59e8:	08 c0       	rjmp	.+16     	; 0x59fa <vStreamBufferDelete+0x44>
    }
    else
    {
        /* The structure and buffer were not allocated dynamically and cannot be
         * freed - just scrub the structure so future use will assert. */
        ( void ) memset( pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) );
    59ea:	89 81       	ldd	r24, Y+1	; 0x01
    59ec:	9a 81       	ldd	r25, Y+2	; 0x02
    59ee:	60 e0       	ldi	r22, 0x00	; 0
    59f0:	70 e0       	ldi	r23, 0x00	; 0
    59f2:	4f e0       	ldi	r20, 0x0F	; 15
    59f4:	50 e0       	ldi	r21, 0x00	; 0
    59f6:	0e 94 89 4c 	call	0x9912	; 0x9912 <memset>
    }
}
    59fa:	0f 90       	pop	r0
    59fc:	0f 90       	pop	r0
    59fe:	0f 90       	pop	r0
    5a00:	0f 90       	pop	r0
    5a02:	cf 91       	pop	r28
    5a04:	df 91       	pop	r29
    5a06:	08 95       	ret

00005a08 <xStreamBufferReset>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferReset( StreamBufferHandle_t xStreamBuffer )
{
    5a08:	0f 93       	push	r16
    5a0a:	df 93       	push	r29
    5a0c:	cf 93       	push	r28
    5a0e:	00 d0       	rcall	.+0      	; 0x5a10 <xStreamBufferReset+0x8>
    5a10:	00 d0       	rcall	.+0      	; 0x5a12 <xStreamBufferReset+0xa>
    5a12:	0f 92       	push	r0
    5a14:	cd b7       	in	r28, 0x3d	; 61
    5a16:	de b7       	in	r29, 0x3e	; 62
    5a18:	9d 83       	std	Y+5, r25	; 0x05
    5a1a:	8c 83       	std	Y+4, r24	; 0x04
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    5a1c:	8c 81       	ldd	r24, Y+4	; 0x04
    5a1e:	9d 81       	ldd	r25, Y+5	; 0x05
    5a20:	9b 83       	std	Y+3, r25	; 0x03
    5a22:	8a 83       	std	Y+2, r24	; 0x02
    BaseType_t xReturn = pdFAIL;
    5a24:	19 82       	std	Y+1, r1	; 0x01
            uxStreamBufferNumber = pxStreamBuffer->uxStreamBufferNumber;
        }
    #endif

    /* Can only reset a message buffer if there are no tasks blocked on it. */
    taskENTER_CRITICAL();
    5a26:	0f b6       	in	r0, 0x3f	; 63
    5a28:	f8 94       	cli
    5a2a:	0f 92       	push	r0
    {
        if( pxStreamBuffer->xTaskWaitingToReceive == NULL )
    5a2c:	ea 81       	ldd	r30, Y+2	; 0x02
    5a2e:	fb 81       	ldd	r31, Y+3	; 0x03
    5a30:	80 85       	ldd	r24, Z+8	; 0x08
    5a32:	91 85       	ldd	r25, Z+9	; 0x09
    5a34:	00 97       	sbiw	r24, 0x00	; 0
    5a36:	f1 f4       	brne	.+60     	; 0x5a74 <xStreamBufferReset+0x6c>
        {
            if( pxStreamBuffer->xTaskWaitingToSend == NULL )
    5a38:	ea 81       	ldd	r30, Y+2	; 0x02
    5a3a:	fb 81       	ldd	r31, Y+3	; 0x03
    5a3c:	82 85       	ldd	r24, Z+10	; 0x0a
    5a3e:	93 85       	ldd	r25, Z+11	; 0x0b
    5a40:	00 97       	sbiw	r24, 0x00	; 0
    5a42:	c1 f4       	brne	.+48     	; 0x5a74 <xStreamBufferReset+0x6c>
            {
                prvInitialiseNewStreamBuffer( pxStreamBuffer,
    5a44:	ea 81       	ldd	r30, Y+2	; 0x02
    5a46:	fb 81       	ldd	r31, Y+3	; 0x03
    5a48:	24 85       	ldd	r18, Z+12	; 0x0c
    5a4a:	35 85       	ldd	r19, Z+13	; 0x0d
    5a4c:	ea 81       	ldd	r30, Y+2	; 0x02
    5a4e:	fb 81       	ldd	r31, Y+3	; 0x03
    5a50:	44 81       	ldd	r20, Z+4	; 0x04
    5a52:	55 81       	ldd	r21, Z+5	; 0x05
    5a54:	ea 81       	ldd	r30, Y+2	; 0x02
    5a56:	fb 81       	ldd	r31, Y+3	; 0x03
    5a58:	a6 81       	ldd	r26, Z+6	; 0x06
    5a5a:	b7 81       	ldd	r27, Z+7	; 0x07
    5a5c:	ea 81       	ldd	r30, Y+2	; 0x02
    5a5e:	fb 81       	ldd	r31, Y+3	; 0x03
    5a60:	e6 85       	ldd	r30, Z+14	; 0x0e
    5a62:	8a 81       	ldd	r24, Y+2	; 0x02
    5a64:	9b 81       	ldd	r25, Y+3	; 0x03
    5a66:	b9 01       	movw	r22, r18
    5a68:	9d 01       	movw	r18, r26
    5a6a:	0e 2f       	mov	r16, r30
    5a6c:	0e 94 0a 34 	call	0x6814	; 0x6814 <prvInitialiseNewStreamBuffer>
                                              pxStreamBuffer->pucBuffer,
                                              pxStreamBuffer->xLength,
                                              pxStreamBuffer->xTriggerLevelBytes,
                                              pxStreamBuffer->ucFlags );
                xReturn = pdPASS;
    5a70:	81 e0       	ldi	r24, 0x01	; 1
    5a72:	89 83       	std	Y+1, r24	; 0x01

                traceSTREAM_BUFFER_RESET( xStreamBuffer );
            }
        }
    }
    taskEXIT_CRITICAL();
    5a74:	0f 90       	pop	r0
    5a76:	0f be       	out	0x3f, r0	; 63

    return xReturn;
    5a78:	89 81       	ldd	r24, Y+1	; 0x01
}
    5a7a:	0f 90       	pop	r0
    5a7c:	0f 90       	pop	r0
    5a7e:	0f 90       	pop	r0
    5a80:	0f 90       	pop	r0
    5a82:	0f 90       	pop	r0
    5a84:	cf 91       	pop	r28
    5a86:	df 91       	pop	r29
    5a88:	0f 91       	pop	r16
    5a8a:	08 95       	ret

00005a8c <xStreamBufferSetTriggerLevel>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferSetTriggerLevel( StreamBufferHandle_t xStreamBuffer,
                                         size_t xTriggerLevel )
{
    5a8c:	df 93       	push	r29
    5a8e:	cf 93       	push	r28
    5a90:	cd b7       	in	r28, 0x3d	; 61
    5a92:	de b7       	in	r29, 0x3e	; 62
    5a94:	27 97       	sbiw	r28, 0x07	; 7
    5a96:	0f b6       	in	r0, 0x3f	; 63
    5a98:	f8 94       	cli
    5a9a:	de bf       	out	0x3e, r29	; 62
    5a9c:	0f be       	out	0x3f, r0	; 63
    5a9e:	cd bf       	out	0x3d, r28	; 61
    5aa0:	9d 83       	std	Y+5, r25	; 0x05
    5aa2:	8c 83       	std	Y+4, r24	; 0x04
    5aa4:	7f 83       	std	Y+7, r23	; 0x07
    5aa6:	6e 83       	std	Y+6, r22	; 0x06
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    5aa8:	8c 81       	ldd	r24, Y+4	; 0x04
    5aaa:	9d 81       	ldd	r25, Y+5	; 0x05
    5aac:	9b 83       	std	Y+3, r25	; 0x03
    5aae:	8a 83       	std	Y+2, r24	; 0x02
    BaseType_t xReturn;

    configASSERT( pxStreamBuffer );

    /* It is not valid for the trigger level to be 0. */
    if( xTriggerLevel == ( size_t ) 0 )
    5ab0:	8e 81       	ldd	r24, Y+6	; 0x06
    5ab2:	9f 81       	ldd	r25, Y+7	; 0x07
    5ab4:	00 97       	sbiw	r24, 0x00	; 0
    5ab6:	21 f4       	brne	.+8      	; 0x5ac0 <xStreamBufferSetTriggerLevel+0x34>
    {
        xTriggerLevel = ( size_t ) 1;
    5ab8:	81 e0       	ldi	r24, 0x01	; 1
    5aba:	90 e0       	ldi	r25, 0x00	; 0
    5abc:	9f 83       	std	Y+7, r25	; 0x07
    5abe:	8e 83       	std	Y+6, r24	; 0x06
    }

    /* The trigger level is the number of bytes that must be in the stream
     * buffer before a task that is waiting for data is unblocked. */
    if( xTriggerLevel < pxStreamBuffer->xLength )
    5ac0:	ea 81       	ldd	r30, Y+2	; 0x02
    5ac2:	fb 81       	ldd	r31, Y+3	; 0x03
    5ac4:	24 81       	ldd	r18, Z+4	; 0x04
    5ac6:	35 81       	ldd	r19, Z+5	; 0x05
    5ac8:	8e 81       	ldd	r24, Y+6	; 0x06
    5aca:	9f 81       	ldd	r25, Y+7	; 0x07
    5acc:	82 17       	cp	r24, r18
    5ace:	93 07       	cpc	r25, r19
    5ad0:	48 f4       	brcc	.+18     	; 0x5ae4 <xStreamBufferSetTriggerLevel+0x58>
    {
        pxStreamBuffer->xTriggerLevelBytes = xTriggerLevel;
    5ad2:	ea 81       	ldd	r30, Y+2	; 0x02
    5ad4:	fb 81       	ldd	r31, Y+3	; 0x03
    5ad6:	8e 81       	ldd	r24, Y+6	; 0x06
    5ad8:	9f 81       	ldd	r25, Y+7	; 0x07
    5ada:	97 83       	std	Z+7, r25	; 0x07
    5adc:	86 83       	std	Z+6, r24	; 0x06
        xReturn = pdPASS;
    5ade:	81 e0       	ldi	r24, 0x01	; 1
    5ae0:	89 83       	std	Y+1, r24	; 0x01
    5ae2:	01 c0       	rjmp	.+2      	; 0x5ae6 <xStreamBufferSetTriggerLevel+0x5a>
    }
    else
    {
        xReturn = pdFALSE;
    5ae4:	19 82       	std	Y+1, r1	; 0x01
    }

    return xReturn;
    5ae6:	89 81       	ldd	r24, Y+1	; 0x01
}
    5ae8:	27 96       	adiw	r28, 0x07	; 7
    5aea:	0f b6       	in	r0, 0x3f	; 63
    5aec:	f8 94       	cli
    5aee:	de bf       	out	0x3e, r29	; 62
    5af0:	0f be       	out	0x3f, r0	; 63
    5af2:	cd bf       	out	0x3d, r28	; 61
    5af4:	cf 91       	pop	r28
    5af6:	df 91       	pop	r29
    5af8:	08 95       	ret

00005afa <xStreamBufferSpacesAvailable>:
/*-----------------------------------------------------------*/

size_t xStreamBufferSpacesAvailable( StreamBufferHandle_t xStreamBuffer )
{
    5afa:	df 93       	push	r29
    5afc:	cf 93       	push	r28
    5afe:	cd b7       	in	r28, 0x3d	; 61
    5b00:	de b7       	in	r29, 0x3e	; 62
    5b02:	28 97       	sbiw	r28, 0x08	; 8
    5b04:	0f b6       	in	r0, 0x3f	; 63
    5b06:	f8 94       	cli
    5b08:	de bf       	out	0x3e, r29	; 62
    5b0a:	0f be       	out	0x3f, r0	; 63
    5b0c:	cd bf       	out	0x3d, r28	; 61
    5b0e:	98 87       	std	Y+8, r25	; 0x08
    5b10:	8f 83       	std	Y+7, r24	; 0x07
    const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    5b12:	8f 81       	ldd	r24, Y+7	; 0x07
    5b14:	98 85       	ldd	r25, Y+8	; 0x08
    5b16:	9e 83       	std	Y+6, r25	; 0x06
    5b18:	8d 83       	std	Y+5, r24	; 0x05
    /* The code below reads xTail and then xHead.  This is safe if the stream
    buffer is updated once between the two reads - but not if the stream buffer
    is updated more than once between the two reads - hence the loop. */
    do
    {
        xOriginalTail = pxStreamBuffer->xTail;
    5b1a:	ed 81       	ldd	r30, Y+5	; 0x05
    5b1c:	fe 81       	ldd	r31, Y+6	; 0x06
    5b1e:	80 81       	ld	r24, Z
    5b20:	91 81       	ldd	r25, Z+1	; 0x01
    5b22:	9a 83       	std	Y+2, r25	; 0x02
    5b24:	89 83       	std	Y+1, r24	; 0x01
        xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;
    5b26:	ed 81       	ldd	r30, Y+5	; 0x05
    5b28:	fe 81       	ldd	r31, Y+6	; 0x06
    5b2a:	24 81       	ldd	r18, Z+4	; 0x04
    5b2c:	35 81       	ldd	r19, Z+5	; 0x05
    5b2e:	ed 81       	ldd	r30, Y+5	; 0x05
    5b30:	fe 81       	ldd	r31, Y+6	; 0x06
    5b32:	80 81       	ld	r24, Z
    5b34:	91 81       	ldd	r25, Z+1	; 0x01
    5b36:	82 0f       	add	r24, r18
    5b38:	93 1f       	adc	r25, r19
    5b3a:	9c 83       	std	Y+4, r25	; 0x04
    5b3c:	8b 83       	std	Y+3, r24	; 0x03
        xSpace -= pxStreamBuffer->xHead;
    5b3e:	ed 81       	ldd	r30, Y+5	; 0x05
    5b40:	fe 81       	ldd	r31, Y+6	; 0x06
    5b42:	22 81       	ldd	r18, Z+2	; 0x02
    5b44:	33 81       	ldd	r19, Z+3	; 0x03
    5b46:	8b 81       	ldd	r24, Y+3	; 0x03
    5b48:	9c 81       	ldd	r25, Y+4	; 0x04
    5b4a:	82 1b       	sub	r24, r18
    5b4c:	93 0b       	sbc	r25, r19
    5b4e:	9c 83       	std	Y+4, r25	; 0x04
    5b50:	8b 83       	std	Y+3, r24	; 0x03
    } while( xOriginalTail != pxStreamBuffer->xTail );
    5b52:	ed 81       	ldd	r30, Y+5	; 0x05
    5b54:	fe 81       	ldd	r31, Y+6	; 0x06
    5b56:	20 81       	ld	r18, Z
    5b58:	31 81       	ldd	r19, Z+1	; 0x01
    5b5a:	89 81       	ldd	r24, Y+1	; 0x01
    5b5c:	9a 81       	ldd	r25, Y+2	; 0x02
    5b5e:	28 17       	cp	r18, r24
    5b60:	39 07       	cpc	r19, r25
    5b62:	d9 f6       	brne	.-74     	; 0x5b1a <xStreamBufferSpacesAvailable+0x20>
    xSpace -= ( size_t ) 1;
    5b64:	8b 81       	ldd	r24, Y+3	; 0x03
    5b66:	9c 81       	ldd	r25, Y+4	; 0x04
    5b68:	01 97       	sbiw	r24, 0x01	; 1
    5b6a:	9c 83       	std	Y+4, r25	; 0x04
    5b6c:	8b 83       	std	Y+3, r24	; 0x03

    if( xSpace >= pxStreamBuffer->xLength )
    5b6e:	ed 81       	ldd	r30, Y+5	; 0x05
    5b70:	fe 81       	ldd	r31, Y+6	; 0x06
    5b72:	24 81       	ldd	r18, Z+4	; 0x04
    5b74:	35 81       	ldd	r19, Z+5	; 0x05
    5b76:	8b 81       	ldd	r24, Y+3	; 0x03
    5b78:	9c 81       	ldd	r25, Y+4	; 0x04
    5b7a:	82 17       	cp	r24, r18
    5b7c:	93 07       	cpc	r25, r19
    5b7e:	50 f0       	brcs	.+20     	; 0x5b94 <xStreamBufferSpacesAvailable+0x9a>
    {
        xSpace -= pxStreamBuffer->xLength;
    5b80:	ed 81       	ldd	r30, Y+5	; 0x05
    5b82:	fe 81       	ldd	r31, Y+6	; 0x06
    5b84:	24 81       	ldd	r18, Z+4	; 0x04
    5b86:	35 81       	ldd	r19, Z+5	; 0x05
    5b88:	8b 81       	ldd	r24, Y+3	; 0x03
    5b8a:	9c 81       	ldd	r25, Y+4	; 0x04
    5b8c:	82 1b       	sub	r24, r18
    5b8e:	93 0b       	sbc	r25, r19
    5b90:	9c 83       	std	Y+4, r25	; 0x04
    5b92:	8b 83       	std	Y+3, r24	; 0x03
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    return xSpace;
    5b94:	8b 81       	ldd	r24, Y+3	; 0x03
    5b96:	9c 81       	ldd	r25, Y+4	; 0x04
}
    5b98:	28 96       	adiw	r28, 0x08	; 8
    5b9a:	0f b6       	in	r0, 0x3f	; 63
    5b9c:	f8 94       	cli
    5b9e:	de bf       	out	0x3e, r29	; 62
    5ba0:	0f be       	out	0x3f, r0	; 63
    5ba2:	cd bf       	out	0x3d, r28	; 61
    5ba4:	cf 91       	pop	r28
    5ba6:	df 91       	pop	r29
    5ba8:	08 95       	ret

00005baa <xStreamBufferBytesAvailable>:
/*-----------------------------------------------------------*/

size_t xStreamBufferBytesAvailable( StreamBufferHandle_t xStreamBuffer )
{
    5baa:	df 93       	push	r29
    5bac:	cf 93       	push	r28
    5bae:	00 d0       	rcall	.+0      	; 0x5bb0 <xStreamBufferBytesAvailable+0x6>
    5bb0:	00 d0       	rcall	.+0      	; 0x5bb2 <xStreamBufferBytesAvailable+0x8>
    5bb2:	00 d0       	rcall	.+0      	; 0x5bb4 <xStreamBufferBytesAvailable+0xa>
    5bb4:	cd b7       	in	r28, 0x3d	; 61
    5bb6:	de b7       	in	r29, 0x3e	; 62
    5bb8:	9e 83       	std	Y+6, r25	; 0x06
    5bba:	8d 83       	std	Y+5, r24	; 0x05
    const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    5bbc:	8d 81       	ldd	r24, Y+5	; 0x05
    5bbe:	9e 81       	ldd	r25, Y+6	; 0x06
    5bc0:	9c 83       	std	Y+4, r25	; 0x04
    5bc2:	8b 83       	std	Y+3, r24	; 0x03
    size_t xReturn;

    configASSERT( pxStreamBuffer );

    xReturn = prvBytesInBuffer( pxStreamBuffer );
    5bc4:	8b 81       	ldd	r24, Y+3	; 0x03
    5bc6:	9c 81       	ldd	r25, Y+4	; 0x04
    5bc8:	0e 94 d0 33 	call	0x67a0	; 0x67a0 <prvBytesInBuffer>
    5bcc:	9a 83       	std	Y+2, r25	; 0x02
    5bce:	89 83       	std	Y+1, r24	; 0x01
    return xReturn;
    5bd0:	89 81       	ldd	r24, Y+1	; 0x01
    5bd2:	9a 81       	ldd	r25, Y+2	; 0x02
}
    5bd4:	26 96       	adiw	r28, 0x06	; 6
    5bd6:	0f b6       	in	r0, 0x3f	; 63
    5bd8:	f8 94       	cli
    5bda:	de bf       	out	0x3e, r29	; 62
    5bdc:	0f be       	out	0x3f, r0	; 63
    5bde:	cd bf       	out	0x3d, r28	; 61
    5be0:	cf 91       	pop	r28
    5be2:	df 91       	pop	r29
    5be4:	08 95       	ret

00005be6 <xStreamBufferSend>:

size_t xStreamBufferSend( StreamBufferHandle_t xStreamBuffer,
                          const void * pvTxData,
                          size_t xDataLengthBytes,
                          TickType_t xTicksToWait )
{
    5be6:	cf 92       	push	r12
    5be8:	df 92       	push	r13
    5bea:	ef 92       	push	r14
    5bec:	ff 92       	push	r15
    5bee:	0f 93       	push	r16
    5bf0:	1f 93       	push	r17
    5bf2:	df 93       	push	r29
    5bf4:	cf 93       	push	r28
    5bf6:	cd b7       	in	r28, 0x3d	; 61
    5bf8:	de b7       	in	r29, 0x3e	; 62
    5bfa:	65 97       	sbiw	r28, 0x15	; 21
    5bfc:	0f b6       	in	r0, 0x3f	; 63
    5bfe:	f8 94       	cli
    5c00:	de bf       	out	0x3e, r29	; 62
    5c02:	0f be       	out	0x3f, r0	; 63
    5c04:	cd bf       	out	0x3d, r28	; 61
    5c06:	9f 87       	std	Y+15, r25	; 0x0f
    5c08:	8e 87       	std	Y+14, r24	; 0x0e
    5c0a:	79 8b       	std	Y+17, r23	; 0x11
    5c0c:	68 8b       	std	Y+16, r22	; 0x10
    5c0e:	5b 8b       	std	Y+19, r21	; 0x13
    5c10:	4a 8b       	std	Y+18, r20	; 0x12
    5c12:	3d 8b       	std	Y+21, r19	; 0x15
    5c14:	2c 8b       	std	Y+20, r18	; 0x14
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    5c16:	8e 85       	ldd	r24, Y+14	; 0x0e
    5c18:	9f 85       	ldd	r25, Y+15	; 0x0f
    5c1a:	9a 87       	std	Y+10, r25	; 0x0a
    5c1c:	89 87       	std	Y+9, r24	; 0x09
    size_t xReturn, xSpace = 0;
    5c1e:	1e 82       	std	Y+6, r1	; 0x06
    5c20:	1d 82       	std	Y+5, r1	; 0x05
    size_t xRequiredSpace = xDataLengthBytes;
    5c22:	8a 89       	ldd	r24, Y+18	; 0x12
    5c24:	9b 89       	ldd	r25, Y+19	; 0x13
    5c26:	9c 83       	std	Y+4, r25	; 0x04
    5c28:	8b 83       	std	Y+3, r24	; 0x03
    TimeOut_t xTimeOut;
    size_t xMaxReportedSpace = 0;
    5c2a:	1a 82       	std	Y+2, r1	; 0x02
    5c2c:	19 82       	std	Y+1, r1	; 0x01
    configASSERT( pvTxData );
    configASSERT( pxStreamBuffer );

    /* The maximum amount of space a stream buffer will ever report is its length
     * minus 1. */
    xMaxReportedSpace = pxStreamBuffer->xLength - ( size_t ) 1;
    5c2e:	e9 85       	ldd	r30, Y+9	; 0x09
    5c30:	fa 85       	ldd	r31, Y+10	; 0x0a
    5c32:	84 81       	ldd	r24, Z+4	; 0x04
    5c34:	95 81       	ldd	r25, Z+5	; 0x05
    5c36:	01 97       	sbiw	r24, 0x01	; 1
    5c38:	9a 83       	std	Y+2, r25	; 0x02
    5c3a:	89 83       	std	Y+1, r24	; 0x01

    /* This send function is used to write to both message buffers and stream
     * buffers.  If this is a message buffer then the space needed must be
     * increased by the amount of bytes needed to store the length of the
     * message. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    5c3c:	e9 85       	ldd	r30, Y+9	; 0x09
    5c3e:	fa 85       	ldd	r31, Y+10	; 0x0a
    5c40:	86 85       	ldd	r24, Z+14	; 0x0e
    5c42:	88 2f       	mov	r24, r24
    5c44:	90 e0       	ldi	r25, 0x00	; 0
    5c46:	81 70       	andi	r24, 0x01	; 1
    5c48:	90 70       	andi	r25, 0x00	; 0
    5c4a:	88 23       	and	r24, r24
    5c4c:	79 f0       	breq	.+30     	; 0x5c6c <xStreamBufferSend+0x86>
    {
        xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
    5c4e:	8b 81       	ldd	r24, Y+3	; 0x03
    5c50:	9c 81       	ldd	r25, Y+4	; 0x04
    5c52:	02 96       	adiw	r24, 0x02	; 2
    5c54:	9c 83       	std	Y+4, r25	; 0x04
    5c56:	8b 83       	std	Y+3, r24	; 0x03
        /* Overflow? */
        configASSERT( xRequiredSpace > xDataLengthBytes );

        /* If this is a message buffer then it must be possible to write the
         * whole message. */
        if( xRequiredSpace > xMaxReportedSpace )
    5c58:	2b 81       	ldd	r18, Y+3	; 0x03
    5c5a:	3c 81       	ldd	r19, Y+4	; 0x04
    5c5c:	89 81       	ldd	r24, Y+1	; 0x01
    5c5e:	9a 81       	ldd	r25, Y+2	; 0x02
    5c60:	82 17       	cp	r24, r18
    5c62:	93 07       	cpc	r25, r19
    5c64:	70 f4       	brcc	.+28     	; 0x5c82 <xStreamBufferSend+0x9c>
        {
            /* The message would not fit even if the entire buffer was empty,
             * so don't wait for space. */
            xTicksToWait = ( TickType_t ) 0;
    5c66:	1d 8a       	std	Y+21, r1	; 0x15
    5c68:	1c 8a       	std	Y+20, r1	; 0x14
    5c6a:	0b c0       	rjmp	.+22     	; 0x5c82 <xStreamBufferSend+0x9c>
    else
    {
        /* If this is a stream buffer then it is acceptable to write only part
         * of the message to the buffer.  Cap the length to the total length of
         * the buffer. */
        if( xRequiredSpace > xMaxReportedSpace )
    5c6c:	2b 81       	ldd	r18, Y+3	; 0x03
    5c6e:	3c 81       	ldd	r19, Y+4	; 0x04
    5c70:	89 81       	ldd	r24, Y+1	; 0x01
    5c72:	9a 81       	ldd	r25, Y+2	; 0x02
    5c74:	82 17       	cp	r24, r18
    5c76:	93 07       	cpc	r25, r19
    5c78:	20 f4       	brcc	.+8      	; 0x5c82 <xStreamBufferSend+0x9c>
        {
            xRequiredSpace = xMaxReportedSpace;
    5c7a:	89 81       	ldd	r24, Y+1	; 0x01
    5c7c:	9a 81       	ldd	r25, Y+2	; 0x02
    5c7e:	9c 83       	std	Y+4, r25	; 0x04
    5c80:	8b 83       	std	Y+3, r24	; 0x03
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    if( xTicksToWait != ( TickType_t ) 0 )
    5c82:	8c 89       	ldd	r24, Y+20	; 0x14
    5c84:	9d 89       	ldd	r25, Y+21	; 0x15
    5c86:	00 97       	sbiw	r24, 0x00	; 0
    5c88:	09 f4       	brne	.+2      	; 0x5c8c <xStreamBufferSend+0xa6>
    5c8a:	43 c0       	rjmp	.+134    	; 0x5d12 <xStreamBufferSend+0x12c>
    {
        vTaskSetTimeOutState( &xTimeOut );
    5c8c:	ce 01       	movw	r24, r28
    5c8e:	0b 96       	adiw	r24, 0x0b	; 11
    5c90:	0e 94 45 3e 	call	0x7c8a	; 0x7c8a <vTaskSetTimeOutState>

        do
        {
            /* Wait until the required number of bytes are free in the message
             * buffer. */
            taskENTER_CRITICAL();
    5c94:	0f b6       	in	r0, 0x3f	; 63
    5c96:	f8 94       	cli
    5c98:	0f 92       	push	r0
            {
                xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    5c9a:	89 85       	ldd	r24, Y+9	; 0x09
    5c9c:	9a 85       	ldd	r25, Y+10	; 0x0a
    5c9e:	0e 94 7d 2d 	call	0x5afa	; 0x5afa <xStreamBufferSpacesAvailable>
    5ca2:	9e 83       	std	Y+6, r25	; 0x06
    5ca4:	8d 83       	std	Y+5, r24	; 0x05

                if( xSpace < xRequiredSpace )
    5ca6:	2d 81       	ldd	r18, Y+5	; 0x05
    5ca8:	3e 81       	ldd	r19, Y+6	; 0x06
    5caa:	8b 81       	ldd	r24, Y+3	; 0x03
    5cac:	9c 81       	ldd	r25, Y+4	; 0x04
    5cae:	28 17       	cp	r18, r24
    5cb0:	39 07       	cpc	r19, r25
    5cb2:	68 f5       	brcc	.+90     	; 0x5d0e <xStreamBufferSend+0x128>
                {
                    /* Clear notification state as going to wait for space. */
                    ( void ) xTaskNotifyStateClear( NULL );
    5cb4:	80 e0       	ldi	r24, 0x00	; 0
    5cb6:	90 e0       	ldi	r25, 0x00	; 0
    5cb8:	60 e0       	ldi	r22, 0x00	; 0
    5cba:	0e 94 21 49 	call	0x9242	; 0x9242 <xTaskGenericNotifyStateClear>

                    /* Should only be one writer. */
                    configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
                    pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
    5cbe:	0e 94 a1 3f 	call	0x7f42	; 0x7f42 <xTaskGetCurrentTaskHandle>
    5cc2:	e9 85       	ldd	r30, Y+9	; 0x09
    5cc4:	fa 85       	ldd	r31, Y+10	; 0x0a
    5cc6:	93 87       	std	Z+11, r25	; 0x0b
    5cc8:	82 87       	std	Z+10, r24	; 0x0a
                {
                    taskEXIT_CRITICAL();
                    break;
                }
            }
            taskEXIT_CRITICAL();
    5cca:	0f 90       	pop	r0
    5ccc:	0f be       	out	0x3f, r0	; 63

            traceBLOCKING_ON_STREAM_BUFFER_SEND( xStreamBuffer );
            ( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
    5cce:	ec 89       	ldd	r30, Y+20	; 0x14
    5cd0:	fd 89       	ldd	r31, Y+21	; 0x15
    5cd2:	80 e0       	ldi	r24, 0x00	; 0
    5cd4:	40 e0       	ldi	r20, 0x00	; 0
    5cd6:	50 e0       	ldi	r21, 0x00	; 0
    5cd8:	60 e0       	ldi	r22, 0x00	; 0
    5cda:	70 e0       	ldi	r23, 0x00	; 0
    5cdc:	00 e0       	ldi	r16, 0x00	; 0
    5cde:	10 e0       	ldi	r17, 0x00	; 0
    5ce0:	20 e0       	ldi	r18, 0x00	; 0
    5ce2:	30 e0       	ldi	r19, 0x00	; 0
    5ce4:	ee 24       	eor	r14, r14
    5ce6:	ff 24       	eor	r15, r15
    5ce8:	6f 01       	movw	r12, r30
    5cea:	0e 94 1d 43 	call	0x863a	; 0x863a <xTaskGenericNotifyWait>
            pxStreamBuffer->xTaskWaitingToSend = NULL;
    5cee:	e9 85       	ldd	r30, Y+9	; 0x09
    5cf0:	fa 85       	ldd	r31, Y+10	; 0x0a
    5cf2:	13 86       	std	Z+11, r1	; 0x0b
    5cf4:	12 86       	std	Z+10, r1	; 0x0a
        } while( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE );
    5cf6:	ce 01       	movw	r24, r28
    5cf8:	0b 96       	adiw	r24, 0x0b	; 11
    5cfa:	9e 01       	movw	r18, r28
    5cfc:	2c 5e       	subi	r18, 0xEC	; 236
    5cfe:	3f 4f       	sbci	r19, 0xFF	; 255
    5d00:	b9 01       	movw	r22, r18
    5d02:	0e 94 7c 3e 	call	0x7cf8	; 0x7cf8 <xTaskCheckForTimeOut>
    5d06:	88 23       	and	r24, r24
    5d08:	09 f4       	brne	.+2      	; 0x5d0c <xStreamBufferSend+0x126>
    5d0a:	c4 cf       	rjmp	.-120    	; 0x5c94 <xStreamBufferSend+0xae>
    5d0c:	02 c0       	rjmp	.+4      	; 0x5d12 <xStreamBufferSend+0x12c>
                    configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
                    pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
                }
                else
                {
                    taskEXIT_CRITICAL();
    5d0e:	0f 90       	pop	r0
    5d10:	0f be       	out	0x3f, r0	; 63
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    if( xSpace == ( size_t ) 0 )
    5d12:	8d 81       	ldd	r24, Y+5	; 0x05
    5d14:	9e 81       	ldd	r25, Y+6	; 0x06
    5d16:	00 97       	sbiw	r24, 0x00	; 0
    5d18:	31 f4       	brne	.+12     	; 0x5d26 <xStreamBufferSend+0x140>
    {
        xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    5d1a:	89 85       	ldd	r24, Y+9	; 0x09
    5d1c:	9a 85       	ldd	r25, Y+10	; 0x0a
    5d1e:	0e 94 7d 2d 	call	0x5afa	; 0x5afa <xStreamBufferSpacesAvailable>
    5d22:	9e 83       	std	Y+6, r25	; 0x06
    5d24:	8d 83       	std	Y+5, r24	; 0x05
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
    5d26:	89 85       	ldd	r24, Y+9	; 0x09
    5d28:	9a 85       	ldd	r25, Y+10	; 0x0a
    5d2a:	28 89       	ldd	r18, Y+16	; 0x10
    5d2c:	39 89       	ldd	r19, Y+17	; 0x11
    5d2e:	4a 89       	ldd	r20, Y+18	; 0x12
    5d30:	5b 89       	ldd	r21, Y+19	; 0x13
    5d32:	ed 81       	ldd	r30, Y+5	; 0x05
    5d34:	fe 81       	ldd	r31, Y+6	; 0x06
    5d36:	ab 81       	ldd	r26, Y+3	; 0x03
    5d38:	bc 81       	ldd	r27, Y+4	; 0x04
    5d3a:	b9 01       	movw	r22, r18
    5d3c:	9f 01       	movw	r18, r30
    5d3e:	8d 01       	movw	r16, r26
    5d40:	0e 94 63 2f 	call	0x5ec6	; 0x5ec6 <prvWriteMessageToBuffer>
    5d44:	98 87       	std	Y+8, r25	; 0x08
    5d46:	8f 83       	std	Y+7, r24	; 0x07

    if( xReturn > ( size_t ) 0 )
    5d48:	8f 81       	ldd	r24, Y+7	; 0x07
    5d4a:	98 85       	ldd	r25, Y+8	; 0x08
    5d4c:	00 97       	sbiw	r24, 0x00	; 0
    5d4e:	41 f1       	breq	.+80     	; 0x5da0 <xStreamBufferSend+0x1ba>
    {
        traceSTREAM_BUFFER_SEND( xStreamBuffer, xReturn );

        /* Was a task waiting for the data? */
        if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
    5d50:	89 85       	ldd	r24, Y+9	; 0x09
    5d52:	9a 85       	ldd	r25, Y+10	; 0x0a
    5d54:	0e 94 d0 33 	call	0x67a0	; 0x67a0 <prvBytesInBuffer>
    5d58:	9c 01       	movw	r18, r24
    5d5a:	e9 85       	ldd	r30, Y+9	; 0x09
    5d5c:	fa 85       	ldd	r31, Y+10	; 0x0a
    5d5e:	86 81       	ldd	r24, Z+6	; 0x06
    5d60:	97 81       	ldd	r25, Z+7	; 0x07
    5d62:	28 17       	cp	r18, r24
    5d64:	39 07       	cpc	r19, r25
    5d66:	e0 f0       	brcs	.+56     	; 0x5da0 <xStreamBufferSend+0x1ba>
        {
            sbSEND_COMPLETED( pxStreamBuffer );
    5d68:	0e 94 8f 37 	call	0x6f1e	; 0x6f1e <vTaskSuspendAll>
    5d6c:	e9 85       	ldd	r30, Y+9	; 0x09
    5d6e:	fa 85       	ldd	r31, Y+10	; 0x0a
    5d70:	80 85       	ldd	r24, Z+8	; 0x08
    5d72:	91 85       	ldd	r25, Z+9	; 0x09
    5d74:	00 97       	sbiw	r24, 0x00	; 0
    5d76:	91 f0       	breq	.+36     	; 0x5d9c <xStreamBufferSend+0x1b6>
    5d78:	e9 85       	ldd	r30, Y+9	; 0x09
    5d7a:	fa 85       	ldd	r31, Y+10	; 0x0a
    5d7c:	80 85       	ldd	r24, Z+8	; 0x08
    5d7e:	91 85       	ldd	r25, Z+9	; 0x09
    5d80:	60 e0       	ldi	r22, 0x00	; 0
    5d82:	20 e0       	ldi	r18, 0x00	; 0
    5d84:	30 e0       	ldi	r19, 0x00	; 0
    5d86:	40 e0       	ldi	r20, 0x00	; 0
    5d88:	50 e0       	ldi	r21, 0x00	; 0
    5d8a:	00 e0       	ldi	r16, 0x00	; 0
    5d8c:	ee 24       	eor	r14, r14
    5d8e:	ff 24       	eor	r15, r15
    5d90:	0e 94 14 44 	call	0x8828	; 0x8828 <xTaskGenericNotify>
    5d94:	e9 85       	ldd	r30, Y+9	; 0x09
    5d96:	fa 85       	ldd	r31, Y+10	; 0x0a
    5d98:	11 86       	std	Z+9, r1	; 0x09
    5d9a:	10 86       	std	Z+8, r1	; 0x08
    5d9c:	0e 94 9b 37 	call	0x6f36	; 0x6f36 <xTaskResumeAll>
    {
        mtCOVERAGE_TEST_MARKER();
        traceSTREAM_BUFFER_SEND_FAILED( xStreamBuffer );
    }

    return xReturn;
    5da0:	8f 81       	ldd	r24, Y+7	; 0x07
    5da2:	98 85       	ldd	r25, Y+8	; 0x08
}
    5da4:	65 96       	adiw	r28, 0x15	; 21
    5da6:	0f b6       	in	r0, 0x3f	; 63
    5da8:	f8 94       	cli
    5daa:	de bf       	out	0x3e, r29	; 62
    5dac:	0f be       	out	0x3f, r0	; 63
    5dae:	cd bf       	out	0x3d, r28	; 61
    5db0:	cf 91       	pop	r28
    5db2:	df 91       	pop	r29
    5db4:	1f 91       	pop	r17
    5db6:	0f 91       	pop	r16
    5db8:	ff 90       	pop	r15
    5dba:	ef 90       	pop	r14
    5dbc:	df 90       	pop	r13
    5dbe:	cf 90       	pop	r12
    5dc0:	08 95       	ret

00005dc2 <xStreamBufferSendFromISR>:

size_t xStreamBufferSendFromISR( StreamBufferHandle_t xStreamBuffer,
                                 const void * pvTxData,
                                 size_t xDataLengthBytes,
                                 BaseType_t * const pxHigherPriorityTaskWoken )
{
    5dc2:	cf 92       	push	r12
    5dc4:	df 92       	push	r13
    5dc6:	ef 92       	push	r14
    5dc8:	ff 92       	push	r15
    5dca:	0f 93       	push	r16
    5dcc:	1f 93       	push	r17
    5dce:	df 93       	push	r29
    5dd0:	cf 93       	push	r28
    5dd2:	cd b7       	in	r28, 0x3d	; 61
    5dd4:	de b7       	in	r29, 0x3e	; 62
    5dd6:	61 97       	sbiw	r28, 0x11	; 17
    5dd8:	0f b6       	in	r0, 0x3f	; 63
    5dda:	f8 94       	cli
    5ddc:	de bf       	out	0x3e, r29	; 62
    5dde:	0f be       	out	0x3f, r0	; 63
    5de0:	cd bf       	out	0x3d, r28	; 61
    5de2:	9b 87       	std	Y+11, r25	; 0x0b
    5de4:	8a 87       	std	Y+10, r24	; 0x0a
    5de6:	7d 87       	std	Y+13, r23	; 0x0d
    5de8:	6c 87       	std	Y+12, r22	; 0x0c
    5dea:	5f 87       	std	Y+15, r21	; 0x0f
    5dec:	4e 87       	std	Y+14, r20	; 0x0e
    5dee:	39 8b       	std	Y+17, r19	; 0x11
    5df0:	28 8b       	std	Y+16, r18	; 0x10
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    5df2:	8a 85       	ldd	r24, Y+10	; 0x0a
    5df4:	9b 85       	ldd	r25, Y+11	; 0x0b
    5df6:	99 87       	std	Y+9, r25	; 0x09
    5df8:	88 87       	std	Y+8, r24	; 0x08
    size_t xReturn, xSpace;
    size_t xRequiredSpace = xDataLengthBytes;
    5dfa:	8e 85       	ldd	r24, Y+14	; 0x0e
    5dfc:	9f 85       	ldd	r25, Y+15	; 0x0f
    5dfe:	9b 83       	std	Y+3, r25	; 0x03
    5e00:	8a 83       	std	Y+2, r24	; 0x02

    /* This send function is used to write to both message buffers and stream
     * buffers.  If this is a message buffer then the space needed must be
     * increased by the amount of bytes needed to store the length of the
     * message. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    5e02:	e8 85       	ldd	r30, Y+8	; 0x08
    5e04:	f9 85       	ldd	r31, Y+9	; 0x09
    5e06:	86 85       	ldd	r24, Z+14	; 0x0e
    5e08:	88 2f       	mov	r24, r24
    5e0a:	90 e0       	ldi	r25, 0x00	; 0
    5e0c:	81 70       	andi	r24, 0x01	; 1
    5e0e:	90 70       	andi	r25, 0x00	; 0
    5e10:	88 23       	and	r24, r24
    5e12:	29 f0       	breq	.+10     	; 0x5e1e <xStreamBufferSendFromISR+0x5c>
    {
        xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
    5e14:	8a 81       	ldd	r24, Y+2	; 0x02
    5e16:	9b 81       	ldd	r25, Y+3	; 0x03
    5e18:	02 96       	adiw	r24, 0x02	; 2
    5e1a:	9b 83       	std	Y+3, r25	; 0x03
    5e1c:	8a 83       	std	Y+2, r24	; 0x02
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    5e1e:	88 85       	ldd	r24, Y+8	; 0x08
    5e20:	99 85       	ldd	r25, Y+9	; 0x09
    5e22:	0e 94 7d 2d 	call	0x5afa	; 0x5afa <xStreamBufferSpacesAvailable>
    5e26:	9d 83       	std	Y+5, r25	; 0x05
    5e28:	8c 83       	std	Y+4, r24	; 0x04
    xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
    5e2a:	88 85       	ldd	r24, Y+8	; 0x08
    5e2c:	99 85       	ldd	r25, Y+9	; 0x09
    5e2e:	2c 85       	ldd	r18, Y+12	; 0x0c
    5e30:	3d 85       	ldd	r19, Y+13	; 0x0d
    5e32:	4e 85       	ldd	r20, Y+14	; 0x0e
    5e34:	5f 85       	ldd	r21, Y+15	; 0x0f
    5e36:	ec 81       	ldd	r30, Y+4	; 0x04
    5e38:	fd 81       	ldd	r31, Y+5	; 0x05
    5e3a:	aa 81       	ldd	r26, Y+2	; 0x02
    5e3c:	bb 81       	ldd	r27, Y+3	; 0x03
    5e3e:	b9 01       	movw	r22, r18
    5e40:	9f 01       	movw	r18, r30
    5e42:	8d 01       	movw	r16, r26
    5e44:	0e 94 63 2f 	call	0x5ec6	; 0x5ec6 <prvWriteMessageToBuffer>
    5e48:	9f 83       	std	Y+7, r25	; 0x07
    5e4a:	8e 83       	std	Y+6, r24	; 0x06

    if( xReturn > ( size_t ) 0 )
    5e4c:	8e 81       	ldd	r24, Y+6	; 0x06
    5e4e:	9f 81       	ldd	r25, Y+7	; 0x07
    5e50:	00 97       	sbiw	r24, 0x00	; 0
    5e52:	41 f1       	breq	.+80     	; 0x5ea4 <xStreamBufferSendFromISR+0xe2>
    {
        /* Was a task waiting for the data? */
        if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
    5e54:	88 85       	ldd	r24, Y+8	; 0x08
    5e56:	99 85       	ldd	r25, Y+9	; 0x09
    5e58:	0e 94 d0 33 	call	0x67a0	; 0x67a0 <prvBytesInBuffer>
    5e5c:	9c 01       	movw	r18, r24
    5e5e:	e8 85       	ldd	r30, Y+8	; 0x08
    5e60:	f9 85       	ldd	r31, Y+9	; 0x09
    5e62:	86 81       	ldd	r24, Z+6	; 0x06
    5e64:	97 81       	ldd	r25, Z+7	; 0x07
    5e66:	28 17       	cp	r18, r24
    5e68:	39 07       	cpc	r19, r25
    5e6a:	e0 f0       	brcs	.+56     	; 0x5ea4 <xStreamBufferSendFromISR+0xe2>
        {
            sbSEND_COMPLETE_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
    5e6c:	19 82       	std	Y+1, r1	; 0x01
    5e6e:	e8 85       	ldd	r30, Y+8	; 0x08
    5e70:	f9 85       	ldd	r31, Y+9	; 0x09
    5e72:	80 85       	ldd	r24, Z+8	; 0x08
    5e74:	91 85       	ldd	r25, Z+9	; 0x09
    5e76:	00 97       	sbiw	r24, 0x00	; 0
    5e78:	a9 f0       	breq	.+42     	; 0x5ea4 <xStreamBufferSendFromISR+0xe2>
    5e7a:	e8 85       	ldd	r30, Y+8	; 0x08
    5e7c:	f9 85       	ldd	r31, Y+9	; 0x09
    5e7e:	80 85       	ldd	r24, Z+8	; 0x08
    5e80:	91 85       	ldd	r25, Z+9	; 0x09
    5e82:	e8 89       	ldd	r30, Y+16	; 0x10
    5e84:	f9 89       	ldd	r31, Y+17	; 0x11
    5e86:	60 e0       	ldi	r22, 0x00	; 0
    5e88:	20 e0       	ldi	r18, 0x00	; 0
    5e8a:	30 e0       	ldi	r19, 0x00	; 0
    5e8c:	40 e0       	ldi	r20, 0x00	; 0
    5e8e:	50 e0       	ldi	r21, 0x00	; 0
    5e90:	00 e0       	ldi	r16, 0x00	; 0
    5e92:	ee 24       	eor	r14, r14
    5e94:	ff 24       	eor	r15, r15
    5e96:	6f 01       	movw	r12, r30
    5e98:	0e 94 d2 45 	call	0x8ba4	; 0x8ba4 <xTaskGenericNotifyFromISR>
    5e9c:	e8 85       	ldd	r30, Y+8	; 0x08
    5e9e:	f9 85       	ldd	r31, Y+9	; 0x09
    5ea0:	11 86       	std	Z+9, r1	; 0x09
    5ea2:	10 86       	std	Z+8, r1	; 0x08
        mtCOVERAGE_TEST_MARKER();
    }

    traceSTREAM_BUFFER_SEND_FROM_ISR( xStreamBuffer, xReturn );

    return xReturn;
    5ea4:	8e 81       	ldd	r24, Y+6	; 0x06
    5ea6:	9f 81       	ldd	r25, Y+7	; 0x07
}
    5ea8:	61 96       	adiw	r28, 0x11	; 17
    5eaa:	0f b6       	in	r0, 0x3f	; 63
    5eac:	f8 94       	cli
    5eae:	de bf       	out	0x3e, r29	; 62
    5eb0:	0f be       	out	0x3f, r0	; 63
    5eb2:	cd bf       	out	0x3d, r28	; 61
    5eb4:	cf 91       	pop	r28
    5eb6:	df 91       	pop	r29
    5eb8:	1f 91       	pop	r17
    5eba:	0f 91       	pop	r16
    5ebc:	ff 90       	pop	r15
    5ebe:	ef 90       	pop	r14
    5ec0:	df 90       	pop	r13
    5ec2:	cf 90       	pop	r12
    5ec4:	08 95       	ret

00005ec6 <prvWriteMessageToBuffer>:
static size_t prvWriteMessageToBuffer( StreamBuffer_t * const pxStreamBuffer,
                                       const void * pvTxData,
                                       size_t xDataLengthBytes,
                                       size_t xSpace,
                                       size_t xRequiredSpace )
{
    5ec6:	0f 93       	push	r16
    5ec8:	1f 93       	push	r17
    5eca:	df 93       	push	r29
    5ecc:	cf 93       	push	r28
    5ece:	cd b7       	in	r28, 0x3d	; 61
    5ed0:	de b7       	in	r29, 0x3e	; 62
    5ed2:	60 97       	sbiw	r28, 0x10	; 16
    5ed4:	0f b6       	in	r0, 0x3f	; 63
    5ed6:	f8 94       	cli
    5ed8:	de bf       	out	0x3e, r29	; 62
    5eda:	0f be       	out	0x3f, r0	; 63
    5edc:	cd bf       	out	0x3d, r28	; 61
    5ede:	9c 83       	std	Y+4, r25	; 0x04
    5ee0:	8b 83       	std	Y+3, r24	; 0x03
    5ee2:	7e 83       	std	Y+6, r23	; 0x06
    5ee4:	6d 83       	std	Y+5, r22	; 0x05
    5ee6:	58 87       	std	Y+8, r21	; 0x08
    5ee8:	4f 83       	std	Y+7, r20	; 0x07
    5eea:	3a 87       	std	Y+10, r19	; 0x0a
    5eec:	29 87       	std	Y+9, r18	; 0x09
    5eee:	1c 87       	std	Y+12, r17	; 0x0c
    5ef0:	0b 87       	std	Y+11, r16	; 0x0b
    size_t xNextHead = pxStreamBuffer->xHead;
    5ef2:	eb 81       	ldd	r30, Y+3	; 0x03
    5ef4:	fc 81       	ldd	r31, Y+4	; 0x04
    5ef6:	82 81       	ldd	r24, Z+2	; 0x02
    5ef8:	93 81       	ldd	r25, Z+3	; 0x03
    5efa:	9a 83       	std	Y+2, r25	; 0x02
    5efc:	89 83       	std	Y+1, r24	; 0x01

    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    5efe:	eb 81       	ldd	r30, Y+3	; 0x03
    5f00:	fc 81       	ldd	r31, Y+4	; 0x04
    5f02:	86 85       	ldd	r24, Z+14	; 0x0e
    5f04:	88 2f       	mov	r24, r24
    5f06:	90 e0       	ldi	r25, 0x00	; 0
    5f08:	81 70       	andi	r24, 0x01	; 1
    5f0a:	90 70       	andi	r25, 0x00	; 0
    5f0c:	88 23       	and	r24, r24
    5f0e:	d1 f0       	breq	.+52     	; 0x5f44 <prvWriteMessageToBuffer+0x7e>
    {
        /* This is a message buffer, as opposed to a stream buffer. */

        if( xSpace >= xRequiredSpace )
    5f10:	29 85       	ldd	r18, Y+9	; 0x09
    5f12:	3a 85       	ldd	r19, Y+10	; 0x0a
    5f14:	8b 85       	ldd	r24, Y+11	; 0x0b
    5f16:	9c 85       	ldd	r25, Y+12	; 0x0c
    5f18:	28 17       	cp	r18, r24
    5f1a:	39 07       	cpc	r19, r25
    5f1c:	80 f0       	brcs	.+32     	; 0x5f3e <prvWriteMessageToBuffer+0x78>
        {
            /* There is enough space to write both the message length and the message
             * itself into the buffer.  Start by writing the length of the data, the data
             * itself will be written later in this function. */
            xNextHead = prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) &( xDataLengthBytes ), sbBYTES_TO_STORE_MESSAGE_LENGTH, xNextHead );
    5f1e:	9e 01       	movw	r18, r28
    5f20:	29 5f       	subi	r18, 0xF9	; 249
    5f22:	3f 4f       	sbci	r19, 0xFF	; 255
    5f24:	8b 81       	ldd	r24, Y+3	; 0x03
    5f26:	9c 81       	ldd	r25, Y+4	; 0x04
    5f28:	e9 81       	ldd	r30, Y+1	; 0x01
    5f2a:	fa 81       	ldd	r31, Y+2	; 0x02
    5f2c:	b9 01       	movw	r22, r18
    5f2e:	42 e0       	ldi	r20, 0x02	; 2
    5f30:	50 e0       	ldi	r21, 0x00	; 0
    5f32:	9f 01       	movw	r18, r30
    5f34:	0e 94 c8 32 	call	0x6590	; 0x6590 <prvWriteBytesToBuffer>
    5f38:	9a 83       	std	Y+2, r25	; 0x02
    5f3a:	89 83       	std	Y+1, r24	; 0x01
    5f3c:	1a c0       	rjmp	.+52     	; 0x5f72 <prvWriteMessageToBuffer+0xac>
        }
        else
        {
            /* Not enough space, so do not write data to the buffer. */
            xDataLengthBytes = 0;
    5f3e:	18 86       	std	Y+8, r1	; 0x08
    5f40:	1f 82       	std	Y+7, r1	; 0x07
    5f42:	17 c0       	rjmp	.+46     	; 0x5f72 <prvWriteMessageToBuffer+0xac>
    else
    {
        /* This is a stream buffer, as opposed to a message buffer, so writing a
         * stream of bytes rather than discrete messages.  Plan to write as many
         * bytes as possible. */
        xDataLengthBytes = configMIN( xDataLengthBytes, xSpace );
    5f44:	2f 81       	ldd	r18, Y+7	; 0x07
    5f46:	38 85       	ldd	r19, Y+8	; 0x08
    5f48:	38 8b       	std	Y+16, r19	; 0x10
    5f4a:	2f 87       	std	Y+15, r18	; 0x0f
    5f4c:	89 85       	ldd	r24, Y+9	; 0x09
    5f4e:	9a 85       	ldd	r25, Y+10	; 0x0a
    5f50:	9e 87       	std	Y+14, r25	; 0x0e
    5f52:	8d 87       	std	Y+13, r24	; 0x0d
    5f54:	2d 85       	ldd	r18, Y+13	; 0x0d
    5f56:	3e 85       	ldd	r19, Y+14	; 0x0e
    5f58:	8f 85       	ldd	r24, Y+15	; 0x0f
    5f5a:	98 89       	ldd	r25, Y+16	; 0x10
    5f5c:	82 17       	cp	r24, r18
    5f5e:	93 07       	cpc	r25, r19
    5f60:	20 f4       	brcc	.+8      	; 0x5f6a <prvWriteMessageToBuffer+0xa4>
    5f62:	2f 85       	ldd	r18, Y+15	; 0x0f
    5f64:	38 89       	ldd	r19, Y+16	; 0x10
    5f66:	3e 87       	std	Y+14, r19	; 0x0e
    5f68:	2d 87       	std	Y+13, r18	; 0x0d
    5f6a:	8d 85       	ldd	r24, Y+13	; 0x0d
    5f6c:	9e 85       	ldd	r25, Y+14	; 0x0e
    5f6e:	98 87       	std	Y+8, r25	; 0x08
    5f70:	8f 83       	std	Y+7, r24	; 0x07
    }

    if( xDataLengthBytes != ( size_t ) 0 )
    5f72:	8f 81       	ldd	r24, Y+7	; 0x07
    5f74:	98 85       	ldd	r25, Y+8	; 0x08
    5f76:	00 97       	sbiw	r24, 0x00	; 0
    5f78:	81 f0       	breq	.+32     	; 0x5f9a <prvWriteMessageToBuffer+0xd4>
    {
        /* Write the data to the buffer. */
        pxStreamBuffer->xHead = prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) pvTxData, xDataLengthBytes, xNextHead ); /*lint !e9079 Storage buffer is implemented as uint8_t for ease of sizing, alignment and access. */
    5f7a:	4d 81       	ldd	r20, Y+5	; 0x05
    5f7c:	5e 81       	ldd	r21, Y+6	; 0x06
    5f7e:	ef 81       	ldd	r30, Y+7	; 0x07
    5f80:	f8 85       	ldd	r31, Y+8	; 0x08
    5f82:	8b 81       	ldd	r24, Y+3	; 0x03
    5f84:	9c 81       	ldd	r25, Y+4	; 0x04
    5f86:	29 81       	ldd	r18, Y+1	; 0x01
    5f88:	3a 81       	ldd	r19, Y+2	; 0x02
    5f8a:	ba 01       	movw	r22, r20
    5f8c:	af 01       	movw	r20, r30
    5f8e:	0e 94 c8 32 	call	0x6590	; 0x6590 <prvWriteBytesToBuffer>
    5f92:	eb 81       	ldd	r30, Y+3	; 0x03
    5f94:	fc 81       	ldd	r31, Y+4	; 0x04
    5f96:	93 83       	std	Z+3, r25	; 0x03
    5f98:	82 83       	std	Z+2, r24	; 0x02
    }

    return xDataLengthBytes;
    5f9a:	8f 81       	ldd	r24, Y+7	; 0x07
    5f9c:	98 85       	ldd	r25, Y+8	; 0x08
}
    5f9e:	60 96       	adiw	r28, 0x10	; 16
    5fa0:	0f b6       	in	r0, 0x3f	; 63
    5fa2:	f8 94       	cli
    5fa4:	de bf       	out	0x3e, r29	; 62
    5fa6:	0f be       	out	0x3f, r0	; 63
    5fa8:	cd bf       	out	0x3d, r28	; 61
    5faa:	cf 91       	pop	r28
    5fac:	df 91       	pop	r29
    5fae:	1f 91       	pop	r17
    5fb0:	0f 91       	pop	r16
    5fb2:	08 95       	ret

00005fb4 <xStreamBufferReceive>:

size_t xStreamBufferReceive( StreamBufferHandle_t xStreamBuffer,
                             void * pvRxData,
                             size_t xBufferLengthBytes,
                             TickType_t xTicksToWait )
{
    5fb4:	cf 92       	push	r12
    5fb6:	df 92       	push	r13
    5fb8:	ef 92       	push	r14
    5fba:	ff 92       	push	r15
    5fbc:	0f 93       	push	r16
    5fbe:	1f 93       	push	r17
    5fc0:	df 93       	push	r29
    5fc2:	cf 93       	push	r28
    5fc4:	cd b7       	in	r28, 0x3d	; 61
    5fc6:	de b7       	in	r29, 0x3e	; 62
    5fc8:	60 97       	sbiw	r28, 0x10	; 16
    5fca:	0f b6       	in	r0, 0x3f	; 63
    5fcc:	f8 94       	cli
    5fce:	de bf       	out	0x3e, r29	; 62
    5fd0:	0f be       	out	0x3f, r0	; 63
    5fd2:	cd bf       	out	0x3d, r28	; 61
    5fd4:	9a 87       	std	Y+10, r25	; 0x0a
    5fd6:	89 87       	std	Y+9, r24	; 0x09
    5fd8:	7c 87       	std	Y+12, r23	; 0x0c
    5fda:	6b 87       	std	Y+11, r22	; 0x0b
    5fdc:	5e 87       	std	Y+14, r21	; 0x0e
    5fde:	4d 87       	std	Y+13, r20	; 0x0d
    5fe0:	38 8b       	std	Y+16, r19	; 0x10
    5fe2:	2f 87       	std	Y+15, r18	; 0x0f
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    5fe4:	89 85       	ldd	r24, Y+9	; 0x09
    5fe6:	9a 85       	ldd	r25, Y+10	; 0x0a
    5fe8:	98 87       	std	Y+8, r25	; 0x08
    5fea:	8f 83       	std	Y+7, r24	; 0x07
    size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
    5fec:	1e 82       	std	Y+6, r1	; 0x06
    5fee:	1d 82       	std	Y+5, r1	; 0x05
    /* This receive function is used by both message buffers, which store
     * discrete messages, and stream buffers, which store a continuous stream of
     * bytes.  Discrete messages include an additional
     * sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
     * message. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    5ff0:	ef 81       	ldd	r30, Y+7	; 0x07
    5ff2:	f8 85       	ldd	r31, Y+8	; 0x08
    5ff4:	86 85       	ldd	r24, Z+14	; 0x0e
    5ff6:	88 2f       	mov	r24, r24
    5ff8:	90 e0       	ldi	r25, 0x00	; 0
    5ffa:	81 70       	andi	r24, 0x01	; 1
    5ffc:	90 70       	andi	r25, 0x00	; 0
    5ffe:	88 23       	and	r24, r24
    6000:	29 f0       	breq	.+10     	; 0x600c <xStreamBufferReceive+0x58>
    {
        xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    6002:	82 e0       	ldi	r24, 0x02	; 2
    6004:	90 e0       	ldi	r25, 0x00	; 0
    6006:	9a 83       	std	Y+2, r25	; 0x02
    6008:	89 83       	std	Y+1, r24	; 0x01
    600a:	02 c0       	rjmp	.+4      	; 0x6010 <xStreamBufferReceive+0x5c>
    }
    else
    {
        xBytesToStoreMessageLength = 0;
    600c:	1a 82       	std	Y+2, r1	; 0x02
    600e:	19 82       	std	Y+1, r1	; 0x01
    }

    if( xTicksToWait != ( TickType_t ) 0 )
    6010:	8f 85       	ldd	r24, Y+15	; 0x0f
    6012:	98 89       	ldd	r25, Y+16	; 0x10
    6014:	00 97       	sbiw	r24, 0x00	; 0
    6016:	09 f4       	brne	.+2      	; 0x601a <xStreamBufferReceive+0x66>
    6018:	3f c0       	rjmp	.+126    	; 0x6098 <xStreamBufferReceive+0xe4>
    {
        /* Checking if there is data and clearing the notification state must be
         * performed atomically. */
        taskENTER_CRITICAL();
    601a:	0f b6       	in	r0, 0x3f	; 63
    601c:	f8 94       	cli
    601e:	0f 92       	push	r0
        {
            xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    6020:	8f 81       	ldd	r24, Y+7	; 0x07
    6022:	98 85       	ldd	r25, Y+8	; 0x08
    6024:	0e 94 d0 33 	call	0x67a0	; 0x67a0 <prvBytesInBuffer>
    6028:	9c 83       	std	Y+4, r25	; 0x04
    602a:	8b 83       	std	Y+3, r24	; 0x03
            /* If this function was invoked by a message buffer read then
             * xBytesToStoreMessageLength holds the number of bytes used to hold
             * the length of the next discrete message.  If this function was
             * invoked by a stream buffer read then xBytesToStoreMessageLength will
             * be 0. */
            if( xBytesAvailable <= xBytesToStoreMessageLength )
    602c:	2b 81       	ldd	r18, Y+3	; 0x03
    602e:	3c 81       	ldd	r19, Y+4	; 0x04
    6030:	89 81       	ldd	r24, Y+1	; 0x01
    6032:	9a 81       	ldd	r25, Y+2	; 0x02
    6034:	82 17       	cp	r24, r18
    6036:	93 07       	cpc	r25, r19
    6038:	58 f0       	brcs	.+22     	; 0x6050 <xStreamBufferReceive+0x9c>
            {
                /* Clear notification state as going to wait for data. */
                ( void ) xTaskNotifyStateClear( NULL );
    603a:	80 e0       	ldi	r24, 0x00	; 0
    603c:	90 e0       	ldi	r25, 0x00	; 0
    603e:	60 e0       	ldi	r22, 0x00	; 0
    6040:	0e 94 21 49 	call	0x9242	; 0x9242 <xTaskGenericNotifyStateClear>

                /* Should only be one reader. */
                configASSERT( pxStreamBuffer->xTaskWaitingToReceive == NULL );
                pxStreamBuffer->xTaskWaitingToReceive = xTaskGetCurrentTaskHandle();
    6044:	0e 94 a1 3f 	call	0x7f42	; 0x7f42 <xTaskGetCurrentTaskHandle>
    6048:	ef 81       	ldd	r30, Y+7	; 0x07
    604a:	f8 85       	ldd	r31, Y+8	; 0x08
    604c:	91 87       	std	Z+9, r25	; 0x09
    604e:	80 87       	std	Z+8, r24	; 0x08
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    6050:	0f 90       	pop	r0
    6052:	0f be       	out	0x3f, r0	; 63

        if( xBytesAvailable <= xBytesToStoreMessageLength )
    6054:	2b 81       	ldd	r18, Y+3	; 0x03
    6056:	3c 81       	ldd	r19, Y+4	; 0x04
    6058:	89 81       	ldd	r24, Y+1	; 0x01
    605a:	9a 81       	ldd	r25, Y+2	; 0x02
    605c:	82 17       	cp	r24, r18
    605e:	93 07       	cpc	r25, r19
    6060:	08 f1       	brcs	.+66     	; 0x60a4 <xStreamBufferReceive+0xf0>
        {
            /* Wait for data to be available. */
            traceBLOCKING_ON_STREAM_BUFFER_RECEIVE( xStreamBuffer );
            ( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
    6062:	ef 85       	ldd	r30, Y+15	; 0x0f
    6064:	f8 89       	ldd	r31, Y+16	; 0x10
    6066:	80 e0       	ldi	r24, 0x00	; 0
    6068:	40 e0       	ldi	r20, 0x00	; 0
    606a:	50 e0       	ldi	r21, 0x00	; 0
    606c:	60 e0       	ldi	r22, 0x00	; 0
    606e:	70 e0       	ldi	r23, 0x00	; 0
    6070:	00 e0       	ldi	r16, 0x00	; 0
    6072:	10 e0       	ldi	r17, 0x00	; 0
    6074:	20 e0       	ldi	r18, 0x00	; 0
    6076:	30 e0       	ldi	r19, 0x00	; 0
    6078:	ee 24       	eor	r14, r14
    607a:	ff 24       	eor	r15, r15
    607c:	6f 01       	movw	r12, r30
    607e:	0e 94 1d 43 	call	0x863a	; 0x863a <xTaskGenericNotifyWait>
            pxStreamBuffer->xTaskWaitingToReceive = NULL;
    6082:	ef 81       	ldd	r30, Y+7	; 0x07
    6084:	f8 85       	ldd	r31, Y+8	; 0x08
    6086:	11 86       	std	Z+9, r1	; 0x09
    6088:	10 86       	std	Z+8, r1	; 0x08

            /* Recheck the data available after blocking. */
            xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    608a:	8f 81       	ldd	r24, Y+7	; 0x07
    608c:	98 85       	ldd	r25, Y+8	; 0x08
    608e:	0e 94 d0 33 	call	0x67a0	; 0x67a0 <prvBytesInBuffer>
    6092:	9c 83       	std	Y+4, r25	; 0x04
    6094:	8b 83       	std	Y+3, r24	; 0x03
    6096:	06 c0       	rjmp	.+12     	; 0x60a4 <xStreamBufferReceive+0xf0>
            mtCOVERAGE_TEST_MARKER();
        }
    }
    else
    {
        xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    6098:	8f 81       	ldd	r24, Y+7	; 0x07
    609a:	98 85       	ldd	r25, Y+8	; 0x08
    609c:	0e 94 d0 33 	call	0x67a0	; 0x67a0 <prvBytesInBuffer>
    60a0:	9c 83       	std	Y+4, r25	; 0x04
    60a2:	8b 83       	std	Y+3, r24	; 0x03
    /* Whether receiving a discrete message (where xBytesToStoreMessageLength
     * holds the number of bytes used to store the message length) or a stream of
     * bytes (where xBytesToStoreMessageLength is zero), the number of bytes
     * available must be greater than xBytesToStoreMessageLength to be able to
     * read bytes from the buffer. */
    if( xBytesAvailable > xBytesToStoreMessageLength )
    60a4:	2b 81       	ldd	r18, Y+3	; 0x03
    60a6:	3c 81       	ldd	r19, Y+4	; 0x04
    60a8:	89 81       	ldd	r24, Y+1	; 0x01
    60aa:	9a 81       	ldd	r25, Y+2	; 0x02
    60ac:	82 17       	cp	r24, r18
    60ae:	93 07       	cpc	r25, r19
    60b0:	70 f5       	brcc	.+92     	; 0x610e <xStreamBufferReceive+0x15a>
    {
        xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable );
    60b2:	8f 81       	ldd	r24, Y+7	; 0x07
    60b4:	98 85       	ldd	r25, Y+8	; 0x08
    60b6:	2b 85       	ldd	r18, Y+11	; 0x0b
    60b8:	3c 85       	ldd	r19, Y+12	; 0x0c
    60ba:	4d 85       	ldd	r20, Y+13	; 0x0d
    60bc:	5e 85       	ldd	r21, Y+14	; 0x0e
    60be:	eb 81       	ldd	r30, Y+3	; 0x03
    60c0:	fc 81       	ldd	r31, Y+4	; 0x04
    60c2:	b9 01       	movw	r22, r18
    60c4:	9f 01       	movw	r18, r30
    60c6:	0e 94 59 31 	call	0x62b2	; 0x62b2 <prvReadMessageFromBuffer>
    60ca:	9e 83       	std	Y+6, r25	; 0x06
    60cc:	8d 83       	std	Y+5, r24	; 0x05

        /* Was a task waiting for space in the buffer? */
        if( xReceivedLength != ( size_t ) 0 )
    60ce:	8d 81       	ldd	r24, Y+5	; 0x05
    60d0:	9e 81       	ldd	r25, Y+6	; 0x06
    60d2:	00 97       	sbiw	r24, 0x00	; 0
    60d4:	e1 f0       	breq	.+56     	; 0x610e <xStreamBufferReceive+0x15a>
        {
            traceSTREAM_BUFFER_RECEIVE( xStreamBuffer, xReceivedLength );
            sbRECEIVE_COMPLETED( pxStreamBuffer );
    60d6:	0e 94 8f 37 	call	0x6f1e	; 0x6f1e <vTaskSuspendAll>
    60da:	ef 81       	ldd	r30, Y+7	; 0x07
    60dc:	f8 85       	ldd	r31, Y+8	; 0x08
    60de:	82 85       	ldd	r24, Z+10	; 0x0a
    60e0:	93 85       	ldd	r25, Z+11	; 0x0b
    60e2:	00 97       	sbiw	r24, 0x00	; 0
    60e4:	91 f0       	breq	.+36     	; 0x610a <xStreamBufferReceive+0x156>
    60e6:	ef 81       	ldd	r30, Y+7	; 0x07
    60e8:	f8 85       	ldd	r31, Y+8	; 0x08
    60ea:	82 85       	ldd	r24, Z+10	; 0x0a
    60ec:	93 85       	ldd	r25, Z+11	; 0x0b
    60ee:	60 e0       	ldi	r22, 0x00	; 0
    60f0:	20 e0       	ldi	r18, 0x00	; 0
    60f2:	30 e0       	ldi	r19, 0x00	; 0
    60f4:	40 e0       	ldi	r20, 0x00	; 0
    60f6:	50 e0       	ldi	r21, 0x00	; 0
    60f8:	00 e0       	ldi	r16, 0x00	; 0
    60fa:	ee 24       	eor	r14, r14
    60fc:	ff 24       	eor	r15, r15
    60fe:	0e 94 14 44 	call	0x8828	; 0x8828 <xTaskGenericNotify>
    6102:	ef 81       	ldd	r30, Y+7	; 0x07
    6104:	f8 85       	ldd	r31, Y+8	; 0x08
    6106:	13 86       	std	Z+11, r1	; 0x0b
    6108:	12 86       	std	Z+10, r1	; 0x0a
    610a:	0e 94 9b 37 	call	0x6f36	; 0x6f36 <xTaskResumeAll>
    {
        traceSTREAM_BUFFER_RECEIVE_FAILED( xStreamBuffer );
        mtCOVERAGE_TEST_MARKER();
    }

    return xReceivedLength;
    610e:	8d 81       	ldd	r24, Y+5	; 0x05
    6110:	9e 81       	ldd	r25, Y+6	; 0x06
}
    6112:	60 96       	adiw	r28, 0x10	; 16
    6114:	0f b6       	in	r0, 0x3f	; 63
    6116:	f8 94       	cli
    6118:	de bf       	out	0x3e, r29	; 62
    611a:	0f be       	out	0x3f, r0	; 63
    611c:	cd bf       	out	0x3d, r28	; 61
    611e:	cf 91       	pop	r28
    6120:	df 91       	pop	r29
    6122:	1f 91       	pop	r17
    6124:	0f 91       	pop	r16
    6126:	ff 90       	pop	r15
    6128:	ef 90       	pop	r14
    612a:	df 90       	pop	r13
    612c:	cf 90       	pop	r12
    612e:	08 95       	ret

00006130 <xStreamBufferNextMessageLengthBytes>:
/*-----------------------------------------------------------*/

size_t xStreamBufferNextMessageLengthBytes( StreamBufferHandle_t xStreamBuffer )
{
    6130:	df 93       	push	r29
    6132:	cf 93       	push	r28
    6134:	cd b7       	in	r28, 0x3d	; 61
    6136:	de b7       	in	r29, 0x3e	; 62
    6138:	2a 97       	sbiw	r28, 0x0a	; 10
    613a:	0f b6       	in	r0, 0x3f	; 63
    613c:	f8 94       	cli
    613e:	de bf       	out	0x3e, r29	; 62
    6140:	0f be       	out	0x3f, r0	; 63
    6142:	cd bf       	out	0x3d, r28	; 61
    6144:	9a 87       	std	Y+10, r25	; 0x0a
    6146:	89 87       	std	Y+9, r24	; 0x09
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    6148:	89 85       	ldd	r24, Y+9	; 0x09
    614a:	9a 85       	ldd	r25, Y+10	; 0x0a
    614c:	9e 83       	std	Y+6, r25	; 0x06
    614e:	8d 83       	std	Y+5, r24	; 0x05
    configMESSAGE_BUFFER_LENGTH_TYPE xTempReturn;

    configASSERT( pxStreamBuffer );

    /* Ensure the stream buffer is being used as a message buffer. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    6150:	ed 81       	ldd	r30, Y+5	; 0x05
    6152:	fe 81       	ldd	r31, Y+6	; 0x06
    6154:	86 85       	ldd	r24, Z+14	; 0x0e
    6156:	88 2f       	mov	r24, r24
    6158:	90 e0       	ldi	r25, 0x00	; 0
    615a:	81 70       	andi	r24, 0x01	; 1
    615c:	90 70       	andi	r25, 0x00	; 0
    615e:	88 23       	and	r24, r24
    6160:	19 f1       	breq	.+70     	; 0x61a8 <xStreamBufferNextMessageLengthBytes+0x78>
    {
        xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    6162:	8d 81       	ldd	r24, Y+5	; 0x05
    6164:	9e 81       	ldd	r25, Y+6	; 0x06
    6166:	0e 94 d0 33 	call	0x67a0	; 0x67a0 <prvBytesInBuffer>
    616a:	9a 83       	std	Y+2, r25	; 0x02
    616c:	89 83       	std	Y+1, r24	; 0x01

        if( xBytesAvailable > sbBYTES_TO_STORE_MESSAGE_LENGTH )
    616e:	89 81       	ldd	r24, Y+1	; 0x01
    6170:	9a 81       	ldd	r25, Y+2	; 0x02
    6172:	83 30       	cpi	r24, 0x03	; 3
    6174:	91 05       	cpc	r25, r1
    6176:	a8 f0       	brcs	.+42     	; 0x61a2 <xStreamBufferNextMessageLengthBytes+0x72>
        {
            /* The number of bytes available is greater than the number of bytes
             * required to hold the length of the next message, so another message
             * is available. */
             ( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempReturn, sbBYTES_TO_STORE_MESSAGE_LENGTH, pxStreamBuffer->xTail );
    6178:	9e 01       	movw	r18, r28
    617a:	29 5f       	subi	r18, 0xF9	; 249
    617c:	3f 4f       	sbci	r19, 0xFF	; 255
    617e:	ed 81       	ldd	r30, Y+5	; 0x05
    6180:	fe 81       	ldd	r31, Y+6	; 0x06
    6182:	01 90       	ld	r0, Z+
    6184:	f0 81       	ld	r31, Z
    6186:	e0 2d       	mov	r30, r0
    6188:	8d 81       	ldd	r24, Y+5	; 0x05
    618a:	9e 81       	ldd	r25, Y+6	; 0x06
    618c:	b9 01       	movw	r22, r18
    618e:	42 e0       	ldi	r20, 0x02	; 2
    6190:	50 e0       	ldi	r21, 0x00	; 0
    6192:	9f 01       	movw	r18, r30
    6194:	0e 94 4b 33 	call	0x6696	; 0x6696 <prvReadBytesFromBuffer>
             xReturn = ( size_t ) xTempReturn;
    6198:	8f 81       	ldd	r24, Y+7	; 0x07
    619a:	98 85       	ldd	r25, Y+8	; 0x08
    619c:	9c 83       	std	Y+4, r25	; 0x04
    619e:	8b 83       	std	Y+3, r24	; 0x03
    61a0:	05 c0       	rjmp	.+10     	; 0x61ac <xStreamBufferNextMessageLengthBytes+0x7c>
            /* The minimum amount of bytes in a message buffer is
             * ( sbBYTES_TO_STORE_MESSAGE_LENGTH + 1 ), so if xBytesAvailable is
             * less than sbBYTES_TO_STORE_MESSAGE_LENGTH the only other valid
             * value is 0. */
            configASSERT( xBytesAvailable == 0 );
            xReturn = 0;
    61a2:	1c 82       	std	Y+4, r1	; 0x04
    61a4:	1b 82       	std	Y+3, r1	; 0x03
    61a6:	02 c0       	rjmp	.+4      	; 0x61ac <xStreamBufferNextMessageLengthBytes+0x7c>
        }
    }
    else
    {
        xReturn = 0;
    61a8:	1c 82       	std	Y+4, r1	; 0x04
    61aa:	1b 82       	std	Y+3, r1	; 0x03
    }

    return xReturn;
    61ac:	8b 81       	ldd	r24, Y+3	; 0x03
    61ae:	9c 81       	ldd	r25, Y+4	; 0x04
}
    61b0:	2a 96       	adiw	r28, 0x0a	; 10
    61b2:	0f b6       	in	r0, 0x3f	; 63
    61b4:	f8 94       	cli
    61b6:	de bf       	out	0x3e, r29	; 62
    61b8:	0f be       	out	0x3f, r0	; 63
    61ba:	cd bf       	out	0x3d, r28	; 61
    61bc:	cf 91       	pop	r28
    61be:	df 91       	pop	r29
    61c0:	08 95       	ret

000061c2 <xStreamBufferReceiveFromISR>:

size_t xStreamBufferReceiveFromISR( StreamBufferHandle_t xStreamBuffer,
                                    void * pvRxData,
                                    size_t xBufferLengthBytes,
                                    BaseType_t * const pxHigherPriorityTaskWoken )
{
    61c2:	cf 92       	push	r12
    61c4:	df 92       	push	r13
    61c6:	ef 92       	push	r14
    61c8:	ff 92       	push	r15
    61ca:	0f 93       	push	r16
    61cc:	df 93       	push	r29
    61ce:	cf 93       	push	r28
    61d0:	cd b7       	in	r28, 0x3d	; 61
    61d2:	de b7       	in	r29, 0x3e	; 62
    61d4:	61 97       	sbiw	r28, 0x11	; 17
    61d6:	0f b6       	in	r0, 0x3f	; 63
    61d8:	f8 94       	cli
    61da:	de bf       	out	0x3e, r29	; 62
    61dc:	0f be       	out	0x3f, r0	; 63
    61de:	cd bf       	out	0x3d, r28	; 61
    61e0:	9b 87       	std	Y+11, r25	; 0x0b
    61e2:	8a 87       	std	Y+10, r24	; 0x0a
    61e4:	7d 87       	std	Y+13, r23	; 0x0d
    61e6:	6c 87       	std	Y+12, r22	; 0x0c
    61e8:	5f 87       	std	Y+15, r21	; 0x0f
    61ea:	4e 87       	std	Y+14, r20	; 0x0e
    61ec:	39 8b       	std	Y+17, r19	; 0x11
    61ee:	28 8b       	std	Y+16, r18	; 0x10
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    61f0:	8a 85       	ldd	r24, Y+10	; 0x0a
    61f2:	9b 85       	ldd	r25, Y+11	; 0x0b
    61f4:	99 87       	std	Y+9, r25	; 0x09
    61f6:	88 87       	std	Y+8, r24	; 0x08
    size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
    61f8:	1f 82       	std	Y+7, r1	; 0x07
    61fa:	1e 82       	std	Y+6, r1	; 0x06
    /* This receive function is used by both message buffers, which store
     * discrete messages, and stream buffers, which store a continuous stream of
     * bytes.  Discrete messages include an additional
     * sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
     * message. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    61fc:	e8 85       	ldd	r30, Y+8	; 0x08
    61fe:	f9 85       	ldd	r31, Y+9	; 0x09
    6200:	86 85       	ldd	r24, Z+14	; 0x0e
    6202:	88 2f       	mov	r24, r24
    6204:	90 e0       	ldi	r25, 0x00	; 0
    6206:	81 70       	andi	r24, 0x01	; 1
    6208:	90 70       	andi	r25, 0x00	; 0
    620a:	88 23       	and	r24, r24
    620c:	29 f0       	breq	.+10     	; 0x6218 <xStreamBufferReceiveFromISR+0x56>
    {
        xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    620e:	82 e0       	ldi	r24, 0x02	; 2
    6210:	90 e0       	ldi	r25, 0x00	; 0
    6212:	9b 83       	std	Y+3, r25	; 0x03
    6214:	8a 83       	std	Y+2, r24	; 0x02
    6216:	02 c0       	rjmp	.+4      	; 0x621c <xStreamBufferReceiveFromISR+0x5a>
    }
    else
    {
        xBytesToStoreMessageLength = 0;
    6218:	1b 82       	std	Y+3, r1	; 0x03
    621a:	1a 82       	std	Y+2, r1	; 0x02
    }

    xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    621c:	88 85       	ldd	r24, Y+8	; 0x08
    621e:	99 85       	ldd	r25, Y+9	; 0x09
    6220:	0e 94 d0 33 	call	0x67a0	; 0x67a0 <prvBytesInBuffer>
    6224:	9d 83       	std	Y+5, r25	; 0x05
    6226:	8c 83       	std	Y+4, r24	; 0x04
    /* Whether receiving a discrete message (where xBytesToStoreMessageLength
     * holds the number of bytes used to store the message length) or a stream of
     * bytes (where xBytesToStoreMessageLength is zero), the number of bytes
     * available must be greater than xBytesToStoreMessageLength to be able to
     * read bytes from the buffer. */
    if( xBytesAvailable > xBytesToStoreMessageLength )
    6228:	2c 81       	ldd	r18, Y+4	; 0x04
    622a:	3d 81       	ldd	r19, Y+5	; 0x05
    622c:	8a 81       	ldd	r24, Y+2	; 0x02
    622e:	9b 81       	ldd	r25, Y+3	; 0x03
    6230:	82 17       	cp	r24, r18
    6232:	93 07       	cpc	r25, r19
    6234:	70 f5       	brcc	.+92     	; 0x6292 <xStreamBufferReceiveFromISR+0xd0>
    {
        xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable );
    6236:	88 85       	ldd	r24, Y+8	; 0x08
    6238:	99 85       	ldd	r25, Y+9	; 0x09
    623a:	2c 85       	ldd	r18, Y+12	; 0x0c
    623c:	3d 85       	ldd	r19, Y+13	; 0x0d
    623e:	4e 85       	ldd	r20, Y+14	; 0x0e
    6240:	5f 85       	ldd	r21, Y+15	; 0x0f
    6242:	ec 81       	ldd	r30, Y+4	; 0x04
    6244:	fd 81       	ldd	r31, Y+5	; 0x05
    6246:	b9 01       	movw	r22, r18
    6248:	9f 01       	movw	r18, r30
    624a:	0e 94 59 31 	call	0x62b2	; 0x62b2 <prvReadMessageFromBuffer>
    624e:	9f 83       	std	Y+7, r25	; 0x07
    6250:	8e 83       	std	Y+6, r24	; 0x06

        /* Was a task waiting for space in the buffer? */
        if( xReceivedLength != ( size_t ) 0 )
    6252:	8e 81       	ldd	r24, Y+6	; 0x06
    6254:	9f 81       	ldd	r25, Y+7	; 0x07
    6256:	00 97       	sbiw	r24, 0x00	; 0
    6258:	e1 f0       	breq	.+56     	; 0x6292 <xStreamBufferReceiveFromISR+0xd0>
        {
            sbRECEIVE_COMPLETED_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
    625a:	19 82       	std	Y+1, r1	; 0x01
    625c:	e8 85       	ldd	r30, Y+8	; 0x08
    625e:	f9 85       	ldd	r31, Y+9	; 0x09
    6260:	82 85       	ldd	r24, Z+10	; 0x0a
    6262:	93 85       	ldd	r25, Z+11	; 0x0b
    6264:	00 97       	sbiw	r24, 0x00	; 0
    6266:	a9 f0       	breq	.+42     	; 0x6292 <xStreamBufferReceiveFromISR+0xd0>
    6268:	e8 85       	ldd	r30, Y+8	; 0x08
    626a:	f9 85       	ldd	r31, Y+9	; 0x09
    626c:	82 85       	ldd	r24, Z+10	; 0x0a
    626e:	93 85       	ldd	r25, Z+11	; 0x0b
    6270:	e8 89       	ldd	r30, Y+16	; 0x10
    6272:	f9 89       	ldd	r31, Y+17	; 0x11
    6274:	60 e0       	ldi	r22, 0x00	; 0
    6276:	20 e0       	ldi	r18, 0x00	; 0
    6278:	30 e0       	ldi	r19, 0x00	; 0
    627a:	40 e0       	ldi	r20, 0x00	; 0
    627c:	50 e0       	ldi	r21, 0x00	; 0
    627e:	00 e0       	ldi	r16, 0x00	; 0
    6280:	ee 24       	eor	r14, r14
    6282:	ff 24       	eor	r15, r15
    6284:	6f 01       	movw	r12, r30
    6286:	0e 94 d2 45 	call	0x8ba4	; 0x8ba4 <xTaskGenericNotifyFromISR>
    628a:	e8 85       	ldd	r30, Y+8	; 0x08
    628c:	f9 85       	ldd	r31, Y+9	; 0x09
    628e:	13 86       	std	Z+11, r1	; 0x0b
    6290:	12 86       	std	Z+10, r1	; 0x0a
        mtCOVERAGE_TEST_MARKER();
    }

    traceSTREAM_BUFFER_RECEIVE_FROM_ISR( xStreamBuffer, xReceivedLength );

    return xReceivedLength;
    6292:	8e 81       	ldd	r24, Y+6	; 0x06
    6294:	9f 81       	ldd	r25, Y+7	; 0x07
}
    6296:	61 96       	adiw	r28, 0x11	; 17
    6298:	0f b6       	in	r0, 0x3f	; 63
    629a:	f8 94       	cli
    629c:	de bf       	out	0x3e, r29	; 62
    629e:	0f be       	out	0x3f, r0	; 63
    62a0:	cd bf       	out	0x3d, r28	; 61
    62a2:	cf 91       	pop	r28
    62a4:	df 91       	pop	r29
    62a6:	0f 91       	pop	r16
    62a8:	ff 90       	pop	r15
    62aa:	ef 90       	pop	r14
    62ac:	df 90       	pop	r13
    62ae:	cf 90       	pop	r12
    62b0:	08 95       	ret

000062b2 <prvReadMessageFromBuffer>:

static size_t prvReadMessageFromBuffer( StreamBuffer_t * pxStreamBuffer,
                                        void * pvRxData,
                                        size_t xBufferLengthBytes,
                                        size_t xBytesAvailable )
{
    62b2:	df 93       	push	r29
    62b4:	cf 93       	push	r28
    62b6:	cd b7       	in	r28, 0x3d	; 61
    62b8:	de b7       	in	r29, 0x3e	; 62
    62ba:	64 97       	sbiw	r28, 0x14	; 20
    62bc:	0f b6       	in	r0, 0x3f	; 63
    62be:	f8 94       	cli
    62c0:	de bf       	out	0x3e, r29	; 62
    62c2:	0f be       	out	0x3f, r0	; 63
    62c4:	cd bf       	out	0x3d, r28	; 61
    62c6:	9a 87       	std	Y+10, r25	; 0x0a
    62c8:	89 87       	std	Y+9, r24	; 0x09
    62ca:	7c 87       	std	Y+12, r23	; 0x0c
    62cc:	6b 87       	std	Y+11, r22	; 0x0b
    62ce:	5e 87       	std	Y+14, r21	; 0x0e
    62d0:	4d 87       	std	Y+13, r20	; 0x0d
    62d2:	38 8b       	std	Y+16, r19	; 0x10
    62d4:	2f 87       	std	Y+15, r18	; 0x0f
    size_t xCount, xNextMessageLength;
    configMESSAGE_BUFFER_LENGTH_TYPE xTempNextMessageLength;
    size_t xNextTail = pxStreamBuffer->xTail;
    62d6:	e9 85       	ldd	r30, Y+9	; 0x09
    62d8:	fa 85       	ldd	r31, Y+10	; 0x0a
    62da:	80 81       	ld	r24, Z
    62dc:	91 81       	ldd	r25, Z+1	; 0x01
    62de:	9a 83       	std	Y+2, r25	; 0x02
    62e0:	89 83       	std	Y+1, r24	; 0x01

    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    62e2:	e9 85       	ldd	r30, Y+9	; 0x09
    62e4:	fa 85       	ldd	r31, Y+10	; 0x0a
    62e6:	86 85       	ldd	r24, Z+14	; 0x0e
    62e8:	88 2f       	mov	r24, r24
    62ea:	90 e0       	ldi	r25, 0x00	; 0
    62ec:	81 70       	andi	r24, 0x01	; 1
    62ee:	90 70       	andi	r25, 0x00	; 0
    62f0:	88 23       	and	r24, r24
    62f2:	11 f1       	breq	.+68     	; 0x6338 <prvReadMessageFromBuffer+0x86>
    {
        /* A discrete message is being received.  First receive the length
         * of the message. */
        xNextTail = prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempNextMessageLength, sbBYTES_TO_STORE_MESSAGE_LENGTH, xNextTail );
    62f4:	9e 01       	movw	r18, r28
    62f6:	29 5f       	subi	r18, 0xF9	; 249
    62f8:	3f 4f       	sbci	r19, 0xFF	; 255
    62fa:	89 85       	ldd	r24, Y+9	; 0x09
    62fc:	9a 85       	ldd	r25, Y+10	; 0x0a
    62fe:	e9 81       	ldd	r30, Y+1	; 0x01
    6300:	fa 81       	ldd	r31, Y+2	; 0x02
    6302:	b9 01       	movw	r22, r18
    6304:	42 e0       	ldi	r20, 0x02	; 2
    6306:	50 e0       	ldi	r21, 0x00	; 0
    6308:	9f 01       	movw	r18, r30
    630a:	0e 94 4b 33 	call	0x6696	; 0x6696 <prvReadBytesFromBuffer>
    630e:	9a 83       	std	Y+2, r25	; 0x02
    6310:	89 83       	std	Y+1, r24	; 0x01
        xNextMessageLength = ( size_t ) xTempNextMessageLength;
    6312:	8f 81       	ldd	r24, Y+7	; 0x07
    6314:	98 85       	ldd	r25, Y+8	; 0x08
    6316:	9c 83       	std	Y+4, r25	; 0x04
    6318:	8b 83       	std	Y+3, r24	; 0x03

        /* Reduce the number of bytes available by the number of bytes just
         * read out. */
        xBytesAvailable -= sbBYTES_TO_STORE_MESSAGE_LENGTH;
    631a:	8f 85       	ldd	r24, Y+15	; 0x0f
    631c:	98 89       	ldd	r25, Y+16	; 0x10
    631e:	02 97       	sbiw	r24, 0x02	; 2
    6320:	98 8b       	std	Y+16, r25	; 0x10
    6322:	8f 87       	std	Y+15, r24	; 0x0f

        /* Check there is enough space in the buffer provided by the
         * user. */
        if( xNextMessageLength > xBufferLengthBytes )
    6324:	2b 81       	ldd	r18, Y+3	; 0x03
    6326:	3c 81       	ldd	r19, Y+4	; 0x04
    6328:	8d 85       	ldd	r24, Y+13	; 0x0d
    632a:	9e 85       	ldd	r25, Y+14	; 0x0e
    632c:	82 17       	cp	r24, r18
    632e:	93 07       	cpc	r25, r19
    6330:	38 f4       	brcc	.+14     	; 0x6340 <prvReadMessageFromBuffer+0x8e>
        {
            /* The user has provided insufficient space to read the message. */
            xNextMessageLength = 0;
    6332:	1c 82       	std	Y+4, r1	; 0x04
    6334:	1b 82       	std	Y+3, r1	; 0x03
    6336:	04 c0       	rjmp	.+8      	; 0x6340 <prvReadMessageFromBuffer+0x8e>
    }
    else
    {
        /* A stream of bytes is being received (as opposed to a discrete
         * message), so read as many bytes as possible. */
        xNextMessageLength = xBufferLengthBytes;
    6338:	8d 85       	ldd	r24, Y+13	; 0x0d
    633a:	9e 85       	ldd	r25, Y+14	; 0x0e
    633c:	9c 83       	std	Y+4, r25	; 0x04
    633e:	8b 83       	std	Y+3, r24	; 0x03
    }

    /* Use the minimum of the wanted bytes and the available bytes. */
    xCount = configMIN( xNextMessageLength, xBytesAvailable );
    6340:	2b 81       	ldd	r18, Y+3	; 0x03
    6342:	3c 81       	ldd	r19, Y+4	; 0x04
    6344:	3c 8b       	std	Y+20, r19	; 0x14
    6346:	2b 8b       	std	Y+19, r18	; 0x13
    6348:	8f 85       	ldd	r24, Y+15	; 0x0f
    634a:	98 89       	ldd	r25, Y+16	; 0x10
    634c:	9a 8b       	std	Y+18, r25	; 0x12
    634e:	89 8b       	std	Y+17, r24	; 0x11
    6350:	29 89       	ldd	r18, Y+17	; 0x11
    6352:	3a 89       	ldd	r19, Y+18	; 0x12
    6354:	8b 89       	ldd	r24, Y+19	; 0x13
    6356:	9c 89       	ldd	r25, Y+20	; 0x14
    6358:	82 17       	cp	r24, r18
    635a:	93 07       	cpc	r25, r19
    635c:	20 f4       	brcc	.+8      	; 0x6366 <prvReadMessageFromBuffer+0xb4>
    635e:	2b 89       	ldd	r18, Y+19	; 0x13
    6360:	3c 89       	ldd	r19, Y+20	; 0x14
    6362:	3a 8b       	std	Y+18, r19	; 0x12
    6364:	29 8b       	std	Y+17, r18	; 0x11
    6366:	89 89       	ldd	r24, Y+17	; 0x11
    6368:	9a 89       	ldd	r25, Y+18	; 0x12
    636a:	9e 83       	std	Y+6, r25	; 0x06
    636c:	8d 83       	std	Y+5, r24	; 0x05

    if( xCount != ( size_t ) 0 )
    636e:	8d 81       	ldd	r24, Y+5	; 0x05
    6370:	9e 81       	ldd	r25, Y+6	; 0x06
    6372:	00 97       	sbiw	r24, 0x00	; 0
    6374:	89 f0       	breq	.+34     	; 0x6398 <prvReadMessageFromBuffer+0xe6>
    {
        /* Read the actual data and update the tail to mark the data as officially consumed. */
        pxStreamBuffer->xTail = prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) pvRxData, xCount, xNextTail); /*lint !e9079 Data storage area is implemented as uint8_t array for ease of sizing, indexing and alignment. */
    6376:	4b 85       	ldd	r20, Y+11	; 0x0b
    6378:	5c 85       	ldd	r21, Y+12	; 0x0c
    637a:	89 85       	ldd	r24, Y+9	; 0x09
    637c:	9a 85       	ldd	r25, Y+10	; 0x0a
    637e:	2d 81       	ldd	r18, Y+5	; 0x05
    6380:	3e 81       	ldd	r19, Y+6	; 0x06
    6382:	e9 81       	ldd	r30, Y+1	; 0x01
    6384:	fa 81       	ldd	r31, Y+2	; 0x02
    6386:	ba 01       	movw	r22, r20
    6388:	a9 01       	movw	r20, r18
    638a:	9f 01       	movw	r18, r30
    638c:	0e 94 4b 33 	call	0x6696	; 0x6696 <prvReadBytesFromBuffer>
    6390:	e9 85       	ldd	r30, Y+9	; 0x09
    6392:	fa 85       	ldd	r31, Y+10	; 0x0a
    6394:	91 83       	std	Z+1, r25	; 0x01
    6396:	80 83       	st	Z, r24
    }

    return xCount;
    6398:	8d 81       	ldd	r24, Y+5	; 0x05
    639a:	9e 81       	ldd	r25, Y+6	; 0x06
}
    639c:	64 96       	adiw	r28, 0x14	; 20
    639e:	0f b6       	in	r0, 0x3f	; 63
    63a0:	f8 94       	cli
    63a2:	de bf       	out	0x3e, r29	; 62
    63a4:	0f be       	out	0x3f, r0	; 63
    63a6:	cd bf       	out	0x3d, r28	; 61
    63a8:	cf 91       	pop	r28
    63aa:	df 91       	pop	r29
    63ac:	08 95       	ret

000063ae <xStreamBufferIsEmpty>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferIsEmpty( StreamBufferHandle_t xStreamBuffer )
{
    63ae:	df 93       	push	r29
    63b0:	cf 93       	push	r28
    63b2:	cd b7       	in	r28, 0x3d	; 61
    63b4:	de b7       	in	r29, 0x3e	; 62
    63b6:	27 97       	sbiw	r28, 0x07	; 7
    63b8:	0f b6       	in	r0, 0x3f	; 63
    63ba:	f8 94       	cli
    63bc:	de bf       	out	0x3e, r29	; 62
    63be:	0f be       	out	0x3f, r0	; 63
    63c0:	cd bf       	out	0x3d, r28	; 61
    63c2:	9f 83       	std	Y+7, r25	; 0x07
    63c4:	8e 83       	std	Y+6, r24	; 0x06
    const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    63c6:	8e 81       	ldd	r24, Y+6	; 0x06
    63c8:	9f 81       	ldd	r25, Y+7	; 0x07
    63ca:	9d 83       	std	Y+5, r25	; 0x05
    63cc:	8c 83       	std	Y+4, r24	; 0x04
    size_t xTail;

    configASSERT( pxStreamBuffer );

    /* True if no bytes are available. */
    xTail = pxStreamBuffer->xTail;
    63ce:	ec 81       	ldd	r30, Y+4	; 0x04
    63d0:	fd 81       	ldd	r31, Y+5	; 0x05
    63d2:	80 81       	ld	r24, Z
    63d4:	91 81       	ldd	r25, Z+1	; 0x01
    63d6:	9a 83       	std	Y+2, r25	; 0x02
    63d8:	89 83       	std	Y+1, r24	; 0x01

    if( pxStreamBuffer->xHead == xTail )
    63da:	ec 81       	ldd	r30, Y+4	; 0x04
    63dc:	fd 81       	ldd	r31, Y+5	; 0x05
    63de:	22 81       	ldd	r18, Z+2	; 0x02
    63e0:	33 81       	ldd	r19, Z+3	; 0x03
    63e2:	89 81       	ldd	r24, Y+1	; 0x01
    63e4:	9a 81       	ldd	r25, Y+2	; 0x02
    63e6:	28 17       	cp	r18, r24
    63e8:	39 07       	cpc	r19, r25
    63ea:	19 f4       	brne	.+6      	; 0x63f2 <xStreamBufferIsEmpty+0x44>
    {
        xReturn = pdTRUE;
    63ec:	81 e0       	ldi	r24, 0x01	; 1
    63ee:	8b 83       	std	Y+3, r24	; 0x03
    63f0:	01 c0       	rjmp	.+2      	; 0x63f4 <xStreamBufferIsEmpty+0x46>
    }
    else
    {
        xReturn = pdFALSE;
    63f2:	1b 82       	std	Y+3, r1	; 0x03
    }

    return xReturn;
    63f4:	8b 81       	ldd	r24, Y+3	; 0x03
}
    63f6:	27 96       	adiw	r28, 0x07	; 7
    63f8:	0f b6       	in	r0, 0x3f	; 63
    63fa:	f8 94       	cli
    63fc:	de bf       	out	0x3e, r29	; 62
    63fe:	0f be       	out	0x3f, r0	; 63
    6400:	cd bf       	out	0x3d, r28	; 61
    6402:	cf 91       	pop	r28
    6404:	df 91       	pop	r29
    6406:	08 95       	ret

00006408 <xStreamBufferIsFull>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferIsFull( StreamBufferHandle_t xStreamBuffer )
{
    6408:	df 93       	push	r29
    640a:	cf 93       	push	r28
    640c:	cd b7       	in	r28, 0x3d	; 61
    640e:	de b7       	in	r29, 0x3e	; 62
    6410:	27 97       	sbiw	r28, 0x07	; 7
    6412:	0f b6       	in	r0, 0x3f	; 63
    6414:	f8 94       	cli
    6416:	de bf       	out	0x3e, r29	; 62
    6418:	0f be       	out	0x3f, r0	; 63
    641a:	cd bf       	out	0x3d, r28	; 61
    641c:	9f 83       	std	Y+7, r25	; 0x07
    641e:	8e 83       	std	Y+6, r24	; 0x06
    BaseType_t xReturn;
    size_t xBytesToStoreMessageLength;
    const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    6420:	8e 81       	ldd	r24, Y+6	; 0x06
    6422:	9f 81       	ldd	r25, Y+7	; 0x07
    6424:	9a 83       	std	Y+2, r25	; 0x02
    6426:	89 83       	std	Y+1, r24	; 0x01

    /* This generic version of the receive function is used by both message
     * buffers, which store discrete messages, and stream buffers, which store a
     * continuous stream of bytes.  Discrete messages include an additional
     * sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the message. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    6428:	e9 81       	ldd	r30, Y+1	; 0x01
    642a:	fa 81       	ldd	r31, Y+2	; 0x02
    642c:	86 85       	ldd	r24, Z+14	; 0x0e
    642e:	88 2f       	mov	r24, r24
    6430:	90 e0       	ldi	r25, 0x00	; 0
    6432:	81 70       	andi	r24, 0x01	; 1
    6434:	90 70       	andi	r25, 0x00	; 0
    6436:	88 23       	and	r24, r24
    6438:	29 f0       	breq	.+10     	; 0x6444 <xStreamBufferIsFull+0x3c>
    {
        xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    643a:	82 e0       	ldi	r24, 0x02	; 2
    643c:	90 e0       	ldi	r25, 0x00	; 0
    643e:	9c 83       	std	Y+4, r25	; 0x04
    6440:	8b 83       	std	Y+3, r24	; 0x03
    6442:	02 c0       	rjmp	.+4      	; 0x6448 <xStreamBufferIsFull+0x40>
    }
    else
    {
        xBytesToStoreMessageLength = 0;
    6444:	1c 82       	std	Y+4, r1	; 0x04
    6446:	1b 82       	std	Y+3, r1	; 0x03
    }

    /* True if the available space equals zero. */
    if( xStreamBufferSpacesAvailable( xStreamBuffer ) <= xBytesToStoreMessageLength )
    6448:	8e 81       	ldd	r24, Y+6	; 0x06
    644a:	9f 81       	ldd	r25, Y+7	; 0x07
    644c:	0e 94 7d 2d 	call	0x5afa	; 0x5afa <xStreamBufferSpacesAvailable>
    6450:	9c 01       	movw	r18, r24
    6452:	8b 81       	ldd	r24, Y+3	; 0x03
    6454:	9c 81       	ldd	r25, Y+4	; 0x04
    6456:	82 17       	cp	r24, r18
    6458:	93 07       	cpc	r25, r19
    645a:	18 f0       	brcs	.+6      	; 0x6462 <xStreamBufferIsFull+0x5a>
    {
        xReturn = pdTRUE;
    645c:	81 e0       	ldi	r24, 0x01	; 1
    645e:	8d 83       	std	Y+5, r24	; 0x05
    6460:	01 c0       	rjmp	.+2      	; 0x6464 <xStreamBufferIsFull+0x5c>
    }
    else
    {
        xReturn = pdFALSE;
    6462:	1d 82       	std	Y+5, r1	; 0x05
    }

    return xReturn;
    6464:	8d 81       	ldd	r24, Y+5	; 0x05
}
    6466:	27 96       	adiw	r28, 0x07	; 7
    6468:	0f b6       	in	r0, 0x3f	; 63
    646a:	f8 94       	cli
    646c:	de bf       	out	0x3e, r29	; 62
    646e:	0f be       	out	0x3f, r0	; 63
    6470:	cd bf       	out	0x3d, r28	; 61
    6472:	cf 91       	pop	r28
    6474:	df 91       	pop	r29
    6476:	08 95       	ret

00006478 <xStreamBufferSendCompletedFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferSendCompletedFromISR( StreamBufferHandle_t xStreamBuffer,
                                              BaseType_t * pxHigherPriorityTaskWoken )
{
    6478:	cf 92       	push	r12
    647a:	df 92       	push	r13
    647c:	ef 92       	push	r14
    647e:	ff 92       	push	r15
    6480:	0f 93       	push	r16
    6482:	df 93       	push	r29
    6484:	cf 93       	push	r28
    6486:	cd b7       	in	r28, 0x3d	; 61
    6488:	de b7       	in	r29, 0x3e	; 62
    648a:	28 97       	sbiw	r28, 0x08	; 8
    648c:	0f b6       	in	r0, 0x3f	; 63
    648e:	f8 94       	cli
    6490:	de bf       	out	0x3e, r29	; 62
    6492:	0f be       	out	0x3f, r0	; 63
    6494:	cd bf       	out	0x3d, r28	; 61
    6496:	9e 83       	std	Y+6, r25	; 0x06
    6498:	8d 83       	std	Y+5, r24	; 0x05
    649a:	78 87       	std	Y+8, r23	; 0x08
    649c:	6f 83       	std	Y+7, r22	; 0x07
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    649e:	8d 81       	ldd	r24, Y+5	; 0x05
    64a0:	9e 81       	ldd	r25, Y+6	; 0x06
    64a2:	9c 83       	std	Y+4, r25	; 0x04
    64a4:	8b 83       	std	Y+3, r24	; 0x03
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;

    configASSERT( pxStreamBuffer );

    uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
    64a6:	19 82       	std	Y+1, r1	; 0x01
    {
        if( ( pxStreamBuffer )->xTaskWaitingToReceive != NULL )
    64a8:	eb 81       	ldd	r30, Y+3	; 0x03
    64aa:	fc 81       	ldd	r31, Y+4	; 0x04
    64ac:	80 85       	ldd	r24, Z+8	; 0x08
    64ae:	91 85       	ldd	r25, Z+9	; 0x09
    64b0:	00 97       	sbiw	r24, 0x00	; 0
    64b2:	c1 f0       	breq	.+48     	; 0x64e4 <xStreamBufferSendCompletedFromISR+0x6c>
        {
            ( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToReceive,
    64b4:	eb 81       	ldd	r30, Y+3	; 0x03
    64b6:	fc 81       	ldd	r31, Y+4	; 0x04
    64b8:	80 85       	ldd	r24, Z+8	; 0x08
    64ba:	91 85       	ldd	r25, Z+9	; 0x09
    64bc:	ef 81       	ldd	r30, Y+7	; 0x07
    64be:	f8 85       	ldd	r31, Y+8	; 0x08
    64c0:	60 e0       	ldi	r22, 0x00	; 0
    64c2:	20 e0       	ldi	r18, 0x00	; 0
    64c4:	30 e0       	ldi	r19, 0x00	; 0
    64c6:	40 e0       	ldi	r20, 0x00	; 0
    64c8:	50 e0       	ldi	r21, 0x00	; 0
    64ca:	00 e0       	ldi	r16, 0x00	; 0
    64cc:	ee 24       	eor	r14, r14
    64ce:	ff 24       	eor	r15, r15
    64d0:	6f 01       	movw	r12, r30
    64d2:	0e 94 d2 45 	call	0x8ba4	; 0x8ba4 <xTaskGenericNotifyFromISR>
                                         ( uint32_t ) 0,
                                         eNoAction,
                                         pxHigherPriorityTaskWoken );
            ( pxStreamBuffer )->xTaskWaitingToReceive = NULL;
    64d6:	eb 81       	ldd	r30, Y+3	; 0x03
    64d8:	fc 81       	ldd	r31, Y+4	; 0x04
    64da:	11 86       	std	Z+9, r1	; 0x09
    64dc:	10 86       	std	Z+8, r1	; 0x08
            xReturn = pdTRUE;
    64de:	81 e0       	ldi	r24, 0x01	; 1
    64e0:	8a 83       	std	Y+2, r24	; 0x02
    64e2:	01 c0       	rjmp	.+2      	; 0x64e6 <xStreamBufferSendCompletedFromISR+0x6e>
        }
        else
        {
            xReturn = pdFALSE;
    64e4:	1a 82       	std	Y+2, r1	; 0x02
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    64e6:	8a 81       	ldd	r24, Y+2	; 0x02
}
    64e8:	28 96       	adiw	r28, 0x08	; 8
    64ea:	0f b6       	in	r0, 0x3f	; 63
    64ec:	f8 94       	cli
    64ee:	de bf       	out	0x3e, r29	; 62
    64f0:	0f be       	out	0x3f, r0	; 63
    64f2:	cd bf       	out	0x3d, r28	; 61
    64f4:	cf 91       	pop	r28
    64f6:	df 91       	pop	r29
    64f8:	0f 91       	pop	r16
    64fa:	ff 90       	pop	r15
    64fc:	ef 90       	pop	r14
    64fe:	df 90       	pop	r13
    6500:	cf 90       	pop	r12
    6502:	08 95       	ret

00006504 <xStreamBufferReceiveCompletedFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferReceiveCompletedFromISR( StreamBufferHandle_t xStreamBuffer,
                                                 BaseType_t * pxHigherPriorityTaskWoken )
{
    6504:	cf 92       	push	r12
    6506:	df 92       	push	r13
    6508:	ef 92       	push	r14
    650a:	ff 92       	push	r15
    650c:	0f 93       	push	r16
    650e:	df 93       	push	r29
    6510:	cf 93       	push	r28
    6512:	cd b7       	in	r28, 0x3d	; 61
    6514:	de b7       	in	r29, 0x3e	; 62
    6516:	28 97       	sbiw	r28, 0x08	; 8
    6518:	0f b6       	in	r0, 0x3f	; 63
    651a:	f8 94       	cli
    651c:	de bf       	out	0x3e, r29	; 62
    651e:	0f be       	out	0x3f, r0	; 63
    6520:	cd bf       	out	0x3d, r28	; 61
    6522:	9e 83       	std	Y+6, r25	; 0x06
    6524:	8d 83       	std	Y+5, r24	; 0x05
    6526:	78 87       	std	Y+8, r23	; 0x08
    6528:	6f 83       	std	Y+7, r22	; 0x07
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    652a:	8d 81       	ldd	r24, Y+5	; 0x05
    652c:	9e 81       	ldd	r25, Y+6	; 0x06
    652e:	9c 83       	std	Y+4, r25	; 0x04
    6530:	8b 83       	std	Y+3, r24	; 0x03
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;

    configASSERT( pxStreamBuffer );

    uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
    6532:	19 82       	std	Y+1, r1	; 0x01
    {
        if( ( pxStreamBuffer )->xTaskWaitingToSend != NULL )
    6534:	eb 81       	ldd	r30, Y+3	; 0x03
    6536:	fc 81       	ldd	r31, Y+4	; 0x04
    6538:	82 85       	ldd	r24, Z+10	; 0x0a
    653a:	93 85       	ldd	r25, Z+11	; 0x0b
    653c:	00 97       	sbiw	r24, 0x00	; 0
    653e:	c1 f0       	breq	.+48     	; 0x6570 <xStreamBufferReceiveCompletedFromISR+0x6c>
        {
            ( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToSend,
    6540:	eb 81       	ldd	r30, Y+3	; 0x03
    6542:	fc 81       	ldd	r31, Y+4	; 0x04
    6544:	82 85       	ldd	r24, Z+10	; 0x0a
    6546:	93 85       	ldd	r25, Z+11	; 0x0b
    6548:	ef 81       	ldd	r30, Y+7	; 0x07
    654a:	f8 85       	ldd	r31, Y+8	; 0x08
    654c:	60 e0       	ldi	r22, 0x00	; 0
    654e:	20 e0       	ldi	r18, 0x00	; 0
    6550:	30 e0       	ldi	r19, 0x00	; 0
    6552:	40 e0       	ldi	r20, 0x00	; 0
    6554:	50 e0       	ldi	r21, 0x00	; 0
    6556:	00 e0       	ldi	r16, 0x00	; 0
    6558:	ee 24       	eor	r14, r14
    655a:	ff 24       	eor	r15, r15
    655c:	6f 01       	movw	r12, r30
    655e:	0e 94 d2 45 	call	0x8ba4	; 0x8ba4 <xTaskGenericNotifyFromISR>
                                         ( uint32_t ) 0,
                                         eNoAction,
                                         pxHigherPriorityTaskWoken );
            ( pxStreamBuffer )->xTaskWaitingToSend = NULL;
    6562:	eb 81       	ldd	r30, Y+3	; 0x03
    6564:	fc 81       	ldd	r31, Y+4	; 0x04
    6566:	13 86       	std	Z+11, r1	; 0x0b
    6568:	12 86       	std	Z+10, r1	; 0x0a
            xReturn = pdTRUE;
    656a:	81 e0       	ldi	r24, 0x01	; 1
    656c:	8a 83       	std	Y+2, r24	; 0x02
    656e:	01 c0       	rjmp	.+2      	; 0x6572 <xStreamBufferReceiveCompletedFromISR+0x6e>
        }
        else
        {
            xReturn = pdFALSE;
    6570:	1a 82       	std	Y+2, r1	; 0x02
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    6572:	8a 81       	ldd	r24, Y+2	; 0x02
}
    6574:	28 96       	adiw	r28, 0x08	; 8
    6576:	0f b6       	in	r0, 0x3f	; 63
    6578:	f8 94       	cli
    657a:	de bf       	out	0x3e, r29	; 62
    657c:	0f be       	out	0x3f, r0	; 63
    657e:	cd bf       	out	0x3d, r28	; 61
    6580:	cf 91       	pop	r28
    6582:	df 91       	pop	r29
    6584:	0f 91       	pop	r16
    6586:	ff 90       	pop	r15
    6588:	ef 90       	pop	r14
    658a:	df 90       	pop	r13
    658c:	cf 90       	pop	r12
    658e:	08 95       	ret

00006590 <prvWriteBytesToBuffer>:

static size_t prvWriteBytesToBuffer( StreamBuffer_t * const pxStreamBuffer,
                                     const uint8_t * pucData,
                                     size_t xCount,
                                     size_t xHead )
{
    6590:	df 93       	push	r29
    6592:	cf 93       	push	r28
    6594:	cd b7       	in	r28, 0x3d	; 61
    6596:	de b7       	in	r29, 0x3e	; 62
    6598:	2e 97       	sbiw	r28, 0x0e	; 14
    659a:	0f b6       	in	r0, 0x3f	; 63
    659c:	f8 94       	cli
    659e:	de bf       	out	0x3e, r29	; 62
    65a0:	0f be       	out	0x3f, r0	; 63
    65a2:	cd bf       	out	0x3d, r28	; 61
    65a4:	9c 83       	std	Y+4, r25	; 0x04
    65a6:	8b 83       	std	Y+3, r24	; 0x03
    65a8:	7e 83       	std	Y+6, r23	; 0x06
    65aa:	6d 83       	std	Y+5, r22	; 0x05
    65ac:	58 87       	std	Y+8, r21	; 0x08
    65ae:	4f 83       	std	Y+7, r20	; 0x07
    65b0:	3a 87       	std	Y+10, r19	; 0x0a
    65b2:	29 87       	std	Y+9, r18	; 0x09
    configASSERT( xCount > ( size_t ) 0 );

    /* Calculate the number of bytes that can be added in the first write -
     * which may be less than the total number of bytes that need to be added if
     * the buffer will wrap back to the beginning. */
    xFirstLength = configMIN( pxStreamBuffer->xLength - xHead, xCount );
    65b4:	eb 81       	ldd	r30, Y+3	; 0x03
    65b6:	fc 81       	ldd	r31, Y+4	; 0x04
    65b8:	24 81       	ldd	r18, Z+4	; 0x04
    65ba:	35 81       	ldd	r19, Z+5	; 0x05
    65bc:	89 85       	ldd	r24, Y+9	; 0x09
    65be:	9a 85       	ldd	r25, Y+10	; 0x0a
    65c0:	a9 01       	movw	r20, r18
    65c2:	48 1b       	sub	r20, r24
    65c4:	59 0b       	sbc	r21, r25
    65c6:	ca 01       	movw	r24, r20
    65c8:	2f 81       	ldd	r18, Y+7	; 0x07
    65ca:	38 85       	ldd	r19, Y+8	; 0x08
    65cc:	3e 87       	std	Y+14, r19	; 0x0e
    65ce:	2d 87       	std	Y+13, r18	; 0x0d
    65d0:	9c 87       	std	Y+12, r25	; 0x0c
    65d2:	8b 87       	std	Y+11, r24	; 0x0b
    65d4:	4b 85       	ldd	r20, Y+11	; 0x0b
    65d6:	5c 85       	ldd	r21, Y+12	; 0x0c
    65d8:	8d 85       	ldd	r24, Y+13	; 0x0d
    65da:	9e 85       	ldd	r25, Y+14	; 0x0e
    65dc:	84 17       	cp	r24, r20
    65de:	95 07       	cpc	r25, r21
    65e0:	20 f4       	brcc	.+8      	; 0x65ea <prvWriteBytesToBuffer+0x5a>
    65e2:	2d 85       	ldd	r18, Y+13	; 0x0d
    65e4:	3e 85       	ldd	r19, Y+14	; 0x0e
    65e6:	3c 87       	std	Y+12, r19	; 0x0c
    65e8:	2b 87       	std	Y+11, r18	; 0x0b
    65ea:	4b 85       	ldd	r20, Y+11	; 0x0b
    65ec:	5c 85       	ldd	r21, Y+12	; 0x0c
    65ee:	5a 83       	std	Y+2, r21	; 0x02
    65f0:	49 83       	std	Y+1, r20	; 0x01

    /* Write as many bytes as can be written in the first write. */
    configASSERT( ( xHead + xFirstLength ) <= pxStreamBuffer->xLength );
    ( void ) memcpy( ( void * ) ( &( pxStreamBuffer->pucBuffer[ xHead ] ) ), ( const void * ) pucData, xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    65f2:	eb 81       	ldd	r30, Y+3	; 0x03
    65f4:	fc 81       	ldd	r31, Y+4	; 0x04
    65f6:	24 85       	ldd	r18, Z+12	; 0x0c
    65f8:	35 85       	ldd	r19, Z+13	; 0x0d
    65fa:	89 85       	ldd	r24, Y+9	; 0x09
    65fc:	9a 85       	ldd	r25, Y+10	; 0x0a
    65fe:	82 0f       	add	r24, r18
    6600:	93 1f       	adc	r25, r19
    6602:	2d 81       	ldd	r18, Y+5	; 0x05
    6604:	3e 81       	ldd	r19, Y+6	; 0x06
    6606:	49 81       	ldd	r20, Y+1	; 0x01
    6608:	5a 81       	ldd	r21, Y+2	; 0x02
    660a:	b9 01       	movw	r22, r18
    660c:	0e 94 80 4c 	call	0x9900	; 0x9900 <memcpy>

    /* If the number of bytes written was less than the number that could be
     * written in the first write... */
    if( xCount > xFirstLength )
    6610:	2f 81       	ldd	r18, Y+7	; 0x07
    6612:	38 85       	ldd	r19, Y+8	; 0x08
    6614:	89 81       	ldd	r24, Y+1	; 0x01
    6616:	9a 81       	ldd	r25, Y+2	; 0x02
    6618:	82 17       	cp	r24, r18
    661a:	93 07       	cpc	r25, r19
    661c:	b0 f4       	brcc	.+44     	; 0x664a <prvWriteBytesToBuffer+0xba>
    {
        /* ...then write the remaining bytes to the start of the buffer. */
        configASSERT( ( xCount - xFirstLength ) <= pxStreamBuffer->xLength );
        ( void ) memcpy( ( void * ) pxStreamBuffer->pucBuffer, ( const void * ) &( pucData[ xFirstLength ] ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    661e:	eb 81       	ldd	r30, Y+3	; 0x03
    6620:	fc 81       	ldd	r31, Y+4	; 0x04
    6622:	64 85       	ldd	r22, Z+12	; 0x0c
    6624:	75 85       	ldd	r23, Z+13	; 0x0d
    6626:	2d 81       	ldd	r18, Y+5	; 0x05
    6628:	3e 81       	ldd	r19, Y+6	; 0x06
    662a:	89 81       	ldd	r24, Y+1	; 0x01
    662c:	9a 81       	ldd	r25, Y+2	; 0x02
    662e:	a9 01       	movw	r20, r18
    6630:	48 0f       	add	r20, r24
    6632:	59 1f       	adc	r21, r25
    6634:	2f 81       	ldd	r18, Y+7	; 0x07
    6636:	38 85       	ldd	r19, Y+8	; 0x08
    6638:	89 81       	ldd	r24, Y+1	; 0x01
    663a:	9a 81       	ldd	r25, Y+2	; 0x02
    663c:	28 1b       	sub	r18, r24
    663e:	39 0b       	sbc	r19, r25
    6640:	cb 01       	movw	r24, r22
    6642:	ba 01       	movw	r22, r20
    6644:	a9 01       	movw	r20, r18
    6646:	0e 94 80 4c 	call	0x9900	; 0x9900 <memcpy>
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    xHead += xCount;
    664a:	29 85       	ldd	r18, Y+9	; 0x09
    664c:	3a 85       	ldd	r19, Y+10	; 0x0a
    664e:	8f 81       	ldd	r24, Y+7	; 0x07
    6650:	98 85       	ldd	r25, Y+8	; 0x08
    6652:	82 0f       	add	r24, r18
    6654:	93 1f       	adc	r25, r19
    6656:	9a 87       	std	Y+10, r25	; 0x0a
    6658:	89 87       	std	Y+9, r24	; 0x09

    if( xHead >= pxStreamBuffer->xLength )
    665a:	eb 81       	ldd	r30, Y+3	; 0x03
    665c:	fc 81       	ldd	r31, Y+4	; 0x04
    665e:	24 81       	ldd	r18, Z+4	; 0x04
    6660:	35 81       	ldd	r19, Z+5	; 0x05
    6662:	89 85       	ldd	r24, Y+9	; 0x09
    6664:	9a 85       	ldd	r25, Y+10	; 0x0a
    6666:	82 17       	cp	r24, r18
    6668:	93 07       	cpc	r25, r19
    666a:	50 f0       	brcs	.+20     	; 0x6680 <prvWriteBytesToBuffer+0xf0>
    {
        xHead -= pxStreamBuffer->xLength;
    666c:	eb 81       	ldd	r30, Y+3	; 0x03
    666e:	fc 81       	ldd	r31, Y+4	; 0x04
    6670:	24 81       	ldd	r18, Z+4	; 0x04
    6672:	35 81       	ldd	r19, Z+5	; 0x05
    6674:	89 85       	ldd	r24, Y+9	; 0x09
    6676:	9a 85       	ldd	r25, Y+10	; 0x0a
    6678:	82 1b       	sub	r24, r18
    667a:	93 0b       	sbc	r25, r19
    667c:	9a 87       	std	Y+10, r25	; 0x0a
    667e:	89 87       	std	Y+9, r24	; 0x09
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    return xHead;
    6680:	89 85       	ldd	r24, Y+9	; 0x09
    6682:	9a 85       	ldd	r25, Y+10	; 0x0a
}
    6684:	2e 96       	adiw	r28, 0x0e	; 14
    6686:	0f b6       	in	r0, 0x3f	; 63
    6688:	f8 94       	cli
    668a:	de bf       	out	0x3e, r29	; 62
    668c:	0f be       	out	0x3f, r0	; 63
    668e:	cd bf       	out	0x3d, r28	; 61
    6690:	cf 91       	pop	r28
    6692:	df 91       	pop	r29
    6694:	08 95       	ret

00006696 <prvReadBytesFromBuffer>:

static size_t prvReadBytesFromBuffer( StreamBuffer_t * pxStreamBuffer,
                                      uint8_t * pucData,
                                      size_t xCount,
                                      size_t xTail )
{
    6696:	df 93       	push	r29
    6698:	cf 93       	push	r28
    669a:	cd b7       	in	r28, 0x3d	; 61
    669c:	de b7       	in	r29, 0x3e	; 62
    669e:	2e 97       	sbiw	r28, 0x0e	; 14
    66a0:	0f b6       	in	r0, 0x3f	; 63
    66a2:	f8 94       	cli
    66a4:	de bf       	out	0x3e, r29	; 62
    66a6:	0f be       	out	0x3f, r0	; 63
    66a8:	cd bf       	out	0x3d, r28	; 61
    66aa:	9c 83       	std	Y+4, r25	; 0x04
    66ac:	8b 83       	std	Y+3, r24	; 0x03
    66ae:	7e 83       	std	Y+6, r23	; 0x06
    66b0:	6d 83       	std	Y+5, r22	; 0x05
    66b2:	58 87       	std	Y+8, r21	; 0x08
    66b4:	4f 83       	std	Y+7, r20	; 0x07
    66b6:	3a 87       	std	Y+10, r19	; 0x0a
    66b8:	29 87       	std	Y+9, r18	; 0x09
    configASSERT( xCount != ( size_t ) 0 );

    /* Calculate the number of bytes that can be read - which may be
     * less than the number wanted if the data wraps around to the start of
     * the buffer. */
    xFirstLength = configMIN( pxStreamBuffer->xLength - xTail, xCount );
    66ba:	eb 81       	ldd	r30, Y+3	; 0x03
    66bc:	fc 81       	ldd	r31, Y+4	; 0x04
    66be:	24 81       	ldd	r18, Z+4	; 0x04
    66c0:	35 81       	ldd	r19, Z+5	; 0x05
    66c2:	89 85       	ldd	r24, Y+9	; 0x09
    66c4:	9a 85       	ldd	r25, Y+10	; 0x0a
    66c6:	a9 01       	movw	r20, r18
    66c8:	48 1b       	sub	r20, r24
    66ca:	59 0b       	sbc	r21, r25
    66cc:	ca 01       	movw	r24, r20
    66ce:	2f 81       	ldd	r18, Y+7	; 0x07
    66d0:	38 85       	ldd	r19, Y+8	; 0x08
    66d2:	3e 87       	std	Y+14, r19	; 0x0e
    66d4:	2d 87       	std	Y+13, r18	; 0x0d
    66d6:	9c 87       	std	Y+12, r25	; 0x0c
    66d8:	8b 87       	std	Y+11, r24	; 0x0b
    66da:	4b 85       	ldd	r20, Y+11	; 0x0b
    66dc:	5c 85       	ldd	r21, Y+12	; 0x0c
    66de:	8d 85       	ldd	r24, Y+13	; 0x0d
    66e0:	9e 85       	ldd	r25, Y+14	; 0x0e
    66e2:	84 17       	cp	r24, r20
    66e4:	95 07       	cpc	r25, r21
    66e6:	20 f4       	brcc	.+8      	; 0x66f0 <prvReadBytesFromBuffer+0x5a>
    66e8:	2d 85       	ldd	r18, Y+13	; 0x0d
    66ea:	3e 85       	ldd	r19, Y+14	; 0x0e
    66ec:	3c 87       	std	Y+12, r19	; 0x0c
    66ee:	2b 87       	std	Y+11, r18	; 0x0b
    66f0:	4b 85       	ldd	r20, Y+11	; 0x0b
    66f2:	5c 85       	ldd	r21, Y+12	; 0x0c
    66f4:	5a 83       	std	Y+2, r21	; 0x02
    66f6:	49 83       	std	Y+1, r20	; 0x01

    /* Obtain the number of bytes it is possible to obtain in the first
     * read.  Asserts check bounds of read and write. */
    configASSERT( xFirstLength <= xCount );
    configASSERT( ( xTail + xFirstLength ) <= pxStreamBuffer->xLength );
    ( void ) memcpy( ( void * ) pucData, ( const void * ) &( pxStreamBuffer->pucBuffer[ xTail ] ), xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    66f8:	eb 81       	ldd	r30, Y+3	; 0x03
    66fa:	fc 81       	ldd	r31, Y+4	; 0x04
    66fc:	24 85       	ldd	r18, Z+12	; 0x0c
    66fe:	35 85       	ldd	r19, Z+13	; 0x0d
    6700:	89 85       	ldd	r24, Y+9	; 0x09
    6702:	9a 85       	ldd	r25, Y+10	; 0x0a
    6704:	a9 01       	movw	r20, r18
    6706:	48 0f       	add	r20, r24
    6708:	59 1f       	adc	r21, r25
    670a:	8d 81       	ldd	r24, Y+5	; 0x05
    670c:	9e 81       	ldd	r25, Y+6	; 0x06
    670e:	29 81       	ldd	r18, Y+1	; 0x01
    6710:	3a 81       	ldd	r19, Y+2	; 0x02
    6712:	ba 01       	movw	r22, r20
    6714:	a9 01       	movw	r20, r18
    6716:	0e 94 80 4c 	call	0x9900	; 0x9900 <memcpy>

    /* If the total number of wanted bytes is greater than the number
     * that could be read in the first read... */
    if( xCount > xFirstLength )
    671a:	2f 81       	ldd	r18, Y+7	; 0x07
    671c:	38 85       	ldd	r19, Y+8	; 0x08
    671e:	89 81       	ldd	r24, Y+1	; 0x01
    6720:	9a 81       	ldd	r25, Y+2	; 0x02
    6722:	82 17       	cp	r24, r18
    6724:	93 07       	cpc	r25, r19
    6726:	b0 f4       	brcc	.+44     	; 0x6754 <prvReadBytesFromBuffer+0xbe>
    {
        /* ...then read the remaining bytes from the start of the buffer. */
        ( void ) memcpy( ( void * ) &( pucData[ xFirstLength ] ), ( void * ) ( pxStreamBuffer->pucBuffer ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    6728:	2d 81       	ldd	r18, Y+5	; 0x05
    672a:	3e 81       	ldd	r19, Y+6	; 0x06
    672c:	89 81       	ldd	r24, Y+1	; 0x01
    672e:	9a 81       	ldd	r25, Y+2	; 0x02
    6730:	b9 01       	movw	r22, r18
    6732:	68 0f       	add	r22, r24
    6734:	79 1f       	adc	r23, r25
    6736:	eb 81       	ldd	r30, Y+3	; 0x03
    6738:	fc 81       	ldd	r31, Y+4	; 0x04
    673a:	44 85       	ldd	r20, Z+12	; 0x0c
    673c:	55 85       	ldd	r21, Z+13	; 0x0d
    673e:	2f 81       	ldd	r18, Y+7	; 0x07
    6740:	38 85       	ldd	r19, Y+8	; 0x08
    6742:	89 81       	ldd	r24, Y+1	; 0x01
    6744:	9a 81       	ldd	r25, Y+2	; 0x02
    6746:	28 1b       	sub	r18, r24
    6748:	39 0b       	sbc	r19, r25
    674a:	cb 01       	movw	r24, r22
    674c:	ba 01       	movw	r22, r20
    674e:	a9 01       	movw	r20, r18
    6750:	0e 94 80 4c 	call	0x9900	; 0x9900 <memcpy>
    {
        mtCOVERAGE_TEST_MARKER();
    }

    /* Move the tail pointer to effectively remove the data read from the buffer. */
    xTail += xCount;
    6754:	29 85       	ldd	r18, Y+9	; 0x09
    6756:	3a 85       	ldd	r19, Y+10	; 0x0a
    6758:	8f 81       	ldd	r24, Y+7	; 0x07
    675a:	98 85       	ldd	r25, Y+8	; 0x08
    675c:	82 0f       	add	r24, r18
    675e:	93 1f       	adc	r25, r19
    6760:	9a 87       	std	Y+10, r25	; 0x0a
    6762:	89 87       	std	Y+9, r24	; 0x09

    if( xTail >= pxStreamBuffer->xLength )
    6764:	eb 81       	ldd	r30, Y+3	; 0x03
    6766:	fc 81       	ldd	r31, Y+4	; 0x04
    6768:	24 81       	ldd	r18, Z+4	; 0x04
    676a:	35 81       	ldd	r19, Z+5	; 0x05
    676c:	89 85       	ldd	r24, Y+9	; 0x09
    676e:	9a 85       	ldd	r25, Y+10	; 0x0a
    6770:	82 17       	cp	r24, r18
    6772:	93 07       	cpc	r25, r19
    6774:	50 f0       	brcs	.+20     	; 0x678a <prvReadBytesFromBuffer+0xf4>
    {
        xTail -= pxStreamBuffer->xLength;
    6776:	eb 81       	ldd	r30, Y+3	; 0x03
    6778:	fc 81       	ldd	r31, Y+4	; 0x04
    677a:	24 81       	ldd	r18, Z+4	; 0x04
    677c:	35 81       	ldd	r19, Z+5	; 0x05
    677e:	89 85       	ldd	r24, Y+9	; 0x09
    6780:	9a 85       	ldd	r25, Y+10	; 0x0a
    6782:	82 1b       	sub	r24, r18
    6784:	93 0b       	sbc	r25, r19
    6786:	9a 87       	std	Y+10, r25	; 0x0a
    6788:	89 87       	std	Y+9, r24	; 0x09
    }

    return xTail;
    678a:	89 85       	ldd	r24, Y+9	; 0x09
    678c:	9a 85       	ldd	r25, Y+10	; 0x0a
}
    678e:	2e 96       	adiw	r28, 0x0e	; 14
    6790:	0f b6       	in	r0, 0x3f	; 63
    6792:	f8 94       	cli
    6794:	de bf       	out	0x3e, r29	; 62
    6796:	0f be       	out	0x3f, r0	; 63
    6798:	cd bf       	out	0x3d, r28	; 61
    679a:	cf 91       	pop	r28
    679c:	df 91       	pop	r29
    679e:	08 95       	ret

000067a0 <prvBytesInBuffer>:
/*-----------------------------------------------------------*/

static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )
{
    67a0:	df 93       	push	r29
    67a2:	cf 93       	push	r28
    67a4:	00 d0       	rcall	.+0      	; 0x67a6 <prvBytesInBuffer+0x6>
    67a6:	00 d0       	rcall	.+0      	; 0x67a8 <prvBytesInBuffer+0x8>
    67a8:	cd b7       	in	r28, 0x3d	; 61
    67aa:	de b7       	in	r29, 0x3e	; 62
    67ac:	9c 83       	std	Y+4, r25	; 0x04
    67ae:	8b 83       	std	Y+3, r24	; 0x03
/* Returns the distance between xTail and xHead. */
    size_t xCount;

    xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
    67b0:	eb 81       	ldd	r30, Y+3	; 0x03
    67b2:	fc 81       	ldd	r31, Y+4	; 0x04
    67b4:	24 81       	ldd	r18, Z+4	; 0x04
    67b6:	35 81       	ldd	r19, Z+5	; 0x05
    67b8:	eb 81       	ldd	r30, Y+3	; 0x03
    67ba:	fc 81       	ldd	r31, Y+4	; 0x04
    67bc:	82 81       	ldd	r24, Z+2	; 0x02
    67be:	93 81       	ldd	r25, Z+3	; 0x03
    67c0:	82 0f       	add	r24, r18
    67c2:	93 1f       	adc	r25, r19
    67c4:	9a 83       	std	Y+2, r25	; 0x02
    67c6:	89 83       	std	Y+1, r24	; 0x01
    xCount -= pxStreamBuffer->xTail;
    67c8:	eb 81       	ldd	r30, Y+3	; 0x03
    67ca:	fc 81       	ldd	r31, Y+4	; 0x04
    67cc:	20 81       	ld	r18, Z
    67ce:	31 81       	ldd	r19, Z+1	; 0x01
    67d0:	89 81       	ldd	r24, Y+1	; 0x01
    67d2:	9a 81       	ldd	r25, Y+2	; 0x02
    67d4:	82 1b       	sub	r24, r18
    67d6:	93 0b       	sbc	r25, r19
    67d8:	9a 83       	std	Y+2, r25	; 0x02
    67da:	89 83       	std	Y+1, r24	; 0x01

    if( xCount >= pxStreamBuffer->xLength )
    67dc:	eb 81       	ldd	r30, Y+3	; 0x03
    67de:	fc 81       	ldd	r31, Y+4	; 0x04
    67e0:	24 81       	ldd	r18, Z+4	; 0x04
    67e2:	35 81       	ldd	r19, Z+5	; 0x05
    67e4:	89 81       	ldd	r24, Y+1	; 0x01
    67e6:	9a 81       	ldd	r25, Y+2	; 0x02
    67e8:	82 17       	cp	r24, r18
    67ea:	93 07       	cpc	r25, r19
    67ec:	50 f0       	brcs	.+20     	; 0x6802 <prvBytesInBuffer+0x62>
    {
        xCount -= pxStreamBuffer->xLength;
    67ee:	eb 81       	ldd	r30, Y+3	; 0x03
    67f0:	fc 81       	ldd	r31, Y+4	; 0x04
    67f2:	24 81       	ldd	r18, Z+4	; 0x04
    67f4:	35 81       	ldd	r19, Z+5	; 0x05
    67f6:	89 81       	ldd	r24, Y+1	; 0x01
    67f8:	9a 81       	ldd	r25, Y+2	; 0x02
    67fa:	82 1b       	sub	r24, r18
    67fc:	93 0b       	sbc	r25, r19
    67fe:	9a 83       	std	Y+2, r25	; 0x02
    6800:	89 83       	std	Y+1, r24	; 0x01
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    return xCount;
    6802:	89 81       	ldd	r24, Y+1	; 0x01
    6804:	9a 81       	ldd	r25, Y+2	; 0x02
}
    6806:	0f 90       	pop	r0
    6808:	0f 90       	pop	r0
    680a:	0f 90       	pop	r0
    680c:	0f 90       	pop	r0
    680e:	cf 91       	pop	r28
    6810:	df 91       	pop	r29
    6812:	08 95       	ret

00006814 <prvInitialiseNewStreamBuffer>:
static void prvInitialiseNewStreamBuffer( StreamBuffer_t * const pxStreamBuffer,
                                          uint8_t * const pucBuffer,
                                          size_t xBufferSizeBytes,
                                          size_t xTriggerLevelBytes,
                                          uint8_t ucFlags )
{
    6814:	0f 93       	push	r16
    6816:	df 93       	push	r29
    6818:	cf 93       	push	r28
    681a:	cd b7       	in	r28, 0x3d	; 61
    681c:	de b7       	in	r29, 0x3e	; 62
    681e:	29 97       	sbiw	r28, 0x09	; 9
    6820:	0f b6       	in	r0, 0x3f	; 63
    6822:	f8 94       	cli
    6824:	de bf       	out	0x3e, r29	; 62
    6826:	0f be       	out	0x3f, r0	; 63
    6828:	cd bf       	out	0x3d, r28	; 61
    682a:	9a 83       	std	Y+2, r25	; 0x02
    682c:	89 83       	std	Y+1, r24	; 0x01
    682e:	7c 83       	std	Y+4, r23	; 0x04
    6830:	6b 83       	std	Y+3, r22	; 0x03
    6832:	5e 83       	std	Y+6, r21	; 0x06
    6834:	4d 83       	std	Y+5, r20	; 0x05
    6836:	38 87       	std	Y+8, r19	; 0x08
    6838:	2f 83       	std	Y+7, r18	; 0x07
    683a:	09 87       	std	Y+9, r16	; 0x09
            const BaseType_t xWriteValue = 0x55;
            configASSERT( memset( pucBuffer, ( int ) xWriteValue, xBufferSizeBytes ) == pucBuffer );
        } /*lint !e529 !e438 xWriteValue is only used if configASSERT() is defined. */
    #endif

    ( void ) memset( ( void * ) pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) ); /*lint !e9087 memset() requires void *. */
    683c:	89 81       	ldd	r24, Y+1	; 0x01
    683e:	9a 81       	ldd	r25, Y+2	; 0x02
    6840:	60 e0       	ldi	r22, 0x00	; 0
    6842:	70 e0       	ldi	r23, 0x00	; 0
    6844:	4f e0       	ldi	r20, 0x0F	; 15
    6846:	50 e0       	ldi	r21, 0x00	; 0
    6848:	0e 94 89 4c 	call	0x9912	; 0x9912 <memset>
    pxStreamBuffer->pucBuffer = pucBuffer;
    684c:	e9 81       	ldd	r30, Y+1	; 0x01
    684e:	fa 81       	ldd	r31, Y+2	; 0x02
    6850:	8b 81       	ldd	r24, Y+3	; 0x03
    6852:	9c 81       	ldd	r25, Y+4	; 0x04
    6854:	95 87       	std	Z+13, r25	; 0x0d
    6856:	84 87       	std	Z+12, r24	; 0x0c
    pxStreamBuffer->xLength = xBufferSizeBytes;
    6858:	e9 81       	ldd	r30, Y+1	; 0x01
    685a:	fa 81       	ldd	r31, Y+2	; 0x02
    685c:	8d 81       	ldd	r24, Y+5	; 0x05
    685e:	9e 81       	ldd	r25, Y+6	; 0x06
    6860:	95 83       	std	Z+5, r25	; 0x05
    6862:	84 83       	std	Z+4, r24	; 0x04
    pxStreamBuffer->xTriggerLevelBytes = xTriggerLevelBytes;
    6864:	e9 81       	ldd	r30, Y+1	; 0x01
    6866:	fa 81       	ldd	r31, Y+2	; 0x02
    6868:	8f 81       	ldd	r24, Y+7	; 0x07
    686a:	98 85       	ldd	r25, Y+8	; 0x08
    686c:	97 83       	std	Z+7, r25	; 0x07
    686e:	86 83       	std	Z+6, r24	; 0x06
    pxStreamBuffer->ucFlags = ucFlags;
    6870:	e9 81       	ldd	r30, Y+1	; 0x01
    6872:	fa 81       	ldd	r31, Y+2	; 0x02
    6874:	89 85       	ldd	r24, Y+9	; 0x09
    6876:	86 87       	std	Z+14, r24	; 0x0e
}
    6878:	29 96       	adiw	r28, 0x09	; 9
    687a:	0f b6       	in	r0, 0x3f	; 63
    687c:	f8 94       	cli
    687e:	de bf       	out	0x3e, r29	; 62
    6880:	0f be       	out	0x3f, r0	; 63
    6882:	cd bf       	out	0x3d, r28	; 61
    6884:	cf 91       	pop	r28
    6886:	df 91       	pop	r29
    6888:	0f 91       	pop	r16
    688a:	08 95       	ret

0000688c <xTaskCreate>:
                            const char * const pcName, /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
                            const configSTACK_DEPTH_TYPE usStackDepth,
                            void * const pvParameters,
                            UBaseType_t uxPriority,
                            TaskHandle_t * const pxCreatedTask )
    {
    688c:	8f 92       	push	r8
    688e:	9f 92       	push	r9
    6890:	af 92       	push	r10
    6892:	bf 92       	push	r11
    6894:	cf 92       	push	r12
    6896:	df 92       	push	r13
    6898:	ef 92       	push	r14
    689a:	ff 92       	push	r15
    689c:	0f 93       	push	r16
    689e:	1f 93       	push	r17
    68a0:	df 93       	push	r29
    68a2:	cf 93       	push	r28
    68a4:	cd b7       	in	r28, 0x3d	; 61
    68a6:	de b7       	in	r29, 0x3e	; 62
    68a8:	60 97       	sbiw	r28, 0x10	; 16
    68aa:	0f b6       	in	r0, 0x3f	; 63
    68ac:	f8 94       	cli
    68ae:	de bf       	out	0x3e, r29	; 62
    68b0:	0f be       	out	0x3f, r0	; 63
    68b2:	cd bf       	out	0x3d, r28	; 61
    68b4:	9f 83       	std	Y+7, r25	; 0x07
    68b6:	8e 83       	std	Y+6, r24	; 0x06
    68b8:	79 87       	std	Y+9, r23	; 0x09
    68ba:	68 87       	std	Y+8, r22	; 0x08
    68bc:	5b 87       	std	Y+11, r21	; 0x0b
    68be:	4a 87       	std	Y+10, r20	; 0x0a
    68c0:	3d 87       	std	Y+13, r19	; 0x0d
    68c2:	2c 87       	std	Y+12, r18	; 0x0c
    68c4:	0e 87       	std	Y+14, r16	; 0x0e
    68c6:	f8 8a       	std	Y+16, r15	; 0x10
    68c8:	ef 86       	std	Y+15, r14	; 0x0f
        #else /* portSTACK_GROWTH */
            {
                StackType_t * pxStack;

                /* Allocate space for the stack used by the task being created. */
                pxStack = pvPortMallocStack( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
    68ca:	8a 85       	ldd	r24, Y+10	; 0x0a
    68cc:	9b 85       	ldd	r25, Y+11	; 0x0b
    68ce:	0e 94 12 1e 	call	0x3c24	; 0x3c24 <pvPortMalloc>
    68d2:	9a 83       	std	Y+2, r25	; 0x02
    68d4:	89 83       	std	Y+1, r24	; 0x01

                if( pxStack != NULL )
    68d6:	89 81       	ldd	r24, Y+1	; 0x01
    68d8:	9a 81       	ldd	r25, Y+2	; 0x02
    68da:	00 97       	sbiw	r24, 0x00	; 0
    68dc:	b1 f0       	breq	.+44     	; 0x690a <xTaskCreate+0x7e>
                {
                    /* Allocate space for the TCB. */
                    pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
    68de:	88 e2       	ldi	r24, 0x28	; 40
    68e0:	90 e0       	ldi	r25, 0x00	; 0
    68e2:	0e 94 12 1e 	call	0x3c24	; 0x3c24 <pvPortMalloc>
    68e6:	9d 83       	std	Y+5, r25	; 0x05
    68e8:	8c 83       	std	Y+4, r24	; 0x04

                    if( pxNewTCB != NULL )
    68ea:	8c 81       	ldd	r24, Y+4	; 0x04
    68ec:	9d 81       	ldd	r25, Y+5	; 0x05
    68ee:	00 97       	sbiw	r24, 0x00	; 0
    68f0:	39 f0       	breq	.+14     	; 0x6900 <xTaskCreate+0x74>
                    {
                        /* Store the stack location in the TCB. */
                        pxNewTCB->pxStack = pxStack;
    68f2:	ec 81       	ldd	r30, Y+4	; 0x04
    68f4:	fd 81       	ldd	r31, Y+5	; 0x05
    68f6:	89 81       	ldd	r24, Y+1	; 0x01
    68f8:	9a 81       	ldd	r25, Y+2	; 0x02
    68fa:	90 8f       	std	Z+24, r25	; 0x18
    68fc:	87 8b       	std	Z+23, r24	; 0x17
    68fe:	07 c0       	rjmp	.+14     	; 0x690e <xTaskCreate+0x82>
                    }
                    else
                    {
                        /* The stack cannot be used as the TCB was not created.  Free
                         * it again. */
                        vPortFreeStack( pxStack );
    6900:	89 81       	ldd	r24, Y+1	; 0x01
    6902:	9a 81       	ldd	r25, Y+2	; 0x02
    6904:	0e 94 6c 1e 	call	0x3cd8	; 0x3cd8 <vPortFree>
    6908:	02 c0       	rjmp	.+4      	; 0x690e <xTaskCreate+0x82>
                    }
                }
                else
                {
                    pxNewTCB = NULL;
    690a:	1d 82       	std	Y+5, r1	; 0x05
    690c:	1c 82       	std	Y+4, r1	; 0x04
                }
            }
        #endif /* portSTACK_GROWTH */

        if( pxNewTCB != NULL )
    690e:	8c 81       	ldd	r24, Y+4	; 0x04
    6910:	9d 81       	ldd	r25, Y+5	; 0x05
    6912:	00 97       	sbiw	r24, 0x00	; 0
    6914:	e9 f0       	breq	.+58     	; 0x6950 <xTaskCreate+0xc4>
                     * task was created dynamically in case it is later deleted. */
                    pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
                }
            #endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

            prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
    6916:	8a 85       	ldd	r24, Y+10	; 0x0a
    6918:	9b 85       	ldd	r25, Y+11	; 0x0b
    691a:	9c 01       	movw	r18, r24
    691c:	40 e0       	ldi	r20, 0x00	; 0
    691e:	50 e0       	ldi	r21, 0x00	; 0
    6920:	8e 81       	ldd	r24, Y+6	; 0x06
    6922:	9f 81       	ldd	r25, Y+7	; 0x07
    6924:	68 85       	ldd	r22, Y+8	; 0x08
    6926:	79 85       	ldd	r23, Y+9	; 0x09
    6928:	ec 85       	ldd	r30, Y+12	; 0x0c
    692a:	fd 85       	ldd	r31, Y+13	; 0x0d
    692c:	af 85       	ldd	r26, Y+15	; 0x0f
    692e:	b8 89       	ldd	r27, Y+16	; 0x10
    6930:	ac 80       	ldd	r10, Y+4	; 0x04
    6932:	bd 80       	ldd	r11, Y+5	; 0x05
    6934:	8f 01       	movw	r16, r30
    6936:	ee 84       	ldd	r14, Y+14	; 0x0e
    6938:	6d 01       	movw	r12, r26
    693a:	88 24       	eor	r8, r8
    693c:	99 24       	eor	r9, r9
    693e:	0e 94 be 34 	call	0x697c	; 0x697c <prvInitialiseNewTask>
            prvAddNewTaskToReadyList( pxNewTCB );
    6942:	8c 81       	ldd	r24, Y+4	; 0x04
    6944:	9d 81       	ldd	r25, Y+5	; 0x05
    6946:	0e 94 8a 35 	call	0x6b14	; 0x6b14 <prvAddNewTaskToReadyList>
            xReturn = pdPASS;
    694a:	81 e0       	ldi	r24, 0x01	; 1
    694c:	8b 83       	std	Y+3, r24	; 0x03
    694e:	02 c0       	rjmp	.+4      	; 0x6954 <xTaskCreate+0xc8>
        }
        else
        {
            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    6950:	8f ef       	ldi	r24, 0xFF	; 255
    6952:	8b 83       	std	Y+3, r24	; 0x03
        }

        return xReturn;
    6954:	8b 81       	ldd	r24, Y+3	; 0x03
    }
    6956:	60 96       	adiw	r28, 0x10	; 16
    6958:	0f b6       	in	r0, 0x3f	; 63
    695a:	f8 94       	cli
    695c:	de bf       	out	0x3e, r29	; 62
    695e:	0f be       	out	0x3f, r0	; 63
    6960:	cd bf       	out	0x3d, r28	; 61
    6962:	cf 91       	pop	r28
    6964:	df 91       	pop	r29
    6966:	1f 91       	pop	r17
    6968:	0f 91       	pop	r16
    696a:	ff 90       	pop	r15
    696c:	ef 90       	pop	r14
    696e:	df 90       	pop	r13
    6970:	cf 90       	pop	r12
    6972:	bf 90       	pop	r11
    6974:	af 90       	pop	r10
    6976:	9f 90       	pop	r9
    6978:	8f 90       	pop	r8
    697a:	08 95       	ret

0000697c <prvInitialiseNewTask>:
                                  void * const pvParameters,
                                  UBaseType_t uxPriority,
                                  TaskHandle_t * const pxCreatedTask,
                                  TCB_t * pxNewTCB,
                                  const MemoryRegion_t * const xRegions )
{
    697c:	8f 92       	push	r8
    697e:	9f 92       	push	r9
    6980:	af 92       	push	r10
    6982:	bf 92       	push	r11
    6984:	cf 92       	push	r12
    6986:	df 92       	push	r13
    6988:	ef 92       	push	r14
    698a:	0f 93       	push	r16
    698c:	1f 93       	push	r17
    698e:	df 93       	push	r29
    6990:	cf 93       	push	r28
    6992:	cd b7       	in	r28, 0x3d	; 61
    6994:	de b7       	in	r29, 0x3e	; 62
    6996:	64 97       	sbiw	r28, 0x14	; 20
    6998:	0f b6       	in	r0, 0x3f	; 63
    699a:	f8 94       	cli
    699c:	de bf       	out	0x3e, r29	; 62
    699e:	0f be       	out	0x3f, r0	; 63
    69a0:	cd bf       	out	0x3d, r28	; 61
    69a2:	9d 83       	std	Y+5, r25	; 0x05
    69a4:	8c 83       	std	Y+4, r24	; 0x04
    69a6:	7f 83       	std	Y+7, r23	; 0x07
    69a8:	6e 83       	std	Y+6, r22	; 0x06
    69aa:	28 87       	std	Y+8, r18	; 0x08
    69ac:	39 87       	std	Y+9, r19	; 0x09
    69ae:	4a 87       	std	Y+10, r20	; 0x0a
    69b0:	5b 87       	std	Y+11, r21	; 0x0b
    69b2:	1d 87       	std	Y+13, r17	; 0x0d
    69b4:	0c 87       	std	Y+12, r16	; 0x0c
    69b6:	ee 86       	std	Y+14, r14	; 0x0e
    69b8:	d8 8a       	std	Y+16, r13	; 0x10
    69ba:	cf 86       	std	Y+15, r12	; 0x0f
    69bc:	ba 8a       	std	Y+18, r11	; 0x12
    69be:	a9 8a       	std	Y+17, r10	; 0x11
    69c0:	9c 8a       	std	Y+20, r9	; 0x14
    69c2:	8b 8a       	std	Y+19, r8	; 0x13
     * grows from high memory to low (as per the 80x86) or vice versa.
     * portSTACK_GROWTH is used to make the result positive or negative as required
     * by the port. */
    #if ( portSTACK_GROWTH < 0 )
        {
            pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
    69c4:	e9 89       	ldd	r30, Y+17	; 0x11
    69c6:	fa 89       	ldd	r31, Y+18	; 0x12
    69c8:	27 89       	ldd	r18, Z+23	; 0x17
    69ca:	30 8d       	ldd	r19, Z+24	; 0x18
    69cc:	88 85       	ldd	r24, Y+8	; 0x08
    69ce:	99 85       	ldd	r25, Y+9	; 0x09
    69d0:	01 97       	sbiw	r24, 0x01	; 1
    69d2:	82 0f       	add	r24, r18
    69d4:	93 1f       	adc	r25, r19
    69d6:	9b 83       	std	Y+3, r25	; 0x03
    69d8:	8a 83       	std	Y+2, r24	; 0x02
            pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
        }
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
    69da:	8e 81       	ldd	r24, Y+6	; 0x06
    69dc:	9f 81       	ldd	r25, Y+7	; 0x07
    69de:	00 97       	sbiw	r24, 0x00	; 0
    69e0:	51 f1       	breq	.+84     	; 0x6a36 <prvInitialiseNewTask+0xba>
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    69e2:	19 82       	std	Y+1, r1	; 0x01
    69e4:	21 c0       	rjmp	.+66     	; 0x6a28 <prvInitialiseNewTask+0xac>
        {
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    69e6:	89 81       	ldd	r24, Y+1	; 0x01
    69e8:	48 2f       	mov	r20, r24
    69ea:	50 e0       	ldi	r21, 0x00	; 0
    69ec:	89 81       	ldd	r24, Y+1	; 0x01
    69ee:	28 2f       	mov	r18, r24
    69f0:	30 e0       	ldi	r19, 0x00	; 0
    69f2:	8e 81       	ldd	r24, Y+6	; 0x06
    69f4:	9f 81       	ldd	r25, Y+7	; 0x07
    69f6:	fc 01       	movw	r30, r24
    69f8:	e2 0f       	add	r30, r18
    69fa:	f3 1f       	adc	r31, r19
    69fc:	20 81       	ld	r18, Z
    69fe:	89 89       	ldd	r24, Y+17	; 0x11
    6a00:	9a 89       	ldd	r25, Y+18	; 0x12
    6a02:	84 0f       	add	r24, r20
    6a04:	95 1f       	adc	r25, r21
    6a06:	fc 01       	movw	r30, r24
    6a08:	79 96       	adiw	r30, 0x19	; 25
    6a0a:	20 83       	st	Z, r18

            /* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
             * configMAX_TASK_NAME_LEN characters just in case the memory after the
             * string is not accessible (extremely unlikely). */
            if( pcName[ x ] == ( char ) 0x00 )
    6a0c:	89 81       	ldd	r24, Y+1	; 0x01
    6a0e:	28 2f       	mov	r18, r24
    6a10:	30 e0       	ldi	r19, 0x00	; 0
    6a12:	8e 81       	ldd	r24, Y+6	; 0x06
    6a14:	9f 81       	ldd	r25, Y+7	; 0x07
    6a16:	fc 01       	movw	r30, r24
    6a18:	e2 0f       	add	r30, r18
    6a1a:	f3 1f       	adc	r31, r19
    6a1c:	80 81       	ld	r24, Z
    6a1e:	88 23       	and	r24, r24
    6a20:	31 f0       	breq	.+12     	; 0x6a2e <prvInitialiseNewTask+0xb2>
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    6a22:	89 81       	ldd	r24, Y+1	; 0x01
    6a24:	8f 5f       	subi	r24, 0xFF	; 255
    6a26:	89 83       	std	Y+1, r24	; 0x01
    6a28:	89 81       	ldd	r24, Y+1	; 0x01
    6a2a:	88 30       	cpi	r24, 0x08	; 8
    6a2c:	e0 f2       	brcs	.-72     	; 0x69e6 <prvInitialiseNewTask+0x6a>
            }
        }

        /* Ensure the name string is terminated in the case that the string length
         * was greater or equal to configMAX_TASK_NAME_LEN. */
        pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    6a2e:	e9 89       	ldd	r30, Y+17	; 0x11
    6a30:	fa 89       	ldd	r31, Y+18	; 0x12
    6a32:	10 a2       	std	Z+32, r1	; 0x20
    6a34:	03 c0       	rjmp	.+6      	; 0x6a3c <prvInitialiseNewTask+0xc0>
    }
    else
    {
        /* The task has not been given a name, so just ensure there is a NULL
         * terminator when it is read out. */
        pxNewTCB->pcTaskName[ 0 ] = 0x00;
    6a36:	e9 89       	ldd	r30, Y+17	; 0x11
    6a38:	fa 89       	ldd	r31, Y+18	; 0x12
    6a3a:	11 8e       	std	Z+25, r1	; 0x19
    }

    /* This is used as an array index so must ensure it's not too large. */
    configASSERT( uxPriority < configMAX_PRIORITIES );
    if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    6a3c:	8e 85       	ldd	r24, Y+14	; 0x0e
    6a3e:	84 30       	cpi	r24, 0x04	; 4
    6a40:	10 f0       	brcs	.+4      	; 0x6a46 <prvInitialiseNewTask+0xca>
    {
        uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    6a42:	83 e0       	ldi	r24, 0x03	; 3
    6a44:	8e 87       	std	Y+14, r24	; 0x0e
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxNewTCB->uxPriority = uxPriority;
    6a46:	e9 89       	ldd	r30, Y+17	; 0x11
    6a48:	fa 89       	ldd	r31, Y+18	; 0x12
    6a4a:	8e 85       	ldd	r24, Y+14	; 0x0e
    6a4c:	86 8b       	std	Z+22, r24	; 0x16
    #if ( configUSE_MUTEXES == 1 )
        {
            pxNewTCB->uxBasePriority = uxPriority;
    6a4e:	e9 89       	ldd	r30, Y+17	; 0x11
    6a50:	fa 89       	ldd	r31, Y+18	; 0x12
    6a52:	8e 85       	ldd	r24, Y+14	; 0x0e
    6a54:	81 a3       	std	Z+33, r24	; 0x21
            pxNewTCB->uxMutexesHeld = 0;
    6a56:	e9 89       	ldd	r30, Y+17	; 0x11
    6a58:	fa 89       	ldd	r31, Y+18	; 0x12
    6a5a:	12 a2       	std	Z+34, r1	; 0x22
        }
    #endif /* configUSE_MUTEXES */

    vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    6a5c:	89 89       	ldd	r24, Y+17	; 0x11
    6a5e:	9a 89       	ldd	r25, Y+18	; 0x12
    6a60:	02 96       	adiw	r24, 0x02	; 2
    6a62:	0e 94 bc 1e 	call	0x3d78	; 0x3d78 <vListInitialiseItem>
    vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    6a66:	89 89       	ldd	r24, Y+17	; 0x11
    6a68:	9a 89       	ldd	r25, Y+18	; 0x12
    6a6a:	0c 96       	adiw	r24, 0x0c	; 12
    6a6c:	0e 94 bc 1e 	call	0x3d78	; 0x3d78 <vListInitialiseItem>

    /* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
     * back to  the containing TCB from a generic item in a list. */
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    6a70:	e9 89       	ldd	r30, Y+17	; 0x11
    6a72:	fa 89       	ldd	r31, Y+18	; 0x12
    6a74:	89 89       	ldd	r24, Y+17	; 0x11
    6a76:	9a 89       	ldd	r25, Y+18	; 0x12
    6a78:	91 87       	std	Z+9, r25	; 0x09
    6a7a:	80 87       	std	Z+8, r24	; 0x08

    /* Event lists are always in priority order. */
    listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    6a7c:	8e 85       	ldd	r24, Y+14	; 0x0e
    6a7e:	28 2f       	mov	r18, r24
    6a80:	30 e0       	ldi	r19, 0x00	; 0
    6a82:	84 e0       	ldi	r24, 0x04	; 4
    6a84:	90 e0       	ldi	r25, 0x00	; 0
    6a86:	82 1b       	sub	r24, r18
    6a88:	93 0b       	sbc	r25, r19
    6a8a:	e9 89       	ldd	r30, Y+17	; 0x11
    6a8c:	fa 89       	ldd	r31, Y+18	; 0x12
    6a8e:	95 87       	std	Z+13, r25	; 0x0d
    6a90:	84 87       	std	Z+12, r24	; 0x0c
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    6a92:	e9 89       	ldd	r30, Y+17	; 0x11
    6a94:	fa 89       	ldd	r31, Y+18	; 0x12
    6a96:	89 89       	ldd	r24, Y+17	; 0x11
    6a98:	9a 89       	ldd	r25, Y+18	; 0x12
    6a9a:	93 8b       	std	Z+19, r25	; 0x13
    6a9c:	82 8b       	std	Z+18, r24	; 0x12
        }
    #endif

    #if ( configUSE_TASK_NOTIFICATIONS == 1 )
        {
            memset( ( void * ) &( pxNewTCB->ulNotifiedValue[ 0 ] ), 0x00, sizeof( pxNewTCB->ulNotifiedValue ) );
    6a9e:	89 89       	ldd	r24, Y+17	; 0x11
    6aa0:	9a 89       	ldd	r25, Y+18	; 0x12
    6aa2:	83 96       	adiw	r24, 0x23	; 35
    6aa4:	60 e0       	ldi	r22, 0x00	; 0
    6aa6:	70 e0       	ldi	r23, 0x00	; 0
    6aa8:	44 e0       	ldi	r20, 0x04	; 4
    6aaa:	50 e0       	ldi	r21, 0x00	; 0
    6aac:	0e 94 89 4c 	call	0x9912	; 0x9912 <memset>
            memset( ( void * ) &( pxNewTCB->ucNotifyState[ 0 ] ), 0x00, sizeof( pxNewTCB->ucNotifyState ) );
    6ab0:	89 89       	ldd	r24, Y+17	; 0x11
    6ab2:	9a 89       	ldd	r25, Y+18	; 0x12
    6ab4:	87 96       	adiw	r24, 0x27	; 39
    6ab6:	60 e0       	ldi	r22, 0x00	; 0
    6ab8:	70 e0       	ldi	r23, 0x00	; 0
    6aba:	41 e0       	ldi	r20, 0x01	; 1
    6abc:	50 e0       	ldi	r21, 0x00	; 0
    6abe:	0e 94 89 4c 	call	0x9912	; 0x9912 <memset>
                        }
                    #endif /* portSTACK_GROWTH */
                }
            #else /* portHAS_STACK_OVERFLOW_CHECKING */
                {
                    pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    6ac2:	8a 81       	ldd	r24, Y+2	; 0x02
    6ac4:	9b 81       	ldd	r25, Y+3	; 0x03
    6ac6:	2c 81       	ldd	r18, Y+4	; 0x04
    6ac8:	3d 81       	ldd	r19, Y+5	; 0x05
    6aca:	4c 85       	ldd	r20, Y+12	; 0x0c
    6acc:	5d 85       	ldd	r21, Y+13	; 0x0d
    6ace:	b9 01       	movw	r22, r18
    6ad0:	0e 94 c8 1f 	call	0x3f90	; 0x3f90 <pxPortInitialiseStack>
    6ad4:	e9 89       	ldd	r30, Y+17	; 0x11
    6ad6:	fa 89       	ldd	r31, Y+18	; 0x12
    6ad8:	91 83       	std	Z+1, r25	; 0x01
    6ada:	80 83       	st	Z, r24
                }
            #endif /* portHAS_STACK_OVERFLOW_CHECKING */
        }
    #endif /* portUSING_MPU_WRAPPERS */

    if( pxCreatedTask != NULL )
    6adc:	8f 85       	ldd	r24, Y+15	; 0x0f
    6ade:	98 89       	ldd	r25, Y+16	; 0x10
    6ae0:	00 97       	sbiw	r24, 0x00	; 0
    6ae2:	31 f0       	breq	.+12     	; 0x6af0 <prvInitialiseNewTask+0x174>
    {
        /* Pass the handle out in an anonymous way.  The handle can be used to
         * change the created task's priority, delete the created task, etc.*/
        *pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    6ae4:	ef 85       	ldd	r30, Y+15	; 0x0f
    6ae6:	f8 89       	ldd	r31, Y+16	; 0x10
    6ae8:	89 89       	ldd	r24, Y+17	; 0x11
    6aea:	9a 89       	ldd	r25, Y+18	; 0x12
    6aec:	91 83       	std	Z+1, r25	; 0x01
    6aee:	80 83       	st	Z, r24
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }
}
    6af0:	64 96       	adiw	r28, 0x14	; 20
    6af2:	0f b6       	in	r0, 0x3f	; 63
    6af4:	f8 94       	cli
    6af6:	de bf       	out	0x3e, r29	; 62
    6af8:	0f be       	out	0x3f, r0	; 63
    6afa:	cd bf       	out	0x3d, r28	; 61
    6afc:	cf 91       	pop	r28
    6afe:	df 91       	pop	r29
    6b00:	1f 91       	pop	r17
    6b02:	0f 91       	pop	r16
    6b04:	ef 90       	pop	r14
    6b06:	df 90       	pop	r13
    6b08:	cf 90       	pop	r12
    6b0a:	bf 90       	pop	r11
    6b0c:	af 90       	pop	r10
    6b0e:	9f 90       	pop	r9
    6b10:	8f 90       	pop	r8
    6b12:	08 95       	ret

00006b14 <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t * pxNewTCB )
{
    6b14:	df 93       	push	r29
    6b16:	cf 93       	push	r28
    6b18:	00 d0       	rcall	.+0      	; 0x6b1a <prvAddNewTaskToReadyList+0x6>
    6b1a:	00 d0       	rcall	.+0      	; 0x6b1c <prvAddNewTaskToReadyList+0x8>
    6b1c:	cd b7       	in	r28, 0x3d	; 61
    6b1e:	de b7       	in	r29, 0x3e	; 62
    6b20:	9c 83       	std	Y+4, r25	; 0x04
    6b22:	8b 83       	std	Y+3, r24	; 0x03
    /* Ensure interrupts don't access the task lists while the lists are being
     * updated. */
    taskENTER_CRITICAL();
    6b24:	0f b6       	in	r0, 0x3f	; 63
    6b26:	f8 94       	cli
    6b28:	0f 92       	push	r0
    {
        uxCurrentNumberOfTasks++;
    6b2a:	80 91 a3 07 	lds	r24, 0x07A3
    6b2e:	8f 5f       	subi	r24, 0xFF	; 255
    6b30:	80 93 a3 07 	sts	0x07A3, r24

        if( pxCurrentTCB == NULL )
    6b34:	80 91 a0 07 	lds	r24, 0x07A0
    6b38:	90 91 a1 07 	lds	r25, 0x07A1
    6b3c:	00 97       	sbiw	r24, 0x00	; 0
    6b3e:	69 f4       	brne	.+26     	; 0x6b5a <prvAddNewTaskToReadyList+0x46>
        {
            /* There are no other tasks, or all the other tasks are in
             * the suspended state - make this the current task. */
            pxCurrentTCB = pxNewTCB;
    6b40:	8b 81       	ldd	r24, Y+3	; 0x03
    6b42:	9c 81       	ldd	r25, Y+4	; 0x04
    6b44:	90 93 a1 07 	sts	0x07A1, r25
    6b48:	80 93 a0 07 	sts	0x07A0, r24

            if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    6b4c:	80 91 a3 07 	lds	r24, 0x07A3
    6b50:	81 30       	cpi	r24, 0x01	; 1
    6b52:	b9 f4       	brne	.+46     	; 0x6b82 <prvAddNewTaskToReadyList+0x6e>
            {
                /* This is the first task to be created so do the preliminary
                 * initialisation required.  We will not recover if this call
                 * fails, but we will report the failure. */
                prvInitialiseTaskLists();
    6b54:	0e 94 fd 3e 	call	0x7dfa	; 0x7dfa <prvInitialiseTaskLists>
    6b58:	14 c0       	rjmp	.+40     	; 0x6b82 <prvAddNewTaskToReadyList+0x6e>
        else
        {
            /* If the scheduler is not already running, make this task the
             * current task if it is the highest priority task to be created
             * so far. */
            if( xSchedulerRunning == pdFALSE )
    6b5a:	80 91 a7 07 	lds	r24, 0x07A7
    6b5e:	88 23       	and	r24, r24
    6b60:	81 f4       	brne	.+32     	; 0x6b82 <prvAddNewTaskToReadyList+0x6e>
            {
                if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    6b62:	e0 91 a0 07 	lds	r30, 0x07A0
    6b66:	f0 91 a1 07 	lds	r31, 0x07A1
    6b6a:	96 89       	ldd	r25, Z+22	; 0x16
    6b6c:	eb 81       	ldd	r30, Y+3	; 0x03
    6b6e:	fc 81       	ldd	r31, Y+4	; 0x04
    6b70:	86 89       	ldd	r24, Z+22	; 0x16
    6b72:	89 17       	cp	r24, r25
    6b74:	30 f0       	brcs	.+12     	; 0x6b82 <prvAddNewTaskToReadyList+0x6e>
                {
                    pxCurrentTCB = pxNewTCB;
    6b76:	8b 81       	ldd	r24, Y+3	; 0x03
    6b78:	9c 81       	ldd	r25, Y+4	; 0x04
    6b7a:	90 93 a1 07 	sts	0x07A1, r25
    6b7e:	80 93 a0 07 	sts	0x07A0, r24
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }

        uxTaskNumber++;
    6b82:	80 91 ac 07 	lds	r24, 0x07AC
    6b86:	8f 5f       	subi	r24, 0xFF	; 255
    6b88:	80 93 ac 07 	sts	0x07AC, r24
                pxNewTCB->uxTCBNumber = uxTaskNumber;
            }
        #endif /* configUSE_TRACE_FACILITY */
        traceTASK_CREATE( pxNewTCB );

        prvAddTaskToReadyList( pxNewTCB );
    6b8c:	eb 81       	ldd	r30, Y+3	; 0x03
    6b8e:	fc 81       	ldd	r31, Y+4	; 0x04
    6b90:	96 89       	ldd	r25, Z+22	; 0x16
    6b92:	80 91 a6 07 	lds	r24, 0x07A6
    6b96:	89 17       	cp	r24, r25
    6b98:	28 f4       	brcc	.+10     	; 0x6ba4 <prvAddNewTaskToReadyList+0x90>
    6b9a:	eb 81       	ldd	r30, Y+3	; 0x03
    6b9c:	fc 81       	ldd	r31, Y+4	; 0x04
    6b9e:	86 89       	ldd	r24, Z+22	; 0x16
    6ba0:	80 93 a6 07 	sts	0x07A6, r24
    6ba4:	eb 81       	ldd	r30, Y+3	; 0x03
    6ba6:	fc 81       	ldd	r31, Y+4	; 0x04
    6ba8:	86 89       	ldd	r24, Z+22	; 0x16
    6baa:	28 2f       	mov	r18, r24
    6bac:	30 e0       	ldi	r19, 0x00	; 0
    6bae:	c9 01       	movw	r24, r18
    6bb0:	88 0f       	add	r24, r24
    6bb2:	99 1f       	adc	r25, r25
    6bb4:	88 0f       	add	r24, r24
    6bb6:	99 1f       	adc	r25, r25
    6bb8:	88 0f       	add	r24, r24
    6bba:	99 1f       	adc	r25, r25
    6bbc:	82 0f       	add	r24, r18
    6bbe:	93 1f       	adc	r25, r19
    6bc0:	fc 01       	movw	r30, r24
    6bc2:	ee 54       	subi	r30, 0x4E	; 78
    6bc4:	f8 4f       	sbci	r31, 0xF8	; 248
    6bc6:	81 81       	ldd	r24, Z+1	; 0x01
    6bc8:	92 81       	ldd	r25, Z+2	; 0x02
    6bca:	9a 83       	std	Y+2, r25	; 0x02
    6bcc:	89 83       	std	Y+1, r24	; 0x01
    6bce:	eb 81       	ldd	r30, Y+3	; 0x03
    6bd0:	fc 81       	ldd	r31, Y+4	; 0x04
    6bd2:	89 81       	ldd	r24, Y+1	; 0x01
    6bd4:	9a 81       	ldd	r25, Y+2	; 0x02
    6bd6:	95 83       	std	Z+5, r25	; 0x05
    6bd8:	84 83       	std	Z+4, r24	; 0x04
    6bda:	e9 81       	ldd	r30, Y+1	; 0x01
    6bdc:	fa 81       	ldd	r31, Y+2	; 0x02
    6bde:	84 81       	ldd	r24, Z+4	; 0x04
    6be0:	95 81       	ldd	r25, Z+5	; 0x05
    6be2:	eb 81       	ldd	r30, Y+3	; 0x03
    6be4:	fc 81       	ldd	r31, Y+4	; 0x04
    6be6:	97 83       	std	Z+7, r25	; 0x07
    6be8:	86 83       	std	Z+6, r24	; 0x06
    6bea:	e9 81       	ldd	r30, Y+1	; 0x01
    6bec:	fa 81       	ldd	r31, Y+2	; 0x02
    6bee:	04 80       	ldd	r0, Z+4	; 0x04
    6bf0:	f5 81       	ldd	r31, Z+5	; 0x05
    6bf2:	e0 2d       	mov	r30, r0
    6bf4:	8b 81       	ldd	r24, Y+3	; 0x03
    6bf6:	9c 81       	ldd	r25, Y+4	; 0x04
    6bf8:	02 96       	adiw	r24, 0x02	; 2
    6bfa:	93 83       	std	Z+3, r25	; 0x03
    6bfc:	82 83       	std	Z+2, r24	; 0x02
    6bfe:	8b 81       	ldd	r24, Y+3	; 0x03
    6c00:	9c 81       	ldd	r25, Y+4	; 0x04
    6c02:	02 96       	adiw	r24, 0x02	; 2
    6c04:	e9 81       	ldd	r30, Y+1	; 0x01
    6c06:	fa 81       	ldd	r31, Y+2	; 0x02
    6c08:	95 83       	std	Z+5, r25	; 0x05
    6c0a:	84 83       	std	Z+4, r24	; 0x04
    6c0c:	eb 81       	ldd	r30, Y+3	; 0x03
    6c0e:	fc 81       	ldd	r31, Y+4	; 0x04
    6c10:	86 89       	ldd	r24, Z+22	; 0x16
    6c12:	28 2f       	mov	r18, r24
    6c14:	30 e0       	ldi	r19, 0x00	; 0
    6c16:	c9 01       	movw	r24, r18
    6c18:	88 0f       	add	r24, r24
    6c1a:	99 1f       	adc	r25, r25
    6c1c:	88 0f       	add	r24, r24
    6c1e:	99 1f       	adc	r25, r25
    6c20:	88 0f       	add	r24, r24
    6c22:	99 1f       	adc	r25, r25
    6c24:	82 0f       	add	r24, r18
    6c26:	93 1f       	adc	r25, r19
    6c28:	8e 54       	subi	r24, 0x4E	; 78
    6c2a:	98 4f       	sbci	r25, 0xF8	; 248
    6c2c:	eb 81       	ldd	r30, Y+3	; 0x03
    6c2e:	fc 81       	ldd	r31, Y+4	; 0x04
    6c30:	93 87       	std	Z+11, r25	; 0x0b
    6c32:	82 87       	std	Z+10, r24	; 0x0a
    6c34:	eb 81       	ldd	r30, Y+3	; 0x03
    6c36:	fc 81       	ldd	r31, Y+4	; 0x04
    6c38:	86 89       	ldd	r24, Z+22	; 0x16
    6c3a:	28 2f       	mov	r18, r24
    6c3c:	30 e0       	ldi	r19, 0x00	; 0
    6c3e:	c9 01       	movw	r24, r18
    6c40:	88 0f       	add	r24, r24
    6c42:	99 1f       	adc	r25, r25
    6c44:	88 0f       	add	r24, r24
    6c46:	99 1f       	adc	r25, r25
    6c48:	88 0f       	add	r24, r24
    6c4a:	99 1f       	adc	r25, r25
    6c4c:	82 0f       	add	r24, r18
    6c4e:	93 1f       	adc	r25, r19
    6c50:	fc 01       	movw	r30, r24
    6c52:	ee 54       	subi	r30, 0x4E	; 78
    6c54:	f8 4f       	sbci	r31, 0xF8	; 248
    6c56:	80 81       	ld	r24, Z
    6c58:	8f 5f       	subi	r24, 0xFF	; 255
    6c5a:	80 83       	st	Z, r24

        portSETUP_TCB( pxNewTCB );
    }
    taskEXIT_CRITICAL();
    6c5c:	0f 90       	pop	r0
    6c5e:	0f be       	out	0x3f, r0	; 63

    if( xSchedulerRunning != pdFALSE )
    6c60:	80 91 a7 07 	lds	r24, 0x07A7
    6c64:	88 23       	and	r24, r24
    6c66:	61 f0       	breq	.+24     	; 0x6c80 <prvAddNewTaskToReadyList+0x16c>
    {
        /* If the created task is of a higher priority than the current task
         * then it should run now. */
        if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    6c68:	e0 91 a0 07 	lds	r30, 0x07A0
    6c6c:	f0 91 a1 07 	lds	r31, 0x07A1
    6c70:	96 89       	ldd	r25, Z+22	; 0x16
    6c72:	eb 81       	ldd	r30, Y+3	; 0x03
    6c74:	fc 81       	ldd	r31, Y+4	; 0x04
    6c76:	86 89       	ldd	r24, Z+22	; 0x16
    6c78:	98 17       	cp	r25, r24
    6c7a:	10 f4       	brcc	.+4      	; 0x6c80 <prvAddNewTaskToReadyList+0x16c>
        {
            taskYIELD_IF_USING_PREEMPTION();
    6c7c:	0e 94 87 21 	call	0x430e	; 0x430e <vPortYield>
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }
}
    6c80:	0f 90       	pop	r0
    6c82:	0f 90       	pop	r0
    6c84:	0f 90       	pop	r0
    6c86:	0f 90       	pop	r0
    6c88:	cf 91       	pop	r28
    6c8a:	df 91       	pop	r29
    6c8c:	08 95       	ret

00006c8e <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

    void vTaskDelete( TaskHandle_t xTaskToDelete )
    {
    6c8e:	df 93       	push	r29
    6c90:	cf 93       	push	r28
    6c92:	00 d0       	rcall	.+0      	; 0x6c94 <vTaskDelete+0x6>
    6c94:	00 d0       	rcall	.+0      	; 0x6c96 <vTaskDelete+0x8>
    6c96:	00 d0       	rcall	.+0      	; 0x6c98 <vTaskDelete+0xa>
    6c98:	cd b7       	in	r28, 0x3d	; 61
    6c9a:	de b7       	in	r29, 0x3e	; 62
    6c9c:	9c 83       	std	Y+4, r25	; 0x04
    6c9e:	8b 83       	std	Y+3, r24	; 0x03
        TCB_t * pxTCB;

        taskENTER_CRITICAL();
    6ca0:	0f b6       	in	r0, 0x3f	; 63
    6ca2:	f8 94       	cli
    6ca4:	0f 92       	push	r0
        {
            /* If null is passed in here then it is the calling task that is
             * being deleted. */
            pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    6ca6:	8b 81       	ldd	r24, Y+3	; 0x03
    6ca8:	9c 81       	ldd	r25, Y+4	; 0x04
    6caa:	00 97       	sbiw	r24, 0x00	; 0
    6cac:	39 f4       	brne	.+14     	; 0x6cbc <vTaskDelete+0x2e>
    6cae:	80 91 a0 07 	lds	r24, 0x07A0
    6cb2:	90 91 a1 07 	lds	r25, 0x07A1
    6cb6:	9e 83       	std	Y+6, r25	; 0x06
    6cb8:	8d 83       	std	Y+5, r24	; 0x05
    6cba:	04 c0       	rjmp	.+8      	; 0x6cc4 <vTaskDelete+0x36>
    6cbc:	8b 81       	ldd	r24, Y+3	; 0x03
    6cbe:	9c 81       	ldd	r25, Y+4	; 0x04
    6cc0:	9e 83       	std	Y+6, r25	; 0x06
    6cc2:	8d 83       	std	Y+5, r24	; 0x05
    6cc4:	8d 81       	ldd	r24, Y+5	; 0x05
    6cc6:	9e 81       	ldd	r25, Y+6	; 0x06
    6cc8:	9a 83       	std	Y+2, r25	; 0x02
    6cca:	89 83       	std	Y+1, r24	; 0x01

            /* Remove task from the ready/delayed list. */
            if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    6ccc:	89 81       	ldd	r24, Y+1	; 0x01
    6cce:	9a 81       	ldd	r25, Y+2	; 0x02
    6cd0:	02 96       	adiw	r24, 0x02	; 2
    6cd2:	0e 94 7c 1f 	call	0x3ef8	; 0x3ef8 <uxListRemove>
            {
                mtCOVERAGE_TEST_MARKER();
            }

            /* Is the task waiting on an event also? */
            if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    6cd6:	e9 81       	ldd	r30, Y+1	; 0x01
    6cd8:	fa 81       	ldd	r31, Y+2	; 0x02
    6cda:	84 89       	ldd	r24, Z+20	; 0x14
    6cdc:	95 89       	ldd	r25, Z+21	; 0x15
    6cde:	00 97       	sbiw	r24, 0x00	; 0
    6ce0:	29 f0       	breq	.+10     	; 0x6cec <vTaskDelete+0x5e>
            {
                ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    6ce2:	89 81       	ldd	r24, Y+1	; 0x01
    6ce4:	9a 81       	ldd	r25, Y+2	; 0x02
    6ce6:	0c 96       	adiw	r24, 0x0c	; 12
    6ce8:	0e 94 7c 1f 	call	0x3ef8	; 0x3ef8 <uxListRemove>

            /* Increment the uxTaskNumber also so kernel aware debuggers can
             * detect that the task lists need re-generating.  This is done before
             * portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
             * not return. */
            uxTaskNumber++;
    6cec:	80 91 ac 07 	lds	r24, 0x07AC
    6cf0:	8f 5f       	subi	r24, 0xFF	; 255
    6cf2:	80 93 ac 07 	sts	0x07AC, r24

            if( pxTCB == pxCurrentTCB )
    6cf6:	20 91 a0 07 	lds	r18, 0x07A0
    6cfa:	30 91 a1 07 	lds	r19, 0x07A1
    6cfe:	89 81       	ldd	r24, Y+1	; 0x01
    6d00:	9a 81       	ldd	r25, Y+2	; 0x02
    6d02:	82 17       	cp	r24, r18
    6d04:	93 07       	cpc	r25, r19
    6d06:	81 f4       	brne	.+32     	; 0x6d28 <vTaskDelete+0x9a>
                /* A task is deleting itself.  This cannot complete within the
                 * task itself, as a context switch to another task is required.
                 * Place the task in the termination list.  The idle task will
                 * check the termination list and free up any memory allocated by
                 * the scheduler for the TCB and stack of the deleted task. */
                vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
    6d08:	89 81       	ldd	r24, Y+1	; 0x01
    6d0a:	9a 81       	ldd	r25, Y+2	; 0x02
    6d0c:	9c 01       	movw	r18, r24
    6d0e:	2e 5f       	subi	r18, 0xFE	; 254
    6d10:	3f 4f       	sbci	r19, 0xFF	; 255
    6d12:	85 ef       	ldi	r24, 0xF5	; 245
    6d14:	97 e0       	ldi	r25, 0x07	; 7
    6d16:	b9 01       	movw	r22, r18
    6d18:	0e 94 cc 1e 	call	0x3d98	; 0x3d98 <vListInsertEnd>

                /* Increment the ucTasksDeleted variable so the idle task knows
                 * there is a task that has been deleted and that it should therefore
                 * check the xTasksWaitingTermination list. */
                ++uxDeletedTasksWaitingCleanUp;
    6d1c:	80 91 a2 07 	lds	r24, 0x07A2
    6d20:	8f 5f       	subi	r24, 0xFF	; 255
    6d22:	80 93 a2 07 	sts	0x07A2, r24
    6d26:	0b c0       	rjmp	.+22     	; 0x6d3e <vTaskDelete+0xb0>
                 * required. */
                portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
            }
            else
            {
                --uxCurrentNumberOfTasks;
    6d28:	80 91 a3 07 	lds	r24, 0x07A3
    6d2c:	81 50       	subi	r24, 0x01	; 1
    6d2e:	80 93 a3 07 	sts	0x07A3, r24
                traceTASK_DELETE( pxTCB );
                prvDeleteTCB( pxTCB );
    6d32:	89 81       	ldd	r24, Y+1	; 0x01
    6d34:	9a 81       	ldd	r25, Y+2	; 0x02
    6d36:	0e 94 69 3f 	call	0x7ed2	; 0x7ed2 <prvDeleteTCB>

                /* Reset the next expected unblock time in case it referred to
                 * the task that has just been deleted. */
                prvResetNextTaskUnblockTime();
    6d3a:	0e 94 7f 3f 	call	0x7efe	; 0x7efe <prvResetNextTaskUnblockTime>
            }
        }
        taskEXIT_CRITICAL();
    6d3e:	0f 90       	pop	r0
    6d40:	0f be       	out	0x3f, r0	; 63

        /* Force a reschedule if it is the currently running task that has just
         * been deleted. */
        if( xSchedulerRunning != pdFALSE )
    6d42:	80 91 a7 07 	lds	r24, 0x07A7
    6d46:	88 23       	and	r24, r24
    6d48:	59 f0       	breq	.+22     	; 0x6d60 <vTaskDelete+0xd2>
        {
            if( pxTCB == pxCurrentTCB )
    6d4a:	20 91 a0 07 	lds	r18, 0x07A0
    6d4e:	30 91 a1 07 	lds	r19, 0x07A1
    6d52:	89 81       	ldd	r24, Y+1	; 0x01
    6d54:	9a 81       	ldd	r25, Y+2	; 0x02
    6d56:	82 17       	cp	r24, r18
    6d58:	93 07       	cpc	r25, r19
    6d5a:	11 f4       	brne	.+4      	; 0x6d60 <vTaskDelete+0xd2>
            {
                configASSERT( uxSchedulerSuspended == 0 );
                portYIELD_WITHIN_API();
    6d5c:	0e 94 87 21 	call	0x430e	; 0x430e <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    }
    6d60:	26 96       	adiw	r28, 0x06	; 6
    6d62:	0f b6       	in	r0, 0x3f	; 63
    6d64:	f8 94       	cli
    6d66:	de bf       	out	0x3e, r29	; 62
    6d68:	0f be       	out	0x3f, r0	; 63
    6d6a:	cd bf       	out	0x3d, r28	; 61
    6d6c:	cf 91       	pop	r28
    6d6e:	df 91       	pop	r29
    6d70:	08 95       	ret

00006d72 <xTaskDelayUntil>:

#if ( INCLUDE_xTaskDelayUntil == 1 )

    BaseType_t xTaskDelayUntil( TickType_t * const pxPreviousWakeTime,
                                const TickType_t xTimeIncrement )
    {
    6d72:	df 93       	push	r29
    6d74:	cf 93       	push	r28
    6d76:	cd b7       	in	r28, 0x3d	; 61
    6d78:	de b7       	in	r29, 0x3e	; 62
    6d7a:	2a 97       	sbiw	r28, 0x0a	; 10
    6d7c:	0f b6       	in	r0, 0x3f	; 63
    6d7e:	f8 94       	cli
    6d80:	de bf       	out	0x3e, r29	; 62
    6d82:	0f be       	out	0x3f, r0	; 63
    6d84:	cd bf       	out	0x3d, r28	; 61
    6d86:	98 87       	std	Y+8, r25	; 0x08
    6d88:	8f 83       	std	Y+7, r24	; 0x07
    6d8a:	7a 87       	std	Y+10, r23	; 0x0a
    6d8c:	69 87       	std	Y+9, r22	; 0x09
        TickType_t xTimeToWake;
        BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
    6d8e:	1b 82       	std	Y+3, r1	; 0x03

        configASSERT( pxPreviousWakeTime );
        configASSERT( ( xTimeIncrement > 0U ) );
        configASSERT( uxSchedulerSuspended == 0 );

        vTaskSuspendAll();
    6d90:	0e 94 8f 37 	call	0x6f1e	; 0x6f1e <vTaskSuspendAll>
        {
            /* Minor optimisation.  The tick count cannot change in this
             * block. */
            const TickType_t xConstTickCount = xTickCount;
    6d94:	80 91 a4 07 	lds	r24, 0x07A4
    6d98:	90 91 a5 07 	lds	r25, 0x07A5
    6d9c:	9a 83       	std	Y+2, r25	; 0x02
    6d9e:	89 83       	std	Y+1, r24	; 0x01

            /* Generate the tick time at which the task wants to wake. */
            xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    6da0:	ef 81       	ldd	r30, Y+7	; 0x07
    6da2:	f8 85       	ldd	r31, Y+8	; 0x08
    6da4:	20 81       	ld	r18, Z
    6da6:	31 81       	ldd	r19, Z+1	; 0x01
    6da8:	89 85       	ldd	r24, Y+9	; 0x09
    6daa:	9a 85       	ldd	r25, Y+10	; 0x0a
    6dac:	82 0f       	add	r24, r18
    6dae:	93 1f       	adc	r25, r19
    6db0:	9e 83       	std	Y+6, r25	; 0x06
    6db2:	8d 83       	std	Y+5, r24	; 0x05

            if( xConstTickCount < *pxPreviousWakeTime )
    6db4:	ef 81       	ldd	r30, Y+7	; 0x07
    6db6:	f8 85       	ldd	r31, Y+8	; 0x08
    6db8:	20 81       	ld	r18, Z
    6dba:	31 81       	ldd	r19, Z+1	; 0x01
    6dbc:	89 81       	ldd	r24, Y+1	; 0x01
    6dbe:	9a 81       	ldd	r25, Y+2	; 0x02
    6dc0:	82 17       	cp	r24, r18
    6dc2:	93 07       	cpc	r25, r19
    6dc4:	98 f4       	brcc	.+38     	; 0x6dec <xTaskDelayUntil+0x7a>
                /* The tick count has overflowed since this function was
                 * lasted called.  In this case the only time we should ever
                 * actually delay is if the wake time has also  overflowed,
                 * and the wake time is greater than the tick time.  When this
                 * is the case it is as if neither time had overflowed. */
                if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    6dc6:	ef 81       	ldd	r30, Y+7	; 0x07
    6dc8:	f8 85       	ldd	r31, Y+8	; 0x08
    6dca:	20 81       	ld	r18, Z
    6dcc:	31 81       	ldd	r19, Z+1	; 0x01
    6dce:	8d 81       	ldd	r24, Y+5	; 0x05
    6dd0:	9e 81       	ldd	r25, Y+6	; 0x06
    6dd2:	82 17       	cp	r24, r18
    6dd4:	93 07       	cpc	r25, r19
    6dd6:	e0 f4       	brcc	.+56     	; 0x6e10 <xTaskDelayUntil+0x9e>
    6dd8:	2d 81       	ldd	r18, Y+5	; 0x05
    6dda:	3e 81       	ldd	r19, Y+6	; 0x06
    6ddc:	89 81       	ldd	r24, Y+1	; 0x01
    6dde:	9a 81       	ldd	r25, Y+2	; 0x02
    6de0:	82 17       	cp	r24, r18
    6de2:	93 07       	cpc	r25, r19
    6de4:	a8 f4       	brcc	.+42     	; 0x6e10 <xTaskDelayUntil+0x9e>
                {
                    xShouldDelay = pdTRUE;
    6de6:	81 e0       	ldi	r24, 0x01	; 1
    6de8:	8b 83       	std	Y+3, r24	; 0x03
    6dea:	12 c0       	rjmp	.+36     	; 0x6e10 <xTaskDelayUntil+0x9e>
            else
            {
                /* The tick time has not overflowed.  In this case we will
                 * delay if either the wake time has overflowed, and/or the
                 * tick time is less than the wake time. */
                if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    6dec:	ef 81       	ldd	r30, Y+7	; 0x07
    6dee:	f8 85       	ldd	r31, Y+8	; 0x08
    6df0:	20 81       	ld	r18, Z
    6df2:	31 81       	ldd	r19, Z+1	; 0x01
    6df4:	8d 81       	ldd	r24, Y+5	; 0x05
    6df6:	9e 81       	ldd	r25, Y+6	; 0x06
    6df8:	82 17       	cp	r24, r18
    6dfa:	93 07       	cpc	r25, r19
    6dfc:	38 f0       	brcs	.+14     	; 0x6e0c <xTaskDelayUntil+0x9a>
    6dfe:	2d 81       	ldd	r18, Y+5	; 0x05
    6e00:	3e 81       	ldd	r19, Y+6	; 0x06
    6e02:	89 81       	ldd	r24, Y+1	; 0x01
    6e04:	9a 81       	ldd	r25, Y+2	; 0x02
    6e06:	82 17       	cp	r24, r18
    6e08:	93 07       	cpc	r25, r19
    6e0a:	10 f4       	brcc	.+4      	; 0x6e10 <xTaskDelayUntil+0x9e>
                {
                    xShouldDelay = pdTRUE;
    6e0c:	81 e0       	ldi	r24, 0x01	; 1
    6e0e:	8b 83       	std	Y+3, r24	; 0x03
                    mtCOVERAGE_TEST_MARKER();
                }
            }

            /* Update the wake time ready for the next call. */
            *pxPreviousWakeTime = xTimeToWake;
    6e10:	ef 81       	ldd	r30, Y+7	; 0x07
    6e12:	f8 85       	ldd	r31, Y+8	; 0x08
    6e14:	8d 81       	ldd	r24, Y+5	; 0x05
    6e16:	9e 81       	ldd	r25, Y+6	; 0x06
    6e18:	91 83       	std	Z+1, r25	; 0x01
    6e1a:	80 83       	st	Z, r24

            if( xShouldDelay != pdFALSE )
    6e1c:	8b 81       	ldd	r24, Y+3	; 0x03
    6e1e:	88 23       	and	r24, r24
    6e20:	49 f0       	breq	.+18     	; 0x6e34 <xTaskDelayUntil+0xc2>
            {
                traceTASK_DELAY_UNTIL( xTimeToWake );

                /* prvAddCurrentTaskToDelayedList() needs the block time, not
                 * the time to wake, so subtract the current tick count. */
                prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
    6e22:	8d 81       	ldd	r24, Y+5	; 0x05
    6e24:	9e 81       	ldd	r25, Y+6	; 0x06
    6e26:	29 81       	ldd	r18, Y+1	; 0x01
    6e28:	3a 81       	ldd	r19, Y+2	; 0x02
    6e2a:	82 1b       	sub	r24, r18
    6e2c:	93 0b       	sbc	r25, r19
    6e2e:	60 e0       	ldi	r22, 0x00	; 0
    6e30:	0e 94 ec 49 	call	0x93d8	; 0x93d8 <prvAddCurrentTaskToDelayedList>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        xAlreadyYielded = xTaskResumeAll();
    6e34:	0e 94 9b 37 	call	0x6f36	; 0x6f36 <xTaskResumeAll>
    6e38:	8c 83       	std	Y+4, r24	; 0x04

        /* Force a reschedule if xTaskResumeAll has not already done so, we may
         * have put ourselves to sleep. */
        if( xAlreadyYielded == pdFALSE )
    6e3a:	8c 81       	ldd	r24, Y+4	; 0x04
    6e3c:	88 23       	and	r24, r24
    6e3e:	11 f4       	brne	.+4      	; 0x6e44 <xTaskDelayUntil+0xd2>
        {
            portYIELD_WITHIN_API();
    6e40:	0e 94 87 21 	call	0x430e	; 0x430e <vPortYield>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xShouldDelay;
    6e44:	8b 81       	ldd	r24, Y+3	; 0x03
    }
    6e46:	2a 96       	adiw	r28, 0x0a	; 10
    6e48:	0f b6       	in	r0, 0x3f	; 63
    6e4a:	f8 94       	cli
    6e4c:	de bf       	out	0x3e, r29	; 62
    6e4e:	0f be       	out	0x3f, r0	; 63
    6e50:	cd bf       	out	0x3d, r28	; 61
    6e52:	cf 91       	pop	r28
    6e54:	df 91       	pop	r29
    6e56:	08 95       	ret

00006e58 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

    void vTaskDelay( const TickType_t xTicksToDelay )
    {
    6e58:	df 93       	push	r29
    6e5a:	cf 93       	push	r28
    6e5c:	00 d0       	rcall	.+0      	; 0x6e5e <vTaskDelay+0x6>
    6e5e:	0f 92       	push	r0
    6e60:	cd b7       	in	r28, 0x3d	; 61
    6e62:	de b7       	in	r29, 0x3e	; 62
    6e64:	9b 83       	std	Y+3, r25	; 0x03
    6e66:	8a 83       	std	Y+2, r24	; 0x02
        BaseType_t xAlreadyYielded = pdFALSE;
    6e68:	19 82       	std	Y+1, r1	; 0x01

        /* A delay time of zero just forces a reschedule. */
        if( xTicksToDelay > ( TickType_t ) 0U )
    6e6a:	8a 81       	ldd	r24, Y+2	; 0x02
    6e6c:	9b 81       	ldd	r25, Y+3	; 0x03
    6e6e:	00 97       	sbiw	r24, 0x00	; 0
    6e70:	51 f0       	breq	.+20     	; 0x6e86 <vTaskDelay+0x2e>
        {
            configASSERT( uxSchedulerSuspended == 0 );
            vTaskSuspendAll();
    6e72:	0e 94 8f 37 	call	0x6f1e	; 0x6f1e <vTaskSuspendAll>
                 * list or removed from the blocked list until the scheduler
                 * is resumed.
                 *
                 * This task cannot be in an event list as it is the currently
                 * executing task. */
                prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    6e76:	8a 81       	ldd	r24, Y+2	; 0x02
    6e78:	9b 81       	ldd	r25, Y+3	; 0x03
    6e7a:	60 e0       	ldi	r22, 0x00	; 0
    6e7c:	0e 94 ec 49 	call	0x93d8	; 0x93d8 <prvAddCurrentTaskToDelayedList>
            }
            xAlreadyYielded = xTaskResumeAll();
    6e80:	0e 94 9b 37 	call	0x6f36	; 0x6f36 <xTaskResumeAll>
    6e84:	89 83       	std	Y+1, r24	; 0x01
            mtCOVERAGE_TEST_MARKER();
        }

        /* Force a reschedule if xTaskResumeAll has not already done so, we may
         * have put ourselves to sleep. */
        if( xAlreadyYielded == pdFALSE )
    6e86:	89 81       	ldd	r24, Y+1	; 0x01
    6e88:	88 23       	and	r24, r24
    6e8a:	11 f4       	brne	.+4      	; 0x6e90 <vTaskDelay+0x38>
        {
            portYIELD_WITHIN_API();
    6e8c:	0e 94 87 21 	call	0x430e	; 0x430e <vPortYield>
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    6e90:	0f 90       	pop	r0
    6e92:	0f 90       	pop	r0
    6e94:	0f 90       	pop	r0
    6e96:	cf 91       	pop	r28
    6e98:	df 91       	pop	r29
    6e9a:	08 95       	ret

00006e9c <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    6e9c:	ef 92       	push	r14
    6e9e:	ff 92       	push	r15
    6ea0:	0f 93       	push	r16
    6ea2:	df 93       	push	r29
    6ea4:	cf 93       	push	r28
    6ea6:	00 d0       	rcall	.+0      	; 0x6ea8 <vTaskStartScheduler+0xc>
    6ea8:	cd b7       	in	r28, 0x3d	; 61
    6eaa:	de b7       	in	r29, 0x3e	; 62
            }
        }
    #else /* if ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
        {
            /* The Idle task is being created using dynamically allocated RAM. */
            xReturn = xTaskCreate( prvIdleTask,
    6eac:	8d ee       	ldi	r24, 0xED	; 237
    6eae:	9e e3       	ldi	r25, 0x3E	; 62
    6eb0:	20 e6       	ldi	r18, 0x60	; 96
    6eb2:	30 e0       	ldi	r19, 0x00	; 0
    6eb4:	ef ea       	ldi	r30, 0xAF	; 175
    6eb6:	f7 e0       	ldi	r31, 0x07	; 7
    6eb8:	b9 01       	movw	r22, r18
    6eba:	44 e6       	ldi	r20, 0x64	; 100
    6ebc:	50 e0       	ldi	r21, 0x00	; 0
    6ebe:	20 e0       	ldi	r18, 0x00	; 0
    6ec0:	30 e0       	ldi	r19, 0x00	; 0
    6ec2:	00 e0       	ldi	r16, 0x00	; 0
    6ec4:	7f 01       	movw	r14, r30
    6ec6:	0e 94 46 34 	call	0x688c	; 0x688c <xTaskCreate>
    6eca:	89 83       	std	Y+1, r24	; 0x01
                mtCOVERAGE_TEST_MARKER();
            }
        }
    #endif /* configUSE_TIMERS */

    if( xReturn == pdPASS )
    6ecc:	89 81       	ldd	r24, Y+1	; 0x01
    6ece:	81 30       	cpi	r24, 0x01	; 1
    6ed0:	81 f4       	brne	.+32     	; 0x6ef2 <vTaskStartScheduler+0x56>
        /* Interrupts are turned off here, to ensure a tick does not occur
         * before or during the call to xPortStartScheduler().  The stacks of
         * the created tasks contain a status word with interrupts switched on
         * so interrupts will automatically get re-enabled when the first task
         * starts to run. */
        portDISABLE_INTERRUPTS();
    6ed2:	f8 94       	cli
                 * for additional information. */
                _impure_ptr = &( pxCurrentTCB->xNewLib_reent );
            }
        #endif /* configUSE_NEWLIB_REENTRANT */

        xNextTaskUnblockTime = portMAX_DELAY;
    6ed4:	8f ef       	ldi	r24, 0xFF	; 255
    6ed6:	9f ef       	ldi	r25, 0xFF	; 255
    6ed8:	90 93 ae 07 	sts	0x07AE, r25
    6edc:	80 93 ad 07 	sts	0x07AD, r24
        xSchedulerRunning = pdTRUE;
    6ee0:	81 e0       	ldi	r24, 0x01	; 1
    6ee2:	80 93 a7 07 	sts	0x07A7, r24
        xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
    6ee6:	10 92 a5 07 	sts	0x07A5, r1
    6eea:	10 92 a4 07 	sts	0x07A4, r1

        traceTASK_SWITCHED_IN();

        /* Setting up the timer tick is hardware specific and thus in the
         * portable interface. */
        if( xPortStartScheduler() != pdFALSE )
    6eee:	0e 94 4b 21 	call	0x4296	; 0x4296 <xPortStartScheduler>
     * meaning xIdleTaskHandle is not used anywhere else. */
    ( void ) xIdleTaskHandle;

    /* OpenOCD makes use of uxTopUsedPriority for thread debugging. Prevent uxTopUsedPriority
     * from getting optimized out as it is no longer used by the kernel. */
    ( void ) uxTopUsedPriority;
    6ef2:	80 91 85 01 	lds	r24, 0x0185
}
    6ef6:	0f 90       	pop	r0
    6ef8:	0f 90       	pop	r0
    6efa:	cf 91       	pop	r28
    6efc:	df 91       	pop	r29
    6efe:	0f 91       	pop	r16
    6f00:	ff 90       	pop	r15
    6f02:	ef 90       	pop	r14
    6f04:	08 95       	ret

00006f06 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    6f06:	df 93       	push	r29
    6f08:	cf 93       	push	r28
    6f0a:	cd b7       	in	r28, 0x3d	; 61
    6f0c:	de b7       	in	r29, 0x3e	; 62
    /* Stop the scheduler interrupts and call the portable scheduler end
     * routine so the original ISRs can be restored if necessary.  The port
     * layer must ensure interrupts enable  bit is left in the correct state. */
    portDISABLE_INTERRUPTS();
    6f0e:	f8 94       	cli
    xSchedulerRunning = pdFALSE;
    6f10:	10 92 a7 07 	sts	0x07A7, r1
    vPortEndScheduler();
    6f14:	0e 94 80 21 	call	0x4300	; 0x4300 <vPortEndScheduler>
}
    6f18:	cf 91       	pop	r28
    6f1a:	df 91       	pop	r29
    6f1c:	08 95       	ret

00006f1e <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    6f1e:	df 93       	push	r29
    6f20:	cf 93       	push	r28
    6f22:	cd b7       	in	r28, 0x3d	; 61
    6f24:	de b7       	in	r29, 0x3e	; 62
     * do not otherwise exhibit real time behaviour. */
    portSOFTWARE_BARRIER();

    /* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
     * is used to allow calls to vTaskSuspendAll() to nest. */
    ++uxSchedulerSuspended;
    6f26:	80 91 b1 07 	lds	r24, 0x07B1
    6f2a:	8f 5f       	subi	r24, 0xFF	; 255
    6f2c:	80 93 b1 07 	sts	0x07B1, r24

    /* Enforces ordering for ports and optimised compilers that may otherwise place
     * the above increment elsewhere. */
    portMEMORY_BARRIER();
}
    6f30:	cf 91       	pop	r28
    6f32:	df 91       	pop	r29
    6f34:	08 95       	ret

00006f36 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    6f36:	df 93       	push	r29
    6f38:	cf 93       	push	r28
    6f3a:	cd b7       	in	r28, 0x3d	; 61
    6f3c:	de b7       	in	r29, 0x3e	; 62
    6f3e:	2b 97       	sbiw	r28, 0x0b	; 11
    6f40:	0f b6       	in	r0, 0x3f	; 63
    6f42:	f8 94       	cli
    6f44:	de bf       	out	0x3e, r29	; 62
    6f46:	0f be       	out	0x3f, r0	; 63
    6f48:	cd bf       	out	0x3d, r28	; 61
    TCB_t * pxTCB = NULL;
    6f4a:	1b 86       	std	Y+11, r1	; 0x0b
    6f4c:	1a 86       	std	Y+10, r1	; 0x0a
    BaseType_t xAlreadyYielded = pdFALSE;
    6f4e:	19 86       	std	Y+9, r1	; 0x09
    /* It is possible that an ISR caused a task to be removed from an event
     * list while the scheduler was suspended.  If this was the case then the
     * removed task will have been added to the xPendingReadyList.  Once the
     * scheduler has been resumed it is safe to move all the pending ready
     * tasks from this list into their appropriate ready list. */
    taskENTER_CRITICAL();
    6f50:	0f b6       	in	r0, 0x3f	; 63
    6f52:	f8 94       	cli
    6f54:	0f 92       	push	r0
    {
        --uxSchedulerSuspended;
    6f56:	80 91 b1 07 	lds	r24, 0x07B1
    6f5a:	81 50       	subi	r24, 0x01	; 1
    6f5c:	80 93 b1 07 	sts	0x07B1, r24

        if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    6f60:	80 91 b1 07 	lds	r24, 0x07B1
    6f64:	88 23       	and	r24, r24
    6f66:	09 f0       	breq	.+2      	; 0x6f6a <xTaskResumeAll+0x34>
    6f68:	2a c1       	rjmp	.+596    	; 0x71be <xTaskResumeAll+0x288>
        {
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    6f6a:	80 91 a3 07 	lds	r24, 0x07A3
    6f6e:	88 23       	and	r24, r24
    6f70:	09 f4       	brne	.+2      	; 0x6f74 <xTaskResumeAll+0x3e>
    6f72:	25 c1       	rjmp	.+586    	; 0x71be <xTaskResumeAll+0x288>
    6f74:	f3 c0       	rjmp	.+486    	; 0x715c <xTaskResumeAll+0x226>
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    6f76:	e0 91 f1 07 	lds	r30, 0x07F1
    6f7a:	f0 91 f2 07 	lds	r31, 0x07F2
    6f7e:	86 81       	ldd	r24, Z+6	; 0x06
    6f80:	97 81       	ldd	r25, Z+7	; 0x07
    6f82:	9b 87       	std	Y+11, r25	; 0x0b
    6f84:	8a 87       	std	Y+10, r24	; 0x0a
                    listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
    6f86:	ea 85       	ldd	r30, Y+10	; 0x0a
    6f88:	fb 85       	ldd	r31, Y+11	; 0x0b
    6f8a:	84 89       	ldd	r24, Z+20	; 0x14
    6f8c:	95 89       	ldd	r25, Z+21	; 0x15
    6f8e:	98 87       	std	Y+8, r25	; 0x08
    6f90:	8f 83       	std	Y+7, r24	; 0x07
    6f92:	ea 85       	ldd	r30, Y+10	; 0x0a
    6f94:	fb 85       	ldd	r31, Y+11	; 0x0b
    6f96:	a6 85       	ldd	r26, Z+14	; 0x0e
    6f98:	b7 85       	ldd	r27, Z+15	; 0x0f
    6f9a:	ea 85       	ldd	r30, Y+10	; 0x0a
    6f9c:	fb 85       	ldd	r31, Y+11	; 0x0b
    6f9e:	80 89       	ldd	r24, Z+16	; 0x10
    6fa0:	91 89       	ldd	r25, Z+17	; 0x11
    6fa2:	15 96       	adiw	r26, 0x05	; 5
    6fa4:	9c 93       	st	X, r25
    6fa6:	8e 93       	st	-X, r24
    6fa8:	14 97       	sbiw	r26, 0x04	; 4
    6faa:	ea 85       	ldd	r30, Y+10	; 0x0a
    6fac:	fb 85       	ldd	r31, Y+11	; 0x0b
    6fae:	a0 89       	ldd	r26, Z+16	; 0x10
    6fb0:	b1 89       	ldd	r27, Z+17	; 0x11
    6fb2:	ea 85       	ldd	r30, Y+10	; 0x0a
    6fb4:	fb 85       	ldd	r31, Y+11	; 0x0b
    6fb6:	86 85       	ldd	r24, Z+14	; 0x0e
    6fb8:	97 85       	ldd	r25, Z+15	; 0x0f
    6fba:	13 96       	adiw	r26, 0x03	; 3
    6fbc:	9c 93       	st	X, r25
    6fbe:	8e 93       	st	-X, r24
    6fc0:	12 97       	sbiw	r26, 0x02	; 2
    6fc2:	ef 81       	ldd	r30, Y+7	; 0x07
    6fc4:	f8 85       	ldd	r31, Y+8	; 0x08
    6fc6:	21 81       	ldd	r18, Z+1	; 0x01
    6fc8:	32 81       	ldd	r19, Z+2	; 0x02
    6fca:	8a 85       	ldd	r24, Y+10	; 0x0a
    6fcc:	9b 85       	ldd	r25, Y+11	; 0x0b
    6fce:	0c 96       	adiw	r24, 0x0c	; 12
    6fd0:	28 17       	cp	r18, r24
    6fd2:	39 07       	cpc	r19, r25
    6fd4:	41 f4       	brne	.+16     	; 0x6fe6 <xTaskResumeAll+0xb0>
    6fd6:	ea 85       	ldd	r30, Y+10	; 0x0a
    6fd8:	fb 85       	ldd	r31, Y+11	; 0x0b
    6fda:	80 89       	ldd	r24, Z+16	; 0x10
    6fdc:	91 89       	ldd	r25, Z+17	; 0x11
    6fde:	ef 81       	ldd	r30, Y+7	; 0x07
    6fe0:	f8 85       	ldd	r31, Y+8	; 0x08
    6fe2:	92 83       	std	Z+2, r25	; 0x02
    6fe4:	81 83       	std	Z+1, r24	; 0x01
    6fe6:	ea 85       	ldd	r30, Y+10	; 0x0a
    6fe8:	fb 85       	ldd	r31, Y+11	; 0x0b
    6fea:	15 8a       	std	Z+21, r1	; 0x15
    6fec:	14 8a       	std	Z+20, r1	; 0x14
    6fee:	ef 81       	ldd	r30, Y+7	; 0x07
    6ff0:	f8 85       	ldd	r31, Y+8	; 0x08
    6ff2:	80 81       	ld	r24, Z
    6ff4:	81 50       	subi	r24, 0x01	; 1
    6ff6:	ef 81       	ldd	r30, Y+7	; 0x07
    6ff8:	f8 85       	ldd	r31, Y+8	; 0x08
    6ffa:	80 83       	st	Z, r24
                    portMEMORY_BARRIER();
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    6ffc:	ea 85       	ldd	r30, Y+10	; 0x0a
    6ffe:	fb 85       	ldd	r31, Y+11	; 0x0b
    7000:	82 85       	ldd	r24, Z+10	; 0x0a
    7002:	93 85       	ldd	r25, Z+11	; 0x0b
    7004:	9e 83       	std	Y+6, r25	; 0x06
    7006:	8d 83       	std	Y+5, r24	; 0x05
    7008:	ea 85       	ldd	r30, Y+10	; 0x0a
    700a:	fb 85       	ldd	r31, Y+11	; 0x0b
    700c:	a4 81       	ldd	r26, Z+4	; 0x04
    700e:	b5 81       	ldd	r27, Z+5	; 0x05
    7010:	ea 85       	ldd	r30, Y+10	; 0x0a
    7012:	fb 85       	ldd	r31, Y+11	; 0x0b
    7014:	86 81       	ldd	r24, Z+6	; 0x06
    7016:	97 81       	ldd	r25, Z+7	; 0x07
    7018:	15 96       	adiw	r26, 0x05	; 5
    701a:	9c 93       	st	X, r25
    701c:	8e 93       	st	-X, r24
    701e:	14 97       	sbiw	r26, 0x04	; 4
    7020:	ea 85       	ldd	r30, Y+10	; 0x0a
    7022:	fb 85       	ldd	r31, Y+11	; 0x0b
    7024:	a6 81       	ldd	r26, Z+6	; 0x06
    7026:	b7 81       	ldd	r27, Z+7	; 0x07
    7028:	ea 85       	ldd	r30, Y+10	; 0x0a
    702a:	fb 85       	ldd	r31, Y+11	; 0x0b
    702c:	84 81       	ldd	r24, Z+4	; 0x04
    702e:	95 81       	ldd	r25, Z+5	; 0x05
    7030:	13 96       	adiw	r26, 0x03	; 3
    7032:	9c 93       	st	X, r25
    7034:	8e 93       	st	-X, r24
    7036:	12 97       	sbiw	r26, 0x02	; 2
    7038:	ed 81       	ldd	r30, Y+5	; 0x05
    703a:	fe 81       	ldd	r31, Y+6	; 0x06
    703c:	21 81       	ldd	r18, Z+1	; 0x01
    703e:	32 81       	ldd	r19, Z+2	; 0x02
    7040:	8a 85       	ldd	r24, Y+10	; 0x0a
    7042:	9b 85       	ldd	r25, Y+11	; 0x0b
    7044:	02 96       	adiw	r24, 0x02	; 2
    7046:	28 17       	cp	r18, r24
    7048:	39 07       	cpc	r19, r25
    704a:	41 f4       	brne	.+16     	; 0x705c <xTaskResumeAll+0x126>
    704c:	ea 85       	ldd	r30, Y+10	; 0x0a
    704e:	fb 85       	ldd	r31, Y+11	; 0x0b
    7050:	86 81       	ldd	r24, Z+6	; 0x06
    7052:	97 81       	ldd	r25, Z+7	; 0x07
    7054:	ed 81       	ldd	r30, Y+5	; 0x05
    7056:	fe 81       	ldd	r31, Y+6	; 0x06
    7058:	92 83       	std	Z+2, r25	; 0x02
    705a:	81 83       	std	Z+1, r24	; 0x01
    705c:	ea 85       	ldd	r30, Y+10	; 0x0a
    705e:	fb 85       	ldd	r31, Y+11	; 0x0b
    7060:	13 86       	std	Z+11, r1	; 0x0b
    7062:	12 86       	std	Z+10, r1	; 0x0a
    7064:	ed 81       	ldd	r30, Y+5	; 0x05
    7066:	fe 81       	ldd	r31, Y+6	; 0x06
    7068:	80 81       	ld	r24, Z
    706a:	81 50       	subi	r24, 0x01	; 1
    706c:	ed 81       	ldd	r30, Y+5	; 0x05
    706e:	fe 81       	ldd	r31, Y+6	; 0x06
    7070:	80 83       	st	Z, r24
                    prvAddTaskToReadyList( pxTCB );
    7072:	ea 85       	ldd	r30, Y+10	; 0x0a
    7074:	fb 85       	ldd	r31, Y+11	; 0x0b
    7076:	96 89       	ldd	r25, Z+22	; 0x16
    7078:	80 91 a6 07 	lds	r24, 0x07A6
    707c:	89 17       	cp	r24, r25
    707e:	28 f4       	brcc	.+10     	; 0x708a <xTaskResumeAll+0x154>
    7080:	ea 85       	ldd	r30, Y+10	; 0x0a
    7082:	fb 85       	ldd	r31, Y+11	; 0x0b
    7084:	86 89       	ldd	r24, Z+22	; 0x16
    7086:	80 93 a6 07 	sts	0x07A6, r24
    708a:	ea 85       	ldd	r30, Y+10	; 0x0a
    708c:	fb 85       	ldd	r31, Y+11	; 0x0b
    708e:	86 89       	ldd	r24, Z+22	; 0x16
    7090:	28 2f       	mov	r18, r24
    7092:	30 e0       	ldi	r19, 0x00	; 0
    7094:	c9 01       	movw	r24, r18
    7096:	88 0f       	add	r24, r24
    7098:	99 1f       	adc	r25, r25
    709a:	88 0f       	add	r24, r24
    709c:	99 1f       	adc	r25, r25
    709e:	88 0f       	add	r24, r24
    70a0:	99 1f       	adc	r25, r25
    70a2:	82 0f       	add	r24, r18
    70a4:	93 1f       	adc	r25, r19
    70a6:	fc 01       	movw	r30, r24
    70a8:	ee 54       	subi	r30, 0x4E	; 78
    70aa:	f8 4f       	sbci	r31, 0xF8	; 248
    70ac:	81 81       	ldd	r24, Z+1	; 0x01
    70ae:	92 81       	ldd	r25, Z+2	; 0x02
    70b0:	9c 83       	std	Y+4, r25	; 0x04
    70b2:	8b 83       	std	Y+3, r24	; 0x03
    70b4:	ea 85       	ldd	r30, Y+10	; 0x0a
    70b6:	fb 85       	ldd	r31, Y+11	; 0x0b
    70b8:	8b 81       	ldd	r24, Y+3	; 0x03
    70ba:	9c 81       	ldd	r25, Y+4	; 0x04
    70bc:	95 83       	std	Z+5, r25	; 0x05
    70be:	84 83       	std	Z+4, r24	; 0x04
    70c0:	eb 81       	ldd	r30, Y+3	; 0x03
    70c2:	fc 81       	ldd	r31, Y+4	; 0x04
    70c4:	84 81       	ldd	r24, Z+4	; 0x04
    70c6:	95 81       	ldd	r25, Z+5	; 0x05
    70c8:	ea 85       	ldd	r30, Y+10	; 0x0a
    70ca:	fb 85       	ldd	r31, Y+11	; 0x0b
    70cc:	97 83       	std	Z+7, r25	; 0x07
    70ce:	86 83       	std	Z+6, r24	; 0x06
    70d0:	eb 81       	ldd	r30, Y+3	; 0x03
    70d2:	fc 81       	ldd	r31, Y+4	; 0x04
    70d4:	04 80       	ldd	r0, Z+4	; 0x04
    70d6:	f5 81       	ldd	r31, Z+5	; 0x05
    70d8:	e0 2d       	mov	r30, r0
    70da:	8a 85       	ldd	r24, Y+10	; 0x0a
    70dc:	9b 85       	ldd	r25, Y+11	; 0x0b
    70de:	02 96       	adiw	r24, 0x02	; 2
    70e0:	93 83       	std	Z+3, r25	; 0x03
    70e2:	82 83       	std	Z+2, r24	; 0x02
    70e4:	8a 85       	ldd	r24, Y+10	; 0x0a
    70e6:	9b 85       	ldd	r25, Y+11	; 0x0b
    70e8:	02 96       	adiw	r24, 0x02	; 2
    70ea:	eb 81       	ldd	r30, Y+3	; 0x03
    70ec:	fc 81       	ldd	r31, Y+4	; 0x04
    70ee:	95 83       	std	Z+5, r25	; 0x05
    70f0:	84 83       	std	Z+4, r24	; 0x04
    70f2:	ea 85       	ldd	r30, Y+10	; 0x0a
    70f4:	fb 85       	ldd	r31, Y+11	; 0x0b
    70f6:	86 89       	ldd	r24, Z+22	; 0x16
    70f8:	28 2f       	mov	r18, r24
    70fa:	30 e0       	ldi	r19, 0x00	; 0
    70fc:	c9 01       	movw	r24, r18
    70fe:	88 0f       	add	r24, r24
    7100:	99 1f       	adc	r25, r25
    7102:	88 0f       	add	r24, r24
    7104:	99 1f       	adc	r25, r25
    7106:	88 0f       	add	r24, r24
    7108:	99 1f       	adc	r25, r25
    710a:	82 0f       	add	r24, r18
    710c:	93 1f       	adc	r25, r19
    710e:	8e 54       	subi	r24, 0x4E	; 78
    7110:	98 4f       	sbci	r25, 0xF8	; 248
    7112:	ea 85       	ldd	r30, Y+10	; 0x0a
    7114:	fb 85       	ldd	r31, Y+11	; 0x0b
    7116:	93 87       	std	Z+11, r25	; 0x0b
    7118:	82 87       	std	Z+10, r24	; 0x0a
    711a:	ea 85       	ldd	r30, Y+10	; 0x0a
    711c:	fb 85       	ldd	r31, Y+11	; 0x0b
    711e:	86 89       	ldd	r24, Z+22	; 0x16
    7120:	28 2f       	mov	r18, r24
    7122:	30 e0       	ldi	r19, 0x00	; 0
    7124:	c9 01       	movw	r24, r18
    7126:	88 0f       	add	r24, r24
    7128:	99 1f       	adc	r25, r25
    712a:	88 0f       	add	r24, r24
    712c:	99 1f       	adc	r25, r25
    712e:	88 0f       	add	r24, r24
    7130:	99 1f       	adc	r25, r25
    7132:	82 0f       	add	r24, r18
    7134:	93 1f       	adc	r25, r19
    7136:	fc 01       	movw	r30, r24
    7138:	ee 54       	subi	r30, 0x4E	; 78
    713a:	f8 4f       	sbci	r31, 0xF8	; 248
    713c:	80 81       	ld	r24, Z
    713e:	8f 5f       	subi	r24, 0xFF	; 255
    7140:	80 83       	st	Z, r24

                    /* If the moved task has a priority higher than or equal to
                     * the current task then a yield must be performed. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    7142:	ea 85       	ldd	r30, Y+10	; 0x0a
    7144:	fb 85       	ldd	r31, Y+11	; 0x0b
    7146:	96 89       	ldd	r25, Z+22	; 0x16
    7148:	e0 91 a0 07 	lds	r30, 0x07A0
    714c:	f0 91 a1 07 	lds	r31, 0x07A1
    7150:	86 89       	ldd	r24, Z+22	; 0x16
    7152:	98 17       	cp	r25, r24
    7154:	18 f0       	brcs	.+6      	; 0x715c <xTaskResumeAll+0x226>
                    {
                        xYieldPending = pdTRUE;
    7156:	81 e0       	ldi	r24, 0x01	; 1
    7158:	80 93 aa 07 	sts	0x07AA, r24
        {
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    715c:	80 91 ec 07 	lds	r24, 0x07EC
    7160:	88 23       	and	r24, r24
    7162:	09 f0       	breq	.+2      	; 0x7166 <xTaskResumeAll+0x230>
    7164:	08 cf       	rjmp	.-496    	; 0x6f76 <xTaskResumeAll+0x40>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( pxTCB != NULL )
    7166:	8a 85       	ldd	r24, Y+10	; 0x0a
    7168:	9b 85       	ldd	r25, Y+11	; 0x0b
    716a:	00 97       	sbiw	r24, 0x00	; 0
    716c:	11 f0       	breq	.+4      	; 0x7172 <xTaskResumeAll+0x23c>
                     * which may have prevented the next unblock time from being
                     * re-calculated, in which case re-calculate it now.  Mainly
                     * important for low power tickless implementations, where
                     * this can prevent an unnecessary exit from low power
                     * state. */
                    prvResetNextTaskUnblockTime();
    716e:	0e 94 7f 3f 	call	0x7efe	; 0x7efe <prvResetNextTaskUnblockTime>
                /* If any ticks occurred while the scheduler was suspended then
                 * they should be processed now.  This ensures the tick count does
                 * not  slip, and that any delayed tasks are resumed at the correct
                 * time. */
                {
                    TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
    7172:	80 91 a8 07 	lds	r24, 0x07A8
    7176:	90 91 a9 07 	lds	r25, 0x07A9
    717a:	9a 83       	std	Y+2, r25	; 0x02
    717c:	89 83       	std	Y+1, r24	; 0x01

                    if( xPendedCounts > ( TickType_t ) 0U )
    717e:	89 81       	ldd	r24, Y+1	; 0x01
    7180:	9a 81       	ldd	r25, Y+2	; 0x02
    7182:	00 97       	sbiw	r24, 0x00	; 0
    7184:	a1 f0       	breq	.+40     	; 0x71ae <xTaskResumeAll+0x278>
                    {
                        do
                        {
                            if( xTaskIncrementTick() != pdFALSE )
    7186:	0e 94 68 39 	call	0x72d0	; 0x72d0 <xTaskIncrementTick>
    718a:	88 23       	and	r24, r24
    718c:	19 f0       	breq	.+6      	; 0x7194 <xTaskResumeAll+0x25e>
                            {
                                xYieldPending = pdTRUE;
    718e:	81 e0       	ldi	r24, 0x01	; 1
    7190:	80 93 aa 07 	sts	0x07AA, r24
                            else
                            {
                                mtCOVERAGE_TEST_MARKER();
                            }

                            --xPendedCounts;
    7194:	89 81       	ldd	r24, Y+1	; 0x01
    7196:	9a 81       	ldd	r25, Y+2	; 0x02
    7198:	01 97       	sbiw	r24, 0x01	; 1
    719a:	9a 83       	std	Y+2, r25	; 0x02
    719c:	89 83       	std	Y+1, r24	; 0x01
                        } while( xPendedCounts > ( TickType_t ) 0U );
    719e:	89 81       	ldd	r24, Y+1	; 0x01
    71a0:	9a 81       	ldd	r25, Y+2	; 0x02
    71a2:	00 97       	sbiw	r24, 0x00	; 0
    71a4:	81 f7       	brne	.-32     	; 0x7186 <xTaskResumeAll+0x250>

                        xPendedTicks = 0;
    71a6:	10 92 a9 07 	sts	0x07A9, r1
    71aa:	10 92 a8 07 	sts	0x07A8, r1
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( xYieldPending != pdFALSE )
    71ae:	80 91 aa 07 	lds	r24, 0x07AA
    71b2:	88 23       	and	r24, r24
    71b4:	21 f0       	breq	.+8      	; 0x71be <xTaskResumeAll+0x288>
                {
                    #if ( configUSE_PREEMPTION != 0 )
                        {
                            xAlreadyYielded = pdTRUE;
    71b6:	81 e0       	ldi	r24, 0x01	; 1
    71b8:	89 87       	std	Y+9, r24	; 0x09
                        }
                    #endif
                    taskYIELD_IF_USING_PREEMPTION();
    71ba:	0e 94 87 21 	call	0x430e	; 0x430e <vPortYield>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    taskEXIT_CRITICAL();
    71be:	0f 90       	pop	r0
    71c0:	0f be       	out	0x3f, r0	; 63

    return xAlreadyYielded;
    71c2:	89 85       	ldd	r24, Y+9	; 0x09
}
    71c4:	2b 96       	adiw	r28, 0x0b	; 11
    71c6:	0f b6       	in	r0, 0x3f	; 63
    71c8:	f8 94       	cli
    71ca:	de bf       	out	0x3e, r29	; 62
    71cc:	0f be       	out	0x3f, r0	; 63
    71ce:	cd bf       	out	0x3d, r28	; 61
    71d0:	cf 91       	pop	r28
    71d2:	df 91       	pop	r29
    71d4:	08 95       	ret

000071d6 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
    71d6:	df 93       	push	r29
    71d8:	cf 93       	push	r28
    71da:	00 d0       	rcall	.+0      	; 0x71dc <xTaskGetTickCount+0x6>
    71dc:	cd b7       	in	r28, 0x3d	; 61
    71de:	de b7       	in	r29, 0x3e	; 62
    TickType_t xTicks;

    /* Critical section required if running on a 16 bit processor. */
    portTICK_TYPE_ENTER_CRITICAL();
    71e0:	0f b6       	in	r0, 0x3f	; 63
    71e2:	f8 94       	cli
    71e4:	0f 92       	push	r0
    {
        xTicks = xTickCount;
    71e6:	80 91 a4 07 	lds	r24, 0x07A4
    71ea:	90 91 a5 07 	lds	r25, 0x07A5
    71ee:	9a 83       	std	Y+2, r25	; 0x02
    71f0:	89 83       	std	Y+1, r24	; 0x01
    }
    portTICK_TYPE_EXIT_CRITICAL();
    71f2:	0f 90       	pop	r0
    71f4:	0f be       	out	0x3f, r0	; 63

    return xTicks;
    71f6:	89 81       	ldd	r24, Y+1	; 0x01
    71f8:	9a 81       	ldd	r25, Y+2	; 0x02
}
    71fa:	0f 90       	pop	r0
    71fc:	0f 90       	pop	r0
    71fe:	cf 91       	pop	r28
    7200:	df 91       	pop	r29
    7202:	08 95       	ret

00007204 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
    7204:	df 93       	push	r29
    7206:	cf 93       	push	r28
    7208:	00 d0       	rcall	.+0      	; 0x720a <xTaskGetTickCountFromISR+0x6>
    720a:	0f 92       	push	r0
    720c:	cd b7       	in	r28, 0x3d	; 61
    720e:	de b7       	in	r29, 0x3e	; 62
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
    7210:	19 82       	std	Y+1, r1	; 0x01
    {
        xReturn = xTickCount;
    7212:	80 91 a4 07 	lds	r24, 0x07A4
    7216:	90 91 a5 07 	lds	r25, 0x07A5
    721a:	9b 83       	std	Y+3, r25	; 0x03
    721c:	8a 83       	std	Y+2, r24	; 0x02
    }
    portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    721e:	8a 81       	ldd	r24, Y+2	; 0x02
    7220:	9b 81       	ldd	r25, Y+3	; 0x03
}
    7222:	0f 90       	pop	r0
    7224:	0f 90       	pop	r0
    7226:	0f 90       	pop	r0
    7228:	cf 91       	pop	r28
    722a:	df 91       	pop	r29
    722c:	08 95       	ret

0000722e <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    722e:	df 93       	push	r29
    7230:	cf 93       	push	r28
    7232:	cd b7       	in	r28, 0x3d	; 61
    7234:	de b7       	in	r29, 0x3e	; 62
    /* A critical section is not required because the variables are of type
     * BaseType_t. */
    return uxCurrentNumberOfTasks;
    7236:	80 91 a3 07 	lds	r24, 0x07A3
}
    723a:	cf 91       	pop	r28
    723c:	df 91       	pop	r29
    723e:	08 95       	ret

00007240 <pcTaskGetName>:
/*-----------------------------------------------------------*/

char * pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    7240:	df 93       	push	r29
    7242:	cf 93       	push	r28
    7244:	00 d0       	rcall	.+0      	; 0x7246 <pcTaskGetName+0x6>
    7246:	00 d0       	rcall	.+0      	; 0x7248 <pcTaskGetName+0x8>
    7248:	00 d0       	rcall	.+0      	; 0x724a <pcTaskGetName+0xa>
    724a:	cd b7       	in	r28, 0x3d	; 61
    724c:	de b7       	in	r29, 0x3e	; 62
    724e:	9c 83       	std	Y+4, r25	; 0x04
    7250:	8b 83       	std	Y+3, r24	; 0x03
    TCB_t * pxTCB;

    /* If null is passed in here then the name of the calling task is being
     * queried. */
    pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    7252:	8b 81       	ldd	r24, Y+3	; 0x03
    7254:	9c 81       	ldd	r25, Y+4	; 0x04
    7256:	00 97       	sbiw	r24, 0x00	; 0
    7258:	39 f4       	brne	.+14     	; 0x7268 <pcTaskGetName+0x28>
    725a:	80 91 a0 07 	lds	r24, 0x07A0
    725e:	90 91 a1 07 	lds	r25, 0x07A1
    7262:	9e 83       	std	Y+6, r25	; 0x06
    7264:	8d 83       	std	Y+5, r24	; 0x05
    7266:	04 c0       	rjmp	.+8      	; 0x7270 <pcTaskGetName+0x30>
    7268:	8b 81       	ldd	r24, Y+3	; 0x03
    726a:	9c 81       	ldd	r25, Y+4	; 0x04
    726c:	9e 83       	std	Y+6, r25	; 0x06
    726e:	8d 83       	std	Y+5, r24	; 0x05
    7270:	8d 81       	ldd	r24, Y+5	; 0x05
    7272:	9e 81       	ldd	r25, Y+6	; 0x06
    7274:	9a 83       	std	Y+2, r25	; 0x02
    7276:	89 83       	std	Y+1, r24	; 0x01
    configASSERT( pxTCB );
    return &( pxTCB->pcTaskName[ 0 ] );
    7278:	89 81       	ldd	r24, Y+1	; 0x01
    727a:	9a 81       	ldd	r25, Y+2	; 0x02
    727c:	49 96       	adiw	r24, 0x19	; 25
}
    727e:	26 96       	adiw	r28, 0x06	; 6
    7280:	0f b6       	in	r0, 0x3f	; 63
    7282:	f8 94       	cli
    7284:	de bf       	out	0x3e, r29	; 62
    7286:	0f be       	out	0x3f, r0	; 63
    7288:	cd bf       	out	0x3d, r28	; 61
    728a:	cf 91       	pop	r28
    728c:	df 91       	pop	r29
    728e:	08 95       	ret

00007290 <xTaskCatchUpTicks>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskCatchUpTicks( TickType_t xTicksToCatchUp )
{
    7290:	df 93       	push	r29
    7292:	cf 93       	push	r28
    7294:	00 d0       	rcall	.+0      	; 0x7296 <xTaskCatchUpTicks+0x6>
    7296:	0f 92       	push	r0
    7298:	cd b7       	in	r28, 0x3d	; 61
    729a:	de b7       	in	r29, 0x3e	; 62
    729c:	9b 83       	std	Y+3, r25	; 0x03
    729e:	8a 83       	std	Y+2, r24	; 0x02
     * relies on xPendedTicks being wound down to 0 in xTaskResumeAll(). */
    configASSERT( uxSchedulerSuspended == 0 );

    /* Use xPendedTicks to mimic xTicksToCatchUp number of ticks occurring when
     * the scheduler is suspended so the ticks are executed in xTaskResumeAll(). */
    vTaskSuspendAll();
    72a0:	0e 94 8f 37 	call	0x6f1e	; 0x6f1e <vTaskSuspendAll>
    xPendedTicks += xTicksToCatchUp;
    72a4:	20 91 a8 07 	lds	r18, 0x07A8
    72a8:	30 91 a9 07 	lds	r19, 0x07A9
    72ac:	8a 81       	ldd	r24, Y+2	; 0x02
    72ae:	9b 81       	ldd	r25, Y+3	; 0x03
    72b0:	82 0f       	add	r24, r18
    72b2:	93 1f       	adc	r25, r19
    72b4:	90 93 a9 07 	sts	0x07A9, r25
    72b8:	80 93 a8 07 	sts	0x07A8, r24
    xYieldOccurred = xTaskResumeAll();
    72bc:	0e 94 9b 37 	call	0x6f36	; 0x6f36 <xTaskResumeAll>
    72c0:	89 83       	std	Y+1, r24	; 0x01

    return xYieldOccurred;
    72c2:	89 81       	ldd	r24, Y+1	; 0x01
}
    72c4:	0f 90       	pop	r0
    72c6:	0f 90       	pop	r0
    72c8:	0f 90       	pop	r0
    72ca:	cf 91       	pop	r28
    72cc:	df 91       	pop	r29
    72ce:	08 95       	ret

000072d0 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    72d0:	df 93       	push	r29
    72d2:	cf 93       	push	r28
    72d4:	cd b7       	in	r28, 0x3d	; 61
    72d6:	de b7       	in	r29, 0x3e	; 62
    72d8:	2f 97       	sbiw	r28, 0x0f	; 15
    72da:	0f b6       	in	r0, 0x3f	; 63
    72dc:	f8 94       	cli
    72de:	de bf       	out	0x3e, r29	; 62
    72e0:	0f be       	out	0x3f, r0	; 63
    72e2:	cd bf       	out	0x3d, r28	; 61
    TCB_t * pxTCB;
    TickType_t xItemValue;
    BaseType_t xSwitchRequired = pdFALSE;
    72e4:	1b 86       	std	Y+11, r1	; 0x0b
    /* Called by the portable layer each time a tick interrupt occurs.
     * Increments the tick then checks to see if the new tick value will cause any
     * tasks to be unblocked. */
    traceTASK_INCREMENT_TICK( xTickCount );

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    72e6:	80 91 b1 07 	lds	r24, 0x07B1
    72ea:	88 23       	and	r24, r24
    72ec:	09 f0       	breq	.+2      	; 0x72f0 <xTaskIncrementTick+0x20>
    72ee:	74 c1       	rjmp	.+744    	; 0x75d8 <xTaskIncrementTick+0x308>
    {
        /* Minor optimisation.  The tick count cannot change in this
         * block. */
        const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
    72f0:	80 91 a4 07 	lds	r24, 0x07A4
    72f4:	90 91 a5 07 	lds	r25, 0x07A5
    72f8:	01 96       	adiw	r24, 0x01	; 1
    72fa:	9a 87       	std	Y+10, r25	; 0x0a
    72fc:	89 87       	std	Y+9, r24	; 0x09

        /* Increment the RTOS tick, switching the delayed and overflowed
         * delayed lists if it wraps to 0. */
        xTickCount = xConstTickCount;
    72fe:	89 85       	ldd	r24, Y+9	; 0x09
    7300:	9a 85       	ldd	r25, Y+10	; 0x0a
    7302:	90 93 a5 07 	sts	0x07A5, r25
    7306:	80 93 a4 07 	sts	0x07A4, r24

        if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
    730a:	89 85       	ldd	r24, Y+9	; 0x09
    730c:	9a 85       	ldd	r25, Y+10	; 0x0a
    730e:	00 97       	sbiw	r24, 0x00	; 0
    7310:	d9 f4       	brne	.+54     	; 0x7348 <xTaskIncrementTick+0x78>
        {
            taskSWITCH_DELAYED_LISTS();
    7312:	80 91 e8 07 	lds	r24, 0x07E8
    7316:	90 91 e9 07 	lds	r25, 0x07E9
    731a:	98 87       	std	Y+8, r25	; 0x08
    731c:	8f 83       	std	Y+7, r24	; 0x07
    731e:	80 91 ea 07 	lds	r24, 0x07EA
    7322:	90 91 eb 07 	lds	r25, 0x07EB
    7326:	90 93 e9 07 	sts	0x07E9, r25
    732a:	80 93 e8 07 	sts	0x07E8, r24
    732e:	8f 81       	ldd	r24, Y+7	; 0x07
    7330:	98 85       	ldd	r25, Y+8	; 0x08
    7332:	90 93 eb 07 	sts	0x07EB, r25
    7336:	80 93 ea 07 	sts	0x07EA, r24
    733a:	80 91 ab 07 	lds	r24, 0x07AB
    733e:	8f 5f       	subi	r24, 0xFF	; 255
    7340:	80 93 ab 07 	sts	0x07AB, r24
    7344:	0e 94 7f 3f 	call	0x7efe	; 0x7efe <prvResetNextTaskUnblockTime>

        /* See if this tick has made a timeout expire.  Tasks are stored in
         * the  queue in the order of their wake time - meaning once one task
         * has been found whose block time has not expired there is no need to
         * look any further down the list. */
        if( xConstTickCount >= xNextTaskUnblockTime )
    7348:	20 91 ad 07 	lds	r18, 0x07AD
    734c:	30 91 ae 07 	lds	r19, 0x07AE
    7350:	89 85       	ldd	r24, Y+9	; 0x09
    7352:	9a 85       	ldd	r25, Y+10	; 0x0a
    7354:	82 17       	cp	r24, r18
    7356:	93 07       	cpc	r25, r19
    7358:	08 f4       	brcc	.+2      	; 0x735c <xTaskIncrementTick+0x8c>
    735a:	1f c1       	rjmp	.+574    	; 0x759a <xTaskIncrementTick+0x2ca>
        {
            for( ; ; )
            {
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    735c:	e0 91 e8 07 	lds	r30, 0x07E8
    7360:	f0 91 e9 07 	lds	r31, 0x07E9
    7364:	80 81       	ld	r24, Z
    7366:	88 23       	and	r24, r24
    7368:	39 f4       	brne	.+14     	; 0x7378 <xTaskIncrementTick+0xa8>
                    /* The delayed list is empty.  Set xNextTaskUnblockTime
                     * to the maximum possible value so it is extremely
                     * unlikely that the
                     * if( xTickCount >= xNextTaskUnblockTime ) test will pass
                     * next time through. */
                    xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    736a:	8f ef       	ldi	r24, 0xFF	; 255
    736c:	9f ef       	ldi	r25, 0xFF	; 255
    736e:	90 93 ae 07 	sts	0x07AE, r25
    7372:	80 93 ad 07 	sts	0x07AD, r24
    7376:	11 c1       	rjmp	.+546    	; 0x759a <xTaskIncrementTick+0x2ca>
                {
                    /* The delayed list is not empty, get the value of the
                     * item at the head of the delayed list.  This is the time
                     * at which the task at the head of the delayed list must
                     * be removed from the Blocked state. */
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    7378:	e0 91 e8 07 	lds	r30, 0x07E8
    737c:	f0 91 e9 07 	lds	r31, 0x07E9
    7380:	05 80       	ldd	r0, Z+5	; 0x05
    7382:	f6 81       	ldd	r31, Z+6	; 0x06
    7384:	e0 2d       	mov	r30, r0
    7386:	86 81       	ldd	r24, Z+6	; 0x06
    7388:	97 81       	ldd	r25, Z+7	; 0x07
    738a:	9f 87       	std	Y+15, r25	; 0x0f
    738c:	8e 87       	std	Y+14, r24	; 0x0e
                    xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    738e:	ee 85       	ldd	r30, Y+14	; 0x0e
    7390:	ff 85       	ldd	r31, Y+15	; 0x0f
    7392:	82 81       	ldd	r24, Z+2	; 0x02
    7394:	93 81       	ldd	r25, Z+3	; 0x03
    7396:	9d 87       	std	Y+13, r25	; 0x0d
    7398:	8c 87       	std	Y+12, r24	; 0x0c

                    if( xConstTickCount < xItemValue )
    739a:	29 85       	ldd	r18, Y+9	; 0x09
    739c:	3a 85       	ldd	r19, Y+10	; 0x0a
    739e:	8c 85       	ldd	r24, Y+12	; 0x0c
    73a0:	9d 85       	ldd	r25, Y+13	; 0x0d
    73a2:	28 17       	cp	r18, r24
    73a4:	39 07       	cpc	r19, r25
    73a6:	38 f4       	brcc	.+14     	; 0x73b6 <xTaskIncrementTick+0xe6>
                        /* It is not time to unblock this item yet, but the
                         * item value is the time at which the task at the head
                         * of the blocked list must be removed from the Blocked
                         * state -  so record the item value in
                         * xNextTaskUnblockTime. */
                        xNextTaskUnblockTime = xItemValue;
    73a8:	8c 85       	ldd	r24, Y+12	; 0x0c
    73aa:	9d 85       	ldd	r25, Y+13	; 0x0d
    73ac:	90 93 ae 07 	sts	0x07AE, r25
    73b0:	80 93 ad 07 	sts	0x07AD, r24
    73b4:	f2 c0       	rjmp	.+484    	; 0x759a <xTaskIncrementTick+0x2ca>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* It is time to remove the item from the Blocked state. */
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    73b6:	ee 85       	ldd	r30, Y+14	; 0x0e
    73b8:	ff 85       	ldd	r31, Y+15	; 0x0f
    73ba:	82 85       	ldd	r24, Z+10	; 0x0a
    73bc:	93 85       	ldd	r25, Z+11	; 0x0b
    73be:	9e 83       	std	Y+6, r25	; 0x06
    73c0:	8d 83       	std	Y+5, r24	; 0x05
    73c2:	ee 85       	ldd	r30, Y+14	; 0x0e
    73c4:	ff 85       	ldd	r31, Y+15	; 0x0f
    73c6:	a4 81       	ldd	r26, Z+4	; 0x04
    73c8:	b5 81       	ldd	r27, Z+5	; 0x05
    73ca:	ee 85       	ldd	r30, Y+14	; 0x0e
    73cc:	ff 85       	ldd	r31, Y+15	; 0x0f
    73ce:	86 81       	ldd	r24, Z+6	; 0x06
    73d0:	97 81       	ldd	r25, Z+7	; 0x07
    73d2:	15 96       	adiw	r26, 0x05	; 5
    73d4:	9c 93       	st	X, r25
    73d6:	8e 93       	st	-X, r24
    73d8:	14 97       	sbiw	r26, 0x04	; 4
    73da:	ee 85       	ldd	r30, Y+14	; 0x0e
    73dc:	ff 85       	ldd	r31, Y+15	; 0x0f
    73de:	a6 81       	ldd	r26, Z+6	; 0x06
    73e0:	b7 81       	ldd	r27, Z+7	; 0x07
    73e2:	ee 85       	ldd	r30, Y+14	; 0x0e
    73e4:	ff 85       	ldd	r31, Y+15	; 0x0f
    73e6:	84 81       	ldd	r24, Z+4	; 0x04
    73e8:	95 81       	ldd	r25, Z+5	; 0x05
    73ea:	13 96       	adiw	r26, 0x03	; 3
    73ec:	9c 93       	st	X, r25
    73ee:	8e 93       	st	-X, r24
    73f0:	12 97       	sbiw	r26, 0x02	; 2
    73f2:	ed 81       	ldd	r30, Y+5	; 0x05
    73f4:	fe 81       	ldd	r31, Y+6	; 0x06
    73f6:	21 81       	ldd	r18, Z+1	; 0x01
    73f8:	32 81       	ldd	r19, Z+2	; 0x02
    73fa:	8e 85       	ldd	r24, Y+14	; 0x0e
    73fc:	9f 85       	ldd	r25, Y+15	; 0x0f
    73fe:	02 96       	adiw	r24, 0x02	; 2
    7400:	28 17       	cp	r18, r24
    7402:	39 07       	cpc	r19, r25
    7404:	41 f4       	brne	.+16     	; 0x7416 <xTaskIncrementTick+0x146>
    7406:	ee 85       	ldd	r30, Y+14	; 0x0e
    7408:	ff 85       	ldd	r31, Y+15	; 0x0f
    740a:	86 81       	ldd	r24, Z+6	; 0x06
    740c:	97 81       	ldd	r25, Z+7	; 0x07
    740e:	ed 81       	ldd	r30, Y+5	; 0x05
    7410:	fe 81       	ldd	r31, Y+6	; 0x06
    7412:	92 83       	std	Z+2, r25	; 0x02
    7414:	81 83       	std	Z+1, r24	; 0x01
    7416:	ee 85       	ldd	r30, Y+14	; 0x0e
    7418:	ff 85       	ldd	r31, Y+15	; 0x0f
    741a:	13 86       	std	Z+11, r1	; 0x0b
    741c:	12 86       	std	Z+10, r1	; 0x0a
    741e:	ed 81       	ldd	r30, Y+5	; 0x05
    7420:	fe 81       	ldd	r31, Y+6	; 0x06
    7422:	80 81       	ld	r24, Z
    7424:	81 50       	subi	r24, 0x01	; 1
    7426:	ed 81       	ldd	r30, Y+5	; 0x05
    7428:	fe 81       	ldd	r31, Y+6	; 0x06
    742a:	80 83       	st	Z, r24

                    /* Is the task waiting on an event also?  If so remove
                     * it from the event list. */
                    if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    742c:	ee 85       	ldd	r30, Y+14	; 0x0e
    742e:	ff 85       	ldd	r31, Y+15	; 0x0f
    7430:	84 89       	ldd	r24, Z+20	; 0x14
    7432:	95 89       	ldd	r25, Z+21	; 0x15
    7434:	00 97       	sbiw	r24, 0x00	; 0
    7436:	d9 f1       	breq	.+118    	; 0x74ae <xTaskIncrementTick+0x1de>
                    {
                        listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
    7438:	ee 85       	ldd	r30, Y+14	; 0x0e
    743a:	ff 85       	ldd	r31, Y+15	; 0x0f
    743c:	84 89       	ldd	r24, Z+20	; 0x14
    743e:	95 89       	ldd	r25, Z+21	; 0x15
    7440:	9c 83       	std	Y+4, r25	; 0x04
    7442:	8b 83       	std	Y+3, r24	; 0x03
    7444:	ee 85       	ldd	r30, Y+14	; 0x0e
    7446:	ff 85       	ldd	r31, Y+15	; 0x0f
    7448:	a6 85       	ldd	r26, Z+14	; 0x0e
    744a:	b7 85       	ldd	r27, Z+15	; 0x0f
    744c:	ee 85       	ldd	r30, Y+14	; 0x0e
    744e:	ff 85       	ldd	r31, Y+15	; 0x0f
    7450:	80 89       	ldd	r24, Z+16	; 0x10
    7452:	91 89       	ldd	r25, Z+17	; 0x11
    7454:	15 96       	adiw	r26, 0x05	; 5
    7456:	9c 93       	st	X, r25
    7458:	8e 93       	st	-X, r24
    745a:	14 97       	sbiw	r26, 0x04	; 4
    745c:	ee 85       	ldd	r30, Y+14	; 0x0e
    745e:	ff 85       	ldd	r31, Y+15	; 0x0f
    7460:	a0 89       	ldd	r26, Z+16	; 0x10
    7462:	b1 89       	ldd	r27, Z+17	; 0x11
    7464:	ee 85       	ldd	r30, Y+14	; 0x0e
    7466:	ff 85       	ldd	r31, Y+15	; 0x0f
    7468:	86 85       	ldd	r24, Z+14	; 0x0e
    746a:	97 85       	ldd	r25, Z+15	; 0x0f
    746c:	13 96       	adiw	r26, 0x03	; 3
    746e:	9c 93       	st	X, r25
    7470:	8e 93       	st	-X, r24
    7472:	12 97       	sbiw	r26, 0x02	; 2
    7474:	eb 81       	ldd	r30, Y+3	; 0x03
    7476:	fc 81       	ldd	r31, Y+4	; 0x04
    7478:	21 81       	ldd	r18, Z+1	; 0x01
    747a:	32 81       	ldd	r19, Z+2	; 0x02
    747c:	8e 85       	ldd	r24, Y+14	; 0x0e
    747e:	9f 85       	ldd	r25, Y+15	; 0x0f
    7480:	0c 96       	adiw	r24, 0x0c	; 12
    7482:	28 17       	cp	r18, r24
    7484:	39 07       	cpc	r19, r25
    7486:	41 f4       	brne	.+16     	; 0x7498 <xTaskIncrementTick+0x1c8>
    7488:	ee 85       	ldd	r30, Y+14	; 0x0e
    748a:	ff 85       	ldd	r31, Y+15	; 0x0f
    748c:	80 89       	ldd	r24, Z+16	; 0x10
    748e:	91 89       	ldd	r25, Z+17	; 0x11
    7490:	eb 81       	ldd	r30, Y+3	; 0x03
    7492:	fc 81       	ldd	r31, Y+4	; 0x04
    7494:	92 83       	std	Z+2, r25	; 0x02
    7496:	81 83       	std	Z+1, r24	; 0x01
    7498:	ee 85       	ldd	r30, Y+14	; 0x0e
    749a:	ff 85       	ldd	r31, Y+15	; 0x0f
    749c:	15 8a       	std	Z+21, r1	; 0x15
    749e:	14 8a       	std	Z+20, r1	; 0x14
    74a0:	eb 81       	ldd	r30, Y+3	; 0x03
    74a2:	fc 81       	ldd	r31, Y+4	; 0x04
    74a4:	80 81       	ld	r24, Z
    74a6:	81 50       	subi	r24, 0x01	; 1
    74a8:	eb 81       	ldd	r30, Y+3	; 0x03
    74aa:	fc 81       	ldd	r31, Y+4	; 0x04
    74ac:	80 83       	st	Z, r24
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* Place the unblocked task into the appropriate ready
                     * list. */
                    prvAddTaskToReadyList( pxTCB );
    74ae:	ee 85       	ldd	r30, Y+14	; 0x0e
    74b0:	ff 85       	ldd	r31, Y+15	; 0x0f
    74b2:	96 89       	ldd	r25, Z+22	; 0x16
    74b4:	80 91 a6 07 	lds	r24, 0x07A6
    74b8:	89 17       	cp	r24, r25
    74ba:	28 f4       	brcc	.+10     	; 0x74c6 <xTaskIncrementTick+0x1f6>
    74bc:	ee 85       	ldd	r30, Y+14	; 0x0e
    74be:	ff 85       	ldd	r31, Y+15	; 0x0f
    74c0:	86 89       	ldd	r24, Z+22	; 0x16
    74c2:	80 93 a6 07 	sts	0x07A6, r24
    74c6:	ee 85       	ldd	r30, Y+14	; 0x0e
    74c8:	ff 85       	ldd	r31, Y+15	; 0x0f
    74ca:	86 89       	ldd	r24, Z+22	; 0x16
    74cc:	28 2f       	mov	r18, r24
    74ce:	30 e0       	ldi	r19, 0x00	; 0
    74d0:	c9 01       	movw	r24, r18
    74d2:	88 0f       	add	r24, r24
    74d4:	99 1f       	adc	r25, r25
    74d6:	88 0f       	add	r24, r24
    74d8:	99 1f       	adc	r25, r25
    74da:	88 0f       	add	r24, r24
    74dc:	99 1f       	adc	r25, r25
    74de:	82 0f       	add	r24, r18
    74e0:	93 1f       	adc	r25, r19
    74e2:	fc 01       	movw	r30, r24
    74e4:	ee 54       	subi	r30, 0x4E	; 78
    74e6:	f8 4f       	sbci	r31, 0xF8	; 248
    74e8:	81 81       	ldd	r24, Z+1	; 0x01
    74ea:	92 81       	ldd	r25, Z+2	; 0x02
    74ec:	9a 83       	std	Y+2, r25	; 0x02
    74ee:	89 83       	std	Y+1, r24	; 0x01
    74f0:	ee 85       	ldd	r30, Y+14	; 0x0e
    74f2:	ff 85       	ldd	r31, Y+15	; 0x0f
    74f4:	89 81       	ldd	r24, Y+1	; 0x01
    74f6:	9a 81       	ldd	r25, Y+2	; 0x02
    74f8:	95 83       	std	Z+5, r25	; 0x05
    74fa:	84 83       	std	Z+4, r24	; 0x04
    74fc:	e9 81       	ldd	r30, Y+1	; 0x01
    74fe:	fa 81       	ldd	r31, Y+2	; 0x02
    7500:	84 81       	ldd	r24, Z+4	; 0x04
    7502:	95 81       	ldd	r25, Z+5	; 0x05
    7504:	ee 85       	ldd	r30, Y+14	; 0x0e
    7506:	ff 85       	ldd	r31, Y+15	; 0x0f
    7508:	97 83       	std	Z+7, r25	; 0x07
    750a:	86 83       	std	Z+6, r24	; 0x06
    750c:	e9 81       	ldd	r30, Y+1	; 0x01
    750e:	fa 81       	ldd	r31, Y+2	; 0x02
    7510:	04 80       	ldd	r0, Z+4	; 0x04
    7512:	f5 81       	ldd	r31, Z+5	; 0x05
    7514:	e0 2d       	mov	r30, r0
    7516:	8e 85       	ldd	r24, Y+14	; 0x0e
    7518:	9f 85       	ldd	r25, Y+15	; 0x0f
    751a:	02 96       	adiw	r24, 0x02	; 2
    751c:	93 83       	std	Z+3, r25	; 0x03
    751e:	82 83       	std	Z+2, r24	; 0x02
    7520:	8e 85       	ldd	r24, Y+14	; 0x0e
    7522:	9f 85       	ldd	r25, Y+15	; 0x0f
    7524:	02 96       	adiw	r24, 0x02	; 2
    7526:	e9 81       	ldd	r30, Y+1	; 0x01
    7528:	fa 81       	ldd	r31, Y+2	; 0x02
    752a:	95 83       	std	Z+5, r25	; 0x05
    752c:	84 83       	std	Z+4, r24	; 0x04
    752e:	ee 85       	ldd	r30, Y+14	; 0x0e
    7530:	ff 85       	ldd	r31, Y+15	; 0x0f
    7532:	86 89       	ldd	r24, Z+22	; 0x16
    7534:	28 2f       	mov	r18, r24
    7536:	30 e0       	ldi	r19, 0x00	; 0
    7538:	c9 01       	movw	r24, r18
    753a:	88 0f       	add	r24, r24
    753c:	99 1f       	adc	r25, r25
    753e:	88 0f       	add	r24, r24
    7540:	99 1f       	adc	r25, r25
    7542:	88 0f       	add	r24, r24
    7544:	99 1f       	adc	r25, r25
    7546:	82 0f       	add	r24, r18
    7548:	93 1f       	adc	r25, r19
    754a:	8e 54       	subi	r24, 0x4E	; 78
    754c:	98 4f       	sbci	r25, 0xF8	; 248
    754e:	ee 85       	ldd	r30, Y+14	; 0x0e
    7550:	ff 85       	ldd	r31, Y+15	; 0x0f
    7552:	93 87       	std	Z+11, r25	; 0x0b
    7554:	82 87       	std	Z+10, r24	; 0x0a
    7556:	ee 85       	ldd	r30, Y+14	; 0x0e
    7558:	ff 85       	ldd	r31, Y+15	; 0x0f
    755a:	86 89       	ldd	r24, Z+22	; 0x16
    755c:	28 2f       	mov	r18, r24
    755e:	30 e0       	ldi	r19, 0x00	; 0
    7560:	c9 01       	movw	r24, r18
    7562:	88 0f       	add	r24, r24
    7564:	99 1f       	adc	r25, r25
    7566:	88 0f       	add	r24, r24
    7568:	99 1f       	adc	r25, r25
    756a:	88 0f       	add	r24, r24
    756c:	99 1f       	adc	r25, r25
    756e:	82 0f       	add	r24, r18
    7570:	93 1f       	adc	r25, r19
    7572:	fc 01       	movw	r30, r24
    7574:	ee 54       	subi	r30, 0x4E	; 78
    7576:	f8 4f       	sbci	r31, 0xF8	; 248
    7578:	80 81       	ld	r24, Z
    757a:	8f 5f       	subi	r24, 0xFF	; 255
    757c:	80 83       	st	Z, r24
                        {
                            /* Preemption is on, but a context switch should
                             * only be performed if the unblocked task has a
                             * priority that is equal to or higher than the
                             * currently executing task. */
                            if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    757e:	ee 85       	ldd	r30, Y+14	; 0x0e
    7580:	ff 85       	ldd	r31, Y+15	; 0x0f
    7582:	96 89       	ldd	r25, Z+22	; 0x16
    7584:	e0 91 a0 07 	lds	r30, 0x07A0
    7588:	f0 91 a1 07 	lds	r31, 0x07A1
    758c:	86 89       	ldd	r24, Z+22	; 0x16
    758e:	98 17       	cp	r25, r24
    7590:	08 f4       	brcc	.+2      	; 0x7594 <xTaskIncrementTick+0x2c4>
    7592:	e4 ce       	rjmp	.-568    	; 0x735c <xTaskIncrementTick+0x8c>
                            {
                                xSwitchRequired = pdTRUE;
    7594:	81 e0       	ldi	r24, 0x01	; 1
    7596:	8b 87       	std	Y+11, r24	; 0x0b
    7598:	e1 ce       	rjmp	.-574    	; 0x735c <xTaskIncrementTick+0x8c>
        /* Tasks of equal priority to the currently running task will share
         * processing time (time slice) if preemption is on, and the application
         * writer has not explicitly turned time slicing off. */
        #if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
            {
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    759a:	e0 91 a0 07 	lds	r30, 0x07A0
    759e:	f0 91 a1 07 	lds	r31, 0x07A1
    75a2:	86 89       	ldd	r24, Z+22	; 0x16
    75a4:	28 2f       	mov	r18, r24
    75a6:	30 e0       	ldi	r19, 0x00	; 0
    75a8:	c9 01       	movw	r24, r18
    75aa:	88 0f       	add	r24, r24
    75ac:	99 1f       	adc	r25, r25
    75ae:	88 0f       	add	r24, r24
    75b0:	99 1f       	adc	r25, r25
    75b2:	88 0f       	add	r24, r24
    75b4:	99 1f       	adc	r25, r25
    75b6:	82 0f       	add	r24, r18
    75b8:	93 1f       	adc	r25, r19
    75ba:	fc 01       	movw	r30, r24
    75bc:	ee 54       	subi	r30, 0x4E	; 78
    75be:	f8 4f       	sbci	r31, 0xF8	; 248
    75c0:	80 81       	ld	r24, Z
    75c2:	82 30       	cpi	r24, 0x02	; 2
    75c4:	10 f0       	brcs	.+4      	; 0x75ca <xTaskIncrementTick+0x2fa>
                {
                    xSwitchRequired = pdTRUE;
    75c6:	81 e0       	ldi	r24, 0x01	; 1
    75c8:	8b 87       	std	Y+11, r24	; 0x0b
            }
        #endif /* configUSE_TICK_HOOK */

        #if ( configUSE_PREEMPTION == 1 )
            {
                if( xYieldPending != pdFALSE )
    75ca:	80 91 aa 07 	lds	r24, 0x07AA
    75ce:	88 23       	and	r24, r24
    75d0:	61 f0       	breq	.+24     	; 0x75ea <xTaskIncrementTick+0x31a>
                {
                    xSwitchRequired = pdTRUE;
    75d2:	81 e0       	ldi	r24, 0x01	; 1
    75d4:	8b 87       	std	Y+11, r24	; 0x0b
    75d6:	09 c0       	rjmp	.+18     	; 0x75ea <xTaskIncrementTick+0x31a>
            }
        #endif /* configUSE_PREEMPTION */
    }
    else
    {
        ++xPendedTicks;
    75d8:	80 91 a8 07 	lds	r24, 0x07A8
    75dc:	90 91 a9 07 	lds	r25, 0x07A9
    75e0:	01 96       	adiw	r24, 0x01	; 1
    75e2:	90 93 a9 07 	sts	0x07A9, r25
    75e6:	80 93 a8 07 	sts	0x07A8, r24
                vApplicationTickHook();
            }
        #endif
    }

    return xSwitchRequired;
    75ea:	8b 85       	ldd	r24, Y+11	; 0x0b
}
    75ec:	2f 96       	adiw	r28, 0x0f	; 15
    75ee:	0f b6       	in	r0, 0x3f	; 63
    75f0:	f8 94       	cli
    75f2:	de bf       	out	0x3e, r29	; 62
    75f4:	0f be       	out	0x3f, r0	; 63
    75f6:	cd bf       	out	0x3d, r28	; 61
    75f8:	cf 91       	pop	r28
    75fa:	df 91       	pop	r29
    75fc:	08 95       	ret

000075fe <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    75fe:	df 93       	push	r29
    7600:	cf 93       	push	r28
    7602:	00 d0       	rcall	.+0      	; 0x7604 <vTaskSwitchContext+0x6>
    7604:	0f 92       	push	r0
    7606:	cd b7       	in	r28, 0x3d	; 61
    7608:	de b7       	in	r29, 0x3e	; 62
    if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    760a:	80 91 b1 07 	lds	r24, 0x07B1
    760e:	88 23       	and	r24, r24
    7610:	21 f0       	breq	.+8      	; 0x761a <vTaskSwitchContext+0x1c>
    {
        /* The scheduler is currently suspended - do not allow a context
         * switch. */
        xYieldPending = pdTRUE;
    7612:	81 e0       	ldi	r24, 0x01	; 1
    7614:	80 93 aa 07 	sts	0x07AA, r24
    7618:	59 c0       	rjmp	.+178    	; 0x76cc <vTaskSwitchContext+0xce>
    }
    else
    {
        xYieldPending = pdFALSE;
    761a:	10 92 aa 07 	sts	0x07AA, r1
            }
        #endif

        /* Select a new task to run using either the generic C or port
         * optimised asm code. */
        taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    761e:	80 91 a6 07 	lds	r24, 0x07A6
    7622:	8b 83       	std	Y+3, r24	; 0x03
    7624:	03 c0       	rjmp	.+6      	; 0x762c <vTaskSwitchContext+0x2e>
    7626:	8b 81       	ldd	r24, Y+3	; 0x03
    7628:	81 50       	subi	r24, 0x01	; 1
    762a:	8b 83       	std	Y+3, r24	; 0x03
    762c:	8b 81       	ldd	r24, Y+3	; 0x03
    762e:	28 2f       	mov	r18, r24
    7630:	30 e0       	ldi	r19, 0x00	; 0
    7632:	c9 01       	movw	r24, r18
    7634:	88 0f       	add	r24, r24
    7636:	99 1f       	adc	r25, r25
    7638:	88 0f       	add	r24, r24
    763a:	99 1f       	adc	r25, r25
    763c:	88 0f       	add	r24, r24
    763e:	99 1f       	adc	r25, r25
    7640:	82 0f       	add	r24, r18
    7642:	93 1f       	adc	r25, r19
    7644:	fc 01       	movw	r30, r24
    7646:	ee 54       	subi	r30, 0x4E	; 78
    7648:	f8 4f       	sbci	r31, 0xF8	; 248
    764a:	80 81       	ld	r24, Z
    764c:	88 23       	and	r24, r24
    764e:	59 f3       	breq	.-42     	; 0x7626 <vTaskSwitchContext+0x28>
    7650:	8b 81       	ldd	r24, Y+3	; 0x03
    7652:	28 2f       	mov	r18, r24
    7654:	30 e0       	ldi	r19, 0x00	; 0
    7656:	c9 01       	movw	r24, r18
    7658:	88 0f       	add	r24, r24
    765a:	99 1f       	adc	r25, r25
    765c:	88 0f       	add	r24, r24
    765e:	99 1f       	adc	r25, r25
    7660:	88 0f       	add	r24, r24
    7662:	99 1f       	adc	r25, r25
    7664:	82 0f       	add	r24, r18
    7666:	93 1f       	adc	r25, r19
    7668:	8e 54       	subi	r24, 0x4E	; 78
    766a:	98 4f       	sbci	r25, 0xF8	; 248
    766c:	9a 83       	std	Y+2, r25	; 0x02
    766e:	89 83       	std	Y+1, r24	; 0x01
    7670:	e9 81       	ldd	r30, Y+1	; 0x01
    7672:	fa 81       	ldd	r31, Y+2	; 0x02
    7674:	01 80       	ldd	r0, Z+1	; 0x01
    7676:	f2 81       	ldd	r31, Z+2	; 0x02
    7678:	e0 2d       	mov	r30, r0
    767a:	82 81       	ldd	r24, Z+2	; 0x02
    767c:	93 81       	ldd	r25, Z+3	; 0x03
    767e:	e9 81       	ldd	r30, Y+1	; 0x01
    7680:	fa 81       	ldd	r31, Y+2	; 0x02
    7682:	92 83       	std	Z+2, r25	; 0x02
    7684:	81 83       	std	Z+1, r24	; 0x01
    7686:	e9 81       	ldd	r30, Y+1	; 0x01
    7688:	fa 81       	ldd	r31, Y+2	; 0x02
    768a:	21 81       	ldd	r18, Z+1	; 0x01
    768c:	32 81       	ldd	r19, Z+2	; 0x02
    768e:	89 81       	ldd	r24, Y+1	; 0x01
    7690:	9a 81       	ldd	r25, Y+2	; 0x02
    7692:	03 96       	adiw	r24, 0x03	; 3
    7694:	28 17       	cp	r18, r24
    7696:	39 07       	cpc	r19, r25
    7698:	59 f4       	brne	.+22     	; 0x76b0 <vTaskSwitchContext+0xb2>
    769a:	e9 81       	ldd	r30, Y+1	; 0x01
    769c:	fa 81       	ldd	r31, Y+2	; 0x02
    769e:	01 80       	ldd	r0, Z+1	; 0x01
    76a0:	f2 81       	ldd	r31, Z+2	; 0x02
    76a2:	e0 2d       	mov	r30, r0
    76a4:	82 81       	ldd	r24, Z+2	; 0x02
    76a6:	93 81       	ldd	r25, Z+3	; 0x03
    76a8:	e9 81       	ldd	r30, Y+1	; 0x01
    76aa:	fa 81       	ldd	r31, Y+2	; 0x02
    76ac:	92 83       	std	Z+2, r25	; 0x02
    76ae:	81 83       	std	Z+1, r24	; 0x01
    76b0:	e9 81       	ldd	r30, Y+1	; 0x01
    76b2:	fa 81       	ldd	r31, Y+2	; 0x02
    76b4:	01 80       	ldd	r0, Z+1	; 0x01
    76b6:	f2 81       	ldd	r31, Z+2	; 0x02
    76b8:	e0 2d       	mov	r30, r0
    76ba:	86 81       	ldd	r24, Z+6	; 0x06
    76bc:	97 81       	ldd	r25, Z+7	; 0x07
    76be:	90 93 a1 07 	sts	0x07A1, r25
    76c2:	80 93 a0 07 	sts	0x07A0, r24
    76c6:	8b 81       	ldd	r24, Y+3	; 0x03
    76c8:	80 93 a6 07 	sts	0x07A6, r24
                 * for additional information. */
                _impure_ptr = &( pxCurrentTCB->xNewLib_reent );
            }
        #endif /* configUSE_NEWLIB_REENTRANT */
    }
}
    76cc:	0f 90       	pop	r0
    76ce:	0f 90       	pop	r0
    76d0:	0f 90       	pop	r0
    76d2:	cf 91       	pop	r28
    76d4:	df 91       	pop	r29
    76d6:	08 95       	ret

000076d8 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList,
                            const TickType_t xTicksToWait )
{
    76d8:	df 93       	push	r29
    76da:	cf 93       	push	r28
    76dc:	00 d0       	rcall	.+0      	; 0x76de <vTaskPlaceOnEventList+0x6>
    76de:	00 d0       	rcall	.+0      	; 0x76e0 <vTaskPlaceOnEventList+0x8>
    76e0:	cd b7       	in	r28, 0x3d	; 61
    76e2:	de b7       	in	r29, 0x3e	; 62
    76e4:	9a 83       	std	Y+2, r25	; 0x02
    76e6:	89 83       	std	Y+1, r24	; 0x01
    76e8:	7c 83       	std	Y+4, r23	; 0x04
    76ea:	6b 83       	std	Y+3, r22	; 0x03
     *      xItemValue = ( configMAX_PRIORITIES - uxPriority )
     * Therefore, the event list is sorted in descending priority order.
     *
     * The queue that contains the event list is locked, preventing
     * simultaneous access from interrupts. */
    vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    76ec:	80 91 a0 07 	lds	r24, 0x07A0
    76f0:	90 91 a1 07 	lds	r25, 0x07A1
    76f4:	9c 01       	movw	r18, r24
    76f6:	24 5f       	subi	r18, 0xF4	; 244
    76f8:	3f 4f       	sbci	r19, 0xFF	; 255
    76fa:	89 81       	ldd	r24, Y+1	; 0x01
    76fc:	9a 81       	ldd	r25, Y+2	; 0x02
    76fe:	b9 01       	movw	r22, r18
    7700:	0e 94 10 1f 	call	0x3e20	; 0x3e20 <vListInsert>

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    7704:	8b 81       	ldd	r24, Y+3	; 0x03
    7706:	9c 81       	ldd	r25, Y+4	; 0x04
    7708:	61 e0       	ldi	r22, 0x01	; 1
    770a:	0e 94 ec 49 	call	0x93d8	; 0x93d8 <prvAddCurrentTaskToDelayedList>
}
    770e:	0f 90       	pop	r0
    7710:	0f 90       	pop	r0
    7712:	0f 90       	pop	r0
    7714:	0f 90       	pop	r0
    7716:	cf 91       	pop	r28
    7718:	df 91       	pop	r29
    771a:	08 95       	ret

0000771c <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList,
                                     const TickType_t xItemValue,
                                     const TickType_t xTicksToWait )
{
    771c:	df 93       	push	r29
    771e:	cf 93       	push	r28
    7720:	cd b7       	in	r28, 0x3d	; 61
    7722:	de b7       	in	r29, 0x3e	; 62
    7724:	28 97       	sbiw	r28, 0x08	; 8
    7726:	0f b6       	in	r0, 0x3f	; 63
    7728:	f8 94       	cli
    772a:	de bf       	out	0x3e, r29	; 62
    772c:	0f be       	out	0x3f, r0	; 63
    772e:	cd bf       	out	0x3d, r28	; 61
    7730:	9c 83       	std	Y+4, r25	; 0x04
    7732:	8b 83       	std	Y+3, r24	; 0x03
    7734:	7e 83       	std	Y+6, r23	; 0x06
    7736:	6d 83       	std	Y+5, r22	; 0x05
    7738:	58 87       	std	Y+8, r21	; 0x08
    773a:	4f 83       	std	Y+7, r20	; 0x07
    configASSERT( uxSchedulerSuspended != 0 );

    /* Store the item value in the event list item.  It is safe to access the
     * event list item here as interrupts won't access the event list item of a
     * task that is not in the Blocked state. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    773c:	e0 91 a0 07 	lds	r30, 0x07A0
    7740:	f0 91 a1 07 	lds	r31, 0x07A1
    7744:	8d 81       	ldd	r24, Y+5	; 0x05
    7746:	9e 81       	ldd	r25, Y+6	; 0x06
    7748:	90 68       	ori	r25, 0x80	; 128
    774a:	95 87       	std	Z+13, r25	; 0x0d
    774c:	84 87       	std	Z+12, r24	; 0x0c
    /* Place the event list item of the TCB at the end of the appropriate event
     * list.  It is safe to access the event list here because it is part of an
     * event group implementation - and interrupts don't access event groups
     * directly (instead they access them indirectly by pending function calls to
     * the task level). */
    listINSERT_END( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    774e:	eb 81       	ldd	r30, Y+3	; 0x03
    7750:	fc 81       	ldd	r31, Y+4	; 0x04
    7752:	81 81       	ldd	r24, Z+1	; 0x01
    7754:	92 81       	ldd	r25, Z+2	; 0x02
    7756:	9a 83       	std	Y+2, r25	; 0x02
    7758:	89 83       	std	Y+1, r24	; 0x01
    775a:	e0 91 a0 07 	lds	r30, 0x07A0
    775e:	f0 91 a1 07 	lds	r31, 0x07A1
    7762:	89 81       	ldd	r24, Y+1	; 0x01
    7764:	9a 81       	ldd	r25, Y+2	; 0x02
    7766:	97 87       	std	Z+15, r25	; 0x0f
    7768:	86 87       	std	Z+14, r24	; 0x0e
    776a:	a0 91 a0 07 	lds	r26, 0x07A0
    776e:	b0 91 a1 07 	lds	r27, 0x07A1
    7772:	e9 81       	ldd	r30, Y+1	; 0x01
    7774:	fa 81       	ldd	r31, Y+2	; 0x02
    7776:	84 81       	ldd	r24, Z+4	; 0x04
    7778:	95 81       	ldd	r25, Z+5	; 0x05
    777a:	51 96       	adiw	r26, 0x11	; 17
    777c:	9c 93       	st	X, r25
    777e:	8e 93       	st	-X, r24
    7780:	50 97       	sbiw	r26, 0x10	; 16
    7782:	e9 81       	ldd	r30, Y+1	; 0x01
    7784:	fa 81       	ldd	r31, Y+2	; 0x02
    7786:	04 80       	ldd	r0, Z+4	; 0x04
    7788:	f5 81       	ldd	r31, Z+5	; 0x05
    778a:	e0 2d       	mov	r30, r0
    778c:	80 91 a0 07 	lds	r24, 0x07A0
    7790:	90 91 a1 07 	lds	r25, 0x07A1
    7794:	0c 96       	adiw	r24, 0x0c	; 12
    7796:	93 83       	std	Z+3, r25	; 0x03
    7798:	82 83       	std	Z+2, r24	; 0x02
    779a:	80 91 a0 07 	lds	r24, 0x07A0
    779e:	90 91 a1 07 	lds	r25, 0x07A1
    77a2:	0c 96       	adiw	r24, 0x0c	; 12
    77a4:	e9 81       	ldd	r30, Y+1	; 0x01
    77a6:	fa 81       	ldd	r31, Y+2	; 0x02
    77a8:	95 83       	std	Z+5, r25	; 0x05
    77aa:	84 83       	std	Z+4, r24	; 0x04
    77ac:	e0 91 a0 07 	lds	r30, 0x07A0
    77b0:	f0 91 a1 07 	lds	r31, 0x07A1
    77b4:	8b 81       	ldd	r24, Y+3	; 0x03
    77b6:	9c 81       	ldd	r25, Y+4	; 0x04
    77b8:	95 8b       	std	Z+21, r25	; 0x15
    77ba:	84 8b       	std	Z+20, r24	; 0x14
    77bc:	eb 81       	ldd	r30, Y+3	; 0x03
    77be:	fc 81       	ldd	r31, Y+4	; 0x04
    77c0:	80 81       	ld	r24, Z
    77c2:	8f 5f       	subi	r24, 0xFF	; 255
    77c4:	eb 81       	ldd	r30, Y+3	; 0x03
    77c6:	fc 81       	ldd	r31, Y+4	; 0x04
    77c8:	80 83       	st	Z, r24

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    77ca:	8f 81       	ldd	r24, Y+7	; 0x07
    77cc:	98 85       	ldd	r25, Y+8	; 0x08
    77ce:	61 e0       	ldi	r22, 0x01	; 1
    77d0:	0e 94 ec 49 	call	0x93d8	; 0x93d8 <prvAddCurrentTaskToDelayedList>
}
    77d4:	28 96       	adiw	r28, 0x08	; 8
    77d6:	0f b6       	in	r0, 0x3f	; 63
    77d8:	f8 94       	cli
    77da:	de bf       	out	0x3e, r29	; 62
    77dc:	0f be       	out	0x3f, r0	; 63
    77de:	cd bf       	out	0x3d, r28	; 61
    77e0:	cf 91       	pop	r28
    77e2:	df 91       	pop	r29
    77e4:	08 95       	ret

000077e6 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    77e6:	df 93       	push	r29
    77e8:	cf 93       	push	r28
    77ea:	cd b7       	in	r28, 0x3d	; 61
    77ec:	de b7       	in	r29, 0x3e	; 62
    77ee:	2d 97       	sbiw	r28, 0x0d	; 13
    77f0:	0f b6       	in	r0, 0x3f	; 63
    77f2:	f8 94       	cli
    77f4:	de bf       	out	0x3e, r29	; 62
    77f6:	0f be       	out	0x3f, r0	; 63
    77f8:	cd bf       	out	0x3d, r28	; 61
    77fa:	9d 87       	std	Y+13, r25	; 0x0d
    77fc:	8c 87       	std	Y+12, r24	; 0x0c
     * get called - the lock count on the queue will get modified instead.  This
     * means exclusive access to the event list is guaranteed here.
     *
     * This function assumes that a check has already been made to ensure that
     * pxEventList is not empty. */
    pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    77fe:	ec 85       	ldd	r30, Y+12	; 0x0c
    7800:	fd 85       	ldd	r31, Y+13	; 0x0d
    7802:	05 80       	ldd	r0, Z+5	; 0x05
    7804:	f6 81       	ldd	r31, Z+6	; 0x06
    7806:	e0 2d       	mov	r30, r0
    7808:	86 81       	ldd	r24, Z+6	; 0x06
    780a:	97 81       	ldd	r25, Z+7	; 0x07
    780c:	9b 87       	std	Y+11, r25	; 0x0b
    780e:	8a 87       	std	Y+10, r24	; 0x0a
    configASSERT( pxUnblockedTCB );
    listREMOVE_ITEM( &( pxUnblockedTCB->xEventListItem ) );
    7810:	ea 85       	ldd	r30, Y+10	; 0x0a
    7812:	fb 85       	ldd	r31, Y+11	; 0x0b
    7814:	84 89       	ldd	r24, Z+20	; 0x14
    7816:	95 89       	ldd	r25, Z+21	; 0x15
    7818:	98 87       	std	Y+8, r25	; 0x08
    781a:	8f 83       	std	Y+7, r24	; 0x07
    781c:	ea 85       	ldd	r30, Y+10	; 0x0a
    781e:	fb 85       	ldd	r31, Y+11	; 0x0b
    7820:	a6 85       	ldd	r26, Z+14	; 0x0e
    7822:	b7 85       	ldd	r27, Z+15	; 0x0f
    7824:	ea 85       	ldd	r30, Y+10	; 0x0a
    7826:	fb 85       	ldd	r31, Y+11	; 0x0b
    7828:	80 89       	ldd	r24, Z+16	; 0x10
    782a:	91 89       	ldd	r25, Z+17	; 0x11
    782c:	15 96       	adiw	r26, 0x05	; 5
    782e:	9c 93       	st	X, r25
    7830:	8e 93       	st	-X, r24
    7832:	14 97       	sbiw	r26, 0x04	; 4
    7834:	ea 85       	ldd	r30, Y+10	; 0x0a
    7836:	fb 85       	ldd	r31, Y+11	; 0x0b
    7838:	a0 89       	ldd	r26, Z+16	; 0x10
    783a:	b1 89       	ldd	r27, Z+17	; 0x11
    783c:	ea 85       	ldd	r30, Y+10	; 0x0a
    783e:	fb 85       	ldd	r31, Y+11	; 0x0b
    7840:	86 85       	ldd	r24, Z+14	; 0x0e
    7842:	97 85       	ldd	r25, Z+15	; 0x0f
    7844:	13 96       	adiw	r26, 0x03	; 3
    7846:	9c 93       	st	X, r25
    7848:	8e 93       	st	-X, r24
    784a:	12 97       	sbiw	r26, 0x02	; 2
    784c:	ef 81       	ldd	r30, Y+7	; 0x07
    784e:	f8 85       	ldd	r31, Y+8	; 0x08
    7850:	21 81       	ldd	r18, Z+1	; 0x01
    7852:	32 81       	ldd	r19, Z+2	; 0x02
    7854:	8a 85       	ldd	r24, Y+10	; 0x0a
    7856:	9b 85       	ldd	r25, Y+11	; 0x0b
    7858:	0c 96       	adiw	r24, 0x0c	; 12
    785a:	28 17       	cp	r18, r24
    785c:	39 07       	cpc	r19, r25
    785e:	41 f4       	brne	.+16     	; 0x7870 <xTaskRemoveFromEventList+0x8a>
    7860:	ea 85       	ldd	r30, Y+10	; 0x0a
    7862:	fb 85       	ldd	r31, Y+11	; 0x0b
    7864:	80 89       	ldd	r24, Z+16	; 0x10
    7866:	91 89       	ldd	r25, Z+17	; 0x11
    7868:	ef 81       	ldd	r30, Y+7	; 0x07
    786a:	f8 85       	ldd	r31, Y+8	; 0x08
    786c:	92 83       	std	Z+2, r25	; 0x02
    786e:	81 83       	std	Z+1, r24	; 0x01
    7870:	ea 85       	ldd	r30, Y+10	; 0x0a
    7872:	fb 85       	ldd	r31, Y+11	; 0x0b
    7874:	15 8a       	std	Z+21, r1	; 0x15
    7876:	14 8a       	std	Z+20, r1	; 0x14
    7878:	ef 81       	ldd	r30, Y+7	; 0x07
    787a:	f8 85       	ldd	r31, Y+8	; 0x08
    787c:	80 81       	ld	r24, Z
    787e:	81 50       	subi	r24, 0x01	; 1
    7880:	ef 81       	ldd	r30, Y+7	; 0x07
    7882:	f8 85       	ldd	r31, Y+8	; 0x08
    7884:	80 83       	st	Z, r24

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    7886:	80 91 b1 07 	lds	r24, 0x07B1
    788a:	88 23       	and	r24, r24
    788c:	09 f0       	breq	.+2      	; 0x7890 <xTaskRemoveFromEventList+0xaa>
    788e:	a4 c0       	rjmp	.+328    	; 0x79d8 <xTaskRemoveFromEventList+0x1f2>
    {
        listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
    7890:	ea 85       	ldd	r30, Y+10	; 0x0a
    7892:	fb 85       	ldd	r31, Y+11	; 0x0b
    7894:	82 85       	ldd	r24, Z+10	; 0x0a
    7896:	93 85       	ldd	r25, Z+11	; 0x0b
    7898:	9e 83       	std	Y+6, r25	; 0x06
    789a:	8d 83       	std	Y+5, r24	; 0x05
    789c:	ea 85       	ldd	r30, Y+10	; 0x0a
    789e:	fb 85       	ldd	r31, Y+11	; 0x0b
    78a0:	a4 81       	ldd	r26, Z+4	; 0x04
    78a2:	b5 81       	ldd	r27, Z+5	; 0x05
    78a4:	ea 85       	ldd	r30, Y+10	; 0x0a
    78a6:	fb 85       	ldd	r31, Y+11	; 0x0b
    78a8:	86 81       	ldd	r24, Z+6	; 0x06
    78aa:	97 81       	ldd	r25, Z+7	; 0x07
    78ac:	15 96       	adiw	r26, 0x05	; 5
    78ae:	9c 93       	st	X, r25
    78b0:	8e 93       	st	-X, r24
    78b2:	14 97       	sbiw	r26, 0x04	; 4
    78b4:	ea 85       	ldd	r30, Y+10	; 0x0a
    78b6:	fb 85       	ldd	r31, Y+11	; 0x0b
    78b8:	a6 81       	ldd	r26, Z+6	; 0x06
    78ba:	b7 81       	ldd	r27, Z+7	; 0x07
    78bc:	ea 85       	ldd	r30, Y+10	; 0x0a
    78be:	fb 85       	ldd	r31, Y+11	; 0x0b
    78c0:	84 81       	ldd	r24, Z+4	; 0x04
    78c2:	95 81       	ldd	r25, Z+5	; 0x05
    78c4:	13 96       	adiw	r26, 0x03	; 3
    78c6:	9c 93       	st	X, r25
    78c8:	8e 93       	st	-X, r24
    78ca:	12 97       	sbiw	r26, 0x02	; 2
    78cc:	ed 81       	ldd	r30, Y+5	; 0x05
    78ce:	fe 81       	ldd	r31, Y+6	; 0x06
    78d0:	21 81       	ldd	r18, Z+1	; 0x01
    78d2:	32 81       	ldd	r19, Z+2	; 0x02
    78d4:	8a 85       	ldd	r24, Y+10	; 0x0a
    78d6:	9b 85       	ldd	r25, Y+11	; 0x0b
    78d8:	02 96       	adiw	r24, 0x02	; 2
    78da:	28 17       	cp	r18, r24
    78dc:	39 07       	cpc	r19, r25
    78de:	41 f4       	brne	.+16     	; 0x78f0 <xTaskRemoveFromEventList+0x10a>
    78e0:	ea 85       	ldd	r30, Y+10	; 0x0a
    78e2:	fb 85       	ldd	r31, Y+11	; 0x0b
    78e4:	86 81       	ldd	r24, Z+6	; 0x06
    78e6:	97 81       	ldd	r25, Z+7	; 0x07
    78e8:	ed 81       	ldd	r30, Y+5	; 0x05
    78ea:	fe 81       	ldd	r31, Y+6	; 0x06
    78ec:	92 83       	std	Z+2, r25	; 0x02
    78ee:	81 83       	std	Z+1, r24	; 0x01
    78f0:	ea 85       	ldd	r30, Y+10	; 0x0a
    78f2:	fb 85       	ldd	r31, Y+11	; 0x0b
    78f4:	13 86       	std	Z+11, r1	; 0x0b
    78f6:	12 86       	std	Z+10, r1	; 0x0a
    78f8:	ed 81       	ldd	r30, Y+5	; 0x05
    78fa:	fe 81       	ldd	r31, Y+6	; 0x06
    78fc:	80 81       	ld	r24, Z
    78fe:	81 50       	subi	r24, 0x01	; 1
    7900:	ed 81       	ldd	r30, Y+5	; 0x05
    7902:	fe 81       	ldd	r31, Y+6	; 0x06
    7904:	80 83       	st	Z, r24
        prvAddTaskToReadyList( pxUnblockedTCB );
    7906:	ea 85       	ldd	r30, Y+10	; 0x0a
    7908:	fb 85       	ldd	r31, Y+11	; 0x0b
    790a:	96 89       	ldd	r25, Z+22	; 0x16
    790c:	80 91 a6 07 	lds	r24, 0x07A6
    7910:	89 17       	cp	r24, r25
    7912:	28 f4       	brcc	.+10     	; 0x791e <xTaskRemoveFromEventList+0x138>
    7914:	ea 85       	ldd	r30, Y+10	; 0x0a
    7916:	fb 85       	ldd	r31, Y+11	; 0x0b
    7918:	86 89       	ldd	r24, Z+22	; 0x16
    791a:	80 93 a6 07 	sts	0x07A6, r24
    791e:	ea 85       	ldd	r30, Y+10	; 0x0a
    7920:	fb 85       	ldd	r31, Y+11	; 0x0b
    7922:	86 89       	ldd	r24, Z+22	; 0x16
    7924:	28 2f       	mov	r18, r24
    7926:	30 e0       	ldi	r19, 0x00	; 0
    7928:	c9 01       	movw	r24, r18
    792a:	88 0f       	add	r24, r24
    792c:	99 1f       	adc	r25, r25
    792e:	88 0f       	add	r24, r24
    7930:	99 1f       	adc	r25, r25
    7932:	88 0f       	add	r24, r24
    7934:	99 1f       	adc	r25, r25
    7936:	82 0f       	add	r24, r18
    7938:	93 1f       	adc	r25, r19
    793a:	fc 01       	movw	r30, r24
    793c:	ee 54       	subi	r30, 0x4E	; 78
    793e:	f8 4f       	sbci	r31, 0xF8	; 248
    7940:	81 81       	ldd	r24, Z+1	; 0x01
    7942:	92 81       	ldd	r25, Z+2	; 0x02
    7944:	9c 83       	std	Y+4, r25	; 0x04
    7946:	8b 83       	std	Y+3, r24	; 0x03
    7948:	ea 85       	ldd	r30, Y+10	; 0x0a
    794a:	fb 85       	ldd	r31, Y+11	; 0x0b
    794c:	8b 81       	ldd	r24, Y+3	; 0x03
    794e:	9c 81       	ldd	r25, Y+4	; 0x04
    7950:	95 83       	std	Z+5, r25	; 0x05
    7952:	84 83       	std	Z+4, r24	; 0x04
    7954:	eb 81       	ldd	r30, Y+3	; 0x03
    7956:	fc 81       	ldd	r31, Y+4	; 0x04
    7958:	84 81       	ldd	r24, Z+4	; 0x04
    795a:	95 81       	ldd	r25, Z+5	; 0x05
    795c:	ea 85       	ldd	r30, Y+10	; 0x0a
    795e:	fb 85       	ldd	r31, Y+11	; 0x0b
    7960:	97 83       	std	Z+7, r25	; 0x07
    7962:	86 83       	std	Z+6, r24	; 0x06
    7964:	eb 81       	ldd	r30, Y+3	; 0x03
    7966:	fc 81       	ldd	r31, Y+4	; 0x04
    7968:	04 80       	ldd	r0, Z+4	; 0x04
    796a:	f5 81       	ldd	r31, Z+5	; 0x05
    796c:	e0 2d       	mov	r30, r0
    796e:	8a 85       	ldd	r24, Y+10	; 0x0a
    7970:	9b 85       	ldd	r25, Y+11	; 0x0b
    7972:	02 96       	adiw	r24, 0x02	; 2
    7974:	93 83       	std	Z+3, r25	; 0x03
    7976:	82 83       	std	Z+2, r24	; 0x02
    7978:	8a 85       	ldd	r24, Y+10	; 0x0a
    797a:	9b 85       	ldd	r25, Y+11	; 0x0b
    797c:	02 96       	adiw	r24, 0x02	; 2
    797e:	eb 81       	ldd	r30, Y+3	; 0x03
    7980:	fc 81       	ldd	r31, Y+4	; 0x04
    7982:	95 83       	std	Z+5, r25	; 0x05
    7984:	84 83       	std	Z+4, r24	; 0x04
    7986:	ea 85       	ldd	r30, Y+10	; 0x0a
    7988:	fb 85       	ldd	r31, Y+11	; 0x0b
    798a:	86 89       	ldd	r24, Z+22	; 0x16
    798c:	28 2f       	mov	r18, r24
    798e:	30 e0       	ldi	r19, 0x00	; 0
    7990:	c9 01       	movw	r24, r18
    7992:	88 0f       	add	r24, r24
    7994:	99 1f       	adc	r25, r25
    7996:	88 0f       	add	r24, r24
    7998:	99 1f       	adc	r25, r25
    799a:	88 0f       	add	r24, r24
    799c:	99 1f       	adc	r25, r25
    799e:	82 0f       	add	r24, r18
    79a0:	93 1f       	adc	r25, r19
    79a2:	8e 54       	subi	r24, 0x4E	; 78
    79a4:	98 4f       	sbci	r25, 0xF8	; 248
    79a6:	ea 85       	ldd	r30, Y+10	; 0x0a
    79a8:	fb 85       	ldd	r31, Y+11	; 0x0b
    79aa:	93 87       	std	Z+11, r25	; 0x0b
    79ac:	82 87       	std	Z+10, r24	; 0x0a
    79ae:	ea 85       	ldd	r30, Y+10	; 0x0a
    79b0:	fb 85       	ldd	r31, Y+11	; 0x0b
    79b2:	86 89       	ldd	r24, Z+22	; 0x16
    79b4:	28 2f       	mov	r18, r24
    79b6:	30 e0       	ldi	r19, 0x00	; 0
    79b8:	c9 01       	movw	r24, r18
    79ba:	88 0f       	add	r24, r24
    79bc:	99 1f       	adc	r25, r25
    79be:	88 0f       	add	r24, r24
    79c0:	99 1f       	adc	r25, r25
    79c2:	88 0f       	add	r24, r24
    79c4:	99 1f       	adc	r25, r25
    79c6:	82 0f       	add	r24, r18
    79c8:	93 1f       	adc	r25, r19
    79ca:	fc 01       	movw	r30, r24
    79cc:	ee 54       	subi	r30, 0x4E	; 78
    79ce:	f8 4f       	sbci	r31, 0xF8	; 248
    79d0:	80 81       	ld	r24, Z
    79d2:	8f 5f       	subi	r24, 0xFF	; 255
    79d4:	80 83       	st	Z, r24
    79d6:	30 c0       	rjmp	.+96     	; 0x7a38 <xTaskRemoveFromEventList+0x252>
    }
    else
    {
        /* The delayed and ready lists cannot be accessed, so hold this task
         * pending until the scheduler is resumed. */
        listINSERT_END( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    79d8:	80 91 ed 07 	lds	r24, 0x07ED
    79dc:	90 91 ee 07 	lds	r25, 0x07EE
    79e0:	9a 83       	std	Y+2, r25	; 0x02
    79e2:	89 83       	std	Y+1, r24	; 0x01
    79e4:	ea 85       	ldd	r30, Y+10	; 0x0a
    79e6:	fb 85       	ldd	r31, Y+11	; 0x0b
    79e8:	89 81       	ldd	r24, Y+1	; 0x01
    79ea:	9a 81       	ldd	r25, Y+2	; 0x02
    79ec:	97 87       	std	Z+15, r25	; 0x0f
    79ee:	86 87       	std	Z+14, r24	; 0x0e
    79f0:	e9 81       	ldd	r30, Y+1	; 0x01
    79f2:	fa 81       	ldd	r31, Y+2	; 0x02
    79f4:	84 81       	ldd	r24, Z+4	; 0x04
    79f6:	95 81       	ldd	r25, Z+5	; 0x05
    79f8:	ea 85       	ldd	r30, Y+10	; 0x0a
    79fa:	fb 85       	ldd	r31, Y+11	; 0x0b
    79fc:	91 8b       	std	Z+17, r25	; 0x11
    79fe:	80 8b       	std	Z+16, r24	; 0x10
    7a00:	e9 81       	ldd	r30, Y+1	; 0x01
    7a02:	fa 81       	ldd	r31, Y+2	; 0x02
    7a04:	04 80       	ldd	r0, Z+4	; 0x04
    7a06:	f5 81       	ldd	r31, Z+5	; 0x05
    7a08:	e0 2d       	mov	r30, r0
    7a0a:	8a 85       	ldd	r24, Y+10	; 0x0a
    7a0c:	9b 85       	ldd	r25, Y+11	; 0x0b
    7a0e:	0c 96       	adiw	r24, 0x0c	; 12
    7a10:	93 83       	std	Z+3, r25	; 0x03
    7a12:	82 83       	std	Z+2, r24	; 0x02
    7a14:	8a 85       	ldd	r24, Y+10	; 0x0a
    7a16:	9b 85       	ldd	r25, Y+11	; 0x0b
    7a18:	0c 96       	adiw	r24, 0x0c	; 12
    7a1a:	e9 81       	ldd	r30, Y+1	; 0x01
    7a1c:	fa 81       	ldd	r31, Y+2	; 0x02
    7a1e:	95 83       	std	Z+5, r25	; 0x05
    7a20:	84 83       	std	Z+4, r24	; 0x04
    7a22:	ea 85       	ldd	r30, Y+10	; 0x0a
    7a24:	fb 85       	ldd	r31, Y+11	; 0x0b
    7a26:	8c ee       	ldi	r24, 0xEC	; 236
    7a28:	97 e0       	ldi	r25, 0x07	; 7
    7a2a:	95 8b       	std	Z+21, r25	; 0x15
    7a2c:	84 8b       	std	Z+20, r24	; 0x14
    7a2e:	80 91 ec 07 	lds	r24, 0x07EC
    7a32:	8f 5f       	subi	r24, 0xFF	; 255
    7a34:	80 93 ec 07 	sts	0x07EC, r24
    }

    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    7a38:	ea 85       	ldd	r30, Y+10	; 0x0a
    7a3a:	fb 85       	ldd	r31, Y+11	; 0x0b
    7a3c:	96 89       	ldd	r25, Z+22	; 0x16
    7a3e:	e0 91 a0 07 	lds	r30, 0x07A0
    7a42:	f0 91 a1 07 	lds	r31, 0x07A1
    7a46:	86 89       	ldd	r24, Z+22	; 0x16
    7a48:	89 17       	cp	r24, r25
    7a4a:	30 f4       	brcc	.+12     	; 0x7a58 <xTaskRemoveFromEventList+0x272>
    {
        /* Return true if the task removed from the event list has a higher
         * priority than the calling task.  This allows the calling task to know if
         * it should force a context switch now. */
        xReturn = pdTRUE;
    7a4c:	81 e0       	ldi	r24, 0x01	; 1
    7a4e:	89 87       	std	Y+9, r24	; 0x09

        /* Mark that a yield is pending in case the user is not using the
         * "xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
        xYieldPending = pdTRUE;
    7a50:	81 e0       	ldi	r24, 0x01	; 1
    7a52:	80 93 aa 07 	sts	0x07AA, r24
    7a56:	01 c0       	rjmp	.+2      	; 0x7a5a <xTaskRemoveFromEventList+0x274>
    }
    else
    {
        xReturn = pdFALSE;
    7a58:	19 86       	std	Y+9, r1	; 0x09
    }

    return xReturn;
    7a5a:	89 85       	ldd	r24, Y+9	; 0x09
}
    7a5c:	2d 96       	adiw	r28, 0x0d	; 13
    7a5e:	0f b6       	in	r0, 0x3f	; 63
    7a60:	f8 94       	cli
    7a62:	de bf       	out	0x3e, r29	; 62
    7a64:	0f be       	out	0x3f, r0	; 63
    7a66:	cd bf       	out	0x3d, r28	; 61
    7a68:	cf 91       	pop	r28
    7a6a:	df 91       	pop	r29
    7a6c:	08 95       	ret

00007a6e <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem,
                                        const TickType_t xItemValue )
{
    7a6e:	df 93       	push	r29
    7a70:	cf 93       	push	r28
    7a72:	cd b7       	in	r28, 0x3d	; 61
    7a74:	de b7       	in	r29, 0x3e	; 62
    7a76:	2c 97       	sbiw	r28, 0x0c	; 12
    7a78:	0f b6       	in	r0, 0x3f	; 63
    7a7a:	f8 94       	cli
    7a7c:	de bf       	out	0x3e, r29	; 62
    7a7e:	0f be       	out	0x3f, r0	; 63
    7a80:	cd bf       	out	0x3d, r28	; 61
    7a82:	9a 87       	std	Y+10, r25	; 0x0a
    7a84:	89 87       	std	Y+9, r24	; 0x09
    7a86:	7c 87       	std	Y+12, r23	; 0x0c
    7a88:	6b 87       	std	Y+11, r22	; 0x0b
    /* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
     * the event flags implementation. */
    configASSERT( uxSchedulerSuspended != pdFALSE );

    /* Store the new item value in the event list. */
    listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    7a8a:	8b 85       	ldd	r24, Y+11	; 0x0b
    7a8c:	9c 85       	ldd	r25, Y+12	; 0x0c
    7a8e:	90 68       	ori	r25, 0x80	; 128
    7a90:	e9 85       	ldd	r30, Y+9	; 0x09
    7a92:	fa 85       	ldd	r31, Y+10	; 0x0a
    7a94:	91 83       	std	Z+1, r25	; 0x01
    7a96:	80 83       	st	Z, r24

    /* Remove the event list form the event flag.  Interrupts do not access
     * event flags. */
    pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    7a98:	e9 85       	ldd	r30, Y+9	; 0x09
    7a9a:	fa 85       	ldd	r31, Y+10	; 0x0a
    7a9c:	86 81       	ldd	r24, Z+6	; 0x06
    7a9e:	97 81       	ldd	r25, Z+7	; 0x07
    7aa0:	98 87       	std	Y+8, r25	; 0x08
    7aa2:	8f 83       	std	Y+7, r24	; 0x07
    configASSERT( pxUnblockedTCB );
    listREMOVE_ITEM( pxEventListItem );
    7aa4:	e9 85       	ldd	r30, Y+9	; 0x09
    7aa6:	fa 85       	ldd	r31, Y+10	; 0x0a
    7aa8:	80 85       	ldd	r24, Z+8	; 0x08
    7aaa:	91 85       	ldd	r25, Z+9	; 0x09
    7aac:	9e 83       	std	Y+6, r25	; 0x06
    7aae:	8d 83       	std	Y+5, r24	; 0x05
    7ab0:	e9 85       	ldd	r30, Y+9	; 0x09
    7ab2:	fa 85       	ldd	r31, Y+10	; 0x0a
    7ab4:	a2 81       	ldd	r26, Z+2	; 0x02
    7ab6:	b3 81       	ldd	r27, Z+3	; 0x03
    7ab8:	e9 85       	ldd	r30, Y+9	; 0x09
    7aba:	fa 85       	ldd	r31, Y+10	; 0x0a
    7abc:	84 81       	ldd	r24, Z+4	; 0x04
    7abe:	95 81       	ldd	r25, Z+5	; 0x05
    7ac0:	15 96       	adiw	r26, 0x05	; 5
    7ac2:	9c 93       	st	X, r25
    7ac4:	8e 93       	st	-X, r24
    7ac6:	14 97       	sbiw	r26, 0x04	; 4
    7ac8:	e9 85       	ldd	r30, Y+9	; 0x09
    7aca:	fa 85       	ldd	r31, Y+10	; 0x0a
    7acc:	a4 81       	ldd	r26, Z+4	; 0x04
    7ace:	b5 81       	ldd	r27, Z+5	; 0x05
    7ad0:	e9 85       	ldd	r30, Y+9	; 0x09
    7ad2:	fa 85       	ldd	r31, Y+10	; 0x0a
    7ad4:	82 81       	ldd	r24, Z+2	; 0x02
    7ad6:	93 81       	ldd	r25, Z+3	; 0x03
    7ad8:	13 96       	adiw	r26, 0x03	; 3
    7ada:	9c 93       	st	X, r25
    7adc:	8e 93       	st	-X, r24
    7ade:	12 97       	sbiw	r26, 0x02	; 2
    7ae0:	ed 81       	ldd	r30, Y+5	; 0x05
    7ae2:	fe 81       	ldd	r31, Y+6	; 0x06
    7ae4:	21 81       	ldd	r18, Z+1	; 0x01
    7ae6:	32 81       	ldd	r19, Z+2	; 0x02
    7ae8:	89 85       	ldd	r24, Y+9	; 0x09
    7aea:	9a 85       	ldd	r25, Y+10	; 0x0a
    7aec:	28 17       	cp	r18, r24
    7aee:	39 07       	cpc	r19, r25
    7af0:	41 f4       	brne	.+16     	; 0x7b02 <vTaskRemoveFromUnorderedEventList+0x94>
    7af2:	e9 85       	ldd	r30, Y+9	; 0x09
    7af4:	fa 85       	ldd	r31, Y+10	; 0x0a
    7af6:	84 81       	ldd	r24, Z+4	; 0x04
    7af8:	95 81       	ldd	r25, Z+5	; 0x05
    7afa:	ed 81       	ldd	r30, Y+5	; 0x05
    7afc:	fe 81       	ldd	r31, Y+6	; 0x06
    7afe:	92 83       	std	Z+2, r25	; 0x02
    7b00:	81 83       	std	Z+1, r24	; 0x01
    7b02:	e9 85       	ldd	r30, Y+9	; 0x09
    7b04:	fa 85       	ldd	r31, Y+10	; 0x0a
    7b06:	11 86       	std	Z+9, r1	; 0x09
    7b08:	10 86       	std	Z+8, r1	; 0x08
    7b0a:	ed 81       	ldd	r30, Y+5	; 0x05
    7b0c:	fe 81       	ldd	r31, Y+6	; 0x06
    7b0e:	80 81       	ld	r24, Z
    7b10:	81 50       	subi	r24, 0x01	; 1
    7b12:	ed 81       	ldd	r30, Y+5	; 0x05
    7b14:	fe 81       	ldd	r31, Y+6	; 0x06
    7b16:	80 83       	st	Z, r24
    #endif

    /* Remove the task from the delayed list and add it to the ready list.  The
     * scheduler is suspended so interrupts will not be accessing the ready
     * lists. */
    listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
    7b18:	ef 81       	ldd	r30, Y+7	; 0x07
    7b1a:	f8 85       	ldd	r31, Y+8	; 0x08
    7b1c:	82 85       	ldd	r24, Z+10	; 0x0a
    7b1e:	93 85       	ldd	r25, Z+11	; 0x0b
    7b20:	9c 83       	std	Y+4, r25	; 0x04
    7b22:	8b 83       	std	Y+3, r24	; 0x03
    7b24:	ef 81       	ldd	r30, Y+7	; 0x07
    7b26:	f8 85       	ldd	r31, Y+8	; 0x08
    7b28:	a4 81       	ldd	r26, Z+4	; 0x04
    7b2a:	b5 81       	ldd	r27, Z+5	; 0x05
    7b2c:	ef 81       	ldd	r30, Y+7	; 0x07
    7b2e:	f8 85       	ldd	r31, Y+8	; 0x08
    7b30:	86 81       	ldd	r24, Z+6	; 0x06
    7b32:	97 81       	ldd	r25, Z+7	; 0x07
    7b34:	15 96       	adiw	r26, 0x05	; 5
    7b36:	9c 93       	st	X, r25
    7b38:	8e 93       	st	-X, r24
    7b3a:	14 97       	sbiw	r26, 0x04	; 4
    7b3c:	ef 81       	ldd	r30, Y+7	; 0x07
    7b3e:	f8 85       	ldd	r31, Y+8	; 0x08
    7b40:	a6 81       	ldd	r26, Z+6	; 0x06
    7b42:	b7 81       	ldd	r27, Z+7	; 0x07
    7b44:	ef 81       	ldd	r30, Y+7	; 0x07
    7b46:	f8 85       	ldd	r31, Y+8	; 0x08
    7b48:	84 81       	ldd	r24, Z+4	; 0x04
    7b4a:	95 81       	ldd	r25, Z+5	; 0x05
    7b4c:	13 96       	adiw	r26, 0x03	; 3
    7b4e:	9c 93       	st	X, r25
    7b50:	8e 93       	st	-X, r24
    7b52:	12 97       	sbiw	r26, 0x02	; 2
    7b54:	eb 81       	ldd	r30, Y+3	; 0x03
    7b56:	fc 81       	ldd	r31, Y+4	; 0x04
    7b58:	21 81       	ldd	r18, Z+1	; 0x01
    7b5a:	32 81       	ldd	r19, Z+2	; 0x02
    7b5c:	8f 81       	ldd	r24, Y+7	; 0x07
    7b5e:	98 85       	ldd	r25, Y+8	; 0x08
    7b60:	02 96       	adiw	r24, 0x02	; 2
    7b62:	28 17       	cp	r18, r24
    7b64:	39 07       	cpc	r19, r25
    7b66:	41 f4       	brne	.+16     	; 0x7b78 <vTaskRemoveFromUnorderedEventList+0x10a>
    7b68:	ef 81       	ldd	r30, Y+7	; 0x07
    7b6a:	f8 85       	ldd	r31, Y+8	; 0x08
    7b6c:	86 81       	ldd	r24, Z+6	; 0x06
    7b6e:	97 81       	ldd	r25, Z+7	; 0x07
    7b70:	eb 81       	ldd	r30, Y+3	; 0x03
    7b72:	fc 81       	ldd	r31, Y+4	; 0x04
    7b74:	92 83       	std	Z+2, r25	; 0x02
    7b76:	81 83       	std	Z+1, r24	; 0x01
    7b78:	ef 81       	ldd	r30, Y+7	; 0x07
    7b7a:	f8 85       	ldd	r31, Y+8	; 0x08
    7b7c:	13 86       	std	Z+11, r1	; 0x0b
    7b7e:	12 86       	std	Z+10, r1	; 0x0a
    7b80:	eb 81       	ldd	r30, Y+3	; 0x03
    7b82:	fc 81       	ldd	r31, Y+4	; 0x04
    7b84:	80 81       	ld	r24, Z
    7b86:	81 50       	subi	r24, 0x01	; 1
    7b88:	eb 81       	ldd	r30, Y+3	; 0x03
    7b8a:	fc 81       	ldd	r31, Y+4	; 0x04
    7b8c:	80 83       	st	Z, r24
    prvAddTaskToReadyList( pxUnblockedTCB );
    7b8e:	ef 81       	ldd	r30, Y+7	; 0x07
    7b90:	f8 85       	ldd	r31, Y+8	; 0x08
    7b92:	96 89       	ldd	r25, Z+22	; 0x16
    7b94:	80 91 a6 07 	lds	r24, 0x07A6
    7b98:	89 17       	cp	r24, r25
    7b9a:	28 f4       	brcc	.+10     	; 0x7ba6 <vTaskRemoveFromUnorderedEventList+0x138>
    7b9c:	ef 81       	ldd	r30, Y+7	; 0x07
    7b9e:	f8 85       	ldd	r31, Y+8	; 0x08
    7ba0:	86 89       	ldd	r24, Z+22	; 0x16
    7ba2:	80 93 a6 07 	sts	0x07A6, r24
    7ba6:	ef 81       	ldd	r30, Y+7	; 0x07
    7ba8:	f8 85       	ldd	r31, Y+8	; 0x08
    7baa:	86 89       	ldd	r24, Z+22	; 0x16
    7bac:	28 2f       	mov	r18, r24
    7bae:	30 e0       	ldi	r19, 0x00	; 0
    7bb0:	c9 01       	movw	r24, r18
    7bb2:	88 0f       	add	r24, r24
    7bb4:	99 1f       	adc	r25, r25
    7bb6:	88 0f       	add	r24, r24
    7bb8:	99 1f       	adc	r25, r25
    7bba:	88 0f       	add	r24, r24
    7bbc:	99 1f       	adc	r25, r25
    7bbe:	82 0f       	add	r24, r18
    7bc0:	93 1f       	adc	r25, r19
    7bc2:	fc 01       	movw	r30, r24
    7bc4:	ee 54       	subi	r30, 0x4E	; 78
    7bc6:	f8 4f       	sbci	r31, 0xF8	; 248
    7bc8:	81 81       	ldd	r24, Z+1	; 0x01
    7bca:	92 81       	ldd	r25, Z+2	; 0x02
    7bcc:	9a 83       	std	Y+2, r25	; 0x02
    7bce:	89 83       	std	Y+1, r24	; 0x01
    7bd0:	ef 81       	ldd	r30, Y+7	; 0x07
    7bd2:	f8 85       	ldd	r31, Y+8	; 0x08
    7bd4:	89 81       	ldd	r24, Y+1	; 0x01
    7bd6:	9a 81       	ldd	r25, Y+2	; 0x02
    7bd8:	95 83       	std	Z+5, r25	; 0x05
    7bda:	84 83       	std	Z+4, r24	; 0x04
    7bdc:	e9 81       	ldd	r30, Y+1	; 0x01
    7bde:	fa 81       	ldd	r31, Y+2	; 0x02
    7be0:	84 81       	ldd	r24, Z+4	; 0x04
    7be2:	95 81       	ldd	r25, Z+5	; 0x05
    7be4:	ef 81       	ldd	r30, Y+7	; 0x07
    7be6:	f8 85       	ldd	r31, Y+8	; 0x08
    7be8:	97 83       	std	Z+7, r25	; 0x07
    7bea:	86 83       	std	Z+6, r24	; 0x06
    7bec:	e9 81       	ldd	r30, Y+1	; 0x01
    7bee:	fa 81       	ldd	r31, Y+2	; 0x02
    7bf0:	04 80       	ldd	r0, Z+4	; 0x04
    7bf2:	f5 81       	ldd	r31, Z+5	; 0x05
    7bf4:	e0 2d       	mov	r30, r0
    7bf6:	8f 81       	ldd	r24, Y+7	; 0x07
    7bf8:	98 85       	ldd	r25, Y+8	; 0x08
    7bfa:	02 96       	adiw	r24, 0x02	; 2
    7bfc:	93 83       	std	Z+3, r25	; 0x03
    7bfe:	82 83       	std	Z+2, r24	; 0x02
    7c00:	8f 81       	ldd	r24, Y+7	; 0x07
    7c02:	98 85       	ldd	r25, Y+8	; 0x08
    7c04:	02 96       	adiw	r24, 0x02	; 2
    7c06:	e9 81       	ldd	r30, Y+1	; 0x01
    7c08:	fa 81       	ldd	r31, Y+2	; 0x02
    7c0a:	95 83       	std	Z+5, r25	; 0x05
    7c0c:	84 83       	std	Z+4, r24	; 0x04
    7c0e:	ef 81       	ldd	r30, Y+7	; 0x07
    7c10:	f8 85       	ldd	r31, Y+8	; 0x08
    7c12:	86 89       	ldd	r24, Z+22	; 0x16
    7c14:	28 2f       	mov	r18, r24
    7c16:	30 e0       	ldi	r19, 0x00	; 0
    7c18:	c9 01       	movw	r24, r18
    7c1a:	88 0f       	add	r24, r24
    7c1c:	99 1f       	adc	r25, r25
    7c1e:	88 0f       	add	r24, r24
    7c20:	99 1f       	adc	r25, r25
    7c22:	88 0f       	add	r24, r24
    7c24:	99 1f       	adc	r25, r25
    7c26:	82 0f       	add	r24, r18
    7c28:	93 1f       	adc	r25, r19
    7c2a:	8e 54       	subi	r24, 0x4E	; 78
    7c2c:	98 4f       	sbci	r25, 0xF8	; 248
    7c2e:	ef 81       	ldd	r30, Y+7	; 0x07
    7c30:	f8 85       	ldd	r31, Y+8	; 0x08
    7c32:	93 87       	std	Z+11, r25	; 0x0b
    7c34:	82 87       	std	Z+10, r24	; 0x0a
    7c36:	ef 81       	ldd	r30, Y+7	; 0x07
    7c38:	f8 85       	ldd	r31, Y+8	; 0x08
    7c3a:	86 89       	ldd	r24, Z+22	; 0x16
    7c3c:	28 2f       	mov	r18, r24
    7c3e:	30 e0       	ldi	r19, 0x00	; 0
    7c40:	c9 01       	movw	r24, r18
    7c42:	88 0f       	add	r24, r24
    7c44:	99 1f       	adc	r25, r25
    7c46:	88 0f       	add	r24, r24
    7c48:	99 1f       	adc	r25, r25
    7c4a:	88 0f       	add	r24, r24
    7c4c:	99 1f       	adc	r25, r25
    7c4e:	82 0f       	add	r24, r18
    7c50:	93 1f       	adc	r25, r19
    7c52:	fc 01       	movw	r30, r24
    7c54:	ee 54       	subi	r30, 0x4E	; 78
    7c56:	f8 4f       	sbci	r31, 0xF8	; 248
    7c58:	80 81       	ld	r24, Z
    7c5a:	8f 5f       	subi	r24, 0xFF	; 255
    7c5c:	80 83       	st	Z, r24

    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    7c5e:	ef 81       	ldd	r30, Y+7	; 0x07
    7c60:	f8 85       	ldd	r31, Y+8	; 0x08
    7c62:	96 89       	ldd	r25, Z+22	; 0x16
    7c64:	e0 91 a0 07 	lds	r30, 0x07A0
    7c68:	f0 91 a1 07 	lds	r31, 0x07A1
    7c6c:	86 89       	ldd	r24, Z+22	; 0x16
    7c6e:	89 17       	cp	r24, r25
    7c70:	18 f4       	brcc	.+6      	; 0x7c78 <vTaskRemoveFromUnorderedEventList+0x20a>
    {
        /* The unblocked task has a priority above that of the calling task, so
         * a context switch is required.  This function is called with the
         * scheduler suspended so xYieldPending is set so the context switch
         * occurs immediately that the scheduler is resumed (unsuspended). */
        xYieldPending = pdTRUE;
    7c72:	81 e0       	ldi	r24, 0x01	; 1
    7c74:	80 93 aa 07 	sts	0x07AA, r24
    }
}
    7c78:	2c 96       	adiw	r28, 0x0c	; 12
    7c7a:	0f b6       	in	r0, 0x3f	; 63
    7c7c:	f8 94       	cli
    7c7e:	de bf       	out	0x3e, r29	; 62
    7c80:	0f be       	out	0x3f, r0	; 63
    7c82:	cd bf       	out	0x3d, r28	; 61
    7c84:	cf 91       	pop	r28
    7c86:	df 91       	pop	r29
    7c88:	08 95       	ret

00007c8a <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    7c8a:	df 93       	push	r29
    7c8c:	cf 93       	push	r28
    7c8e:	00 d0       	rcall	.+0      	; 0x7c90 <vTaskSetTimeOutState+0x6>
    7c90:	cd b7       	in	r28, 0x3d	; 61
    7c92:	de b7       	in	r29, 0x3e	; 62
    7c94:	9a 83       	std	Y+2, r25	; 0x02
    7c96:	89 83       	std	Y+1, r24	; 0x01
    configASSERT( pxTimeOut );
    taskENTER_CRITICAL();
    7c98:	0f b6       	in	r0, 0x3f	; 63
    7c9a:	f8 94       	cli
    7c9c:	0f 92       	push	r0
    {
        pxTimeOut->xOverflowCount = xNumOfOverflows;
    7c9e:	80 91 ab 07 	lds	r24, 0x07AB
    7ca2:	e9 81       	ldd	r30, Y+1	; 0x01
    7ca4:	fa 81       	ldd	r31, Y+2	; 0x02
    7ca6:	80 83       	st	Z, r24
        pxTimeOut->xTimeOnEntering = xTickCount;
    7ca8:	80 91 a4 07 	lds	r24, 0x07A4
    7cac:	90 91 a5 07 	lds	r25, 0x07A5
    7cb0:	e9 81       	ldd	r30, Y+1	; 0x01
    7cb2:	fa 81       	ldd	r31, Y+2	; 0x02
    7cb4:	92 83       	std	Z+2, r25	; 0x02
    7cb6:	81 83       	std	Z+1, r24	; 0x01
    }
    taskEXIT_CRITICAL();
    7cb8:	0f 90       	pop	r0
    7cba:	0f be       	out	0x3f, r0	; 63
}
    7cbc:	0f 90       	pop	r0
    7cbe:	0f 90       	pop	r0
    7cc0:	cf 91       	pop	r28
    7cc2:	df 91       	pop	r29
    7cc4:	08 95       	ret

00007cc6 <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    7cc6:	df 93       	push	r29
    7cc8:	cf 93       	push	r28
    7cca:	00 d0       	rcall	.+0      	; 0x7ccc <vTaskInternalSetTimeOutState+0x6>
    7ccc:	cd b7       	in	r28, 0x3d	; 61
    7cce:	de b7       	in	r29, 0x3e	; 62
    7cd0:	9a 83       	std	Y+2, r25	; 0x02
    7cd2:	89 83       	std	Y+1, r24	; 0x01
    /* For internal use only as it does not use a critical section. */
    pxTimeOut->xOverflowCount = xNumOfOverflows;
    7cd4:	80 91 ab 07 	lds	r24, 0x07AB
    7cd8:	e9 81       	ldd	r30, Y+1	; 0x01
    7cda:	fa 81       	ldd	r31, Y+2	; 0x02
    7cdc:	80 83       	st	Z, r24
    pxTimeOut->xTimeOnEntering = xTickCount;
    7cde:	80 91 a4 07 	lds	r24, 0x07A4
    7ce2:	90 91 a5 07 	lds	r25, 0x07A5
    7ce6:	e9 81       	ldd	r30, Y+1	; 0x01
    7ce8:	fa 81       	ldd	r31, Y+2	; 0x02
    7cea:	92 83       	std	Z+2, r25	; 0x02
    7cec:	81 83       	std	Z+1, r24	; 0x01
}
    7cee:	0f 90       	pop	r0
    7cf0:	0f 90       	pop	r0
    7cf2:	cf 91       	pop	r28
    7cf4:	df 91       	pop	r29
    7cf6:	08 95       	ret

00007cf8 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut,
                                 TickType_t * const pxTicksToWait )
{
    7cf8:	df 93       	push	r29
    7cfa:	cf 93       	push	r28
    7cfc:	cd b7       	in	r28, 0x3d	; 61
    7cfe:	de b7       	in	r29, 0x3e	; 62
    7d00:	29 97       	sbiw	r28, 0x09	; 9
    7d02:	0f b6       	in	r0, 0x3f	; 63
    7d04:	f8 94       	cli
    7d06:	de bf       	out	0x3e, r29	; 62
    7d08:	0f be       	out	0x3f, r0	; 63
    7d0a:	cd bf       	out	0x3d, r28	; 61
    7d0c:	9f 83       	std	Y+7, r25	; 0x07
    7d0e:	8e 83       	std	Y+6, r24	; 0x06
    7d10:	79 87       	std	Y+9, r23	; 0x09
    7d12:	68 87       	std	Y+8, r22	; 0x08
    BaseType_t xReturn;

    configASSERT( pxTimeOut );
    configASSERT( pxTicksToWait );

    taskENTER_CRITICAL();
    7d14:	0f b6       	in	r0, 0x3f	; 63
    7d16:	f8 94       	cli
    7d18:	0f 92       	push	r0
    {
        /* Minor optimisation.  The tick count cannot change in this block. */
        const TickType_t xConstTickCount = xTickCount;
    7d1a:	80 91 a4 07 	lds	r24, 0x07A4
    7d1e:	90 91 a5 07 	lds	r25, 0x07A5
    7d22:	9c 83       	std	Y+4, r25	; 0x04
    7d24:	8b 83       	std	Y+3, r24	; 0x03
        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    7d26:	ee 81       	ldd	r30, Y+6	; 0x06
    7d28:	ff 81       	ldd	r31, Y+7	; 0x07
    7d2a:	21 81       	ldd	r18, Z+1	; 0x01
    7d2c:	32 81       	ldd	r19, Z+2	; 0x02
    7d2e:	8b 81       	ldd	r24, Y+3	; 0x03
    7d30:	9c 81       	ldd	r25, Y+4	; 0x04
    7d32:	82 1b       	sub	r24, r18
    7d34:	93 0b       	sbc	r25, r19
    7d36:	9a 83       	std	Y+2, r25	; 0x02
    7d38:	89 83       	std	Y+1, r24	; 0x01
                xReturn = pdFALSE;
            }
            else
        #endif

        if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    7d3a:	ee 81       	ldd	r30, Y+6	; 0x06
    7d3c:	ff 81       	ldd	r31, Y+7	; 0x07
    7d3e:	90 81       	ld	r25, Z
    7d40:	80 91 ab 07 	lds	r24, 0x07AB
    7d44:	98 17       	cp	r25, r24
    7d46:	81 f0       	breq	.+32     	; 0x7d68 <xTaskCheckForTimeOut+0x70>
    7d48:	ee 81       	ldd	r30, Y+6	; 0x06
    7d4a:	ff 81       	ldd	r31, Y+7	; 0x07
    7d4c:	21 81       	ldd	r18, Z+1	; 0x01
    7d4e:	32 81       	ldd	r19, Z+2	; 0x02
    7d50:	8b 81       	ldd	r24, Y+3	; 0x03
    7d52:	9c 81       	ldd	r25, Y+4	; 0x04
    7d54:	82 17       	cp	r24, r18
    7d56:	93 07       	cpc	r25, r19
    7d58:	38 f0       	brcs	.+14     	; 0x7d68 <xTaskCheckForTimeOut+0x70>
            /* The tick count is greater than the time at which
             * vTaskSetTimeout() was called, but has also overflowed since
             * vTaskSetTimeOut() was called.  It must have wrapped all the way
             * around and gone past again. This passed since vTaskSetTimeout()
             * was called. */
            xReturn = pdTRUE;
    7d5a:	81 e0       	ldi	r24, 0x01	; 1
    7d5c:	8d 83       	std	Y+5, r24	; 0x05
            *pxTicksToWait = ( TickType_t ) 0;
    7d5e:	e8 85       	ldd	r30, Y+8	; 0x08
    7d60:	f9 85       	ldd	r31, Y+9	; 0x09
    7d62:	11 82       	std	Z+1, r1	; 0x01
    7d64:	10 82       	st	Z, r1
    7d66:	23 c0       	rjmp	.+70     	; 0x7dae <xTaskCheckForTimeOut+0xb6>
        }
        else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    7d68:	e8 85       	ldd	r30, Y+8	; 0x08
    7d6a:	f9 85       	ldd	r31, Y+9	; 0x09
    7d6c:	20 81       	ld	r18, Z
    7d6e:	31 81       	ldd	r19, Z+1	; 0x01
    7d70:	89 81       	ldd	r24, Y+1	; 0x01
    7d72:	9a 81       	ldd	r25, Y+2	; 0x02
    7d74:	82 17       	cp	r24, r18
    7d76:	93 07       	cpc	r25, r19
    7d78:	a0 f4       	brcc	.+40     	; 0x7da2 <xTaskCheckForTimeOut+0xaa>
        {
            /* Not a genuine timeout. Adjust parameters for time remaining. */
            *pxTicksToWait -= xElapsedTime;
    7d7a:	e8 85       	ldd	r30, Y+8	; 0x08
    7d7c:	f9 85       	ldd	r31, Y+9	; 0x09
    7d7e:	20 81       	ld	r18, Z
    7d80:	31 81       	ldd	r19, Z+1	; 0x01
    7d82:	89 81       	ldd	r24, Y+1	; 0x01
    7d84:	9a 81       	ldd	r25, Y+2	; 0x02
    7d86:	a9 01       	movw	r20, r18
    7d88:	48 1b       	sub	r20, r24
    7d8a:	59 0b       	sbc	r21, r25
    7d8c:	ca 01       	movw	r24, r20
    7d8e:	e8 85       	ldd	r30, Y+8	; 0x08
    7d90:	f9 85       	ldd	r31, Y+9	; 0x09
    7d92:	91 83       	std	Z+1, r25	; 0x01
    7d94:	80 83       	st	Z, r24
            vTaskInternalSetTimeOutState( pxTimeOut );
    7d96:	8e 81       	ldd	r24, Y+6	; 0x06
    7d98:	9f 81       	ldd	r25, Y+7	; 0x07
    7d9a:	0e 94 63 3e 	call	0x7cc6	; 0x7cc6 <vTaskInternalSetTimeOutState>
            xReturn = pdFALSE;
    7d9e:	1d 82       	std	Y+5, r1	; 0x05
    7da0:	06 c0       	rjmp	.+12     	; 0x7dae <xTaskCheckForTimeOut+0xb6>
        }
        else
        {
            *pxTicksToWait = ( TickType_t ) 0;
    7da2:	e8 85       	ldd	r30, Y+8	; 0x08
    7da4:	f9 85       	ldd	r31, Y+9	; 0x09
    7da6:	11 82       	std	Z+1, r1	; 0x01
    7da8:	10 82       	st	Z, r1
            xReturn = pdTRUE;
    7daa:	81 e0       	ldi	r24, 0x01	; 1
    7dac:	8d 83       	std	Y+5, r24	; 0x05
        }
    }
    taskEXIT_CRITICAL();
    7dae:	0f 90       	pop	r0
    7db0:	0f be       	out	0x3f, r0	; 63

    return xReturn;
    7db2:	8d 81       	ldd	r24, Y+5	; 0x05
}
    7db4:	29 96       	adiw	r28, 0x09	; 9
    7db6:	0f b6       	in	r0, 0x3f	; 63
    7db8:	f8 94       	cli
    7dba:	de bf       	out	0x3e, r29	; 62
    7dbc:	0f be       	out	0x3f, r0	; 63
    7dbe:	cd bf       	out	0x3d, r28	; 61
    7dc0:	cf 91       	pop	r28
    7dc2:	df 91       	pop	r29
    7dc4:	08 95       	ret

00007dc6 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    7dc6:	df 93       	push	r29
    7dc8:	cf 93       	push	r28
    7dca:	cd b7       	in	r28, 0x3d	; 61
    7dcc:	de b7       	in	r29, 0x3e	; 62
    xYieldPending = pdTRUE;
    7dce:	81 e0       	ldi	r24, 0x01	; 1
    7dd0:	80 93 aa 07 	sts	0x07AA, r24
}
    7dd4:	cf 91       	pop	r28
    7dd6:	df 91       	pop	r29
    7dd8:	08 95       	ret

00007dda <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    7dda:	df 93       	push	r29
    7ddc:	cf 93       	push	r28
    7dde:	00 d0       	rcall	.+0      	; 0x7de0 <prvIdleTask+0x6>
    7de0:	cd b7       	in	r28, 0x3d	; 61
    7de2:	de b7       	in	r29, 0x3e	; 62
    7de4:	9a 83       	std	Y+2, r25	; 0x02
    7de6:	89 83       	std	Y+1, r24	; 0x01

    for( ; ; )
    {
        /* See if any tasks have deleted themselves - if so then the idle task
         * is responsible for freeing the deleted task's TCB and stack. */
        prvCheckTasksWaitingTermination();
    7de8:	0e 94 3a 3f 	call	0x7e74	; 0x7e74 <prvCheckTasksWaitingTermination>
                 *
                 * A critical region is not required here as we are just reading from
                 * the list, and an occasional incorrect value will not matter.  If
                 * the ready list at the idle priority contains more than one task
                 * then a task other than the idle task is ready to execute. */
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    7dec:	80 91 b2 07 	lds	r24, 0x07B2
    7df0:	82 30       	cpi	r24, 0x02	; 2
    7df2:	d0 f3       	brcs	.-12     	; 0x7de8 <prvIdleTask+0xe>
                {
                    taskYIELD();
    7df4:	0e 94 87 21 	call	0x430e	; 0x430e <vPortYield>
    7df8:	f7 cf       	rjmp	.-18     	; 0x7de8 <prvIdleTask+0xe>

00007dfa <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    7dfa:	df 93       	push	r29
    7dfc:	cf 93       	push	r28
    7dfe:	0f 92       	push	r0
    7e00:	cd b7       	in	r28, 0x3d	; 61
    7e02:	de b7       	in	r29, 0x3e	; 62
    UBaseType_t uxPriority;

    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    7e04:	19 82       	std	Y+1, r1	; 0x01
    7e06:	13 c0       	rjmp	.+38     	; 0x7e2e <prvInitialiseTaskLists+0x34>
    {
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    7e08:	89 81       	ldd	r24, Y+1	; 0x01
    7e0a:	28 2f       	mov	r18, r24
    7e0c:	30 e0       	ldi	r19, 0x00	; 0
    7e0e:	c9 01       	movw	r24, r18
    7e10:	88 0f       	add	r24, r24
    7e12:	99 1f       	adc	r25, r25
    7e14:	88 0f       	add	r24, r24
    7e16:	99 1f       	adc	r25, r25
    7e18:	88 0f       	add	r24, r24
    7e1a:	99 1f       	adc	r25, r25
    7e1c:	82 0f       	add	r24, r18
    7e1e:	93 1f       	adc	r25, r19
    7e20:	8e 54       	subi	r24, 0x4E	; 78
    7e22:	98 4f       	sbci	r25, 0xF8	; 248
    7e24:	0e 94 92 1e 	call	0x3d24	; 0x3d24 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
    UBaseType_t uxPriority;

    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    7e28:	89 81       	ldd	r24, Y+1	; 0x01
    7e2a:	8f 5f       	subi	r24, 0xFF	; 255
    7e2c:	89 83       	std	Y+1, r24	; 0x01
    7e2e:	89 81       	ldd	r24, Y+1	; 0x01
    7e30:	84 30       	cpi	r24, 0x04	; 4
    7e32:	50 f3       	brcs	.-44     	; 0x7e08 <prvInitialiseTaskLists+0xe>
    {
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    }

    vListInitialise( &xDelayedTaskList1 );
    7e34:	86 ed       	ldi	r24, 0xD6	; 214
    7e36:	97 e0       	ldi	r25, 0x07	; 7
    7e38:	0e 94 92 1e 	call	0x3d24	; 0x3d24 <vListInitialise>
    vListInitialise( &xDelayedTaskList2 );
    7e3c:	8f ed       	ldi	r24, 0xDF	; 223
    7e3e:	97 e0       	ldi	r25, 0x07	; 7
    7e40:	0e 94 92 1e 	call	0x3d24	; 0x3d24 <vListInitialise>
    vListInitialise( &xPendingReadyList );
    7e44:	8c ee       	ldi	r24, 0xEC	; 236
    7e46:	97 e0       	ldi	r25, 0x07	; 7
    7e48:	0e 94 92 1e 	call	0x3d24	; 0x3d24 <vListInitialise>

    #if ( INCLUDE_vTaskDelete == 1 )
        {
            vListInitialise( &xTasksWaitingTermination );
    7e4c:	85 ef       	ldi	r24, 0xF5	; 245
    7e4e:	97 e0       	ldi	r25, 0x07	; 7
    7e50:	0e 94 92 1e 	call	0x3d24	; 0x3d24 <vListInitialise>
        }
    #endif /* INCLUDE_vTaskSuspend */

    /* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
     * using list2. */
    pxDelayedTaskList = &xDelayedTaskList1;
    7e54:	86 ed       	ldi	r24, 0xD6	; 214
    7e56:	97 e0       	ldi	r25, 0x07	; 7
    7e58:	90 93 e9 07 	sts	0x07E9, r25
    7e5c:	80 93 e8 07 	sts	0x07E8, r24
    pxOverflowDelayedTaskList = &xDelayedTaskList2;
    7e60:	8f ed       	ldi	r24, 0xDF	; 223
    7e62:	97 e0       	ldi	r25, 0x07	; 7
    7e64:	90 93 eb 07 	sts	0x07EB, r25
    7e68:	80 93 ea 07 	sts	0x07EA, r24
}
    7e6c:	0f 90       	pop	r0
    7e6e:	cf 91       	pop	r28
    7e70:	df 91       	pop	r29
    7e72:	08 95       	ret

00007e74 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    7e74:	df 93       	push	r29
    7e76:	cf 93       	push	r28
    7e78:	00 d0       	rcall	.+0      	; 0x7e7a <prvCheckTasksWaitingTermination+0x6>
    7e7a:	cd b7       	in	r28, 0x3d	; 61
    7e7c:	de b7       	in	r29, 0x3e	; 62
    7e7e:	20 c0       	rjmp	.+64     	; 0x7ec0 <prvCheckTasksWaitingTermination+0x4c>

            /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
             * being called too often in the idle task. */
            while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
            {
                taskENTER_CRITICAL();
    7e80:	0f b6       	in	r0, 0x3f	; 63
    7e82:	f8 94       	cli
    7e84:	0f 92       	push	r0
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    7e86:	e0 91 fa 07 	lds	r30, 0x07FA
    7e8a:	f0 91 fb 07 	lds	r31, 0x07FB
    7e8e:	86 81       	ldd	r24, Z+6	; 0x06
    7e90:	97 81       	ldd	r25, Z+7	; 0x07
    7e92:	9a 83       	std	Y+2, r25	; 0x02
    7e94:	89 83       	std	Y+1, r24	; 0x01
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    7e96:	89 81       	ldd	r24, Y+1	; 0x01
    7e98:	9a 81       	ldd	r25, Y+2	; 0x02
    7e9a:	02 96       	adiw	r24, 0x02	; 2
    7e9c:	0e 94 7c 1f 	call	0x3ef8	; 0x3ef8 <uxListRemove>
                    --uxCurrentNumberOfTasks;
    7ea0:	80 91 a3 07 	lds	r24, 0x07A3
    7ea4:	81 50       	subi	r24, 0x01	; 1
    7ea6:	80 93 a3 07 	sts	0x07A3, r24
                    --uxDeletedTasksWaitingCleanUp;
    7eaa:	80 91 a2 07 	lds	r24, 0x07A2
    7eae:	81 50       	subi	r24, 0x01	; 1
    7eb0:	80 93 a2 07 	sts	0x07A2, r24
                }
                taskEXIT_CRITICAL();
    7eb4:	0f 90       	pop	r0
    7eb6:	0f be       	out	0x3f, r0	; 63

                prvDeleteTCB( pxTCB );
    7eb8:	89 81       	ldd	r24, Y+1	; 0x01
    7eba:	9a 81       	ldd	r25, Y+2	; 0x02
    7ebc:	0e 94 69 3f 	call	0x7ed2	; 0x7ed2 <prvDeleteTCB>
        {
            TCB_t * pxTCB;

            /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
             * being called too often in the idle task. */
            while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    7ec0:	80 91 a2 07 	lds	r24, 0x07A2
    7ec4:	88 23       	and	r24, r24
    7ec6:	e1 f6       	brne	.-72     	; 0x7e80 <prvCheckTasksWaitingTermination+0xc>

                prvDeleteTCB( pxTCB );
            }
        }
    #endif /* INCLUDE_vTaskDelete */
}
    7ec8:	0f 90       	pop	r0
    7eca:	0f 90       	pop	r0
    7ecc:	cf 91       	pop	r28
    7ece:	df 91       	pop	r29
    7ed0:	08 95       	ret

00007ed2 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

    static void prvDeleteTCB( TCB_t * pxTCB )
    {
    7ed2:	df 93       	push	r29
    7ed4:	cf 93       	push	r28
    7ed6:	00 d0       	rcall	.+0      	; 0x7ed8 <prvDeleteTCB+0x6>
    7ed8:	cd b7       	in	r28, 0x3d	; 61
    7eda:	de b7       	in	r29, 0x3e	; 62
    7edc:	9a 83       	std	Y+2, r25	; 0x02
    7ede:	89 83       	std	Y+1, r24	; 0x01

        #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
            {
                /* The task can only have been allocated dynamically - free both
                 * the stack and TCB. */
                vPortFreeStack( pxTCB->pxStack );
    7ee0:	e9 81       	ldd	r30, Y+1	; 0x01
    7ee2:	fa 81       	ldd	r31, Y+2	; 0x02
    7ee4:	87 89       	ldd	r24, Z+23	; 0x17
    7ee6:	90 8d       	ldd	r25, Z+24	; 0x18
    7ee8:	0e 94 6c 1e 	call	0x3cd8	; 0x3cd8 <vPortFree>
                vPortFree( pxTCB );
    7eec:	89 81       	ldd	r24, Y+1	; 0x01
    7eee:	9a 81       	ldd	r25, Y+2	; 0x02
    7ef0:	0e 94 6c 1e 	call	0x3cd8	; 0x3cd8 <vPortFree>
                    configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB );
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
    }
    7ef4:	0f 90       	pop	r0
    7ef6:	0f 90       	pop	r0
    7ef8:	cf 91       	pop	r28
    7efa:	df 91       	pop	r29
    7efc:	08 95       	ret

00007efe <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    7efe:	df 93       	push	r29
    7f00:	cf 93       	push	r28
    7f02:	cd b7       	in	r28, 0x3d	; 61
    7f04:	de b7       	in	r29, 0x3e	; 62
    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    7f06:	e0 91 e8 07 	lds	r30, 0x07E8
    7f0a:	f0 91 e9 07 	lds	r31, 0x07E9
    7f0e:	80 81       	ld	r24, Z
    7f10:	88 23       	and	r24, r24
    7f12:	39 f4       	brne	.+14     	; 0x7f22 <prvResetNextTaskUnblockTime+0x24>
    {
        /* The new current delayed list is empty.  Set xNextTaskUnblockTime to
         * the maximum possible value so it is  extremely unlikely that the
         * if( xTickCount >= xNextTaskUnblockTime ) test will pass until
         * there is an item in the delayed list. */
        xNextTaskUnblockTime = portMAX_DELAY;
    7f14:	8f ef       	ldi	r24, 0xFF	; 255
    7f16:	9f ef       	ldi	r25, 0xFF	; 255
    7f18:	90 93 ae 07 	sts	0x07AE, r25
    7f1c:	80 93 ad 07 	sts	0x07AD, r24
    7f20:	0d c0       	rjmp	.+26     	; 0x7f3c <prvResetNextTaskUnblockTime+0x3e>
    {
        /* The new current delayed list is not empty, get the value of
         * the item at the head of the delayed list.  This is the time at
         * which the task at the head of the delayed list should be removed
         * from the Blocked state. */
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
    7f22:	e0 91 e8 07 	lds	r30, 0x07E8
    7f26:	f0 91 e9 07 	lds	r31, 0x07E9
    7f2a:	05 80       	ldd	r0, Z+5	; 0x05
    7f2c:	f6 81       	ldd	r31, Z+6	; 0x06
    7f2e:	e0 2d       	mov	r30, r0
    7f30:	80 81       	ld	r24, Z
    7f32:	91 81       	ldd	r25, Z+1	; 0x01
    7f34:	90 93 ae 07 	sts	0x07AE, r25
    7f38:	80 93 ad 07 	sts	0x07AD, r24
    }
}
    7f3c:	cf 91       	pop	r28
    7f3e:	df 91       	pop	r29
    7f40:	08 95       	ret

00007f42 <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

    TaskHandle_t xTaskGetCurrentTaskHandle( void )
    {
    7f42:	df 93       	push	r29
    7f44:	cf 93       	push	r28
    7f46:	00 d0       	rcall	.+0      	; 0x7f48 <xTaskGetCurrentTaskHandle+0x6>
    7f48:	cd b7       	in	r28, 0x3d	; 61
    7f4a:	de b7       	in	r29, 0x3e	; 62
        TaskHandle_t xReturn;

        /* A critical section is not required as this is not called from
         * an interrupt and the current TCB will always be the same for any
         * individual execution thread. */
        xReturn = pxCurrentTCB;
    7f4c:	80 91 a0 07 	lds	r24, 0x07A0
    7f50:	90 91 a1 07 	lds	r25, 0x07A1
    7f54:	9a 83       	std	Y+2, r25	; 0x02
    7f56:	89 83       	std	Y+1, r24	; 0x01

        return xReturn;
    7f58:	89 81       	ldd	r24, Y+1	; 0x01
    7f5a:	9a 81       	ldd	r25, Y+2	; 0x02
    }
    7f5c:	0f 90       	pop	r0
    7f5e:	0f 90       	pop	r0
    7f60:	cf 91       	pop	r28
    7f62:	df 91       	pop	r29
    7f64:	08 95       	ret

00007f66 <xTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

    BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
    {
    7f66:	df 93       	push	r29
    7f68:	cf 93       	push	r28
    7f6a:	cd b7       	in	r28, 0x3d	; 61
    7f6c:	de b7       	in	r29, 0x3e	; 62
    7f6e:	27 97       	sbiw	r28, 0x07	; 7
    7f70:	0f b6       	in	r0, 0x3f	; 63
    7f72:	f8 94       	cli
    7f74:	de bf       	out	0x3e, r29	; 62
    7f76:	0f be       	out	0x3f, r0	; 63
    7f78:	cd bf       	out	0x3d, r28	; 61
    7f7a:	9f 83       	std	Y+7, r25	; 0x07
    7f7c:	8e 83       	std	Y+6, r24	; 0x06
        TCB_t * const pxMutexHolderTCB = pxMutexHolder;
    7f7e:	8e 81       	ldd	r24, Y+6	; 0x06
    7f80:	9f 81       	ldd	r25, Y+7	; 0x07
    7f82:	9d 83       	std	Y+5, r25	; 0x05
    7f84:	8c 83       	std	Y+4, r24	; 0x04
        BaseType_t xReturn = pdFALSE;
    7f86:	1b 82       	std	Y+3, r1	; 0x03

        /* If the mutex was given back by an interrupt while the queue was
         * locked then the mutex holder might now be NULL.  _RB_ Is this still
         * needed as interrupts can no longer use mutexes? */
        if( pxMutexHolder != NULL )
    7f88:	8e 81       	ldd	r24, Y+6	; 0x06
    7f8a:	9f 81       	ldd	r25, Y+7	; 0x07
    7f8c:	00 97       	sbiw	r24, 0x00	; 0
    7f8e:	09 f4       	brne	.+2      	; 0x7f92 <xTaskPriorityInherit+0x2c>
    7f90:	c5 c0       	rjmp	.+394    	; 0x811c <xTaskPriorityInherit+0x1b6>
        {
            /* If the holder of the mutex has a priority below the priority of
             * the task attempting to obtain the mutex then it will temporarily
             * inherit the priority of the task attempting to obtain the mutex. */
            if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
    7f92:	ec 81       	ldd	r30, Y+4	; 0x04
    7f94:	fd 81       	ldd	r31, Y+5	; 0x05
    7f96:	96 89       	ldd	r25, Z+22	; 0x16
    7f98:	e0 91 a0 07 	lds	r30, 0x07A0
    7f9c:	f0 91 a1 07 	lds	r31, 0x07A1
    7fa0:	86 89       	ldd	r24, Z+22	; 0x16
    7fa2:	98 17       	cp	r25, r24
    7fa4:	08 f0       	brcs	.+2      	; 0x7fa8 <xTaskPriorityInherit+0x42>
    7fa6:	ae c0       	rjmp	.+348    	; 0x8104 <xTaskPriorityInherit+0x19e>
            {
                /* Adjust the mutex holder state to account for its new
                 * priority.  Only reset the event list item value if the value is
                 * not being used for anything else. */
                if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    7fa8:	ec 81       	ldd	r30, Y+4	; 0x04
    7faa:	fd 81       	ldd	r31, Y+5	; 0x05
    7fac:	84 85       	ldd	r24, Z+12	; 0x0c
    7fae:	95 85       	ldd	r25, Z+13	; 0x0d
    7fb0:	99 23       	and	r25, r25
    7fb2:	7c f0       	brlt	.+30     	; 0x7fd2 <xTaskPriorityInherit+0x6c>
                {
                    listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    7fb4:	e0 91 a0 07 	lds	r30, 0x07A0
    7fb8:	f0 91 a1 07 	lds	r31, 0x07A1
    7fbc:	86 89       	ldd	r24, Z+22	; 0x16
    7fbe:	28 2f       	mov	r18, r24
    7fc0:	30 e0       	ldi	r19, 0x00	; 0
    7fc2:	84 e0       	ldi	r24, 0x04	; 4
    7fc4:	90 e0       	ldi	r25, 0x00	; 0
    7fc6:	82 1b       	sub	r24, r18
    7fc8:	93 0b       	sbc	r25, r19
    7fca:	ec 81       	ldd	r30, Y+4	; 0x04
    7fcc:	fd 81       	ldd	r31, Y+5	; 0x05
    7fce:	95 87       	std	Z+13, r25	; 0x0d
    7fd0:	84 87       	std	Z+12, r24	; 0x0c
                    mtCOVERAGE_TEST_MARKER();
                }

                /* If the task being modified is in the ready state it will need
                 * to be moved into a new list. */
                if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
    7fd2:	ec 81       	ldd	r30, Y+4	; 0x04
    7fd4:	fd 81       	ldd	r31, Y+5	; 0x05
    7fd6:	42 85       	ldd	r20, Z+10	; 0x0a
    7fd8:	53 85       	ldd	r21, Z+11	; 0x0b
    7fda:	ec 81       	ldd	r30, Y+4	; 0x04
    7fdc:	fd 81       	ldd	r31, Y+5	; 0x05
    7fde:	86 89       	ldd	r24, Z+22	; 0x16
    7fe0:	28 2f       	mov	r18, r24
    7fe2:	30 e0       	ldi	r19, 0x00	; 0
    7fe4:	c9 01       	movw	r24, r18
    7fe6:	88 0f       	add	r24, r24
    7fe8:	99 1f       	adc	r25, r25
    7fea:	88 0f       	add	r24, r24
    7fec:	99 1f       	adc	r25, r25
    7fee:	88 0f       	add	r24, r24
    7ff0:	99 1f       	adc	r25, r25
    7ff2:	82 0f       	add	r24, r18
    7ff4:	93 1f       	adc	r25, r19
    7ff6:	8e 54       	subi	r24, 0x4E	; 78
    7ff8:	98 4f       	sbci	r25, 0xF8	; 248
    7ffa:	48 17       	cp	r20, r24
    7ffc:	59 07       	cpc	r21, r25
    7ffe:	09 f0       	breq	.+2      	; 0x8002 <xTaskPriorityInherit+0x9c>
    8000:	76 c0       	rjmp	.+236    	; 0x80ee <xTaskPriorityInherit+0x188>
                {
                    if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    8002:	8c 81       	ldd	r24, Y+4	; 0x04
    8004:	9d 81       	ldd	r25, Y+5	; 0x05
    8006:	02 96       	adiw	r24, 0x02	; 2
    8008:	0e 94 7c 1f 	call	0x3ef8	; 0x3ef8 <uxListRemove>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* Inherit the priority before being moved into the new list. */
                    pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
    800c:	e0 91 a0 07 	lds	r30, 0x07A0
    8010:	f0 91 a1 07 	lds	r31, 0x07A1
    8014:	86 89       	ldd	r24, Z+22	; 0x16
    8016:	ec 81       	ldd	r30, Y+4	; 0x04
    8018:	fd 81       	ldd	r31, Y+5	; 0x05
    801a:	86 8b       	std	Z+22, r24	; 0x16
                    prvAddTaskToReadyList( pxMutexHolderTCB );
    801c:	ec 81       	ldd	r30, Y+4	; 0x04
    801e:	fd 81       	ldd	r31, Y+5	; 0x05
    8020:	96 89       	ldd	r25, Z+22	; 0x16
    8022:	80 91 a6 07 	lds	r24, 0x07A6
    8026:	89 17       	cp	r24, r25
    8028:	28 f4       	brcc	.+10     	; 0x8034 <xTaskPriorityInherit+0xce>
    802a:	ec 81       	ldd	r30, Y+4	; 0x04
    802c:	fd 81       	ldd	r31, Y+5	; 0x05
    802e:	86 89       	ldd	r24, Z+22	; 0x16
    8030:	80 93 a6 07 	sts	0x07A6, r24
    8034:	ec 81       	ldd	r30, Y+4	; 0x04
    8036:	fd 81       	ldd	r31, Y+5	; 0x05
    8038:	86 89       	ldd	r24, Z+22	; 0x16
    803a:	28 2f       	mov	r18, r24
    803c:	30 e0       	ldi	r19, 0x00	; 0
    803e:	c9 01       	movw	r24, r18
    8040:	88 0f       	add	r24, r24
    8042:	99 1f       	adc	r25, r25
    8044:	88 0f       	add	r24, r24
    8046:	99 1f       	adc	r25, r25
    8048:	88 0f       	add	r24, r24
    804a:	99 1f       	adc	r25, r25
    804c:	82 0f       	add	r24, r18
    804e:	93 1f       	adc	r25, r19
    8050:	fc 01       	movw	r30, r24
    8052:	ee 54       	subi	r30, 0x4E	; 78
    8054:	f8 4f       	sbci	r31, 0xF8	; 248
    8056:	81 81       	ldd	r24, Z+1	; 0x01
    8058:	92 81       	ldd	r25, Z+2	; 0x02
    805a:	9a 83       	std	Y+2, r25	; 0x02
    805c:	89 83       	std	Y+1, r24	; 0x01
    805e:	ec 81       	ldd	r30, Y+4	; 0x04
    8060:	fd 81       	ldd	r31, Y+5	; 0x05
    8062:	89 81       	ldd	r24, Y+1	; 0x01
    8064:	9a 81       	ldd	r25, Y+2	; 0x02
    8066:	95 83       	std	Z+5, r25	; 0x05
    8068:	84 83       	std	Z+4, r24	; 0x04
    806a:	e9 81       	ldd	r30, Y+1	; 0x01
    806c:	fa 81       	ldd	r31, Y+2	; 0x02
    806e:	84 81       	ldd	r24, Z+4	; 0x04
    8070:	95 81       	ldd	r25, Z+5	; 0x05
    8072:	ec 81       	ldd	r30, Y+4	; 0x04
    8074:	fd 81       	ldd	r31, Y+5	; 0x05
    8076:	97 83       	std	Z+7, r25	; 0x07
    8078:	86 83       	std	Z+6, r24	; 0x06
    807a:	e9 81       	ldd	r30, Y+1	; 0x01
    807c:	fa 81       	ldd	r31, Y+2	; 0x02
    807e:	04 80       	ldd	r0, Z+4	; 0x04
    8080:	f5 81       	ldd	r31, Z+5	; 0x05
    8082:	e0 2d       	mov	r30, r0
    8084:	8c 81       	ldd	r24, Y+4	; 0x04
    8086:	9d 81       	ldd	r25, Y+5	; 0x05
    8088:	02 96       	adiw	r24, 0x02	; 2
    808a:	93 83       	std	Z+3, r25	; 0x03
    808c:	82 83       	std	Z+2, r24	; 0x02
    808e:	8c 81       	ldd	r24, Y+4	; 0x04
    8090:	9d 81       	ldd	r25, Y+5	; 0x05
    8092:	02 96       	adiw	r24, 0x02	; 2
    8094:	e9 81       	ldd	r30, Y+1	; 0x01
    8096:	fa 81       	ldd	r31, Y+2	; 0x02
    8098:	95 83       	std	Z+5, r25	; 0x05
    809a:	84 83       	std	Z+4, r24	; 0x04
    809c:	ec 81       	ldd	r30, Y+4	; 0x04
    809e:	fd 81       	ldd	r31, Y+5	; 0x05
    80a0:	86 89       	ldd	r24, Z+22	; 0x16
    80a2:	28 2f       	mov	r18, r24
    80a4:	30 e0       	ldi	r19, 0x00	; 0
    80a6:	c9 01       	movw	r24, r18
    80a8:	88 0f       	add	r24, r24
    80aa:	99 1f       	adc	r25, r25
    80ac:	88 0f       	add	r24, r24
    80ae:	99 1f       	adc	r25, r25
    80b0:	88 0f       	add	r24, r24
    80b2:	99 1f       	adc	r25, r25
    80b4:	82 0f       	add	r24, r18
    80b6:	93 1f       	adc	r25, r19
    80b8:	8e 54       	subi	r24, 0x4E	; 78
    80ba:	98 4f       	sbci	r25, 0xF8	; 248
    80bc:	ec 81       	ldd	r30, Y+4	; 0x04
    80be:	fd 81       	ldd	r31, Y+5	; 0x05
    80c0:	93 87       	std	Z+11, r25	; 0x0b
    80c2:	82 87       	std	Z+10, r24	; 0x0a
    80c4:	ec 81       	ldd	r30, Y+4	; 0x04
    80c6:	fd 81       	ldd	r31, Y+5	; 0x05
    80c8:	86 89       	ldd	r24, Z+22	; 0x16
    80ca:	28 2f       	mov	r18, r24
    80cc:	30 e0       	ldi	r19, 0x00	; 0
    80ce:	c9 01       	movw	r24, r18
    80d0:	88 0f       	add	r24, r24
    80d2:	99 1f       	adc	r25, r25
    80d4:	88 0f       	add	r24, r24
    80d6:	99 1f       	adc	r25, r25
    80d8:	88 0f       	add	r24, r24
    80da:	99 1f       	adc	r25, r25
    80dc:	82 0f       	add	r24, r18
    80de:	93 1f       	adc	r25, r19
    80e0:	fc 01       	movw	r30, r24
    80e2:	ee 54       	subi	r30, 0x4E	; 78
    80e4:	f8 4f       	sbci	r31, 0xF8	; 248
    80e6:	80 81       	ld	r24, Z
    80e8:	8f 5f       	subi	r24, 0xFF	; 255
    80ea:	80 83       	st	Z, r24
    80ec:	08 c0       	rjmp	.+16     	; 0x80fe <xTaskPriorityInherit+0x198>
                }
                else
                {
                    /* Just inherit the priority. */
                    pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
    80ee:	e0 91 a0 07 	lds	r30, 0x07A0
    80f2:	f0 91 a1 07 	lds	r31, 0x07A1
    80f6:	86 89       	ldd	r24, Z+22	; 0x16
    80f8:	ec 81       	ldd	r30, Y+4	; 0x04
    80fa:	fd 81       	ldd	r31, Y+5	; 0x05
    80fc:	86 8b       	std	Z+22, r24	; 0x16
                }

                traceTASK_PRIORITY_INHERIT( pxMutexHolderTCB, pxCurrentTCB->uxPriority );

                /* Inheritance occurred. */
                xReturn = pdTRUE;
    80fe:	81 e0       	ldi	r24, 0x01	; 1
    8100:	8b 83       	std	Y+3, r24	; 0x03
    8102:	0c c0       	rjmp	.+24     	; 0x811c <xTaskPriorityInherit+0x1b6>
            }
            else
            {
                if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
    8104:	ec 81       	ldd	r30, Y+4	; 0x04
    8106:	fd 81       	ldd	r31, Y+5	; 0x05
    8108:	91 a1       	ldd	r25, Z+33	; 0x21
    810a:	e0 91 a0 07 	lds	r30, 0x07A0
    810e:	f0 91 a1 07 	lds	r31, 0x07A1
    8112:	86 89       	ldd	r24, Z+22	; 0x16
    8114:	98 17       	cp	r25, r24
    8116:	10 f4       	brcc	.+4      	; 0x811c <xTaskPriorityInherit+0x1b6>
                     * current priority of the mutex holder is not lower than the
                     * priority of the task attempting to take the mutex.
                     * Therefore the mutex holder must have already inherited a
                     * priority, but inheritance would have occurred if that had
                     * not been the case. */
                    xReturn = pdTRUE;
    8118:	81 e0       	ldi	r24, 0x01	; 1
    811a:	8b 83       	std	Y+3, r24	; 0x03
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
    811c:	8b 81       	ldd	r24, Y+3	; 0x03
    }
    811e:	27 96       	adiw	r28, 0x07	; 7
    8120:	0f b6       	in	r0, 0x3f	; 63
    8122:	f8 94       	cli
    8124:	de bf       	out	0x3e, r29	; 62
    8126:	0f be       	out	0x3f, r0	; 63
    8128:	cd bf       	out	0x3d, r28	; 61
    812a:	cf 91       	pop	r28
    812c:	df 91       	pop	r29
    812e:	08 95       	ret

00008130 <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

    BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
    {
    8130:	df 93       	push	r29
    8132:	cf 93       	push	r28
    8134:	cd b7       	in	r28, 0x3d	; 61
    8136:	de b7       	in	r29, 0x3e	; 62
    8138:	27 97       	sbiw	r28, 0x07	; 7
    813a:	0f b6       	in	r0, 0x3f	; 63
    813c:	f8 94       	cli
    813e:	de bf       	out	0x3e, r29	; 62
    8140:	0f be       	out	0x3f, r0	; 63
    8142:	cd bf       	out	0x3d, r28	; 61
    8144:	9f 83       	std	Y+7, r25	; 0x07
    8146:	8e 83       	std	Y+6, r24	; 0x06
        TCB_t * const pxTCB = pxMutexHolder;
    8148:	8e 81       	ldd	r24, Y+6	; 0x06
    814a:	9f 81       	ldd	r25, Y+7	; 0x07
    814c:	9d 83       	std	Y+5, r25	; 0x05
    814e:	8c 83       	std	Y+4, r24	; 0x04
        BaseType_t xReturn = pdFALSE;
    8150:	1b 82       	std	Y+3, r1	; 0x03

        if( pxMutexHolder != NULL )
    8152:	8e 81       	ldd	r24, Y+6	; 0x06
    8154:	9f 81       	ldd	r25, Y+7	; 0x07
    8156:	00 97       	sbiw	r24, 0x00	; 0
    8158:	09 f4       	brne	.+2      	; 0x815c <xTaskPriorityDisinherit+0x2c>
    815a:	98 c0       	rjmp	.+304    	; 0x828c <xTaskPriorityDisinherit+0x15c>
             * If the mutex is held by a task then it cannot be given from an
             * interrupt, and if a mutex is given by the holding task then it must
             * be the running state task. */
            configASSERT( pxTCB == pxCurrentTCB );
            configASSERT( pxTCB->uxMutexesHeld );
            ( pxTCB->uxMutexesHeld )--;
    815c:	ec 81       	ldd	r30, Y+4	; 0x04
    815e:	fd 81       	ldd	r31, Y+5	; 0x05
    8160:	82 a1       	ldd	r24, Z+34	; 0x22
    8162:	81 50       	subi	r24, 0x01	; 1
    8164:	ec 81       	ldd	r30, Y+4	; 0x04
    8166:	fd 81       	ldd	r31, Y+5	; 0x05
    8168:	82 a3       	std	Z+34, r24	; 0x22

            /* Has the holder of the mutex inherited the priority of another
             * task? */
            if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    816a:	ec 81       	ldd	r30, Y+4	; 0x04
    816c:	fd 81       	ldd	r31, Y+5	; 0x05
    816e:	96 89       	ldd	r25, Z+22	; 0x16
    8170:	ec 81       	ldd	r30, Y+4	; 0x04
    8172:	fd 81       	ldd	r31, Y+5	; 0x05
    8174:	81 a1       	ldd	r24, Z+33	; 0x21
    8176:	98 17       	cp	r25, r24
    8178:	09 f4       	brne	.+2      	; 0x817c <xTaskPriorityDisinherit+0x4c>
    817a:	88 c0       	rjmp	.+272    	; 0x828c <xTaskPriorityDisinherit+0x15c>
            {
                /* Only disinherit if no other mutexes are held. */
                if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    817c:	ec 81       	ldd	r30, Y+4	; 0x04
    817e:	fd 81       	ldd	r31, Y+5	; 0x05
    8180:	82 a1       	ldd	r24, Z+34	; 0x22
    8182:	88 23       	and	r24, r24
    8184:	09 f0       	breq	.+2      	; 0x8188 <xTaskPriorityDisinherit+0x58>
    8186:	82 c0       	rjmp	.+260    	; 0x828c <xTaskPriorityDisinherit+0x15c>
                    /* A task can only have an inherited priority if it holds
                     * the mutex.  If the mutex is held by a task then it cannot be
                     * given from an interrupt, and if a mutex is given by the
                     * holding task then it must be the running state task.  Remove
                     * the holding task from the ready list. */
                    if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    8188:	8c 81       	ldd	r24, Y+4	; 0x04
    818a:	9d 81       	ldd	r25, Y+5	; 0x05
    818c:	02 96       	adiw	r24, 0x02	; 2
    818e:	0e 94 7c 1f 	call	0x3ef8	; 0x3ef8 <uxListRemove>
                    }

                    /* Disinherit the priority before adding the task into the
                     * new  ready list. */
                    traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
                    pxTCB->uxPriority = pxTCB->uxBasePriority;
    8192:	ec 81       	ldd	r30, Y+4	; 0x04
    8194:	fd 81       	ldd	r31, Y+5	; 0x05
    8196:	81 a1       	ldd	r24, Z+33	; 0x21
    8198:	ec 81       	ldd	r30, Y+4	; 0x04
    819a:	fd 81       	ldd	r31, Y+5	; 0x05
    819c:	86 8b       	std	Z+22, r24	; 0x16

                    /* Reset the event list item value.  It cannot be in use for
                     * any other purpose if this task is running, and it must be
                     * running to give back the mutex. */
                    listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    819e:	ec 81       	ldd	r30, Y+4	; 0x04
    81a0:	fd 81       	ldd	r31, Y+5	; 0x05
    81a2:	86 89       	ldd	r24, Z+22	; 0x16
    81a4:	28 2f       	mov	r18, r24
    81a6:	30 e0       	ldi	r19, 0x00	; 0
    81a8:	84 e0       	ldi	r24, 0x04	; 4
    81aa:	90 e0       	ldi	r25, 0x00	; 0
    81ac:	82 1b       	sub	r24, r18
    81ae:	93 0b       	sbc	r25, r19
    81b0:	ec 81       	ldd	r30, Y+4	; 0x04
    81b2:	fd 81       	ldd	r31, Y+5	; 0x05
    81b4:	95 87       	std	Z+13, r25	; 0x0d
    81b6:	84 87       	std	Z+12, r24	; 0x0c
                    prvAddTaskToReadyList( pxTCB );
    81b8:	ec 81       	ldd	r30, Y+4	; 0x04
    81ba:	fd 81       	ldd	r31, Y+5	; 0x05
    81bc:	96 89       	ldd	r25, Z+22	; 0x16
    81be:	80 91 a6 07 	lds	r24, 0x07A6
    81c2:	89 17       	cp	r24, r25
    81c4:	28 f4       	brcc	.+10     	; 0x81d0 <xTaskPriorityDisinherit+0xa0>
    81c6:	ec 81       	ldd	r30, Y+4	; 0x04
    81c8:	fd 81       	ldd	r31, Y+5	; 0x05
    81ca:	86 89       	ldd	r24, Z+22	; 0x16
    81cc:	80 93 a6 07 	sts	0x07A6, r24
    81d0:	ec 81       	ldd	r30, Y+4	; 0x04
    81d2:	fd 81       	ldd	r31, Y+5	; 0x05
    81d4:	86 89       	ldd	r24, Z+22	; 0x16
    81d6:	28 2f       	mov	r18, r24
    81d8:	30 e0       	ldi	r19, 0x00	; 0
    81da:	c9 01       	movw	r24, r18
    81dc:	88 0f       	add	r24, r24
    81de:	99 1f       	adc	r25, r25
    81e0:	88 0f       	add	r24, r24
    81e2:	99 1f       	adc	r25, r25
    81e4:	88 0f       	add	r24, r24
    81e6:	99 1f       	adc	r25, r25
    81e8:	82 0f       	add	r24, r18
    81ea:	93 1f       	adc	r25, r19
    81ec:	fc 01       	movw	r30, r24
    81ee:	ee 54       	subi	r30, 0x4E	; 78
    81f0:	f8 4f       	sbci	r31, 0xF8	; 248
    81f2:	81 81       	ldd	r24, Z+1	; 0x01
    81f4:	92 81       	ldd	r25, Z+2	; 0x02
    81f6:	9a 83       	std	Y+2, r25	; 0x02
    81f8:	89 83       	std	Y+1, r24	; 0x01
    81fa:	ec 81       	ldd	r30, Y+4	; 0x04
    81fc:	fd 81       	ldd	r31, Y+5	; 0x05
    81fe:	89 81       	ldd	r24, Y+1	; 0x01
    8200:	9a 81       	ldd	r25, Y+2	; 0x02
    8202:	95 83       	std	Z+5, r25	; 0x05
    8204:	84 83       	std	Z+4, r24	; 0x04
    8206:	e9 81       	ldd	r30, Y+1	; 0x01
    8208:	fa 81       	ldd	r31, Y+2	; 0x02
    820a:	84 81       	ldd	r24, Z+4	; 0x04
    820c:	95 81       	ldd	r25, Z+5	; 0x05
    820e:	ec 81       	ldd	r30, Y+4	; 0x04
    8210:	fd 81       	ldd	r31, Y+5	; 0x05
    8212:	97 83       	std	Z+7, r25	; 0x07
    8214:	86 83       	std	Z+6, r24	; 0x06
    8216:	e9 81       	ldd	r30, Y+1	; 0x01
    8218:	fa 81       	ldd	r31, Y+2	; 0x02
    821a:	04 80       	ldd	r0, Z+4	; 0x04
    821c:	f5 81       	ldd	r31, Z+5	; 0x05
    821e:	e0 2d       	mov	r30, r0
    8220:	8c 81       	ldd	r24, Y+4	; 0x04
    8222:	9d 81       	ldd	r25, Y+5	; 0x05
    8224:	02 96       	adiw	r24, 0x02	; 2
    8226:	93 83       	std	Z+3, r25	; 0x03
    8228:	82 83       	std	Z+2, r24	; 0x02
    822a:	8c 81       	ldd	r24, Y+4	; 0x04
    822c:	9d 81       	ldd	r25, Y+5	; 0x05
    822e:	02 96       	adiw	r24, 0x02	; 2
    8230:	e9 81       	ldd	r30, Y+1	; 0x01
    8232:	fa 81       	ldd	r31, Y+2	; 0x02
    8234:	95 83       	std	Z+5, r25	; 0x05
    8236:	84 83       	std	Z+4, r24	; 0x04
    8238:	ec 81       	ldd	r30, Y+4	; 0x04
    823a:	fd 81       	ldd	r31, Y+5	; 0x05
    823c:	86 89       	ldd	r24, Z+22	; 0x16
    823e:	28 2f       	mov	r18, r24
    8240:	30 e0       	ldi	r19, 0x00	; 0
    8242:	c9 01       	movw	r24, r18
    8244:	88 0f       	add	r24, r24
    8246:	99 1f       	adc	r25, r25
    8248:	88 0f       	add	r24, r24
    824a:	99 1f       	adc	r25, r25
    824c:	88 0f       	add	r24, r24
    824e:	99 1f       	adc	r25, r25
    8250:	82 0f       	add	r24, r18
    8252:	93 1f       	adc	r25, r19
    8254:	8e 54       	subi	r24, 0x4E	; 78
    8256:	98 4f       	sbci	r25, 0xF8	; 248
    8258:	ec 81       	ldd	r30, Y+4	; 0x04
    825a:	fd 81       	ldd	r31, Y+5	; 0x05
    825c:	93 87       	std	Z+11, r25	; 0x0b
    825e:	82 87       	std	Z+10, r24	; 0x0a
    8260:	ec 81       	ldd	r30, Y+4	; 0x04
    8262:	fd 81       	ldd	r31, Y+5	; 0x05
    8264:	86 89       	ldd	r24, Z+22	; 0x16
    8266:	28 2f       	mov	r18, r24
    8268:	30 e0       	ldi	r19, 0x00	; 0
    826a:	c9 01       	movw	r24, r18
    826c:	88 0f       	add	r24, r24
    826e:	99 1f       	adc	r25, r25
    8270:	88 0f       	add	r24, r24
    8272:	99 1f       	adc	r25, r25
    8274:	88 0f       	add	r24, r24
    8276:	99 1f       	adc	r25, r25
    8278:	82 0f       	add	r24, r18
    827a:	93 1f       	adc	r25, r19
    827c:	fc 01       	movw	r30, r24
    827e:	ee 54       	subi	r30, 0x4E	; 78
    8280:	f8 4f       	sbci	r31, 0xF8	; 248
    8282:	80 81       	ld	r24, Z
    8284:	8f 5f       	subi	r24, 0xFF	; 255
    8286:	80 83       	st	Z, r24
                     * in an order different to that in which they were taken.
                     * If a context switch did not occur when the first mutex was
                     * returned, even if a task was waiting on it, then a context
                     * switch should occur when the last mutex is returned whether
                     * a task is waiting on it or not. */
                    xReturn = pdTRUE;
    8288:	81 e0       	ldi	r24, 0x01	; 1
    828a:	8b 83       	std	Y+3, r24	; 0x03
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
    828c:	8b 81       	ldd	r24, Y+3	; 0x03
    }
    828e:	27 96       	adiw	r28, 0x07	; 7
    8290:	0f b6       	in	r0, 0x3f	; 63
    8292:	f8 94       	cli
    8294:	de bf       	out	0x3e, r29	; 62
    8296:	0f be       	out	0x3f, r0	; 63
    8298:	cd bf       	out	0x3d, r28	; 61
    829a:	cf 91       	pop	r28
    829c:	df 91       	pop	r29
    829e:	08 95       	ret

000082a0 <vTaskPriorityDisinheritAfterTimeout>:

#if ( configUSE_MUTEXES == 1 )

    void vTaskPriorityDisinheritAfterTimeout( TaskHandle_t const pxMutexHolder,
                                              UBaseType_t uxHighestPriorityWaitingTask )
    {
    82a0:	df 93       	push	r29
    82a2:	cf 93       	push	r28
    82a4:	cd b7       	in	r28, 0x3d	; 61
    82a6:	de b7       	in	r29, 0x3e	; 62
    82a8:	2a 97       	sbiw	r28, 0x0a	; 10
    82aa:	0f b6       	in	r0, 0x3f	; 63
    82ac:	f8 94       	cli
    82ae:	de bf       	out	0x3e, r29	; 62
    82b0:	0f be       	out	0x3f, r0	; 63
    82b2:	cd bf       	out	0x3d, r28	; 61
    82b4:	99 87       	std	Y+9, r25	; 0x09
    82b6:	88 87       	std	Y+8, r24	; 0x08
    82b8:	6a 87       	std	Y+10, r22	; 0x0a
        TCB_t * const pxTCB = pxMutexHolder;
    82ba:	88 85       	ldd	r24, Y+8	; 0x08
    82bc:	99 85       	ldd	r25, Y+9	; 0x09
    82be:	9f 83       	std	Y+7, r25	; 0x07
    82c0:	8e 83       	std	Y+6, r24	; 0x06
        UBaseType_t uxPriorityUsedOnEntry, uxPriorityToUse;
        const UBaseType_t uxOnlyOneMutexHeld = ( UBaseType_t ) 1;
    82c2:	81 e0       	ldi	r24, 0x01	; 1
    82c4:	8b 83       	std	Y+3, r24	; 0x03

        if( pxMutexHolder != NULL )
    82c6:	88 85       	ldd	r24, Y+8	; 0x08
    82c8:	99 85       	ldd	r25, Y+9	; 0x09
    82ca:	00 97       	sbiw	r24, 0x00	; 0
    82cc:	09 f4       	brne	.+2      	; 0x82d0 <vTaskPriorityDisinheritAfterTimeout+0x30>
    82ce:	b7 c0       	rjmp	.+366    	; 0x843e <vTaskPriorityDisinheritAfterTimeout+0x19e>

            /* Determine the priority to which the priority of the task that
             * holds the mutex should be set.  This will be the greater of the
             * holding task's base priority and the priority of the highest
             * priority task that is waiting to obtain the mutex. */
            if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
    82d0:	ee 81       	ldd	r30, Y+6	; 0x06
    82d2:	ff 81       	ldd	r31, Y+7	; 0x07
    82d4:	91 a1       	ldd	r25, Z+33	; 0x21
    82d6:	8a 85       	ldd	r24, Y+10	; 0x0a
    82d8:	98 17       	cp	r25, r24
    82da:	18 f4       	brcc	.+6      	; 0x82e2 <vTaskPriorityDisinheritAfterTimeout+0x42>
            {
                uxPriorityToUse = uxHighestPriorityWaitingTask;
    82dc:	8a 85       	ldd	r24, Y+10	; 0x0a
    82de:	8c 83       	std	Y+4, r24	; 0x04
    82e0:	04 c0       	rjmp	.+8      	; 0x82ea <vTaskPriorityDisinheritAfterTimeout+0x4a>
            }
            else
            {
                uxPriorityToUse = pxTCB->uxBasePriority;
    82e2:	ee 81       	ldd	r30, Y+6	; 0x06
    82e4:	ff 81       	ldd	r31, Y+7	; 0x07
    82e6:	81 a1       	ldd	r24, Z+33	; 0x21
    82e8:	8c 83       	std	Y+4, r24	; 0x04
            }

            /* Does the priority need to change? */
            if( pxTCB->uxPriority != uxPriorityToUse )
    82ea:	ee 81       	ldd	r30, Y+6	; 0x06
    82ec:	ff 81       	ldd	r31, Y+7	; 0x07
    82ee:	96 89       	ldd	r25, Z+22	; 0x16
    82f0:	8c 81       	ldd	r24, Y+4	; 0x04
    82f2:	98 17       	cp	r25, r24
    82f4:	09 f4       	brne	.+2      	; 0x82f8 <vTaskPriorityDisinheritAfterTimeout+0x58>
    82f6:	a3 c0       	rjmp	.+326    	; 0x843e <vTaskPriorityDisinheritAfterTimeout+0x19e>
            {
                /* Only disinherit if no other mutexes are held.  This is a
                 * simplification in the priority inheritance implementation.  If
                 * the task that holds the mutex is also holding other mutexes then
                 * the other mutexes may have caused the priority inheritance. */
                if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
    82f8:	ee 81       	ldd	r30, Y+6	; 0x06
    82fa:	ff 81       	ldd	r31, Y+7	; 0x07
    82fc:	92 a1       	ldd	r25, Z+34	; 0x22
    82fe:	8b 81       	ldd	r24, Y+3	; 0x03
    8300:	98 17       	cp	r25, r24
    8302:	09 f0       	breq	.+2      	; 0x8306 <vTaskPriorityDisinheritAfterTimeout+0x66>
    8304:	9c c0       	rjmp	.+312    	; 0x843e <vTaskPriorityDisinheritAfterTimeout+0x19e>

                    /* Disinherit the priority, remembering the previous
                     * priority to facilitate determining the subject task's
                     * state. */
                    traceTASK_PRIORITY_DISINHERIT( pxTCB, uxPriorityToUse );
                    uxPriorityUsedOnEntry = pxTCB->uxPriority;
    8306:	ee 81       	ldd	r30, Y+6	; 0x06
    8308:	ff 81       	ldd	r31, Y+7	; 0x07
    830a:	86 89       	ldd	r24, Z+22	; 0x16
    830c:	8d 83       	std	Y+5, r24	; 0x05
                    pxTCB->uxPriority = uxPriorityToUse;
    830e:	ee 81       	ldd	r30, Y+6	; 0x06
    8310:	ff 81       	ldd	r31, Y+7	; 0x07
    8312:	8c 81       	ldd	r24, Y+4	; 0x04
    8314:	86 8b       	std	Z+22, r24	; 0x16

                    /* Only reset the event list item value if the value is not
                     * being used for anything else. */
                    if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    8316:	ee 81       	ldd	r30, Y+6	; 0x06
    8318:	ff 81       	ldd	r31, Y+7	; 0x07
    831a:	84 85       	ldd	r24, Z+12	; 0x0c
    831c:	95 85       	ldd	r25, Z+13	; 0x0d
    831e:	99 23       	and	r25, r25
    8320:	5c f0       	brlt	.+22     	; 0x8338 <vTaskPriorityDisinheritAfterTimeout+0x98>
                    {
                        listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    8322:	8c 81       	ldd	r24, Y+4	; 0x04
    8324:	28 2f       	mov	r18, r24
    8326:	30 e0       	ldi	r19, 0x00	; 0
    8328:	84 e0       	ldi	r24, 0x04	; 4
    832a:	90 e0       	ldi	r25, 0x00	; 0
    832c:	82 1b       	sub	r24, r18
    832e:	93 0b       	sbc	r25, r19
    8330:	ee 81       	ldd	r30, Y+6	; 0x06
    8332:	ff 81       	ldd	r31, Y+7	; 0x07
    8334:	95 87       	std	Z+13, r25	; 0x0d
    8336:	84 87       	std	Z+12, r24	; 0x0c
                     * then the task that holds the mutex could be in either the
                     * Ready, Blocked or Suspended states.  Only remove the task
                     * from its current state list if it is in the Ready state as
                     * the task's priority is going to change and there is one
                     * Ready list per priority. */
                    if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
    8338:	ee 81       	ldd	r30, Y+6	; 0x06
    833a:	ff 81       	ldd	r31, Y+7	; 0x07
    833c:	42 85       	ldd	r20, Z+10	; 0x0a
    833e:	53 85       	ldd	r21, Z+11	; 0x0b
    8340:	8d 81       	ldd	r24, Y+5	; 0x05
    8342:	28 2f       	mov	r18, r24
    8344:	30 e0       	ldi	r19, 0x00	; 0
    8346:	c9 01       	movw	r24, r18
    8348:	88 0f       	add	r24, r24
    834a:	99 1f       	adc	r25, r25
    834c:	88 0f       	add	r24, r24
    834e:	99 1f       	adc	r25, r25
    8350:	88 0f       	add	r24, r24
    8352:	99 1f       	adc	r25, r25
    8354:	82 0f       	add	r24, r18
    8356:	93 1f       	adc	r25, r19
    8358:	8e 54       	subi	r24, 0x4E	; 78
    835a:	98 4f       	sbci	r25, 0xF8	; 248
    835c:	48 17       	cp	r20, r24
    835e:	59 07       	cpc	r21, r25
    8360:	09 f0       	breq	.+2      	; 0x8364 <vTaskPriorityDisinheritAfterTimeout+0xc4>
    8362:	6d c0       	rjmp	.+218    	; 0x843e <vTaskPriorityDisinheritAfterTimeout+0x19e>
                    {
                        if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    8364:	8e 81       	ldd	r24, Y+6	; 0x06
    8366:	9f 81       	ldd	r25, Y+7	; 0x07
    8368:	02 96       	adiw	r24, 0x02	; 2
    836a:	0e 94 7c 1f 	call	0x3ef8	; 0x3ef8 <uxListRemove>
                        else
                        {
                            mtCOVERAGE_TEST_MARKER();
                        }

                        prvAddTaskToReadyList( pxTCB );
    836e:	ee 81       	ldd	r30, Y+6	; 0x06
    8370:	ff 81       	ldd	r31, Y+7	; 0x07
    8372:	96 89       	ldd	r25, Z+22	; 0x16
    8374:	80 91 a6 07 	lds	r24, 0x07A6
    8378:	89 17       	cp	r24, r25
    837a:	28 f4       	brcc	.+10     	; 0x8386 <vTaskPriorityDisinheritAfterTimeout+0xe6>
    837c:	ee 81       	ldd	r30, Y+6	; 0x06
    837e:	ff 81       	ldd	r31, Y+7	; 0x07
    8380:	86 89       	ldd	r24, Z+22	; 0x16
    8382:	80 93 a6 07 	sts	0x07A6, r24
    8386:	ee 81       	ldd	r30, Y+6	; 0x06
    8388:	ff 81       	ldd	r31, Y+7	; 0x07
    838a:	86 89       	ldd	r24, Z+22	; 0x16
    838c:	28 2f       	mov	r18, r24
    838e:	30 e0       	ldi	r19, 0x00	; 0
    8390:	c9 01       	movw	r24, r18
    8392:	88 0f       	add	r24, r24
    8394:	99 1f       	adc	r25, r25
    8396:	88 0f       	add	r24, r24
    8398:	99 1f       	adc	r25, r25
    839a:	88 0f       	add	r24, r24
    839c:	99 1f       	adc	r25, r25
    839e:	82 0f       	add	r24, r18
    83a0:	93 1f       	adc	r25, r19
    83a2:	fc 01       	movw	r30, r24
    83a4:	ee 54       	subi	r30, 0x4E	; 78
    83a6:	f8 4f       	sbci	r31, 0xF8	; 248
    83a8:	81 81       	ldd	r24, Z+1	; 0x01
    83aa:	92 81       	ldd	r25, Z+2	; 0x02
    83ac:	9a 83       	std	Y+2, r25	; 0x02
    83ae:	89 83       	std	Y+1, r24	; 0x01
    83b0:	ee 81       	ldd	r30, Y+6	; 0x06
    83b2:	ff 81       	ldd	r31, Y+7	; 0x07
    83b4:	89 81       	ldd	r24, Y+1	; 0x01
    83b6:	9a 81       	ldd	r25, Y+2	; 0x02
    83b8:	95 83       	std	Z+5, r25	; 0x05
    83ba:	84 83       	std	Z+4, r24	; 0x04
    83bc:	e9 81       	ldd	r30, Y+1	; 0x01
    83be:	fa 81       	ldd	r31, Y+2	; 0x02
    83c0:	84 81       	ldd	r24, Z+4	; 0x04
    83c2:	95 81       	ldd	r25, Z+5	; 0x05
    83c4:	ee 81       	ldd	r30, Y+6	; 0x06
    83c6:	ff 81       	ldd	r31, Y+7	; 0x07
    83c8:	97 83       	std	Z+7, r25	; 0x07
    83ca:	86 83       	std	Z+6, r24	; 0x06
    83cc:	e9 81       	ldd	r30, Y+1	; 0x01
    83ce:	fa 81       	ldd	r31, Y+2	; 0x02
    83d0:	04 80       	ldd	r0, Z+4	; 0x04
    83d2:	f5 81       	ldd	r31, Z+5	; 0x05
    83d4:	e0 2d       	mov	r30, r0
    83d6:	8e 81       	ldd	r24, Y+6	; 0x06
    83d8:	9f 81       	ldd	r25, Y+7	; 0x07
    83da:	02 96       	adiw	r24, 0x02	; 2
    83dc:	93 83       	std	Z+3, r25	; 0x03
    83de:	82 83       	std	Z+2, r24	; 0x02
    83e0:	8e 81       	ldd	r24, Y+6	; 0x06
    83e2:	9f 81       	ldd	r25, Y+7	; 0x07
    83e4:	02 96       	adiw	r24, 0x02	; 2
    83e6:	e9 81       	ldd	r30, Y+1	; 0x01
    83e8:	fa 81       	ldd	r31, Y+2	; 0x02
    83ea:	95 83       	std	Z+5, r25	; 0x05
    83ec:	84 83       	std	Z+4, r24	; 0x04
    83ee:	ee 81       	ldd	r30, Y+6	; 0x06
    83f0:	ff 81       	ldd	r31, Y+7	; 0x07
    83f2:	86 89       	ldd	r24, Z+22	; 0x16
    83f4:	28 2f       	mov	r18, r24
    83f6:	30 e0       	ldi	r19, 0x00	; 0
    83f8:	c9 01       	movw	r24, r18
    83fa:	88 0f       	add	r24, r24
    83fc:	99 1f       	adc	r25, r25
    83fe:	88 0f       	add	r24, r24
    8400:	99 1f       	adc	r25, r25
    8402:	88 0f       	add	r24, r24
    8404:	99 1f       	adc	r25, r25
    8406:	82 0f       	add	r24, r18
    8408:	93 1f       	adc	r25, r19
    840a:	8e 54       	subi	r24, 0x4E	; 78
    840c:	98 4f       	sbci	r25, 0xF8	; 248
    840e:	ee 81       	ldd	r30, Y+6	; 0x06
    8410:	ff 81       	ldd	r31, Y+7	; 0x07
    8412:	93 87       	std	Z+11, r25	; 0x0b
    8414:	82 87       	std	Z+10, r24	; 0x0a
    8416:	ee 81       	ldd	r30, Y+6	; 0x06
    8418:	ff 81       	ldd	r31, Y+7	; 0x07
    841a:	86 89       	ldd	r24, Z+22	; 0x16
    841c:	28 2f       	mov	r18, r24
    841e:	30 e0       	ldi	r19, 0x00	; 0
    8420:	c9 01       	movw	r24, r18
    8422:	88 0f       	add	r24, r24
    8424:	99 1f       	adc	r25, r25
    8426:	88 0f       	add	r24, r24
    8428:	99 1f       	adc	r25, r25
    842a:	88 0f       	add	r24, r24
    842c:	99 1f       	adc	r25, r25
    842e:	82 0f       	add	r24, r18
    8430:	93 1f       	adc	r25, r19
    8432:	fc 01       	movw	r30, r24
    8434:	ee 54       	subi	r30, 0x4E	; 78
    8436:	f8 4f       	sbci	r31, 0xF8	; 248
    8438:	80 81       	ld	r24, Z
    843a:	8f 5f       	subi	r24, 0xFF	; 255
    843c:	80 83       	st	Z, r24
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    843e:	2a 96       	adiw	r28, 0x0a	; 10
    8440:	0f b6       	in	r0, 0x3f	; 63
    8442:	f8 94       	cli
    8444:	de bf       	out	0x3e, r29	; 62
    8446:	0f be       	out	0x3f, r0	; 63
    8448:	cd bf       	out	0x3d, r28	; 61
    844a:	cf 91       	pop	r28
    844c:	df 91       	pop	r29
    844e:	08 95       	ret

00008450 <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    8450:	df 93       	push	r29
    8452:	cf 93       	push	r28
    8454:	00 d0       	rcall	.+0      	; 0x8456 <uxTaskResetEventItemValue+0x6>
    8456:	cd b7       	in	r28, 0x3d	; 61
    8458:	de b7       	in	r29, 0x3e	; 62
    TickType_t uxReturn;

    uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    845a:	e0 91 a0 07 	lds	r30, 0x07A0
    845e:	f0 91 a1 07 	lds	r31, 0x07A1
    8462:	84 85       	ldd	r24, Z+12	; 0x0c
    8464:	95 85       	ldd	r25, Z+13	; 0x0d
    8466:	9a 83       	std	Y+2, r25	; 0x02
    8468:	89 83       	std	Y+1, r24	; 0x01

    /* Reset the event list item to its normal value - so it can be used with
     * queues and semaphores. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    846a:	a0 91 a0 07 	lds	r26, 0x07A0
    846e:	b0 91 a1 07 	lds	r27, 0x07A1
    8472:	e0 91 a0 07 	lds	r30, 0x07A0
    8476:	f0 91 a1 07 	lds	r31, 0x07A1
    847a:	86 89       	ldd	r24, Z+22	; 0x16
    847c:	28 2f       	mov	r18, r24
    847e:	30 e0       	ldi	r19, 0x00	; 0
    8480:	84 e0       	ldi	r24, 0x04	; 4
    8482:	90 e0       	ldi	r25, 0x00	; 0
    8484:	82 1b       	sub	r24, r18
    8486:	93 0b       	sbc	r25, r19
    8488:	1d 96       	adiw	r26, 0x0d	; 13
    848a:	9c 93       	st	X, r25
    848c:	8e 93       	st	-X, r24
    848e:	1c 97       	sbiw	r26, 0x0c	; 12

    return uxReturn;
    8490:	89 81       	ldd	r24, Y+1	; 0x01
    8492:	9a 81       	ldd	r25, Y+2	; 0x02
}
    8494:	0f 90       	pop	r0
    8496:	0f 90       	pop	r0
    8498:	cf 91       	pop	r28
    849a:	df 91       	pop	r29
    849c:	08 95       	ret

0000849e <pvTaskIncrementMutexHeldCount>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

    TaskHandle_t pvTaskIncrementMutexHeldCount( void )
    {
    849e:	df 93       	push	r29
    84a0:	cf 93       	push	r28
    84a2:	cd b7       	in	r28, 0x3d	; 61
    84a4:	de b7       	in	r29, 0x3e	; 62
        /* If xSemaphoreCreateMutex() is called before any tasks have been created
         * then pxCurrentTCB will be NULL. */
        if( pxCurrentTCB != NULL )
    84a6:	80 91 a0 07 	lds	r24, 0x07A0
    84aa:	90 91 a1 07 	lds	r25, 0x07A1
    84ae:	00 97       	sbiw	r24, 0x00	; 0
    84b0:	39 f0       	breq	.+14     	; 0x84c0 <pvTaskIncrementMutexHeldCount+0x22>
        {
            ( pxCurrentTCB->uxMutexesHeld )++;
    84b2:	e0 91 a0 07 	lds	r30, 0x07A0
    84b6:	f0 91 a1 07 	lds	r31, 0x07A1
    84ba:	82 a1       	ldd	r24, Z+34	; 0x22
    84bc:	8f 5f       	subi	r24, 0xFF	; 255
    84be:	82 a3       	std	Z+34, r24	; 0x22
        }

        return pxCurrentTCB;
    84c0:	80 91 a0 07 	lds	r24, 0x07A0
    84c4:	90 91 a1 07 	lds	r25, 0x07A1
    }
    84c8:	cf 91       	pop	r28
    84ca:	df 91       	pop	r29
    84cc:	08 95       	ret

000084ce <ulTaskGenericNotifyTake>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    uint32_t ulTaskGenericNotifyTake( UBaseType_t uxIndexToWait,
                                      BaseType_t xClearCountOnExit,
                                      TickType_t xTicksToWait )
    {
    84ce:	df 93       	push	r29
    84d0:	cf 93       	push	r28
    84d2:	cd b7       	in	r28, 0x3d	; 61
    84d4:	de b7       	in	r29, 0x3e	; 62
    84d6:	28 97       	sbiw	r28, 0x08	; 8
    84d8:	0f b6       	in	r0, 0x3f	; 63
    84da:	f8 94       	cli
    84dc:	de bf       	out	0x3e, r29	; 62
    84de:	0f be       	out	0x3f, r0	; 63
    84e0:	cd bf       	out	0x3d, r28	; 61
    84e2:	8d 83       	std	Y+5, r24	; 0x05
    84e4:	6e 83       	std	Y+6, r22	; 0x06
    84e6:	58 87       	std	Y+8, r21	; 0x08
    84e8:	4f 83       	std	Y+7, r20	; 0x07
        uint32_t ulReturn;

        configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        taskENTER_CRITICAL();
    84ea:	0f b6       	in	r0, 0x3f	; 63
    84ec:	f8 94       	cli
    84ee:	0f 92       	push	r0
        {
            /* Only block if the notification count is not already non-zero. */
            if( pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] == 0UL )
    84f0:	20 91 a0 07 	lds	r18, 0x07A0
    84f4:	30 91 a1 07 	lds	r19, 0x07A1
    84f8:	8d 81       	ldd	r24, Y+5	; 0x05
    84fa:	88 2f       	mov	r24, r24
    84fc:	90 e0       	ldi	r25, 0x00	; 0
    84fe:	88 0f       	add	r24, r24
    8500:	99 1f       	adc	r25, r25
    8502:	88 0f       	add	r24, r24
    8504:	99 1f       	adc	r25, r25
    8506:	82 0f       	add	r24, r18
    8508:	93 1f       	adc	r25, r19
    850a:	fc 01       	movw	r30, r24
    850c:	b3 96       	adiw	r30, 0x23	; 35
    850e:	80 81       	ld	r24, Z
    8510:	91 81       	ldd	r25, Z+1	; 0x01
    8512:	a2 81       	ldd	r26, Z+2	; 0x02
    8514:	b3 81       	ldd	r27, Z+3	; 0x03
    8516:	00 97       	sbiw	r24, 0x00	; 0
    8518:	a1 05       	cpc	r26, r1
    851a:	b1 05       	cpc	r27, r1
    851c:	c1 f4       	brne	.+48     	; 0x854e <ulTaskGenericNotifyTake+0x80>
            {
                /* Mark this task as waiting for a notification. */
                pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
    851e:	20 91 a0 07 	lds	r18, 0x07A0
    8522:	30 91 a1 07 	lds	r19, 0x07A1
    8526:	8d 81       	ldd	r24, Y+5	; 0x05
    8528:	88 2f       	mov	r24, r24
    852a:	90 e0       	ldi	r25, 0x00	; 0
    852c:	82 0f       	add	r24, r18
    852e:	93 1f       	adc	r25, r19
    8530:	fc 01       	movw	r30, r24
    8532:	b7 96       	adiw	r30, 0x27	; 39
    8534:	81 e0       	ldi	r24, 0x01	; 1
    8536:	80 83       	st	Z, r24

                if( xTicksToWait > ( TickType_t ) 0 )
    8538:	8f 81       	ldd	r24, Y+7	; 0x07
    853a:	98 85       	ldd	r25, Y+8	; 0x08
    853c:	00 97       	sbiw	r24, 0x00	; 0
    853e:	39 f0       	breq	.+14     	; 0x854e <ulTaskGenericNotifyTake+0x80>
                {
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    8540:	8f 81       	ldd	r24, Y+7	; 0x07
    8542:	98 85       	ldd	r25, Y+8	; 0x08
    8544:	61 e0       	ldi	r22, 0x01	; 1
    8546:	0e 94 ec 49 	call	0x93d8	; 0x93d8 <prvAddCurrentTaskToDelayedList>

                    /* All ports are written to allow a yield in a critical
                     * section (some will yield immediately, others wait until the
                     * critical section exits) - but it is not something that
                     * application code should ever do. */
                    portYIELD_WITHIN_API();
    854a:	0e 94 87 21 	call	0x430e	; 0x430e <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    854e:	0f 90       	pop	r0
    8550:	0f be       	out	0x3f, r0	; 63

        taskENTER_CRITICAL();
    8552:	0f b6       	in	r0, 0x3f	; 63
    8554:	f8 94       	cli
    8556:	0f 92       	push	r0
        {
            traceTASK_NOTIFY_TAKE( uxIndexToWait );
            ulReturn = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
    8558:	20 91 a0 07 	lds	r18, 0x07A0
    855c:	30 91 a1 07 	lds	r19, 0x07A1
    8560:	8d 81       	ldd	r24, Y+5	; 0x05
    8562:	88 2f       	mov	r24, r24
    8564:	90 e0       	ldi	r25, 0x00	; 0
    8566:	88 0f       	add	r24, r24
    8568:	99 1f       	adc	r25, r25
    856a:	88 0f       	add	r24, r24
    856c:	99 1f       	adc	r25, r25
    856e:	82 0f       	add	r24, r18
    8570:	93 1f       	adc	r25, r19
    8572:	fc 01       	movw	r30, r24
    8574:	b3 96       	adiw	r30, 0x23	; 35
    8576:	80 81       	ld	r24, Z
    8578:	91 81       	ldd	r25, Z+1	; 0x01
    857a:	a2 81       	ldd	r26, Z+2	; 0x02
    857c:	b3 81       	ldd	r27, Z+3	; 0x03
    857e:	89 83       	std	Y+1, r24	; 0x01
    8580:	9a 83       	std	Y+2, r25	; 0x02
    8582:	ab 83       	std	Y+3, r26	; 0x03
    8584:	bc 83       	std	Y+4, r27	; 0x04

            if( ulReturn != 0UL )
    8586:	89 81       	ldd	r24, Y+1	; 0x01
    8588:	9a 81       	ldd	r25, Y+2	; 0x02
    858a:	ab 81       	ldd	r26, Y+3	; 0x03
    858c:	bc 81       	ldd	r27, Y+4	; 0x04
    858e:	00 97       	sbiw	r24, 0x00	; 0
    8590:	a1 05       	cpc	r26, r1
    8592:	b1 05       	cpc	r27, r1
    8594:	a9 f1       	breq	.+106    	; 0x8600 <ulTaskGenericNotifyTake+0x132>
            {
                if( xClearCountOnExit != pdFALSE )
    8596:	8e 81       	ldd	r24, Y+6	; 0x06
    8598:	88 23       	and	r24, r24
    859a:	a1 f0       	breq	.+40     	; 0x85c4 <ulTaskGenericNotifyTake+0xf6>
                {
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = 0UL;
    859c:	20 91 a0 07 	lds	r18, 0x07A0
    85a0:	30 91 a1 07 	lds	r19, 0x07A1
    85a4:	8d 81       	ldd	r24, Y+5	; 0x05
    85a6:	88 2f       	mov	r24, r24
    85a8:	90 e0       	ldi	r25, 0x00	; 0
    85aa:	88 0f       	add	r24, r24
    85ac:	99 1f       	adc	r25, r25
    85ae:	88 0f       	add	r24, r24
    85b0:	99 1f       	adc	r25, r25
    85b2:	82 0f       	add	r24, r18
    85b4:	93 1f       	adc	r25, r19
    85b6:	fc 01       	movw	r30, r24
    85b8:	b3 96       	adiw	r30, 0x23	; 35
    85ba:	10 82       	st	Z, r1
    85bc:	11 82       	std	Z+1, r1	; 0x01
    85be:	12 82       	std	Z+2, r1	; 0x02
    85c0:	13 82       	std	Z+3, r1	; 0x03
    85c2:	1e c0       	rjmp	.+60     	; 0x8600 <ulTaskGenericNotifyTake+0x132>
                }
                else
                {
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = ulReturn - ( uint32_t ) 1;
    85c4:	e0 91 a0 07 	lds	r30, 0x07A0
    85c8:	f0 91 a1 07 	lds	r31, 0x07A1
    85cc:	8d 81       	ldd	r24, Y+5	; 0x05
    85ce:	68 2f       	mov	r22, r24
    85d0:	70 e0       	ldi	r23, 0x00	; 0
    85d2:	89 81       	ldd	r24, Y+1	; 0x01
    85d4:	9a 81       	ldd	r25, Y+2	; 0x02
    85d6:	ab 81       	ldd	r26, Y+3	; 0x03
    85d8:	bc 81       	ldd	r27, Y+4	; 0x04
    85da:	9c 01       	movw	r18, r24
    85dc:	ad 01       	movw	r20, r26
    85de:	21 50       	subi	r18, 0x01	; 1
    85e0:	30 40       	sbci	r19, 0x00	; 0
    85e2:	40 40       	sbci	r20, 0x00	; 0
    85e4:	50 40       	sbci	r21, 0x00	; 0
    85e6:	cb 01       	movw	r24, r22
    85e8:	88 0f       	add	r24, r24
    85ea:	99 1f       	adc	r25, r25
    85ec:	88 0f       	add	r24, r24
    85ee:	99 1f       	adc	r25, r25
    85f0:	8e 0f       	add	r24, r30
    85f2:	9f 1f       	adc	r25, r31
    85f4:	fc 01       	movw	r30, r24
    85f6:	b3 96       	adiw	r30, 0x23	; 35
    85f8:	20 83       	st	Z, r18
    85fa:	31 83       	std	Z+1, r19	; 0x01
    85fc:	42 83       	std	Z+2, r20	; 0x02
    85fe:	53 83       	std	Z+3, r21	; 0x03
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
    8600:	20 91 a0 07 	lds	r18, 0x07A0
    8604:	30 91 a1 07 	lds	r19, 0x07A1
    8608:	8d 81       	ldd	r24, Y+5	; 0x05
    860a:	88 2f       	mov	r24, r24
    860c:	90 e0       	ldi	r25, 0x00	; 0
    860e:	82 0f       	add	r24, r18
    8610:	93 1f       	adc	r25, r19
    8612:	fc 01       	movw	r30, r24
    8614:	b7 96       	adiw	r30, 0x27	; 39
    8616:	10 82       	st	Z, r1
        }
        taskEXIT_CRITICAL();
    8618:	0f 90       	pop	r0
    861a:	0f be       	out	0x3f, r0	; 63

        return ulReturn;
    861c:	89 81       	ldd	r24, Y+1	; 0x01
    861e:	9a 81       	ldd	r25, Y+2	; 0x02
    8620:	ab 81       	ldd	r26, Y+3	; 0x03
    8622:	bc 81       	ldd	r27, Y+4	; 0x04
    }
    8624:	bc 01       	movw	r22, r24
    8626:	cd 01       	movw	r24, r26
    8628:	28 96       	adiw	r28, 0x08	; 8
    862a:	0f b6       	in	r0, 0x3f	; 63
    862c:	f8 94       	cli
    862e:	de bf       	out	0x3e, r29	; 62
    8630:	0f be       	out	0x3f, r0	; 63
    8632:	cd bf       	out	0x3d, r28	; 61
    8634:	cf 91       	pop	r28
    8636:	df 91       	pop	r29
    8638:	08 95       	ret

0000863a <xTaskGenericNotifyWait>:
    BaseType_t xTaskGenericNotifyWait( UBaseType_t uxIndexToWait,
                                       uint32_t ulBitsToClearOnEntry,
                                       uint32_t ulBitsToClearOnExit,
                                       uint32_t * pulNotificationValue,
                                       TickType_t xTicksToWait )
    {
    863a:	cf 92       	push	r12
    863c:	df 92       	push	r13
    863e:	ef 92       	push	r14
    8640:	ff 92       	push	r15
    8642:	0f 93       	push	r16
    8644:	1f 93       	push	r17
    8646:	df 93       	push	r29
    8648:	cf 93       	push	r28
    864a:	cd b7       	in	r28, 0x3d	; 61
    864c:	de b7       	in	r29, 0x3e	; 62
    864e:	2e 97       	sbiw	r28, 0x0e	; 14
    8650:	0f b6       	in	r0, 0x3f	; 63
    8652:	f8 94       	cli
    8654:	de bf       	out	0x3e, r29	; 62
    8656:	0f be       	out	0x3f, r0	; 63
    8658:	cd bf       	out	0x3d, r28	; 61
    865a:	8a 83       	std	Y+2, r24	; 0x02
    865c:	4b 83       	std	Y+3, r20	; 0x03
    865e:	5c 83       	std	Y+4, r21	; 0x04
    8660:	6d 83       	std	Y+5, r22	; 0x05
    8662:	7e 83       	std	Y+6, r23	; 0x06
    8664:	0f 83       	std	Y+7, r16	; 0x07
    8666:	18 87       	std	Y+8, r17	; 0x08
    8668:	29 87       	std	Y+9, r18	; 0x09
    866a:	3a 87       	std	Y+10, r19	; 0x0a
    866c:	fc 86       	std	Y+12, r15	; 0x0c
    866e:	eb 86       	std	Y+11, r14	; 0x0b
    8670:	de 86       	std	Y+14, r13	; 0x0e
    8672:	cd 86       	std	Y+13, r12	; 0x0d
        BaseType_t xReturn;

        configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        taskENTER_CRITICAL();
    8674:	0f b6       	in	r0, 0x3f	; 63
    8676:	f8 94       	cli
    8678:	0f 92       	push	r0
        {
            /* Only block if a notification is not already pending. */
            if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
    867a:	20 91 a0 07 	lds	r18, 0x07A0
    867e:	30 91 a1 07 	lds	r19, 0x07A1
    8682:	8a 81       	ldd	r24, Y+2	; 0x02
    8684:	88 2f       	mov	r24, r24
    8686:	90 e0       	ldi	r25, 0x00	; 0
    8688:	82 0f       	add	r24, r18
    868a:	93 1f       	adc	r25, r19
    868c:	fc 01       	movw	r30, r24
    868e:	b7 96       	adiw	r30, 0x27	; 39
    8690:	80 81       	ld	r24, Z
    8692:	82 30       	cpi	r24, 0x02	; 2
    8694:	09 f4       	brne	.+2      	; 0x8698 <xTaskGenericNotifyWait+0x5e>
    8696:	47 c0       	rjmp	.+142    	; 0x8726 <xTaskGenericNotifyWait+0xec>
            {
                /* Clear bits in the task's notification value as bits may get
                 * set  by the notifying task or interrupt.  This can be used to
                 * clear the value to zero. */
                pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnEntry;
    8698:	60 91 a0 07 	lds	r22, 0x07A0
    869c:	70 91 a1 07 	lds	r23, 0x07A1
    86a0:	8a 81       	ldd	r24, Y+2	; 0x02
    86a2:	08 2f       	mov	r16, r24
    86a4:	10 e0       	ldi	r17, 0x00	; 0
    86a6:	8a 81       	ldd	r24, Y+2	; 0x02
    86a8:	88 2f       	mov	r24, r24
    86aa:	90 e0       	ldi	r25, 0x00	; 0
    86ac:	88 0f       	add	r24, r24
    86ae:	99 1f       	adc	r25, r25
    86b0:	88 0f       	add	r24, r24
    86b2:	99 1f       	adc	r25, r25
    86b4:	86 0f       	add	r24, r22
    86b6:	97 1f       	adc	r25, r23
    86b8:	fc 01       	movw	r30, r24
    86ba:	b3 96       	adiw	r30, 0x23	; 35
    86bc:	20 81       	ld	r18, Z
    86be:	31 81       	ldd	r19, Z+1	; 0x01
    86c0:	42 81       	ldd	r20, Z+2	; 0x02
    86c2:	53 81       	ldd	r21, Z+3	; 0x03
    86c4:	8b 81       	ldd	r24, Y+3	; 0x03
    86c6:	9c 81       	ldd	r25, Y+4	; 0x04
    86c8:	ad 81       	ldd	r26, Y+5	; 0x05
    86ca:	be 81       	ldd	r27, Y+6	; 0x06
    86cc:	80 95       	com	r24
    86ce:	90 95       	com	r25
    86d0:	a0 95       	com	r26
    86d2:	b0 95       	com	r27
    86d4:	28 23       	and	r18, r24
    86d6:	39 23       	and	r19, r25
    86d8:	4a 23       	and	r20, r26
    86da:	5b 23       	and	r21, r27
    86dc:	c8 01       	movw	r24, r16
    86de:	88 0f       	add	r24, r24
    86e0:	99 1f       	adc	r25, r25
    86e2:	88 0f       	add	r24, r24
    86e4:	99 1f       	adc	r25, r25
    86e6:	86 0f       	add	r24, r22
    86e8:	97 1f       	adc	r25, r23
    86ea:	fc 01       	movw	r30, r24
    86ec:	b3 96       	adiw	r30, 0x23	; 35
    86ee:	20 83       	st	Z, r18
    86f0:	31 83       	std	Z+1, r19	; 0x01
    86f2:	42 83       	std	Z+2, r20	; 0x02
    86f4:	53 83       	std	Z+3, r21	; 0x03

                /* Mark this task as waiting for a notification. */
                pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
    86f6:	20 91 a0 07 	lds	r18, 0x07A0
    86fa:	30 91 a1 07 	lds	r19, 0x07A1
    86fe:	8a 81       	ldd	r24, Y+2	; 0x02
    8700:	88 2f       	mov	r24, r24
    8702:	90 e0       	ldi	r25, 0x00	; 0
    8704:	82 0f       	add	r24, r18
    8706:	93 1f       	adc	r25, r19
    8708:	fc 01       	movw	r30, r24
    870a:	b7 96       	adiw	r30, 0x27	; 39
    870c:	81 e0       	ldi	r24, 0x01	; 1
    870e:	80 83       	st	Z, r24

                if( xTicksToWait > ( TickType_t ) 0 )
    8710:	8d 85       	ldd	r24, Y+13	; 0x0d
    8712:	9e 85       	ldd	r25, Y+14	; 0x0e
    8714:	00 97       	sbiw	r24, 0x00	; 0
    8716:	39 f0       	breq	.+14     	; 0x8726 <xTaskGenericNotifyWait+0xec>
                {
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    8718:	8d 85       	ldd	r24, Y+13	; 0x0d
    871a:	9e 85       	ldd	r25, Y+14	; 0x0e
    871c:	61 e0       	ldi	r22, 0x01	; 1
    871e:	0e 94 ec 49 	call	0x93d8	; 0x93d8 <prvAddCurrentTaskToDelayedList>

                    /* All ports are written to allow a yield in a critical
                     * section (some will yield immediately, others wait until the
                     * critical section exits) - but it is not something that
                     * application code should ever do. */
                    portYIELD_WITHIN_API();
    8722:	0e 94 87 21 	call	0x430e	; 0x430e <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    8726:	0f 90       	pop	r0
    8728:	0f be       	out	0x3f, r0	; 63

        taskENTER_CRITICAL();
    872a:	0f b6       	in	r0, 0x3f	; 63
    872c:	f8 94       	cli
    872e:	0f 92       	push	r0
        {
            traceTASK_NOTIFY_WAIT( uxIndexToWait );

            if( pulNotificationValue != NULL )
    8730:	8b 85       	ldd	r24, Y+11	; 0x0b
    8732:	9c 85       	ldd	r25, Y+12	; 0x0c
    8734:	00 97       	sbiw	r24, 0x00	; 0
    8736:	c9 f0       	breq	.+50     	; 0x876a <xTaskGenericNotifyWait+0x130>
            {
                /* Output the current notification value, which may or may not
                 * have changed. */
                *pulNotificationValue = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
    8738:	20 91 a0 07 	lds	r18, 0x07A0
    873c:	30 91 a1 07 	lds	r19, 0x07A1
    8740:	8a 81       	ldd	r24, Y+2	; 0x02
    8742:	88 2f       	mov	r24, r24
    8744:	90 e0       	ldi	r25, 0x00	; 0
    8746:	88 0f       	add	r24, r24
    8748:	99 1f       	adc	r25, r25
    874a:	88 0f       	add	r24, r24
    874c:	99 1f       	adc	r25, r25
    874e:	82 0f       	add	r24, r18
    8750:	93 1f       	adc	r25, r19
    8752:	fc 01       	movw	r30, r24
    8754:	b3 96       	adiw	r30, 0x23	; 35
    8756:	80 81       	ld	r24, Z
    8758:	91 81       	ldd	r25, Z+1	; 0x01
    875a:	a2 81       	ldd	r26, Z+2	; 0x02
    875c:	b3 81       	ldd	r27, Z+3	; 0x03
    875e:	eb 85       	ldd	r30, Y+11	; 0x0b
    8760:	fc 85       	ldd	r31, Y+12	; 0x0c
    8762:	80 83       	st	Z, r24
    8764:	91 83       	std	Z+1, r25	; 0x01
    8766:	a2 83       	std	Z+2, r26	; 0x02
    8768:	b3 83       	std	Z+3, r27	; 0x03

            /* If ucNotifyValue is set then either the task never entered the
             * blocked state (because a notification was already pending) or the
             * task unblocked because of a notification.  Otherwise the task
             * unblocked because of a timeout. */
            if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
    876a:	20 91 a0 07 	lds	r18, 0x07A0
    876e:	30 91 a1 07 	lds	r19, 0x07A1
    8772:	8a 81       	ldd	r24, Y+2	; 0x02
    8774:	88 2f       	mov	r24, r24
    8776:	90 e0       	ldi	r25, 0x00	; 0
    8778:	82 0f       	add	r24, r18
    877a:	93 1f       	adc	r25, r19
    877c:	fc 01       	movw	r30, r24
    877e:	b7 96       	adiw	r30, 0x27	; 39
    8780:	80 81       	ld	r24, Z
    8782:	82 30       	cpi	r24, 0x02	; 2
    8784:	11 f0       	breq	.+4      	; 0x878a <xTaskGenericNotifyWait+0x150>
            {
                /* A notification was not received. */
                xReturn = pdFALSE;
    8786:	19 82       	std	Y+1, r1	; 0x01
    8788:	31 c0       	rjmp	.+98     	; 0x87ec <xTaskGenericNotifyWait+0x1b2>
            }
            else
            {
                /* A notification was already pending or a notification was
                 * received while the task was waiting. */
                pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnExit;
    878a:	60 91 a0 07 	lds	r22, 0x07A0
    878e:	70 91 a1 07 	lds	r23, 0x07A1
    8792:	8a 81       	ldd	r24, Y+2	; 0x02
    8794:	08 2f       	mov	r16, r24
    8796:	10 e0       	ldi	r17, 0x00	; 0
    8798:	8a 81       	ldd	r24, Y+2	; 0x02
    879a:	88 2f       	mov	r24, r24
    879c:	90 e0       	ldi	r25, 0x00	; 0
    879e:	88 0f       	add	r24, r24
    87a0:	99 1f       	adc	r25, r25
    87a2:	88 0f       	add	r24, r24
    87a4:	99 1f       	adc	r25, r25
    87a6:	86 0f       	add	r24, r22
    87a8:	97 1f       	adc	r25, r23
    87aa:	fc 01       	movw	r30, r24
    87ac:	b3 96       	adiw	r30, 0x23	; 35
    87ae:	20 81       	ld	r18, Z
    87b0:	31 81       	ldd	r19, Z+1	; 0x01
    87b2:	42 81       	ldd	r20, Z+2	; 0x02
    87b4:	53 81       	ldd	r21, Z+3	; 0x03
    87b6:	8f 81       	ldd	r24, Y+7	; 0x07
    87b8:	98 85       	ldd	r25, Y+8	; 0x08
    87ba:	a9 85       	ldd	r26, Y+9	; 0x09
    87bc:	ba 85       	ldd	r27, Y+10	; 0x0a
    87be:	80 95       	com	r24
    87c0:	90 95       	com	r25
    87c2:	a0 95       	com	r26
    87c4:	b0 95       	com	r27
    87c6:	28 23       	and	r18, r24
    87c8:	39 23       	and	r19, r25
    87ca:	4a 23       	and	r20, r26
    87cc:	5b 23       	and	r21, r27
    87ce:	c8 01       	movw	r24, r16
    87d0:	88 0f       	add	r24, r24
    87d2:	99 1f       	adc	r25, r25
    87d4:	88 0f       	add	r24, r24
    87d6:	99 1f       	adc	r25, r25
    87d8:	86 0f       	add	r24, r22
    87da:	97 1f       	adc	r25, r23
    87dc:	fc 01       	movw	r30, r24
    87de:	b3 96       	adiw	r30, 0x23	; 35
    87e0:	20 83       	st	Z, r18
    87e2:	31 83       	std	Z+1, r19	; 0x01
    87e4:	42 83       	std	Z+2, r20	; 0x02
    87e6:	53 83       	std	Z+3, r21	; 0x03
                xReturn = pdTRUE;
    87e8:	81 e0       	ldi	r24, 0x01	; 1
    87ea:	89 83       	std	Y+1, r24	; 0x01
            }

            pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
    87ec:	20 91 a0 07 	lds	r18, 0x07A0
    87f0:	30 91 a1 07 	lds	r19, 0x07A1
    87f4:	8a 81       	ldd	r24, Y+2	; 0x02
    87f6:	88 2f       	mov	r24, r24
    87f8:	90 e0       	ldi	r25, 0x00	; 0
    87fa:	82 0f       	add	r24, r18
    87fc:	93 1f       	adc	r25, r19
    87fe:	fc 01       	movw	r30, r24
    8800:	b7 96       	adiw	r30, 0x27	; 39
    8802:	10 82       	st	Z, r1
        }
        taskEXIT_CRITICAL();
    8804:	0f 90       	pop	r0
    8806:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    8808:	89 81       	ldd	r24, Y+1	; 0x01
    }
    880a:	2e 96       	adiw	r28, 0x0e	; 14
    880c:	0f b6       	in	r0, 0x3f	; 63
    880e:	f8 94       	cli
    8810:	de bf       	out	0x3e, r29	; 62
    8812:	0f be       	out	0x3f, r0	; 63
    8814:	cd bf       	out	0x3d, r28	; 61
    8816:	cf 91       	pop	r28
    8818:	df 91       	pop	r29
    881a:	1f 91       	pop	r17
    881c:	0f 91       	pop	r16
    881e:	ff 90       	pop	r15
    8820:	ef 90       	pop	r14
    8822:	df 90       	pop	r13
    8824:	cf 90       	pop	r12
    8826:	08 95       	ret

00008828 <xTaskGenericNotify>:
    BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify,
                                   UBaseType_t uxIndexToNotify,
                                   uint32_t ulValue,
                                   eNotifyAction eAction,
                                   uint32_t * pulPreviousNotificationValue )
    {
    8828:	ef 92       	push	r14
    882a:	ff 92       	push	r15
    882c:	0f 93       	push	r16
    882e:	1f 93       	push	r17
    8830:	df 93       	push	r29
    8832:	cf 93       	push	r28
    8834:	cd b7       	in	r28, 0x3d	; 61
    8836:	de b7       	in	r29, 0x3e	; 62
    8838:	64 97       	sbiw	r28, 0x14	; 20
    883a:	0f b6       	in	r0, 0x3f	; 63
    883c:	f8 94       	cli
    883e:	de bf       	out	0x3e, r29	; 62
    8840:	0f be       	out	0x3f, r0	; 63
    8842:	cd bf       	out	0x3d, r28	; 61
    8844:	9a 87       	std	Y+10, r25	; 0x0a
    8846:	89 87       	std	Y+9, r24	; 0x09
    8848:	6b 87       	std	Y+11, r22	; 0x0b
    884a:	2c 87       	std	Y+12, r18	; 0x0c
    884c:	3d 87       	std	Y+13, r19	; 0x0d
    884e:	4e 87       	std	Y+14, r20	; 0x0e
    8850:	5f 87       	std	Y+15, r21	; 0x0f
    8852:	08 8b       	std	Y+16, r16	; 0x10
    8854:	fa 8a       	std	Y+18, r15	; 0x12
    8856:	e9 8a       	std	Y+17, r14	; 0x11
        TCB_t * pxTCB;
        BaseType_t xReturn = pdPASS;
    8858:	81 e0       	ldi	r24, 0x01	; 1
    885a:	8e 83       	std	Y+6, r24	; 0x06
        uint8_t ucOriginalNotifyState;

        configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );
        configASSERT( xTaskToNotify );
        pxTCB = xTaskToNotify;
    885c:	89 85       	ldd	r24, Y+9	; 0x09
    885e:	9a 85       	ldd	r25, Y+10	; 0x0a
    8860:	98 87       	std	Y+8, r25	; 0x08
    8862:	8f 83       	std	Y+7, r24	; 0x07

        taskENTER_CRITICAL();
    8864:	0f b6       	in	r0, 0x3f	; 63
    8866:	f8 94       	cli
    8868:	0f 92       	push	r0
        {
            if( pulPreviousNotificationValue != NULL )
    886a:	89 89       	ldd	r24, Y+17	; 0x11
    886c:	9a 89       	ldd	r25, Y+18	; 0x12
    886e:	00 97       	sbiw	r24, 0x00	; 0
    8870:	b9 f0       	breq	.+46     	; 0x88a0 <xTaskGenericNotify+0x78>
            {
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
    8872:	8b 85       	ldd	r24, Y+11	; 0x0b
    8874:	88 2f       	mov	r24, r24
    8876:	90 e0       	ldi	r25, 0x00	; 0
    8878:	2f 81       	ldd	r18, Y+7	; 0x07
    887a:	38 85       	ldd	r19, Y+8	; 0x08
    887c:	88 0f       	add	r24, r24
    887e:	99 1f       	adc	r25, r25
    8880:	88 0f       	add	r24, r24
    8882:	99 1f       	adc	r25, r25
    8884:	82 0f       	add	r24, r18
    8886:	93 1f       	adc	r25, r19
    8888:	fc 01       	movw	r30, r24
    888a:	b3 96       	adiw	r30, 0x23	; 35
    888c:	80 81       	ld	r24, Z
    888e:	91 81       	ldd	r25, Z+1	; 0x01
    8890:	a2 81       	ldd	r26, Z+2	; 0x02
    8892:	b3 81       	ldd	r27, Z+3	; 0x03
    8894:	e9 89       	ldd	r30, Y+17	; 0x11
    8896:	fa 89       	ldd	r31, Y+18	; 0x12
    8898:	80 83       	st	Z, r24
    889a:	91 83       	std	Z+1, r25	; 0x01
    889c:	a2 83       	std	Z+2, r26	; 0x02
    889e:	b3 83       	std	Z+3, r27	; 0x03
            }

            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    88a0:	8b 85       	ldd	r24, Y+11	; 0x0b
    88a2:	28 2f       	mov	r18, r24
    88a4:	30 e0       	ldi	r19, 0x00	; 0
    88a6:	8f 81       	ldd	r24, Y+7	; 0x07
    88a8:	98 85       	ldd	r25, Y+8	; 0x08
    88aa:	82 0f       	add	r24, r18
    88ac:	93 1f       	adc	r25, r19
    88ae:	fc 01       	movw	r30, r24
    88b0:	b7 96       	adiw	r30, 0x27	; 39
    88b2:	80 81       	ld	r24, Z
    88b4:	8d 83       	std	Y+5, r24	; 0x05

            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    88b6:	8b 85       	ldd	r24, Y+11	; 0x0b
    88b8:	28 2f       	mov	r18, r24
    88ba:	30 e0       	ldi	r19, 0x00	; 0
    88bc:	8f 81       	ldd	r24, Y+7	; 0x07
    88be:	98 85       	ldd	r25, Y+8	; 0x08
    88c0:	82 0f       	add	r24, r18
    88c2:	93 1f       	adc	r25, r19
    88c4:	fc 01       	movw	r30, r24
    88c6:	b7 96       	adiw	r30, 0x27	; 39
    88c8:	82 e0       	ldi	r24, 0x02	; 2
    88ca:	80 83       	st	Z, r24

            switch( eAction )
    88cc:	88 89       	ldd	r24, Y+16	; 0x10
    88ce:	28 2f       	mov	r18, r24
    88d0:	30 e0       	ldi	r19, 0x00	; 0
    88d2:	3c 8b       	std	Y+20, r19	; 0x14
    88d4:	2b 8b       	std	Y+19, r18	; 0x13
    88d6:	8b 89       	ldd	r24, Y+19	; 0x13
    88d8:	9c 89       	ldd	r25, Y+20	; 0x14
    88da:	82 30       	cpi	r24, 0x02	; 2
    88dc:	91 05       	cpc	r25, r1
    88de:	09 f4       	brne	.+2      	; 0x88e2 <xTaskGenericNotify+0xba>
    88e0:	46 c0       	rjmp	.+140    	; 0x896e <xTaskGenericNotify+0x146>
    88e2:	2b 89       	ldd	r18, Y+19	; 0x13
    88e4:	3c 89       	ldd	r19, Y+20	; 0x14
    88e6:	23 30       	cpi	r18, 0x03	; 3
    88e8:	31 05       	cpc	r19, r1
    88ea:	34 f4       	brge	.+12     	; 0x88f8 <xTaskGenericNotify+0xd0>
    88ec:	8b 89       	ldd	r24, Y+19	; 0x13
    88ee:	9c 89       	ldd	r25, Y+20	; 0x14
    88f0:	81 30       	cpi	r24, 0x01	; 1
    88f2:	91 05       	cpc	r25, r1
    88f4:	71 f0       	breq	.+28     	; 0x8912 <xTaskGenericNotify+0xea>
    88f6:	93 c0       	rjmp	.+294    	; 0x8a1e <xTaskGenericNotify+0x1f6>
    88f8:	2b 89       	ldd	r18, Y+19	; 0x13
    88fa:	3c 89       	ldd	r19, Y+20	; 0x14
    88fc:	23 30       	cpi	r18, 0x03	; 3
    88fe:	31 05       	cpc	r19, r1
    8900:	09 f4       	brne	.+2      	; 0x8904 <xTaskGenericNotify+0xdc>
    8902:	5d c0       	rjmp	.+186    	; 0x89be <xTaskGenericNotify+0x196>
    8904:	8b 89       	ldd	r24, Y+19	; 0x13
    8906:	9c 89       	ldd	r25, Y+20	; 0x14
    8908:	84 30       	cpi	r24, 0x04	; 4
    890a:	91 05       	cpc	r25, r1
    890c:	09 f4       	brne	.+2      	; 0x8910 <xTaskGenericNotify+0xe8>
    890e:	6d c0       	rjmp	.+218    	; 0x89ea <xTaskGenericNotify+0x1c2>
    8910:	86 c0       	rjmp	.+268    	; 0x8a1e <xTaskGenericNotify+0x1f6>
            {
                case eSetBits:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
    8912:	8b 85       	ldd	r24, Y+11	; 0x0b
    8914:	08 2f       	mov	r16, r24
    8916:	10 e0       	ldi	r17, 0x00	; 0
    8918:	8b 85       	ldd	r24, Y+11	; 0x0b
    891a:	88 2f       	mov	r24, r24
    891c:	90 e0       	ldi	r25, 0x00	; 0
    891e:	2f 81       	ldd	r18, Y+7	; 0x07
    8920:	38 85       	ldd	r19, Y+8	; 0x08
    8922:	88 0f       	add	r24, r24
    8924:	99 1f       	adc	r25, r25
    8926:	88 0f       	add	r24, r24
    8928:	99 1f       	adc	r25, r25
    892a:	82 0f       	add	r24, r18
    892c:	93 1f       	adc	r25, r19
    892e:	fc 01       	movw	r30, r24
    8930:	b3 96       	adiw	r30, 0x23	; 35
    8932:	20 81       	ld	r18, Z
    8934:	31 81       	ldd	r19, Z+1	; 0x01
    8936:	42 81       	ldd	r20, Z+2	; 0x02
    8938:	53 81       	ldd	r21, Z+3	; 0x03
    893a:	8c 85       	ldd	r24, Y+12	; 0x0c
    893c:	9d 85       	ldd	r25, Y+13	; 0x0d
    893e:	ae 85       	ldd	r26, Y+14	; 0x0e
    8940:	bf 85       	ldd	r27, Y+15	; 0x0f
    8942:	ba 01       	movw	r22, r20
    8944:	a9 01       	movw	r20, r18
    8946:	48 2b       	or	r20, r24
    8948:	59 2b       	or	r21, r25
    894a:	6a 2b       	or	r22, r26
    894c:	7b 2b       	or	r23, r27
    894e:	2f 81       	ldd	r18, Y+7	; 0x07
    8950:	38 85       	ldd	r19, Y+8	; 0x08
    8952:	c8 01       	movw	r24, r16
    8954:	88 0f       	add	r24, r24
    8956:	99 1f       	adc	r25, r25
    8958:	88 0f       	add	r24, r24
    895a:	99 1f       	adc	r25, r25
    895c:	82 0f       	add	r24, r18
    895e:	93 1f       	adc	r25, r19
    8960:	fc 01       	movw	r30, r24
    8962:	b3 96       	adiw	r30, 0x23	; 35
    8964:	40 83       	st	Z, r20
    8966:	51 83       	std	Z+1, r21	; 0x01
    8968:	62 83       	std	Z+2, r22	; 0x02
    896a:	73 83       	std	Z+3, r23	; 0x03
    896c:	58 c0       	rjmp	.+176    	; 0x8a1e <xTaskGenericNotify+0x1f6>
                    break;

                case eIncrement:
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    896e:	8b 85       	ldd	r24, Y+11	; 0x0b
    8970:	08 2f       	mov	r16, r24
    8972:	10 e0       	ldi	r17, 0x00	; 0
    8974:	2f 81       	ldd	r18, Y+7	; 0x07
    8976:	38 85       	ldd	r19, Y+8	; 0x08
    8978:	c8 01       	movw	r24, r16
    897a:	88 0f       	add	r24, r24
    897c:	99 1f       	adc	r25, r25
    897e:	88 0f       	add	r24, r24
    8980:	99 1f       	adc	r25, r25
    8982:	82 0f       	add	r24, r18
    8984:	93 1f       	adc	r25, r19
    8986:	fc 01       	movw	r30, r24
    8988:	b3 96       	adiw	r30, 0x23	; 35
    898a:	80 81       	ld	r24, Z
    898c:	91 81       	ldd	r25, Z+1	; 0x01
    898e:	a2 81       	ldd	r26, Z+2	; 0x02
    8990:	b3 81       	ldd	r27, Z+3	; 0x03
    8992:	ac 01       	movw	r20, r24
    8994:	bd 01       	movw	r22, r26
    8996:	4f 5f       	subi	r20, 0xFF	; 255
    8998:	5f 4f       	sbci	r21, 0xFF	; 255
    899a:	6f 4f       	sbci	r22, 0xFF	; 255
    899c:	7f 4f       	sbci	r23, 0xFF	; 255
    899e:	2f 81       	ldd	r18, Y+7	; 0x07
    89a0:	38 85       	ldd	r19, Y+8	; 0x08
    89a2:	c8 01       	movw	r24, r16
    89a4:	88 0f       	add	r24, r24
    89a6:	99 1f       	adc	r25, r25
    89a8:	88 0f       	add	r24, r24
    89aa:	99 1f       	adc	r25, r25
    89ac:	82 0f       	add	r24, r18
    89ae:	93 1f       	adc	r25, r19
    89b0:	fc 01       	movw	r30, r24
    89b2:	b3 96       	adiw	r30, 0x23	; 35
    89b4:	40 83       	st	Z, r20
    89b6:	51 83       	std	Z+1, r21	; 0x01
    89b8:	62 83       	std	Z+2, r22	; 0x02
    89ba:	73 83       	std	Z+3, r23	; 0x03
    89bc:	30 c0       	rjmp	.+96     	; 0x8a1e <xTaskGenericNotify+0x1f6>
                    break;

                case eSetValueWithOverwrite:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    89be:	8b 85       	ldd	r24, Y+11	; 0x0b
    89c0:	88 2f       	mov	r24, r24
    89c2:	90 e0       	ldi	r25, 0x00	; 0
    89c4:	2f 81       	ldd	r18, Y+7	; 0x07
    89c6:	38 85       	ldd	r19, Y+8	; 0x08
    89c8:	88 0f       	add	r24, r24
    89ca:	99 1f       	adc	r25, r25
    89cc:	88 0f       	add	r24, r24
    89ce:	99 1f       	adc	r25, r25
    89d0:	82 0f       	add	r24, r18
    89d2:	93 1f       	adc	r25, r19
    89d4:	fc 01       	movw	r30, r24
    89d6:	b3 96       	adiw	r30, 0x23	; 35
    89d8:	8c 85       	ldd	r24, Y+12	; 0x0c
    89da:	9d 85       	ldd	r25, Y+13	; 0x0d
    89dc:	ae 85       	ldd	r26, Y+14	; 0x0e
    89de:	bf 85       	ldd	r27, Y+15	; 0x0f
    89e0:	80 83       	st	Z, r24
    89e2:	91 83       	std	Z+1, r25	; 0x01
    89e4:	a2 83       	std	Z+2, r26	; 0x02
    89e6:	b3 83       	std	Z+3, r27	; 0x03
    89e8:	1a c0       	rjmp	.+52     	; 0x8a1e <xTaskGenericNotify+0x1f6>
                    break;

                case eSetValueWithoutOverwrite:

                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    89ea:	8d 81       	ldd	r24, Y+5	; 0x05
    89ec:	82 30       	cpi	r24, 0x02	; 2
    89ee:	b1 f0       	breq	.+44     	; 0x8a1c <xTaskGenericNotify+0x1f4>
                    {
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    89f0:	8b 85       	ldd	r24, Y+11	; 0x0b
    89f2:	88 2f       	mov	r24, r24
    89f4:	90 e0       	ldi	r25, 0x00	; 0
    89f6:	2f 81       	ldd	r18, Y+7	; 0x07
    89f8:	38 85       	ldd	r19, Y+8	; 0x08
    89fa:	88 0f       	add	r24, r24
    89fc:	99 1f       	adc	r25, r25
    89fe:	88 0f       	add	r24, r24
    8a00:	99 1f       	adc	r25, r25
    8a02:	82 0f       	add	r24, r18
    8a04:	93 1f       	adc	r25, r19
    8a06:	fc 01       	movw	r30, r24
    8a08:	b3 96       	adiw	r30, 0x23	; 35
    8a0a:	8c 85       	ldd	r24, Y+12	; 0x0c
    8a0c:	9d 85       	ldd	r25, Y+13	; 0x0d
    8a0e:	ae 85       	ldd	r26, Y+14	; 0x0e
    8a10:	bf 85       	ldd	r27, Y+15	; 0x0f
    8a12:	80 83       	st	Z, r24
    8a14:	91 83       	std	Z+1, r25	; 0x01
    8a16:	a2 83       	std	Z+2, r26	; 0x02
    8a18:	b3 83       	std	Z+3, r27	; 0x03
    8a1a:	01 c0       	rjmp	.+2      	; 0x8a1e <xTaskGenericNotify+0x1f6>
                    }
                    else
                    {
                        /* The value could not be written to the task. */
                        xReturn = pdFAIL;
    8a1c:	1e 82       	std	Y+6, r1	; 0x06

            traceTASK_NOTIFY( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    8a1e:	8d 81       	ldd	r24, Y+5	; 0x05
    8a20:	81 30       	cpi	r24, 0x01	; 1
    8a22:	09 f0       	breq	.+2      	; 0x8a26 <xTaskGenericNotify+0x1fe>
    8a24:	af c0       	rjmp	.+350    	; 0x8b84 <xTaskGenericNotify+0x35c>
            {
                listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    8a26:	ef 81       	ldd	r30, Y+7	; 0x07
    8a28:	f8 85       	ldd	r31, Y+8	; 0x08
    8a2a:	82 85       	ldd	r24, Z+10	; 0x0a
    8a2c:	93 85       	ldd	r25, Z+11	; 0x0b
    8a2e:	9c 83       	std	Y+4, r25	; 0x04
    8a30:	8b 83       	std	Y+3, r24	; 0x03
    8a32:	ef 81       	ldd	r30, Y+7	; 0x07
    8a34:	f8 85       	ldd	r31, Y+8	; 0x08
    8a36:	a4 81       	ldd	r26, Z+4	; 0x04
    8a38:	b5 81       	ldd	r27, Z+5	; 0x05
    8a3a:	ef 81       	ldd	r30, Y+7	; 0x07
    8a3c:	f8 85       	ldd	r31, Y+8	; 0x08
    8a3e:	86 81       	ldd	r24, Z+6	; 0x06
    8a40:	97 81       	ldd	r25, Z+7	; 0x07
    8a42:	15 96       	adiw	r26, 0x05	; 5
    8a44:	9c 93       	st	X, r25
    8a46:	8e 93       	st	-X, r24
    8a48:	14 97       	sbiw	r26, 0x04	; 4
    8a4a:	ef 81       	ldd	r30, Y+7	; 0x07
    8a4c:	f8 85       	ldd	r31, Y+8	; 0x08
    8a4e:	a6 81       	ldd	r26, Z+6	; 0x06
    8a50:	b7 81       	ldd	r27, Z+7	; 0x07
    8a52:	ef 81       	ldd	r30, Y+7	; 0x07
    8a54:	f8 85       	ldd	r31, Y+8	; 0x08
    8a56:	84 81       	ldd	r24, Z+4	; 0x04
    8a58:	95 81       	ldd	r25, Z+5	; 0x05
    8a5a:	13 96       	adiw	r26, 0x03	; 3
    8a5c:	9c 93       	st	X, r25
    8a5e:	8e 93       	st	-X, r24
    8a60:	12 97       	sbiw	r26, 0x02	; 2
    8a62:	eb 81       	ldd	r30, Y+3	; 0x03
    8a64:	fc 81       	ldd	r31, Y+4	; 0x04
    8a66:	21 81       	ldd	r18, Z+1	; 0x01
    8a68:	32 81       	ldd	r19, Z+2	; 0x02
    8a6a:	8f 81       	ldd	r24, Y+7	; 0x07
    8a6c:	98 85       	ldd	r25, Y+8	; 0x08
    8a6e:	02 96       	adiw	r24, 0x02	; 2
    8a70:	28 17       	cp	r18, r24
    8a72:	39 07       	cpc	r19, r25
    8a74:	41 f4       	brne	.+16     	; 0x8a86 <xTaskGenericNotify+0x25e>
    8a76:	ef 81       	ldd	r30, Y+7	; 0x07
    8a78:	f8 85       	ldd	r31, Y+8	; 0x08
    8a7a:	86 81       	ldd	r24, Z+6	; 0x06
    8a7c:	97 81       	ldd	r25, Z+7	; 0x07
    8a7e:	eb 81       	ldd	r30, Y+3	; 0x03
    8a80:	fc 81       	ldd	r31, Y+4	; 0x04
    8a82:	92 83       	std	Z+2, r25	; 0x02
    8a84:	81 83       	std	Z+1, r24	; 0x01
    8a86:	ef 81       	ldd	r30, Y+7	; 0x07
    8a88:	f8 85       	ldd	r31, Y+8	; 0x08
    8a8a:	13 86       	std	Z+11, r1	; 0x0b
    8a8c:	12 86       	std	Z+10, r1	; 0x0a
    8a8e:	eb 81       	ldd	r30, Y+3	; 0x03
    8a90:	fc 81       	ldd	r31, Y+4	; 0x04
    8a92:	80 81       	ld	r24, Z
    8a94:	81 50       	subi	r24, 0x01	; 1
    8a96:	eb 81       	ldd	r30, Y+3	; 0x03
    8a98:	fc 81       	ldd	r31, Y+4	; 0x04
    8a9a:	80 83       	st	Z, r24
                prvAddTaskToReadyList( pxTCB );
    8a9c:	ef 81       	ldd	r30, Y+7	; 0x07
    8a9e:	f8 85       	ldd	r31, Y+8	; 0x08
    8aa0:	96 89       	ldd	r25, Z+22	; 0x16
    8aa2:	80 91 a6 07 	lds	r24, 0x07A6
    8aa6:	89 17       	cp	r24, r25
    8aa8:	28 f4       	brcc	.+10     	; 0x8ab4 <xTaskGenericNotify+0x28c>
    8aaa:	ef 81       	ldd	r30, Y+7	; 0x07
    8aac:	f8 85       	ldd	r31, Y+8	; 0x08
    8aae:	86 89       	ldd	r24, Z+22	; 0x16
    8ab0:	80 93 a6 07 	sts	0x07A6, r24
    8ab4:	ef 81       	ldd	r30, Y+7	; 0x07
    8ab6:	f8 85       	ldd	r31, Y+8	; 0x08
    8ab8:	86 89       	ldd	r24, Z+22	; 0x16
    8aba:	28 2f       	mov	r18, r24
    8abc:	30 e0       	ldi	r19, 0x00	; 0
    8abe:	c9 01       	movw	r24, r18
    8ac0:	88 0f       	add	r24, r24
    8ac2:	99 1f       	adc	r25, r25
    8ac4:	88 0f       	add	r24, r24
    8ac6:	99 1f       	adc	r25, r25
    8ac8:	88 0f       	add	r24, r24
    8aca:	99 1f       	adc	r25, r25
    8acc:	82 0f       	add	r24, r18
    8ace:	93 1f       	adc	r25, r19
    8ad0:	fc 01       	movw	r30, r24
    8ad2:	ee 54       	subi	r30, 0x4E	; 78
    8ad4:	f8 4f       	sbci	r31, 0xF8	; 248
    8ad6:	81 81       	ldd	r24, Z+1	; 0x01
    8ad8:	92 81       	ldd	r25, Z+2	; 0x02
    8ada:	9a 83       	std	Y+2, r25	; 0x02
    8adc:	89 83       	std	Y+1, r24	; 0x01
    8ade:	ef 81       	ldd	r30, Y+7	; 0x07
    8ae0:	f8 85       	ldd	r31, Y+8	; 0x08
    8ae2:	89 81       	ldd	r24, Y+1	; 0x01
    8ae4:	9a 81       	ldd	r25, Y+2	; 0x02
    8ae6:	95 83       	std	Z+5, r25	; 0x05
    8ae8:	84 83       	std	Z+4, r24	; 0x04
    8aea:	e9 81       	ldd	r30, Y+1	; 0x01
    8aec:	fa 81       	ldd	r31, Y+2	; 0x02
    8aee:	84 81       	ldd	r24, Z+4	; 0x04
    8af0:	95 81       	ldd	r25, Z+5	; 0x05
    8af2:	ef 81       	ldd	r30, Y+7	; 0x07
    8af4:	f8 85       	ldd	r31, Y+8	; 0x08
    8af6:	97 83       	std	Z+7, r25	; 0x07
    8af8:	86 83       	std	Z+6, r24	; 0x06
    8afa:	e9 81       	ldd	r30, Y+1	; 0x01
    8afc:	fa 81       	ldd	r31, Y+2	; 0x02
    8afe:	04 80       	ldd	r0, Z+4	; 0x04
    8b00:	f5 81       	ldd	r31, Z+5	; 0x05
    8b02:	e0 2d       	mov	r30, r0
    8b04:	8f 81       	ldd	r24, Y+7	; 0x07
    8b06:	98 85       	ldd	r25, Y+8	; 0x08
    8b08:	02 96       	adiw	r24, 0x02	; 2
    8b0a:	93 83       	std	Z+3, r25	; 0x03
    8b0c:	82 83       	std	Z+2, r24	; 0x02
    8b0e:	8f 81       	ldd	r24, Y+7	; 0x07
    8b10:	98 85       	ldd	r25, Y+8	; 0x08
    8b12:	02 96       	adiw	r24, 0x02	; 2
    8b14:	e9 81       	ldd	r30, Y+1	; 0x01
    8b16:	fa 81       	ldd	r31, Y+2	; 0x02
    8b18:	95 83       	std	Z+5, r25	; 0x05
    8b1a:	84 83       	std	Z+4, r24	; 0x04
    8b1c:	ef 81       	ldd	r30, Y+7	; 0x07
    8b1e:	f8 85       	ldd	r31, Y+8	; 0x08
    8b20:	86 89       	ldd	r24, Z+22	; 0x16
    8b22:	28 2f       	mov	r18, r24
    8b24:	30 e0       	ldi	r19, 0x00	; 0
    8b26:	c9 01       	movw	r24, r18
    8b28:	88 0f       	add	r24, r24
    8b2a:	99 1f       	adc	r25, r25
    8b2c:	88 0f       	add	r24, r24
    8b2e:	99 1f       	adc	r25, r25
    8b30:	88 0f       	add	r24, r24
    8b32:	99 1f       	adc	r25, r25
    8b34:	82 0f       	add	r24, r18
    8b36:	93 1f       	adc	r25, r19
    8b38:	8e 54       	subi	r24, 0x4E	; 78
    8b3a:	98 4f       	sbci	r25, 0xF8	; 248
    8b3c:	ef 81       	ldd	r30, Y+7	; 0x07
    8b3e:	f8 85       	ldd	r31, Y+8	; 0x08
    8b40:	93 87       	std	Z+11, r25	; 0x0b
    8b42:	82 87       	std	Z+10, r24	; 0x0a
    8b44:	ef 81       	ldd	r30, Y+7	; 0x07
    8b46:	f8 85       	ldd	r31, Y+8	; 0x08
    8b48:	86 89       	ldd	r24, Z+22	; 0x16
    8b4a:	28 2f       	mov	r18, r24
    8b4c:	30 e0       	ldi	r19, 0x00	; 0
    8b4e:	c9 01       	movw	r24, r18
    8b50:	88 0f       	add	r24, r24
    8b52:	99 1f       	adc	r25, r25
    8b54:	88 0f       	add	r24, r24
    8b56:	99 1f       	adc	r25, r25
    8b58:	88 0f       	add	r24, r24
    8b5a:	99 1f       	adc	r25, r25
    8b5c:	82 0f       	add	r24, r18
    8b5e:	93 1f       	adc	r25, r19
    8b60:	fc 01       	movw	r30, r24
    8b62:	ee 54       	subi	r30, 0x4E	; 78
    8b64:	f8 4f       	sbci	r31, 0xF8	; 248
    8b66:	80 81       	ld	r24, Z
    8b68:	8f 5f       	subi	r24, 0xFF	; 255
    8b6a:	80 83       	st	Z, r24
                         * earliest possible time. */
                        prvResetNextTaskUnblockTime();
                    }
                #endif

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    8b6c:	ef 81       	ldd	r30, Y+7	; 0x07
    8b6e:	f8 85       	ldd	r31, Y+8	; 0x08
    8b70:	96 89       	ldd	r25, Z+22	; 0x16
    8b72:	e0 91 a0 07 	lds	r30, 0x07A0
    8b76:	f0 91 a1 07 	lds	r31, 0x07A1
    8b7a:	86 89       	ldd	r24, Z+22	; 0x16
    8b7c:	89 17       	cp	r24, r25
    8b7e:	10 f4       	brcc	.+4      	; 0x8b84 <xTaskGenericNotify+0x35c>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    taskYIELD_IF_USING_PREEMPTION();
    8b80:	0e 94 87 21 	call	0x430e	; 0x430e <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    8b84:	0f 90       	pop	r0
    8b86:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    8b88:	8e 81       	ldd	r24, Y+6	; 0x06
    }
    8b8a:	64 96       	adiw	r28, 0x14	; 20
    8b8c:	0f b6       	in	r0, 0x3f	; 63
    8b8e:	f8 94       	cli
    8b90:	de bf       	out	0x3e, r29	; 62
    8b92:	0f be       	out	0x3f, r0	; 63
    8b94:	cd bf       	out	0x3d, r28	; 61
    8b96:	cf 91       	pop	r28
    8b98:	df 91       	pop	r29
    8b9a:	1f 91       	pop	r17
    8b9c:	0f 91       	pop	r16
    8b9e:	ff 90       	pop	r15
    8ba0:	ef 90       	pop	r14
    8ba2:	08 95       	ret

00008ba4 <xTaskGenericNotifyFromISR>:
                                          UBaseType_t uxIndexToNotify,
                                          uint32_t ulValue,
                                          eNotifyAction eAction,
                                          uint32_t * pulPreviousNotificationValue,
                                          BaseType_t * pxHigherPriorityTaskWoken )
    {
    8ba4:	cf 92       	push	r12
    8ba6:	df 92       	push	r13
    8ba8:	ef 92       	push	r14
    8baa:	ff 92       	push	r15
    8bac:	0f 93       	push	r16
    8bae:	1f 93       	push	r17
    8bb0:	df 93       	push	r29
    8bb2:	cf 93       	push	r28
    8bb4:	cd b7       	in	r28, 0x3d	; 61
    8bb6:	de b7       	in	r29, 0x3e	; 62
    8bb8:	69 97       	sbiw	r28, 0x19	; 25
    8bba:	0f b6       	in	r0, 0x3f	; 63
    8bbc:	f8 94       	cli
    8bbe:	de bf       	out	0x3e, r29	; 62
    8bc0:	0f be       	out	0x3f, r0	; 63
    8bc2:	cd bf       	out	0x3d, r28	; 61
    8bc4:	9d 87       	std	Y+13, r25	; 0x0d
    8bc6:	8c 87       	std	Y+12, r24	; 0x0c
    8bc8:	6e 87       	std	Y+14, r22	; 0x0e
    8bca:	2f 87       	std	Y+15, r18	; 0x0f
    8bcc:	38 8b       	std	Y+16, r19	; 0x10
    8bce:	49 8b       	std	Y+17, r20	; 0x11
    8bd0:	5a 8b       	std	Y+18, r21	; 0x12
    8bd2:	0b 8b       	std	Y+19, r16	; 0x13
    8bd4:	fd 8a       	std	Y+21, r15	; 0x15
    8bd6:	ec 8a       	std	Y+20, r14	; 0x14
    8bd8:	df 8a       	std	Y+23, r13	; 0x17
    8bda:	ce 8a       	std	Y+22, r12	; 0x16
        TCB_t * pxTCB;
        uint8_t ucOriginalNotifyState;
        BaseType_t xReturn = pdPASS;
    8bdc:	81 e0       	ldi	r24, 0x01	; 1
    8bde:	88 87       	std	Y+8, r24	; 0x08
         * simple as possible.  More information (albeit Cortex-M specific) is
         * provided on the following link:
         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

        pxTCB = xTaskToNotify;
    8be0:	8c 85       	ldd	r24, Y+12	; 0x0c
    8be2:	9d 85       	ldd	r25, Y+13	; 0x0d
    8be4:	9b 87       	std	Y+11, r25	; 0x0b
    8be6:	8a 87       	std	Y+10, r24	; 0x0a

        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    8be8:	1f 82       	std	Y+7, r1	; 0x07
        {
            if( pulPreviousNotificationValue != NULL )
    8bea:	8c 89       	ldd	r24, Y+20	; 0x14
    8bec:	9d 89       	ldd	r25, Y+21	; 0x15
    8bee:	00 97       	sbiw	r24, 0x00	; 0
    8bf0:	b9 f0       	breq	.+46     	; 0x8c20 <xTaskGenericNotifyFromISR+0x7c>
            {
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
    8bf2:	8e 85       	ldd	r24, Y+14	; 0x0e
    8bf4:	88 2f       	mov	r24, r24
    8bf6:	90 e0       	ldi	r25, 0x00	; 0
    8bf8:	2a 85       	ldd	r18, Y+10	; 0x0a
    8bfa:	3b 85       	ldd	r19, Y+11	; 0x0b
    8bfc:	88 0f       	add	r24, r24
    8bfe:	99 1f       	adc	r25, r25
    8c00:	88 0f       	add	r24, r24
    8c02:	99 1f       	adc	r25, r25
    8c04:	82 0f       	add	r24, r18
    8c06:	93 1f       	adc	r25, r19
    8c08:	fc 01       	movw	r30, r24
    8c0a:	b3 96       	adiw	r30, 0x23	; 35
    8c0c:	80 81       	ld	r24, Z
    8c0e:	91 81       	ldd	r25, Z+1	; 0x01
    8c10:	a2 81       	ldd	r26, Z+2	; 0x02
    8c12:	b3 81       	ldd	r27, Z+3	; 0x03
    8c14:	ec 89       	ldd	r30, Y+20	; 0x14
    8c16:	fd 89       	ldd	r31, Y+21	; 0x15
    8c18:	80 83       	st	Z, r24
    8c1a:	91 83       	std	Z+1, r25	; 0x01
    8c1c:	a2 83       	std	Z+2, r26	; 0x02
    8c1e:	b3 83       	std	Z+3, r27	; 0x03
            }

            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    8c20:	8e 85       	ldd	r24, Y+14	; 0x0e
    8c22:	28 2f       	mov	r18, r24
    8c24:	30 e0       	ldi	r19, 0x00	; 0
    8c26:	8a 85       	ldd	r24, Y+10	; 0x0a
    8c28:	9b 85       	ldd	r25, Y+11	; 0x0b
    8c2a:	82 0f       	add	r24, r18
    8c2c:	93 1f       	adc	r25, r19
    8c2e:	fc 01       	movw	r30, r24
    8c30:	b7 96       	adiw	r30, 0x27	; 39
    8c32:	80 81       	ld	r24, Z
    8c34:	89 87       	std	Y+9, r24	; 0x09
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    8c36:	8e 85       	ldd	r24, Y+14	; 0x0e
    8c38:	28 2f       	mov	r18, r24
    8c3a:	30 e0       	ldi	r19, 0x00	; 0
    8c3c:	8a 85       	ldd	r24, Y+10	; 0x0a
    8c3e:	9b 85       	ldd	r25, Y+11	; 0x0b
    8c40:	82 0f       	add	r24, r18
    8c42:	93 1f       	adc	r25, r19
    8c44:	fc 01       	movw	r30, r24
    8c46:	b7 96       	adiw	r30, 0x27	; 39
    8c48:	82 e0       	ldi	r24, 0x02	; 2
    8c4a:	80 83       	st	Z, r24

            switch( eAction )
    8c4c:	8b 89       	ldd	r24, Y+19	; 0x13
    8c4e:	28 2f       	mov	r18, r24
    8c50:	30 e0       	ldi	r19, 0x00	; 0
    8c52:	39 8f       	std	Y+25, r19	; 0x19
    8c54:	28 8f       	std	Y+24, r18	; 0x18
    8c56:	88 8d       	ldd	r24, Y+24	; 0x18
    8c58:	99 8d       	ldd	r25, Y+25	; 0x19
    8c5a:	82 30       	cpi	r24, 0x02	; 2
    8c5c:	91 05       	cpc	r25, r1
    8c5e:	09 f4       	brne	.+2      	; 0x8c62 <xTaskGenericNotifyFromISR+0xbe>
    8c60:	46 c0       	rjmp	.+140    	; 0x8cee <xTaskGenericNotifyFromISR+0x14a>
    8c62:	28 8d       	ldd	r18, Y+24	; 0x18
    8c64:	39 8d       	ldd	r19, Y+25	; 0x19
    8c66:	23 30       	cpi	r18, 0x03	; 3
    8c68:	31 05       	cpc	r19, r1
    8c6a:	34 f4       	brge	.+12     	; 0x8c78 <xTaskGenericNotifyFromISR+0xd4>
    8c6c:	88 8d       	ldd	r24, Y+24	; 0x18
    8c6e:	99 8d       	ldd	r25, Y+25	; 0x19
    8c70:	81 30       	cpi	r24, 0x01	; 1
    8c72:	91 05       	cpc	r25, r1
    8c74:	71 f0       	breq	.+28     	; 0x8c92 <xTaskGenericNotifyFromISR+0xee>
    8c76:	93 c0       	rjmp	.+294    	; 0x8d9e <xTaskGenericNotifyFromISR+0x1fa>
    8c78:	28 8d       	ldd	r18, Y+24	; 0x18
    8c7a:	39 8d       	ldd	r19, Y+25	; 0x19
    8c7c:	23 30       	cpi	r18, 0x03	; 3
    8c7e:	31 05       	cpc	r19, r1
    8c80:	09 f4       	brne	.+2      	; 0x8c84 <xTaskGenericNotifyFromISR+0xe0>
    8c82:	5d c0       	rjmp	.+186    	; 0x8d3e <xTaskGenericNotifyFromISR+0x19a>
    8c84:	88 8d       	ldd	r24, Y+24	; 0x18
    8c86:	99 8d       	ldd	r25, Y+25	; 0x19
    8c88:	84 30       	cpi	r24, 0x04	; 4
    8c8a:	91 05       	cpc	r25, r1
    8c8c:	09 f4       	brne	.+2      	; 0x8c90 <xTaskGenericNotifyFromISR+0xec>
    8c8e:	6d c0       	rjmp	.+218    	; 0x8d6a <xTaskGenericNotifyFromISR+0x1c6>
    8c90:	86 c0       	rjmp	.+268    	; 0x8d9e <xTaskGenericNotifyFromISR+0x1fa>
            {
                case eSetBits:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
    8c92:	8e 85       	ldd	r24, Y+14	; 0x0e
    8c94:	08 2f       	mov	r16, r24
    8c96:	10 e0       	ldi	r17, 0x00	; 0
    8c98:	8e 85       	ldd	r24, Y+14	; 0x0e
    8c9a:	88 2f       	mov	r24, r24
    8c9c:	90 e0       	ldi	r25, 0x00	; 0
    8c9e:	2a 85       	ldd	r18, Y+10	; 0x0a
    8ca0:	3b 85       	ldd	r19, Y+11	; 0x0b
    8ca2:	88 0f       	add	r24, r24
    8ca4:	99 1f       	adc	r25, r25
    8ca6:	88 0f       	add	r24, r24
    8ca8:	99 1f       	adc	r25, r25
    8caa:	82 0f       	add	r24, r18
    8cac:	93 1f       	adc	r25, r19
    8cae:	fc 01       	movw	r30, r24
    8cb0:	b3 96       	adiw	r30, 0x23	; 35
    8cb2:	20 81       	ld	r18, Z
    8cb4:	31 81       	ldd	r19, Z+1	; 0x01
    8cb6:	42 81       	ldd	r20, Z+2	; 0x02
    8cb8:	53 81       	ldd	r21, Z+3	; 0x03
    8cba:	8f 85       	ldd	r24, Y+15	; 0x0f
    8cbc:	98 89       	ldd	r25, Y+16	; 0x10
    8cbe:	a9 89       	ldd	r26, Y+17	; 0x11
    8cc0:	ba 89       	ldd	r27, Y+18	; 0x12
    8cc2:	ba 01       	movw	r22, r20
    8cc4:	a9 01       	movw	r20, r18
    8cc6:	48 2b       	or	r20, r24
    8cc8:	59 2b       	or	r21, r25
    8cca:	6a 2b       	or	r22, r26
    8ccc:	7b 2b       	or	r23, r27
    8cce:	2a 85       	ldd	r18, Y+10	; 0x0a
    8cd0:	3b 85       	ldd	r19, Y+11	; 0x0b
    8cd2:	c8 01       	movw	r24, r16
    8cd4:	88 0f       	add	r24, r24
    8cd6:	99 1f       	adc	r25, r25
    8cd8:	88 0f       	add	r24, r24
    8cda:	99 1f       	adc	r25, r25
    8cdc:	82 0f       	add	r24, r18
    8cde:	93 1f       	adc	r25, r19
    8ce0:	fc 01       	movw	r30, r24
    8ce2:	b3 96       	adiw	r30, 0x23	; 35
    8ce4:	40 83       	st	Z, r20
    8ce6:	51 83       	std	Z+1, r21	; 0x01
    8ce8:	62 83       	std	Z+2, r22	; 0x02
    8cea:	73 83       	std	Z+3, r23	; 0x03
    8cec:	58 c0       	rjmp	.+176    	; 0x8d9e <xTaskGenericNotifyFromISR+0x1fa>
                    break;

                case eIncrement:
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    8cee:	8e 85       	ldd	r24, Y+14	; 0x0e
    8cf0:	08 2f       	mov	r16, r24
    8cf2:	10 e0       	ldi	r17, 0x00	; 0
    8cf4:	2a 85       	ldd	r18, Y+10	; 0x0a
    8cf6:	3b 85       	ldd	r19, Y+11	; 0x0b
    8cf8:	c8 01       	movw	r24, r16
    8cfa:	88 0f       	add	r24, r24
    8cfc:	99 1f       	adc	r25, r25
    8cfe:	88 0f       	add	r24, r24
    8d00:	99 1f       	adc	r25, r25
    8d02:	82 0f       	add	r24, r18
    8d04:	93 1f       	adc	r25, r19
    8d06:	fc 01       	movw	r30, r24
    8d08:	b3 96       	adiw	r30, 0x23	; 35
    8d0a:	80 81       	ld	r24, Z
    8d0c:	91 81       	ldd	r25, Z+1	; 0x01
    8d0e:	a2 81       	ldd	r26, Z+2	; 0x02
    8d10:	b3 81       	ldd	r27, Z+3	; 0x03
    8d12:	ac 01       	movw	r20, r24
    8d14:	bd 01       	movw	r22, r26
    8d16:	4f 5f       	subi	r20, 0xFF	; 255
    8d18:	5f 4f       	sbci	r21, 0xFF	; 255
    8d1a:	6f 4f       	sbci	r22, 0xFF	; 255
    8d1c:	7f 4f       	sbci	r23, 0xFF	; 255
    8d1e:	2a 85       	ldd	r18, Y+10	; 0x0a
    8d20:	3b 85       	ldd	r19, Y+11	; 0x0b
    8d22:	c8 01       	movw	r24, r16
    8d24:	88 0f       	add	r24, r24
    8d26:	99 1f       	adc	r25, r25
    8d28:	88 0f       	add	r24, r24
    8d2a:	99 1f       	adc	r25, r25
    8d2c:	82 0f       	add	r24, r18
    8d2e:	93 1f       	adc	r25, r19
    8d30:	fc 01       	movw	r30, r24
    8d32:	b3 96       	adiw	r30, 0x23	; 35
    8d34:	40 83       	st	Z, r20
    8d36:	51 83       	std	Z+1, r21	; 0x01
    8d38:	62 83       	std	Z+2, r22	; 0x02
    8d3a:	73 83       	std	Z+3, r23	; 0x03
    8d3c:	30 c0       	rjmp	.+96     	; 0x8d9e <xTaskGenericNotifyFromISR+0x1fa>
                    break;

                case eSetValueWithOverwrite:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    8d3e:	8e 85       	ldd	r24, Y+14	; 0x0e
    8d40:	88 2f       	mov	r24, r24
    8d42:	90 e0       	ldi	r25, 0x00	; 0
    8d44:	2a 85       	ldd	r18, Y+10	; 0x0a
    8d46:	3b 85       	ldd	r19, Y+11	; 0x0b
    8d48:	88 0f       	add	r24, r24
    8d4a:	99 1f       	adc	r25, r25
    8d4c:	88 0f       	add	r24, r24
    8d4e:	99 1f       	adc	r25, r25
    8d50:	82 0f       	add	r24, r18
    8d52:	93 1f       	adc	r25, r19
    8d54:	fc 01       	movw	r30, r24
    8d56:	b3 96       	adiw	r30, 0x23	; 35
    8d58:	8f 85       	ldd	r24, Y+15	; 0x0f
    8d5a:	98 89       	ldd	r25, Y+16	; 0x10
    8d5c:	a9 89       	ldd	r26, Y+17	; 0x11
    8d5e:	ba 89       	ldd	r27, Y+18	; 0x12
    8d60:	80 83       	st	Z, r24
    8d62:	91 83       	std	Z+1, r25	; 0x01
    8d64:	a2 83       	std	Z+2, r26	; 0x02
    8d66:	b3 83       	std	Z+3, r27	; 0x03
    8d68:	1a c0       	rjmp	.+52     	; 0x8d9e <xTaskGenericNotifyFromISR+0x1fa>
                    break;

                case eSetValueWithoutOverwrite:

                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    8d6a:	89 85       	ldd	r24, Y+9	; 0x09
    8d6c:	82 30       	cpi	r24, 0x02	; 2
    8d6e:	b1 f0       	breq	.+44     	; 0x8d9c <xTaskGenericNotifyFromISR+0x1f8>
                    {
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    8d70:	8e 85       	ldd	r24, Y+14	; 0x0e
    8d72:	88 2f       	mov	r24, r24
    8d74:	90 e0       	ldi	r25, 0x00	; 0
    8d76:	2a 85       	ldd	r18, Y+10	; 0x0a
    8d78:	3b 85       	ldd	r19, Y+11	; 0x0b
    8d7a:	88 0f       	add	r24, r24
    8d7c:	99 1f       	adc	r25, r25
    8d7e:	88 0f       	add	r24, r24
    8d80:	99 1f       	adc	r25, r25
    8d82:	82 0f       	add	r24, r18
    8d84:	93 1f       	adc	r25, r19
    8d86:	fc 01       	movw	r30, r24
    8d88:	b3 96       	adiw	r30, 0x23	; 35
    8d8a:	8f 85       	ldd	r24, Y+15	; 0x0f
    8d8c:	98 89       	ldd	r25, Y+16	; 0x10
    8d8e:	a9 89       	ldd	r26, Y+17	; 0x11
    8d90:	ba 89       	ldd	r27, Y+18	; 0x12
    8d92:	80 83       	st	Z, r24
    8d94:	91 83       	std	Z+1, r25	; 0x01
    8d96:	a2 83       	std	Z+2, r26	; 0x02
    8d98:	b3 83       	std	Z+3, r27	; 0x03
    8d9a:	01 c0       	rjmp	.+2      	; 0x8d9e <xTaskGenericNotifyFromISR+0x1fa>
                    }
                    else
                    {
                        /* The value could not be written to the task. */
                        xReturn = pdFAIL;
    8d9c:	18 86       	std	Y+8, r1	; 0x08

            traceTASK_NOTIFY_FROM_ISR( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    8d9e:	89 85       	ldd	r24, Y+9	; 0x09
    8da0:	81 30       	cpi	r24, 0x01	; 1
    8da2:	09 f0       	breq	.+2      	; 0x8da6 <xTaskGenericNotifyFromISR+0x202>
    8da4:	ee c0       	rjmp	.+476    	; 0x8f82 <xTaskGenericNotifyFromISR+0x3de>
            {
                /* The task should not have been on an event list. */
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    8da6:	80 91 b1 07 	lds	r24, 0x07B1
    8daa:	88 23       	and	r24, r24
    8dac:	09 f0       	breq	.+2      	; 0x8db0 <xTaskGenericNotifyFromISR+0x20c>
    8dae:	a4 c0       	rjmp	.+328    	; 0x8ef8 <xTaskGenericNotifyFromISR+0x354>
                {
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    8db0:	ea 85       	ldd	r30, Y+10	; 0x0a
    8db2:	fb 85       	ldd	r31, Y+11	; 0x0b
    8db4:	82 85       	ldd	r24, Z+10	; 0x0a
    8db6:	93 85       	ldd	r25, Z+11	; 0x0b
    8db8:	9e 83       	std	Y+6, r25	; 0x06
    8dba:	8d 83       	std	Y+5, r24	; 0x05
    8dbc:	ea 85       	ldd	r30, Y+10	; 0x0a
    8dbe:	fb 85       	ldd	r31, Y+11	; 0x0b
    8dc0:	a4 81       	ldd	r26, Z+4	; 0x04
    8dc2:	b5 81       	ldd	r27, Z+5	; 0x05
    8dc4:	ea 85       	ldd	r30, Y+10	; 0x0a
    8dc6:	fb 85       	ldd	r31, Y+11	; 0x0b
    8dc8:	86 81       	ldd	r24, Z+6	; 0x06
    8dca:	97 81       	ldd	r25, Z+7	; 0x07
    8dcc:	15 96       	adiw	r26, 0x05	; 5
    8dce:	9c 93       	st	X, r25
    8dd0:	8e 93       	st	-X, r24
    8dd2:	14 97       	sbiw	r26, 0x04	; 4
    8dd4:	ea 85       	ldd	r30, Y+10	; 0x0a
    8dd6:	fb 85       	ldd	r31, Y+11	; 0x0b
    8dd8:	a6 81       	ldd	r26, Z+6	; 0x06
    8dda:	b7 81       	ldd	r27, Z+7	; 0x07
    8ddc:	ea 85       	ldd	r30, Y+10	; 0x0a
    8dde:	fb 85       	ldd	r31, Y+11	; 0x0b
    8de0:	84 81       	ldd	r24, Z+4	; 0x04
    8de2:	95 81       	ldd	r25, Z+5	; 0x05
    8de4:	13 96       	adiw	r26, 0x03	; 3
    8de6:	9c 93       	st	X, r25
    8de8:	8e 93       	st	-X, r24
    8dea:	12 97       	sbiw	r26, 0x02	; 2
    8dec:	ed 81       	ldd	r30, Y+5	; 0x05
    8dee:	fe 81       	ldd	r31, Y+6	; 0x06
    8df0:	21 81       	ldd	r18, Z+1	; 0x01
    8df2:	32 81       	ldd	r19, Z+2	; 0x02
    8df4:	8a 85       	ldd	r24, Y+10	; 0x0a
    8df6:	9b 85       	ldd	r25, Y+11	; 0x0b
    8df8:	02 96       	adiw	r24, 0x02	; 2
    8dfa:	28 17       	cp	r18, r24
    8dfc:	39 07       	cpc	r19, r25
    8dfe:	41 f4       	brne	.+16     	; 0x8e10 <xTaskGenericNotifyFromISR+0x26c>
    8e00:	ea 85       	ldd	r30, Y+10	; 0x0a
    8e02:	fb 85       	ldd	r31, Y+11	; 0x0b
    8e04:	86 81       	ldd	r24, Z+6	; 0x06
    8e06:	97 81       	ldd	r25, Z+7	; 0x07
    8e08:	ed 81       	ldd	r30, Y+5	; 0x05
    8e0a:	fe 81       	ldd	r31, Y+6	; 0x06
    8e0c:	92 83       	std	Z+2, r25	; 0x02
    8e0e:	81 83       	std	Z+1, r24	; 0x01
    8e10:	ea 85       	ldd	r30, Y+10	; 0x0a
    8e12:	fb 85       	ldd	r31, Y+11	; 0x0b
    8e14:	13 86       	std	Z+11, r1	; 0x0b
    8e16:	12 86       	std	Z+10, r1	; 0x0a
    8e18:	ed 81       	ldd	r30, Y+5	; 0x05
    8e1a:	fe 81       	ldd	r31, Y+6	; 0x06
    8e1c:	80 81       	ld	r24, Z
    8e1e:	81 50       	subi	r24, 0x01	; 1
    8e20:	ed 81       	ldd	r30, Y+5	; 0x05
    8e22:	fe 81       	ldd	r31, Y+6	; 0x06
    8e24:	80 83       	st	Z, r24
                    prvAddTaskToReadyList( pxTCB );
    8e26:	ea 85       	ldd	r30, Y+10	; 0x0a
    8e28:	fb 85       	ldd	r31, Y+11	; 0x0b
    8e2a:	96 89       	ldd	r25, Z+22	; 0x16
    8e2c:	80 91 a6 07 	lds	r24, 0x07A6
    8e30:	89 17       	cp	r24, r25
    8e32:	28 f4       	brcc	.+10     	; 0x8e3e <xTaskGenericNotifyFromISR+0x29a>
    8e34:	ea 85       	ldd	r30, Y+10	; 0x0a
    8e36:	fb 85       	ldd	r31, Y+11	; 0x0b
    8e38:	86 89       	ldd	r24, Z+22	; 0x16
    8e3a:	80 93 a6 07 	sts	0x07A6, r24
    8e3e:	ea 85       	ldd	r30, Y+10	; 0x0a
    8e40:	fb 85       	ldd	r31, Y+11	; 0x0b
    8e42:	86 89       	ldd	r24, Z+22	; 0x16
    8e44:	28 2f       	mov	r18, r24
    8e46:	30 e0       	ldi	r19, 0x00	; 0
    8e48:	c9 01       	movw	r24, r18
    8e4a:	88 0f       	add	r24, r24
    8e4c:	99 1f       	adc	r25, r25
    8e4e:	88 0f       	add	r24, r24
    8e50:	99 1f       	adc	r25, r25
    8e52:	88 0f       	add	r24, r24
    8e54:	99 1f       	adc	r25, r25
    8e56:	82 0f       	add	r24, r18
    8e58:	93 1f       	adc	r25, r19
    8e5a:	fc 01       	movw	r30, r24
    8e5c:	ee 54       	subi	r30, 0x4E	; 78
    8e5e:	f8 4f       	sbci	r31, 0xF8	; 248
    8e60:	81 81       	ldd	r24, Z+1	; 0x01
    8e62:	92 81       	ldd	r25, Z+2	; 0x02
    8e64:	9c 83       	std	Y+4, r25	; 0x04
    8e66:	8b 83       	std	Y+3, r24	; 0x03
    8e68:	ea 85       	ldd	r30, Y+10	; 0x0a
    8e6a:	fb 85       	ldd	r31, Y+11	; 0x0b
    8e6c:	8b 81       	ldd	r24, Y+3	; 0x03
    8e6e:	9c 81       	ldd	r25, Y+4	; 0x04
    8e70:	95 83       	std	Z+5, r25	; 0x05
    8e72:	84 83       	std	Z+4, r24	; 0x04
    8e74:	eb 81       	ldd	r30, Y+3	; 0x03
    8e76:	fc 81       	ldd	r31, Y+4	; 0x04
    8e78:	84 81       	ldd	r24, Z+4	; 0x04
    8e7a:	95 81       	ldd	r25, Z+5	; 0x05
    8e7c:	ea 85       	ldd	r30, Y+10	; 0x0a
    8e7e:	fb 85       	ldd	r31, Y+11	; 0x0b
    8e80:	97 83       	std	Z+7, r25	; 0x07
    8e82:	86 83       	std	Z+6, r24	; 0x06
    8e84:	eb 81       	ldd	r30, Y+3	; 0x03
    8e86:	fc 81       	ldd	r31, Y+4	; 0x04
    8e88:	04 80       	ldd	r0, Z+4	; 0x04
    8e8a:	f5 81       	ldd	r31, Z+5	; 0x05
    8e8c:	e0 2d       	mov	r30, r0
    8e8e:	8a 85       	ldd	r24, Y+10	; 0x0a
    8e90:	9b 85       	ldd	r25, Y+11	; 0x0b
    8e92:	02 96       	adiw	r24, 0x02	; 2
    8e94:	93 83       	std	Z+3, r25	; 0x03
    8e96:	82 83       	std	Z+2, r24	; 0x02
    8e98:	8a 85       	ldd	r24, Y+10	; 0x0a
    8e9a:	9b 85       	ldd	r25, Y+11	; 0x0b
    8e9c:	02 96       	adiw	r24, 0x02	; 2
    8e9e:	eb 81       	ldd	r30, Y+3	; 0x03
    8ea0:	fc 81       	ldd	r31, Y+4	; 0x04
    8ea2:	95 83       	std	Z+5, r25	; 0x05
    8ea4:	84 83       	std	Z+4, r24	; 0x04
    8ea6:	ea 85       	ldd	r30, Y+10	; 0x0a
    8ea8:	fb 85       	ldd	r31, Y+11	; 0x0b
    8eaa:	86 89       	ldd	r24, Z+22	; 0x16
    8eac:	28 2f       	mov	r18, r24
    8eae:	30 e0       	ldi	r19, 0x00	; 0
    8eb0:	c9 01       	movw	r24, r18
    8eb2:	88 0f       	add	r24, r24
    8eb4:	99 1f       	adc	r25, r25
    8eb6:	88 0f       	add	r24, r24
    8eb8:	99 1f       	adc	r25, r25
    8eba:	88 0f       	add	r24, r24
    8ebc:	99 1f       	adc	r25, r25
    8ebe:	82 0f       	add	r24, r18
    8ec0:	93 1f       	adc	r25, r19
    8ec2:	8e 54       	subi	r24, 0x4E	; 78
    8ec4:	98 4f       	sbci	r25, 0xF8	; 248
    8ec6:	ea 85       	ldd	r30, Y+10	; 0x0a
    8ec8:	fb 85       	ldd	r31, Y+11	; 0x0b
    8eca:	93 87       	std	Z+11, r25	; 0x0b
    8ecc:	82 87       	std	Z+10, r24	; 0x0a
    8ece:	ea 85       	ldd	r30, Y+10	; 0x0a
    8ed0:	fb 85       	ldd	r31, Y+11	; 0x0b
    8ed2:	86 89       	ldd	r24, Z+22	; 0x16
    8ed4:	28 2f       	mov	r18, r24
    8ed6:	30 e0       	ldi	r19, 0x00	; 0
    8ed8:	c9 01       	movw	r24, r18
    8eda:	88 0f       	add	r24, r24
    8edc:	99 1f       	adc	r25, r25
    8ede:	88 0f       	add	r24, r24
    8ee0:	99 1f       	adc	r25, r25
    8ee2:	88 0f       	add	r24, r24
    8ee4:	99 1f       	adc	r25, r25
    8ee6:	82 0f       	add	r24, r18
    8ee8:	93 1f       	adc	r25, r19
    8eea:	fc 01       	movw	r30, r24
    8eec:	ee 54       	subi	r30, 0x4E	; 78
    8eee:	f8 4f       	sbci	r31, 0xF8	; 248
    8ef0:	80 81       	ld	r24, Z
    8ef2:	8f 5f       	subi	r24, 0xFF	; 255
    8ef4:	80 83       	st	Z, r24
    8ef6:	30 c0       	rjmp	.+96     	; 0x8f58 <xTaskGenericNotifyFromISR+0x3b4>
                }
                else
                {
                    /* The delayed and ready lists cannot be accessed, so hold
                     * this task pending until the scheduler is resumed. */
                    listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    8ef8:	80 91 ed 07 	lds	r24, 0x07ED
    8efc:	90 91 ee 07 	lds	r25, 0x07EE
    8f00:	9a 83       	std	Y+2, r25	; 0x02
    8f02:	89 83       	std	Y+1, r24	; 0x01
    8f04:	ea 85       	ldd	r30, Y+10	; 0x0a
    8f06:	fb 85       	ldd	r31, Y+11	; 0x0b
    8f08:	89 81       	ldd	r24, Y+1	; 0x01
    8f0a:	9a 81       	ldd	r25, Y+2	; 0x02
    8f0c:	97 87       	std	Z+15, r25	; 0x0f
    8f0e:	86 87       	std	Z+14, r24	; 0x0e
    8f10:	e9 81       	ldd	r30, Y+1	; 0x01
    8f12:	fa 81       	ldd	r31, Y+2	; 0x02
    8f14:	84 81       	ldd	r24, Z+4	; 0x04
    8f16:	95 81       	ldd	r25, Z+5	; 0x05
    8f18:	ea 85       	ldd	r30, Y+10	; 0x0a
    8f1a:	fb 85       	ldd	r31, Y+11	; 0x0b
    8f1c:	91 8b       	std	Z+17, r25	; 0x11
    8f1e:	80 8b       	std	Z+16, r24	; 0x10
    8f20:	e9 81       	ldd	r30, Y+1	; 0x01
    8f22:	fa 81       	ldd	r31, Y+2	; 0x02
    8f24:	04 80       	ldd	r0, Z+4	; 0x04
    8f26:	f5 81       	ldd	r31, Z+5	; 0x05
    8f28:	e0 2d       	mov	r30, r0
    8f2a:	8a 85       	ldd	r24, Y+10	; 0x0a
    8f2c:	9b 85       	ldd	r25, Y+11	; 0x0b
    8f2e:	0c 96       	adiw	r24, 0x0c	; 12
    8f30:	93 83       	std	Z+3, r25	; 0x03
    8f32:	82 83       	std	Z+2, r24	; 0x02
    8f34:	8a 85       	ldd	r24, Y+10	; 0x0a
    8f36:	9b 85       	ldd	r25, Y+11	; 0x0b
    8f38:	0c 96       	adiw	r24, 0x0c	; 12
    8f3a:	e9 81       	ldd	r30, Y+1	; 0x01
    8f3c:	fa 81       	ldd	r31, Y+2	; 0x02
    8f3e:	95 83       	std	Z+5, r25	; 0x05
    8f40:	84 83       	std	Z+4, r24	; 0x04
    8f42:	ea 85       	ldd	r30, Y+10	; 0x0a
    8f44:	fb 85       	ldd	r31, Y+11	; 0x0b
    8f46:	8c ee       	ldi	r24, 0xEC	; 236
    8f48:	97 e0       	ldi	r25, 0x07	; 7
    8f4a:	95 8b       	std	Z+21, r25	; 0x15
    8f4c:	84 8b       	std	Z+20, r24	; 0x14
    8f4e:	80 91 ec 07 	lds	r24, 0x07EC
    8f52:	8f 5f       	subi	r24, 0xFF	; 255
    8f54:	80 93 ec 07 	sts	0x07EC, r24
                }

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    8f58:	ea 85       	ldd	r30, Y+10	; 0x0a
    8f5a:	fb 85       	ldd	r31, Y+11	; 0x0b
    8f5c:	96 89       	ldd	r25, Z+22	; 0x16
    8f5e:	e0 91 a0 07 	lds	r30, 0x07A0
    8f62:	f0 91 a1 07 	lds	r31, 0x07A1
    8f66:	86 89       	ldd	r24, Z+22	; 0x16
    8f68:	89 17       	cp	r24, r25
    8f6a:	58 f4       	brcc	.+22     	; 0x8f82 <xTaskGenericNotifyFromISR+0x3de>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    if( pxHigherPriorityTaskWoken != NULL )
    8f6c:	8e 89       	ldd	r24, Y+22	; 0x16
    8f6e:	9f 89       	ldd	r25, Y+23	; 0x17
    8f70:	00 97       	sbiw	r24, 0x00	; 0
    8f72:	21 f0       	breq	.+8      	; 0x8f7c <xTaskGenericNotifyFromISR+0x3d8>
                    {
                        *pxHigherPriorityTaskWoken = pdTRUE;
    8f74:	ee 89       	ldd	r30, Y+22	; 0x16
    8f76:	ff 89       	ldd	r31, Y+23	; 0x17
    8f78:	81 e0       	ldi	r24, 0x01	; 1
    8f7a:	80 83       	st	Z, r24
                    }

                    /* Mark that a yield is pending in case the user is not
                     * using the "xHigherPriorityTaskWoken" parameter to an ISR
                     * safe FreeRTOS function. */
                    xYieldPending = pdTRUE;
    8f7c:	81 e0       	ldi	r24, 0x01	; 1
    8f7e:	80 93 aa 07 	sts	0x07AA, r24
                }
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

        return xReturn;
    8f82:	88 85       	ldd	r24, Y+8	; 0x08
    }
    8f84:	69 96       	adiw	r28, 0x19	; 25
    8f86:	0f b6       	in	r0, 0x3f	; 63
    8f88:	f8 94       	cli
    8f8a:	de bf       	out	0x3e, r29	; 62
    8f8c:	0f be       	out	0x3f, r0	; 63
    8f8e:	cd bf       	out	0x3d, r28	; 61
    8f90:	cf 91       	pop	r28
    8f92:	df 91       	pop	r29
    8f94:	1f 91       	pop	r17
    8f96:	0f 91       	pop	r16
    8f98:	ff 90       	pop	r15
    8f9a:	ef 90       	pop	r14
    8f9c:	df 90       	pop	r13
    8f9e:	cf 90       	pop	r12
    8fa0:	08 95       	ret

00008fa2 <vTaskGenericNotifyGiveFromISR>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    void vTaskGenericNotifyGiveFromISR( TaskHandle_t xTaskToNotify,
                                        UBaseType_t uxIndexToNotify,
                                        BaseType_t * pxHigherPriorityTaskWoken )
    {
    8fa2:	0f 93       	push	r16
    8fa4:	1f 93       	push	r17
    8fa6:	df 93       	push	r29
    8fa8:	cf 93       	push	r28
    8faa:	cd b7       	in	r28, 0x3d	; 61
    8fac:	de b7       	in	r29, 0x3e	; 62
    8fae:	2f 97       	sbiw	r28, 0x0f	; 15
    8fb0:	0f b6       	in	r0, 0x3f	; 63
    8fb2:	f8 94       	cli
    8fb4:	de bf       	out	0x3e, r29	; 62
    8fb6:	0f be       	out	0x3f, r0	; 63
    8fb8:	cd bf       	out	0x3d, r28	; 61
    8fba:	9c 87       	std	Y+12, r25	; 0x0c
    8fbc:	8b 87       	std	Y+11, r24	; 0x0b
    8fbe:	6d 87       	std	Y+13, r22	; 0x0d
    8fc0:	5f 87       	std	Y+15, r21	; 0x0f
    8fc2:	4e 87       	std	Y+14, r20	; 0x0e
         * simple as possible.  More information (albeit Cortex-M specific) is
         * provided on the following link:
         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

        pxTCB = xTaskToNotify;
    8fc4:	8b 85       	ldd	r24, Y+11	; 0x0b
    8fc6:	9c 85       	ldd	r25, Y+12	; 0x0c
    8fc8:	9a 87       	std	Y+10, r25	; 0x0a
    8fca:	89 87       	std	Y+9, r24	; 0x09

        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    8fcc:	1f 82       	std	Y+7, r1	; 0x07
        {
            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    8fce:	8d 85       	ldd	r24, Y+13	; 0x0d
    8fd0:	28 2f       	mov	r18, r24
    8fd2:	30 e0       	ldi	r19, 0x00	; 0
    8fd4:	89 85       	ldd	r24, Y+9	; 0x09
    8fd6:	9a 85       	ldd	r25, Y+10	; 0x0a
    8fd8:	82 0f       	add	r24, r18
    8fda:	93 1f       	adc	r25, r19
    8fdc:	fc 01       	movw	r30, r24
    8fde:	b7 96       	adiw	r30, 0x27	; 39
    8fe0:	80 81       	ld	r24, Z
    8fe2:	88 87       	std	Y+8, r24	; 0x08
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    8fe4:	8d 85       	ldd	r24, Y+13	; 0x0d
    8fe6:	28 2f       	mov	r18, r24
    8fe8:	30 e0       	ldi	r19, 0x00	; 0
    8fea:	89 85       	ldd	r24, Y+9	; 0x09
    8fec:	9a 85       	ldd	r25, Y+10	; 0x0a
    8fee:	82 0f       	add	r24, r18
    8ff0:	93 1f       	adc	r25, r19
    8ff2:	fc 01       	movw	r30, r24
    8ff4:	b7 96       	adiw	r30, 0x27	; 39
    8ff6:	82 e0       	ldi	r24, 0x02	; 2
    8ff8:	80 83       	st	Z, r24

            /* 'Giving' is equivalent to incrementing a count in a counting
             * semaphore. */
            ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    8ffa:	8d 85       	ldd	r24, Y+13	; 0x0d
    8ffc:	08 2f       	mov	r16, r24
    8ffe:	10 e0       	ldi	r17, 0x00	; 0
    9000:	29 85       	ldd	r18, Y+9	; 0x09
    9002:	3a 85       	ldd	r19, Y+10	; 0x0a
    9004:	c8 01       	movw	r24, r16
    9006:	88 0f       	add	r24, r24
    9008:	99 1f       	adc	r25, r25
    900a:	88 0f       	add	r24, r24
    900c:	99 1f       	adc	r25, r25
    900e:	82 0f       	add	r24, r18
    9010:	93 1f       	adc	r25, r19
    9012:	fc 01       	movw	r30, r24
    9014:	b3 96       	adiw	r30, 0x23	; 35
    9016:	80 81       	ld	r24, Z
    9018:	91 81       	ldd	r25, Z+1	; 0x01
    901a:	a2 81       	ldd	r26, Z+2	; 0x02
    901c:	b3 81       	ldd	r27, Z+3	; 0x03
    901e:	ac 01       	movw	r20, r24
    9020:	bd 01       	movw	r22, r26
    9022:	4f 5f       	subi	r20, 0xFF	; 255
    9024:	5f 4f       	sbci	r21, 0xFF	; 255
    9026:	6f 4f       	sbci	r22, 0xFF	; 255
    9028:	7f 4f       	sbci	r23, 0xFF	; 255
    902a:	29 85       	ldd	r18, Y+9	; 0x09
    902c:	3a 85       	ldd	r19, Y+10	; 0x0a
    902e:	c8 01       	movw	r24, r16
    9030:	88 0f       	add	r24, r24
    9032:	99 1f       	adc	r25, r25
    9034:	88 0f       	add	r24, r24
    9036:	99 1f       	adc	r25, r25
    9038:	82 0f       	add	r24, r18
    903a:	93 1f       	adc	r25, r19
    903c:	fc 01       	movw	r30, r24
    903e:	b3 96       	adiw	r30, 0x23	; 35
    9040:	40 83       	st	Z, r20
    9042:	51 83       	std	Z+1, r21	; 0x01
    9044:	62 83       	std	Z+2, r22	; 0x02
    9046:	73 83       	std	Z+3, r23	; 0x03

            traceTASK_NOTIFY_GIVE_FROM_ISR( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    9048:	88 85       	ldd	r24, Y+8	; 0x08
    904a:	81 30       	cpi	r24, 0x01	; 1
    904c:	09 f0       	breq	.+2      	; 0x9050 <vTaskGenericNotifyGiveFromISR+0xae>
    904e:	ee c0       	rjmp	.+476    	; 0x922c <vTaskGenericNotifyGiveFromISR+0x28a>
            {
                /* The task should not have been on an event list. */
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    9050:	80 91 b1 07 	lds	r24, 0x07B1
    9054:	88 23       	and	r24, r24
    9056:	09 f0       	breq	.+2      	; 0x905a <vTaskGenericNotifyGiveFromISR+0xb8>
    9058:	a4 c0       	rjmp	.+328    	; 0x91a2 <vTaskGenericNotifyGiveFromISR+0x200>
                {
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    905a:	e9 85       	ldd	r30, Y+9	; 0x09
    905c:	fa 85       	ldd	r31, Y+10	; 0x0a
    905e:	82 85       	ldd	r24, Z+10	; 0x0a
    9060:	93 85       	ldd	r25, Z+11	; 0x0b
    9062:	9e 83       	std	Y+6, r25	; 0x06
    9064:	8d 83       	std	Y+5, r24	; 0x05
    9066:	e9 85       	ldd	r30, Y+9	; 0x09
    9068:	fa 85       	ldd	r31, Y+10	; 0x0a
    906a:	a4 81       	ldd	r26, Z+4	; 0x04
    906c:	b5 81       	ldd	r27, Z+5	; 0x05
    906e:	e9 85       	ldd	r30, Y+9	; 0x09
    9070:	fa 85       	ldd	r31, Y+10	; 0x0a
    9072:	86 81       	ldd	r24, Z+6	; 0x06
    9074:	97 81       	ldd	r25, Z+7	; 0x07
    9076:	15 96       	adiw	r26, 0x05	; 5
    9078:	9c 93       	st	X, r25
    907a:	8e 93       	st	-X, r24
    907c:	14 97       	sbiw	r26, 0x04	; 4
    907e:	e9 85       	ldd	r30, Y+9	; 0x09
    9080:	fa 85       	ldd	r31, Y+10	; 0x0a
    9082:	a6 81       	ldd	r26, Z+6	; 0x06
    9084:	b7 81       	ldd	r27, Z+7	; 0x07
    9086:	e9 85       	ldd	r30, Y+9	; 0x09
    9088:	fa 85       	ldd	r31, Y+10	; 0x0a
    908a:	84 81       	ldd	r24, Z+4	; 0x04
    908c:	95 81       	ldd	r25, Z+5	; 0x05
    908e:	13 96       	adiw	r26, 0x03	; 3
    9090:	9c 93       	st	X, r25
    9092:	8e 93       	st	-X, r24
    9094:	12 97       	sbiw	r26, 0x02	; 2
    9096:	ed 81       	ldd	r30, Y+5	; 0x05
    9098:	fe 81       	ldd	r31, Y+6	; 0x06
    909a:	21 81       	ldd	r18, Z+1	; 0x01
    909c:	32 81       	ldd	r19, Z+2	; 0x02
    909e:	89 85       	ldd	r24, Y+9	; 0x09
    90a0:	9a 85       	ldd	r25, Y+10	; 0x0a
    90a2:	02 96       	adiw	r24, 0x02	; 2
    90a4:	28 17       	cp	r18, r24
    90a6:	39 07       	cpc	r19, r25
    90a8:	41 f4       	brne	.+16     	; 0x90ba <vTaskGenericNotifyGiveFromISR+0x118>
    90aa:	e9 85       	ldd	r30, Y+9	; 0x09
    90ac:	fa 85       	ldd	r31, Y+10	; 0x0a
    90ae:	86 81       	ldd	r24, Z+6	; 0x06
    90b0:	97 81       	ldd	r25, Z+7	; 0x07
    90b2:	ed 81       	ldd	r30, Y+5	; 0x05
    90b4:	fe 81       	ldd	r31, Y+6	; 0x06
    90b6:	92 83       	std	Z+2, r25	; 0x02
    90b8:	81 83       	std	Z+1, r24	; 0x01
    90ba:	e9 85       	ldd	r30, Y+9	; 0x09
    90bc:	fa 85       	ldd	r31, Y+10	; 0x0a
    90be:	13 86       	std	Z+11, r1	; 0x0b
    90c0:	12 86       	std	Z+10, r1	; 0x0a
    90c2:	ed 81       	ldd	r30, Y+5	; 0x05
    90c4:	fe 81       	ldd	r31, Y+6	; 0x06
    90c6:	80 81       	ld	r24, Z
    90c8:	81 50       	subi	r24, 0x01	; 1
    90ca:	ed 81       	ldd	r30, Y+5	; 0x05
    90cc:	fe 81       	ldd	r31, Y+6	; 0x06
    90ce:	80 83       	st	Z, r24
                    prvAddTaskToReadyList( pxTCB );
    90d0:	e9 85       	ldd	r30, Y+9	; 0x09
    90d2:	fa 85       	ldd	r31, Y+10	; 0x0a
    90d4:	96 89       	ldd	r25, Z+22	; 0x16
    90d6:	80 91 a6 07 	lds	r24, 0x07A6
    90da:	89 17       	cp	r24, r25
    90dc:	28 f4       	brcc	.+10     	; 0x90e8 <vTaskGenericNotifyGiveFromISR+0x146>
    90de:	e9 85       	ldd	r30, Y+9	; 0x09
    90e0:	fa 85       	ldd	r31, Y+10	; 0x0a
    90e2:	86 89       	ldd	r24, Z+22	; 0x16
    90e4:	80 93 a6 07 	sts	0x07A6, r24
    90e8:	e9 85       	ldd	r30, Y+9	; 0x09
    90ea:	fa 85       	ldd	r31, Y+10	; 0x0a
    90ec:	86 89       	ldd	r24, Z+22	; 0x16
    90ee:	28 2f       	mov	r18, r24
    90f0:	30 e0       	ldi	r19, 0x00	; 0
    90f2:	c9 01       	movw	r24, r18
    90f4:	88 0f       	add	r24, r24
    90f6:	99 1f       	adc	r25, r25
    90f8:	88 0f       	add	r24, r24
    90fa:	99 1f       	adc	r25, r25
    90fc:	88 0f       	add	r24, r24
    90fe:	99 1f       	adc	r25, r25
    9100:	82 0f       	add	r24, r18
    9102:	93 1f       	adc	r25, r19
    9104:	fc 01       	movw	r30, r24
    9106:	ee 54       	subi	r30, 0x4E	; 78
    9108:	f8 4f       	sbci	r31, 0xF8	; 248
    910a:	81 81       	ldd	r24, Z+1	; 0x01
    910c:	92 81       	ldd	r25, Z+2	; 0x02
    910e:	9c 83       	std	Y+4, r25	; 0x04
    9110:	8b 83       	std	Y+3, r24	; 0x03
    9112:	e9 85       	ldd	r30, Y+9	; 0x09
    9114:	fa 85       	ldd	r31, Y+10	; 0x0a
    9116:	8b 81       	ldd	r24, Y+3	; 0x03
    9118:	9c 81       	ldd	r25, Y+4	; 0x04
    911a:	95 83       	std	Z+5, r25	; 0x05
    911c:	84 83       	std	Z+4, r24	; 0x04
    911e:	eb 81       	ldd	r30, Y+3	; 0x03
    9120:	fc 81       	ldd	r31, Y+4	; 0x04
    9122:	84 81       	ldd	r24, Z+4	; 0x04
    9124:	95 81       	ldd	r25, Z+5	; 0x05
    9126:	e9 85       	ldd	r30, Y+9	; 0x09
    9128:	fa 85       	ldd	r31, Y+10	; 0x0a
    912a:	97 83       	std	Z+7, r25	; 0x07
    912c:	86 83       	std	Z+6, r24	; 0x06
    912e:	eb 81       	ldd	r30, Y+3	; 0x03
    9130:	fc 81       	ldd	r31, Y+4	; 0x04
    9132:	04 80       	ldd	r0, Z+4	; 0x04
    9134:	f5 81       	ldd	r31, Z+5	; 0x05
    9136:	e0 2d       	mov	r30, r0
    9138:	89 85       	ldd	r24, Y+9	; 0x09
    913a:	9a 85       	ldd	r25, Y+10	; 0x0a
    913c:	02 96       	adiw	r24, 0x02	; 2
    913e:	93 83       	std	Z+3, r25	; 0x03
    9140:	82 83       	std	Z+2, r24	; 0x02
    9142:	89 85       	ldd	r24, Y+9	; 0x09
    9144:	9a 85       	ldd	r25, Y+10	; 0x0a
    9146:	02 96       	adiw	r24, 0x02	; 2
    9148:	eb 81       	ldd	r30, Y+3	; 0x03
    914a:	fc 81       	ldd	r31, Y+4	; 0x04
    914c:	95 83       	std	Z+5, r25	; 0x05
    914e:	84 83       	std	Z+4, r24	; 0x04
    9150:	e9 85       	ldd	r30, Y+9	; 0x09
    9152:	fa 85       	ldd	r31, Y+10	; 0x0a
    9154:	86 89       	ldd	r24, Z+22	; 0x16
    9156:	28 2f       	mov	r18, r24
    9158:	30 e0       	ldi	r19, 0x00	; 0
    915a:	c9 01       	movw	r24, r18
    915c:	88 0f       	add	r24, r24
    915e:	99 1f       	adc	r25, r25
    9160:	88 0f       	add	r24, r24
    9162:	99 1f       	adc	r25, r25
    9164:	88 0f       	add	r24, r24
    9166:	99 1f       	adc	r25, r25
    9168:	82 0f       	add	r24, r18
    916a:	93 1f       	adc	r25, r19
    916c:	8e 54       	subi	r24, 0x4E	; 78
    916e:	98 4f       	sbci	r25, 0xF8	; 248
    9170:	e9 85       	ldd	r30, Y+9	; 0x09
    9172:	fa 85       	ldd	r31, Y+10	; 0x0a
    9174:	93 87       	std	Z+11, r25	; 0x0b
    9176:	82 87       	std	Z+10, r24	; 0x0a
    9178:	e9 85       	ldd	r30, Y+9	; 0x09
    917a:	fa 85       	ldd	r31, Y+10	; 0x0a
    917c:	86 89       	ldd	r24, Z+22	; 0x16
    917e:	28 2f       	mov	r18, r24
    9180:	30 e0       	ldi	r19, 0x00	; 0
    9182:	c9 01       	movw	r24, r18
    9184:	88 0f       	add	r24, r24
    9186:	99 1f       	adc	r25, r25
    9188:	88 0f       	add	r24, r24
    918a:	99 1f       	adc	r25, r25
    918c:	88 0f       	add	r24, r24
    918e:	99 1f       	adc	r25, r25
    9190:	82 0f       	add	r24, r18
    9192:	93 1f       	adc	r25, r19
    9194:	fc 01       	movw	r30, r24
    9196:	ee 54       	subi	r30, 0x4E	; 78
    9198:	f8 4f       	sbci	r31, 0xF8	; 248
    919a:	80 81       	ld	r24, Z
    919c:	8f 5f       	subi	r24, 0xFF	; 255
    919e:	80 83       	st	Z, r24
    91a0:	30 c0       	rjmp	.+96     	; 0x9202 <vTaskGenericNotifyGiveFromISR+0x260>
                }
                else
                {
                    /* The delayed and ready lists cannot be accessed, so hold
                     * this task pending until the scheduler is resumed. */
                    listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    91a2:	80 91 ed 07 	lds	r24, 0x07ED
    91a6:	90 91 ee 07 	lds	r25, 0x07EE
    91aa:	9a 83       	std	Y+2, r25	; 0x02
    91ac:	89 83       	std	Y+1, r24	; 0x01
    91ae:	e9 85       	ldd	r30, Y+9	; 0x09
    91b0:	fa 85       	ldd	r31, Y+10	; 0x0a
    91b2:	89 81       	ldd	r24, Y+1	; 0x01
    91b4:	9a 81       	ldd	r25, Y+2	; 0x02
    91b6:	97 87       	std	Z+15, r25	; 0x0f
    91b8:	86 87       	std	Z+14, r24	; 0x0e
    91ba:	e9 81       	ldd	r30, Y+1	; 0x01
    91bc:	fa 81       	ldd	r31, Y+2	; 0x02
    91be:	84 81       	ldd	r24, Z+4	; 0x04
    91c0:	95 81       	ldd	r25, Z+5	; 0x05
    91c2:	e9 85       	ldd	r30, Y+9	; 0x09
    91c4:	fa 85       	ldd	r31, Y+10	; 0x0a
    91c6:	91 8b       	std	Z+17, r25	; 0x11
    91c8:	80 8b       	std	Z+16, r24	; 0x10
    91ca:	e9 81       	ldd	r30, Y+1	; 0x01
    91cc:	fa 81       	ldd	r31, Y+2	; 0x02
    91ce:	04 80       	ldd	r0, Z+4	; 0x04
    91d0:	f5 81       	ldd	r31, Z+5	; 0x05
    91d2:	e0 2d       	mov	r30, r0
    91d4:	89 85       	ldd	r24, Y+9	; 0x09
    91d6:	9a 85       	ldd	r25, Y+10	; 0x0a
    91d8:	0c 96       	adiw	r24, 0x0c	; 12
    91da:	93 83       	std	Z+3, r25	; 0x03
    91dc:	82 83       	std	Z+2, r24	; 0x02
    91de:	89 85       	ldd	r24, Y+9	; 0x09
    91e0:	9a 85       	ldd	r25, Y+10	; 0x0a
    91e2:	0c 96       	adiw	r24, 0x0c	; 12
    91e4:	e9 81       	ldd	r30, Y+1	; 0x01
    91e6:	fa 81       	ldd	r31, Y+2	; 0x02
    91e8:	95 83       	std	Z+5, r25	; 0x05
    91ea:	84 83       	std	Z+4, r24	; 0x04
    91ec:	e9 85       	ldd	r30, Y+9	; 0x09
    91ee:	fa 85       	ldd	r31, Y+10	; 0x0a
    91f0:	8c ee       	ldi	r24, 0xEC	; 236
    91f2:	97 e0       	ldi	r25, 0x07	; 7
    91f4:	95 8b       	std	Z+21, r25	; 0x15
    91f6:	84 8b       	std	Z+20, r24	; 0x14
    91f8:	80 91 ec 07 	lds	r24, 0x07EC
    91fc:	8f 5f       	subi	r24, 0xFF	; 255
    91fe:	80 93 ec 07 	sts	0x07EC, r24
                }

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    9202:	e9 85       	ldd	r30, Y+9	; 0x09
    9204:	fa 85       	ldd	r31, Y+10	; 0x0a
    9206:	96 89       	ldd	r25, Z+22	; 0x16
    9208:	e0 91 a0 07 	lds	r30, 0x07A0
    920c:	f0 91 a1 07 	lds	r31, 0x07A1
    9210:	86 89       	ldd	r24, Z+22	; 0x16
    9212:	89 17       	cp	r24, r25
    9214:	58 f4       	brcc	.+22     	; 0x922c <vTaskGenericNotifyGiveFromISR+0x28a>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    if( pxHigherPriorityTaskWoken != NULL )
    9216:	8e 85       	ldd	r24, Y+14	; 0x0e
    9218:	9f 85       	ldd	r25, Y+15	; 0x0f
    921a:	00 97       	sbiw	r24, 0x00	; 0
    921c:	21 f0       	breq	.+8      	; 0x9226 <vTaskGenericNotifyGiveFromISR+0x284>
                    {
                        *pxHigherPriorityTaskWoken = pdTRUE;
    921e:	ee 85       	ldd	r30, Y+14	; 0x0e
    9220:	ff 85       	ldd	r31, Y+15	; 0x0f
    9222:	81 e0       	ldi	r24, 0x01	; 1
    9224:	80 83       	st	Z, r24
                    }

                    /* Mark that a yield is pending in case the user is not
                     * using the "xHigherPriorityTaskWoken" parameter in an ISR
                     * safe FreeRTOS function. */
                    xYieldPending = pdTRUE;
    9226:	81 e0       	ldi	r24, 0x01	; 1
    9228:	80 93 aa 07 	sts	0x07AA, r24
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
    }
    922c:	2f 96       	adiw	r28, 0x0f	; 15
    922e:	0f b6       	in	r0, 0x3f	; 63
    9230:	f8 94       	cli
    9232:	de bf       	out	0x3e, r29	; 62
    9234:	0f be       	out	0x3f, r0	; 63
    9236:	cd bf       	out	0x3d, r28	; 61
    9238:	cf 91       	pop	r28
    923a:	df 91       	pop	r29
    923c:	1f 91       	pop	r17
    923e:	0f 91       	pop	r16
    9240:	08 95       	ret

00009242 <xTaskGenericNotifyStateClear>:

#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    BaseType_t xTaskGenericNotifyStateClear( TaskHandle_t xTask,
                                             UBaseType_t uxIndexToClear )
    {
    9242:	df 93       	push	r29
    9244:	cf 93       	push	r28
    9246:	cd b7       	in	r28, 0x3d	; 61
    9248:	de b7       	in	r29, 0x3e	; 62
    924a:	28 97       	sbiw	r28, 0x08	; 8
    924c:	0f b6       	in	r0, 0x3f	; 63
    924e:	f8 94       	cli
    9250:	de bf       	out	0x3e, r29	; 62
    9252:	0f be       	out	0x3f, r0	; 63
    9254:	cd bf       	out	0x3d, r28	; 61
    9256:	9d 83       	std	Y+5, r25	; 0x05
    9258:	8c 83       	std	Y+4, r24	; 0x04
    925a:	6e 83       	std	Y+6, r22	; 0x06

        configASSERT( uxIndexToClear < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        /* If null is passed in here then it is the calling task that is having
         * its notification state cleared. */
        pxTCB = prvGetTCBFromHandle( xTask );
    925c:	8c 81       	ldd	r24, Y+4	; 0x04
    925e:	9d 81       	ldd	r25, Y+5	; 0x05
    9260:	00 97       	sbiw	r24, 0x00	; 0
    9262:	39 f4       	brne	.+14     	; 0x9272 <xTaskGenericNotifyStateClear+0x30>
    9264:	80 91 a0 07 	lds	r24, 0x07A0
    9268:	90 91 a1 07 	lds	r25, 0x07A1
    926c:	98 87       	std	Y+8, r25	; 0x08
    926e:	8f 83       	std	Y+7, r24	; 0x07
    9270:	04 c0       	rjmp	.+8      	; 0x927a <xTaskGenericNotifyStateClear+0x38>
    9272:	8c 81       	ldd	r24, Y+4	; 0x04
    9274:	9d 81       	ldd	r25, Y+5	; 0x05
    9276:	98 87       	std	Y+8, r25	; 0x08
    9278:	8f 83       	std	Y+7, r24	; 0x07
    927a:	8f 81       	ldd	r24, Y+7	; 0x07
    927c:	98 85       	ldd	r25, Y+8	; 0x08
    927e:	9b 83       	std	Y+3, r25	; 0x03
    9280:	8a 83       	std	Y+2, r24	; 0x02

        taskENTER_CRITICAL();
    9282:	0f b6       	in	r0, 0x3f	; 63
    9284:	f8 94       	cli
    9286:	0f 92       	push	r0
        {
            if( pxTCB->ucNotifyState[ uxIndexToClear ] == taskNOTIFICATION_RECEIVED )
    9288:	8e 81       	ldd	r24, Y+6	; 0x06
    928a:	28 2f       	mov	r18, r24
    928c:	30 e0       	ldi	r19, 0x00	; 0
    928e:	8a 81       	ldd	r24, Y+2	; 0x02
    9290:	9b 81       	ldd	r25, Y+3	; 0x03
    9292:	82 0f       	add	r24, r18
    9294:	93 1f       	adc	r25, r19
    9296:	fc 01       	movw	r30, r24
    9298:	b7 96       	adiw	r30, 0x27	; 39
    929a:	80 81       	ld	r24, Z
    929c:	82 30       	cpi	r24, 0x02	; 2
    929e:	69 f4       	brne	.+26     	; 0x92ba <xTaskGenericNotifyStateClear+0x78>
            {
                pxTCB->ucNotifyState[ uxIndexToClear ] = taskNOT_WAITING_NOTIFICATION;
    92a0:	8e 81       	ldd	r24, Y+6	; 0x06
    92a2:	28 2f       	mov	r18, r24
    92a4:	30 e0       	ldi	r19, 0x00	; 0
    92a6:	8a 81       	ldd	r24, Y+2	; 0x02
    92a8:	9b 81       	ldd	r25, Y+3	; 0x03
    92aa:	82 0f       	add	r24, r18
    92ac:	93 1f       	adc	r25, r19
    92ae:	fc 01       	movw	r30, r24
    92b0:	b7 96       	adiw	r30, 0x27	; 39
    92b2:	10 82       	st	Z, r1
                xReturn = pdPASS;
    92b4:	81 e0       	ldi	r24, 0x01	; 1
    92b6:	89 83       	std	Y+1, r24	; 0x01
    92b8:	01 c0       	rjmp	.+2      	; 0x92bc <xTaskGenericNotifyStateClear+0x7a>
            }
            else
            {
                xReturn = pdFAIL;
    92ba:	19 82       	std	Y+1, r1	; 0x01
            }
        }
        taskEXIT_CRITICAL();
    92bc:	0f 90       	pop	r0
    92be:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    92c0:	89 81       	ldd	r24, Y+1	; 0x01
    }
    92c2:	28 96       	adiw	r28, 0x08	; 8
    92c4:	0f b6       	in	r0, 0x3f	; 63
    92c6:	f8 94       	cli
    92c8:	de bf       	out	0x3e, r29	; 62
    92ca:	0f be       	out	0x3f, r0	; 63
    92cc:	cd bf       	out	0x3d, r28	; 61
    92ce:	cf 91       	pop	r28
    92d0:	df 91       	pop	r29
    92d2:	08 95       	ret

000092d4 <ulTaskGenericNotifyValueClear>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    uint32_t ulTaskGenericNotifyValueClear( TaskHandle_t xTask,
                                            UBaseType_t uxIndexToClear,
                                            uint32_t ulBitsToClear )
    {
    92d4:	0f 93       	push	r16
    92d6:	1f 93       	push	r17
    92d8:	df 93       	push	r29
    92da:	cf 93       	push	r28
    92dc:	cd b7       	in	r28, 0x3d	; 61
    92de:	de b7       	in	r29, 0x3e	; 62
    92e0:	2f 97       	sbiw	r28, 0x0f	; 15
    92e2:	0f b6       	in	r0, 0x3f	; 63
    92e4:	f8 94       	cli
    92e6:	de bf       	out	0x3e, r29	; 62
    92e8:	0f be       	out	0x3f, r0	; 63
    92ea:	cd bf       	out	0x3d, r28	; 61
    92ec:	98 87       	std	Y+8, r25	; 0x08
    92ee:	8f 83       	std	Y+7, r24	; 0x07
    92f0:	69 87       	std	Y+9, r22	; 0x09
    92f2:	2a 87       	std	Y+10, r18	; 0x0a
    92f4:	3b 87       	std	Y+11, r19	; 0x0b
    92f6:	4c 87       	std	Y+12, r20	; 0x0c
    92f8:	5d 87       	std	Y+13, r21	; 0x0d
        TCB_t * pxTCB;
        uint32_t ulReturn;

        /* If null is passed in here then it is the calling task that is having
         * its notification state cleared. */
        pxTCB = prvGetTCBFromHandle( xTask );
    92fa:	8f 81       	ldd	r24, Y+7	; 0x07
    92fc:	98 85       	ldd	r25, Y+8	; 0x08
    92fe:	00 97       	sbiw	r24, 0x00	; 0
    9300:	39 f4       	brne	.+14     	; 0x9310 <ulTaskGenericNotifyValueClear+0x3c>
    9302:	80 91 a0 07 	lds	r24, 0x07A0
    9306:	90 91 a1 07 	lds	r25, 0x07A1
    930a:	9f 87       	std	Y+15, r25	; 0x0f
    930c:	8e 87       	std	Y+14, r24	; 0x0e
    930e:	04 c0       	rjmp	.+8      	; 0x9318 <ulTaskGenericNotifyValueClear+0x44>
    9310:	8f 81       	ldd	r24, Y+7	; 0x07
    9312:	98 85       	ldd	r25, Y+8	; 0x08
    9314:	9f 87       	std	Y+15, r25	; 0x0f
    9316:	8e 87       	std	Y+14, r24	; 0x0e
    9318:	8e 85       	ldd	r24, Y+14	; 0x0e
    931a:	9f 85       	ldd	r25, Y+15	; 0x0f
    931c:	9e 83       	std	Y+6, r25	; 0x06
    931e:	8d 83       	std	Y+5, r24	; 0x05

        taskENTER_CRITICAL();
    9320:	0f b6       	in	r0, 0x3f	; 63
    9322:	f8 94       	cli
    9324:	0f 92       	push	r0
        {
            /* Return the notification as it was before the bits were cleared,
             * then clear the bit mask. */
            ulReturn = pxTCB->ulNotifiedValue[ uxIndexToClear ];
    9326:	89 85       	ldd	r24, Y+9	; 0x09
    9328:	88 2f       	mov	r24, r24
    932a:	90 e0       	ldi	r25, 0x00	; 0
    932c:	2d 81       	ldd	r18, Y+5	; 0x05
    932e:	3e 81       	ldd	r19, Y+6	; 0x06
    9330:	88 0f       	add	r24, r24
    9332:	99 1f       	adc	r25, r25
    9334:	88 0f       	add	r24, r24
    9336:	99 1f       	adc	r25, r25
    9338:	82 0f       	add	r24, r18
    933a:	93 1f       	adc	r25, r19
    933c:	fc 01       	movw	r30, r24
    933e:	b3 96       	adiw	r30, 0x23	; 35
    9340:	80 81       	ld	r24, Z
    9342:	91 81       	ldd	r25, Z+1	; 0x01
    9344:	a2 81       	ldd	r26, Z+2	; 0x02
    9346:	b3 81       	ldd	r27, Z+3	; 0x03
    9348:	89 83       	std	Y+1, r24	; 0x01
    934a:	9a 83       	std	Y+2, r25	; 0x02
    934c:	ab 83       	std	Y+3, r26	; 0x03
    934e:	bc 83       	std	Y+4, r27	; 0x04
            pxTCB->ulNotifiedValue[ uxIndexToClear ] &= ~ulBitsToClear;
    9350:	89 85       	ldd	r24, Y+9	; 0x09
    9352:	08 2f       	mov	r16, r24
    9354:	10 e0       	ldi	r17, 0x00	; 0
    9356:	89 85       	ldd	r24, Y+9	; 0x09
    9358:	88 2f       	mov	r24, r24
    935a:	90 e0       	ldi	r25, 0x00	; 0
    935c:	2d 81       	ldd	r18, Y+5	; 0x05
    935e:	3e 81       	ldd	r19, Y+6	; 0x06
    9360:	88 0f       	add	r24, r24
    9362:	99 1f       	adc	r25, r25
    9364:	88 0f       	add	r24, r24
    9366:	99 1f       	adc	r25, r25
    9368:	82 0f       	add	r24, r18
    936a:	93 1f       	adc	r25, r19
    936c:	fc 01       	movw	r30, r24
    936e:	b3 96       	adiw	r30, 0x23	; 35
    9370:	20 81       	ld	r18, Z
    9372:	31 81       	ldd	r19, Z+1	; 0x01
    9374:	42 81       	ldd	r20, Z+2	; 0x02
    9376:	53 81       	ldd	r21, Z+3	; 0x03
    9378:	8a 85       	ldd	r24, Y+10	; 0x0a
    937a:	9b 85       	ldd	r25, Y+11	; 0x0b
    937c:	ac 85       	ldd	r26, Y+12	; 0x0c
    937e:	bd 85       	ldd	r27, Y+13	; 0x0d
    9380:	80 95       	com	r24
    9382:	90 95       	com	r25
    9384:	a0 95       	com	r26
    9386:	b0 95       	com	r27
    9388:	ba 01       	movw	r22, r20
    938a:	a9 01       	movw	r20, r18
    938c:	48 23       	and	r20, r24
    938e:	59 23       	and	r21, r25
    9390:	6a 23       	and	r22, r26
    9392:	7b 23       	and	r23, r27
    9394:	2d 81       	ldd	r18, Y+5	; 0x05
    9396:	3e 81       	ldd	r19, Y+6	; 0x06
    9398:	c8 01       	movw	r24, r16
    939a:	88 0f       	add	r24, r24
    939c:	99 1f       	adc	r25, r25
    939e:	88 0f       	add	r24, r24
    93a0:	99 1f       	adc	r25, r25
    93a2:	82 0f       	add	r24, r18
    93a4:	93 1f       	adc	r25, r19
    93a6:	fc 01       	movw	r30, r24
    93a8:	b3 96       	adiw	r30, 0x23	; 35
    93aa:	40 83       	st	Z, r20
    93ac:	51 83       	std	Z+1, r21	; 0x01
    93ae:	62 83       	std	Z+2, r22	; 0x02
    93b0:	73 83       	std	Z+3, r23	; 0x03
        }
        taskEXIT_CRITICAL();
    93b2:	0f 90       	pop	r0
    93b4:	0f be       	out	0x3f, r0	; 63

        return ulReturn;
    93b6:	89 81       	ldd	r24, Y+1	; 0x01
    93b8:	9a 81       	ldd	r25, Y+2	; 0x02
    93ba:	ab 81       	ldd	r26, Y+3	; 0x03
    93bc:	bc 81       	ldd	r27, Y+4	; 0x04
    }
    93be:	bc 01       	movw	r22, r24
    93c0:	cd 01       	movw	r24, r26
    93c2:	2f 96       	adiw	r28, 0x0f	; 15
    93c4:	0f b6       	in	r0, 0x3f	; 63
    93c6:	f8 94       	cli
    93c8:	de bf       	out	0x3e, r29	; 62
    93ca:	0f be       	out	0x3f, r0	; 63
    93cc:	cd bf       	out	0x3d, r28	; 61
    93ce:	cf 91       	pop	r28
    93d0:	df 91       	pop	r29
    93d2:	1f 91       	pop	r17
    93d4:	0f 91       	pop	r16
    93d6:	08 95       	ret

000093d8 <prvAddCurrentTaskToDelayedList>:
#endif
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait,
                                            const BaseType_t xCanBlockIndefinitely )
{
    93d8:	df 93       	push	r29
    93da:	cf 93       	push	r28
    93dc:	cd b7       	in	r28, 0x3d	; 61
    93de:	de b7       	in	r29, 0x3e	; 62
    93e0:	27 97       	sbiw	r28, 0x07	; 7
    93e2:	0f b6       	in	r0, 0x3f	; 63
    93e4:	f8 94       	cli
    93e6:	de bf       	out	0x3e, r29	; 62
    93e8:	0f be       	out	0x3f, r0	; 63
    93ea:	cd bf       	out	0x3d, r28	; 61
    93ec:	9e 83       	std	Y+6, r25	; 0x06
    93ee:	8d 83       	std	Y+5, r24	; 0x05
    93f0:	6f 83       	std	Y+7, r22	; 0x07
    TickType_t xTimeToWake;
    const TickType_t xConstTickCount = xTickCount;
    93f2:	80 91 a4 07 	lds	r24, 0x07A4
    93f6:	90 91 a5 07 	lds	r25, 0x07A5
    93fa:	9a 83       	std	Y+2, r25	; 0x02
    93fc:	89 83       	std	Y+1, r24	; 0x01
        }
    #endif

    /* Remove the task from the ready list before adding it to the blocked list
     * as the same list item is used for both lists. */
    if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    93fe:	80 91 a0 07 	lds	r24, 0x07A0
    9402:	90 91 a1 07 	lds	r25, 0x07A1
    9406:	02 96       	adiw	r24, 0x02	; 2
    9408:	0e 94 7c 1f 	call	0x3ef8	; 0x3ef8 <uxListRemove>
    #else /* INCLUDE_vTaskSuspend */
        {
            /* Calculate the time at which the task should be woken if the event
             * does not occur.  This may overflow but this doesn't matter, the kernel
             * will manage it correctly. */
            xTimeToWake = xConstTickCount + xTicksToWait;
    940c:	29 81       	ldd	r18, Y+1	; 0x01
    940e:	3a 81       	ldd	r19, Y+2	; 0x02
    9410:	8d 81       	ldd	r24, Y+5	; 0x05
    9412:	9e 81       	ldd	r25, Y+6	; 0x06
    9414:	82 0f       	add	r24, r18
    9416:	93 1f       	adc	r25, r19
    9418:	9c 83       	std	Y+4, r25	; 0x04
    941a:	8b 83       	std	Y+3, r24	; 0x03

            /* The list item will be inserted in wake time order. */
            listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    941c:	e0 91 a0 07 	lds	r30, 0x07A0
    9420:	f0 91 a1 07 	lds	r31, 0x07A1
    9424:	8b 81       	ldd	r24, Y+3	; 0x03
    9426:	9c 81       	ldd	r25, Y+4	; 0x04
    9428:	93 83       	std	Z+3, r25	; 0x03
    942a:	82 83       	std	Z+2, r24	; 0x02

            if( xTimeToWake < xConstTickCount )
    942c:	2b 81       	ldd	r18, Y+3	; 0x03
    942e:	3c 81       	ldd	r19, Y+4	; 0x04
    9430:	89 81       	ldd	r24, Y+1	; 0x01
    9432:	9a 81       	ldd	r25, Y+2	; 0x02
    9434:	28 17       	cp	r18, r24
    9436:	39 07       	cpc	r19, r25
    9438:	70 f4       	brcc	.+28     	; 0x9456 <prvAddCurrentTaskToDelayedList+0x7e>
            {
                /* Wake time has overflowed.  Place this item in the overflow list. */
                vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    943a:	80 91 ea 07 	lds	r24, 0x07EA
    943e:	90 91 eb 07 	lds	r25, 0x07EB
    9442:	20 91 a0 07 	lds	r18, 0x07A0
    9446:	30 91 a1 07 	lds	r19, 0x07A1
    944a:	2e 5f       	subi	r18, 0xFE	; 254
    944c:	3f 4f       	sbci	r19, 0xFF	; 255
    944e:	b9 01       	movw	r22, r18
    9450:	0e 94 10 1f 	call	0x3e20	; 0x3e20 <vListInsert>
    9454:	1e c0       	rjmp	.+60     	; 0x9492 <prvAddCurrentTaskToDelayedList+0xba>
            }
            else
            {
                /* The wake time has not overflowed, so the current block list is used. */
                vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    9456:	40 91 e8 07 	lds	r20, 0x07E8
    945a:	50 91 e9 07 	lds	r21, 0x07E9
    945e:	80 91 a0 07 	lds	r24, 0x07A0
    9462:	90 91 a1 07 	lds	r25, 0x07A1
    9466:	9c 01       	movw	r18, r24
    9468:	2e 5f       	subi	r18, 0xFE	; 254
    946a:	3f 4f       	sbci	r19, 0xFF	; 255
    946c:	ca 01       	movw	r24, r20
    946e:	b9 01       	movw	r22, r18
    9470:	0e 94 10 1f 	call	0x3e20	; 0x3e20 <vListInsert>

                /* If the task entering the blocked state was placed at the head of the
                 * list of blocked tasks then xNextTaskUnblockTime needs to be updated
                 * too. */
                if( xTimeToWake < xNextTaskUnblockTime )
    9474:	20 91 ad 07 	lds	r18, 0x07AD
    9478:	30 91 ae 07 	lds	r19, 0x07AE
    947c:	8b 81       	ldd	r24, Y+3	; 0x03
    947e:	9c 81       	ldd	r25, Y+4	; 0x04
    9480:	82 17       	cp	r24, r18
    9482:	93 07       	cpc	r25, r19
    9484:	30 f4       	brcc	.+12     	; 0x9492 <prvAddCurrentTaskToDelayedList+0xba>
                {
                    xNextTaskUnblockTime = xTimeToWake;
    9486:	8b 81       	ldd	r24, Y+3	; 0x03
    9488:	9c 81       	ldd	r25, Y+4	; 0x04
    948a:	90 93 ae 07 	sts	0x07AE, r25
    948e:	80 93 ad 07 	sts	0x07AD, r24

            /* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
            ( void ) xCanBlockIndefinitely;
        }
    #endif /* INCLUDE_vTaskSuspend */
}
    9492:	27 96       	adiw	r28, 0x07	; 7
    9494:	0f b6       	in	r0, 0x3f	; 63
    9496:	f8 94       	cli
    9498:	de bf       	out	0x3e, r29	; 62
    949a:	0f be       	out	0x3f, r0	; 63
    949c:	cd bf       	out	0x3d, r28	; 61
    949e:	cf 91       	pop	r28
    94a0:	df 91       	pop	r29
    94a2:	08 95       	ret

000094a4 <main>:

void USART_Receive_ISR(void);



int main(void){
    94a4:	ef 92       	push	r14
    94a6:	ff 92       	push	r15
    94a8:	0f 93       	push	r16
    94aa:	df 93       	push	r29
    94ac:	cf 93       	push	r28
    94ae:	cd b7       	in	r28, 0x3d	; 61
    94b0:	de b7       	in	r29, 0x3e	; 62

	/*ADXL Initialization*/
	ADXL_init();
    94b2:	0e 94 ea 16 	call	0x2dd4	; 0x2dd4 <ADXL_init>

	/*Button Initialization*/
	MDIO_Error_State_SetPinDirection(PIN1,MDIO_PORTB,PIN_INPUT);
    94b6:	81 e0       	ldi	r24, 0x01	; 1
    94b8:	61 e0       	ldi	r22, 0x01	; 1
    94ba:	40 e0       	ldi	r20, 0x00	; 0
    94bc:	0e 94 8f 08 	call	0x111e	; 0x111e <MDIO_Error_State_SetPinDirection>

	/*Buzzer Initialization*/
	MDIO_Error_State_SetPinDirection(PIN0,MDIO_PORTB,PIN_OUTPUT);
    94c0:	80 e0       	ldi	r24, 0x00	; 0
    94c2:	61 e0       	ldi	r22, 0x01	; 1
    94c4:	41 e0       	ldi	r20, 0x01	; 1
    94c6:	0e 94 8f 08 	call	0x111e	; 0x111e <MDIO_Error_State_SetPinDirection>

	/* TX and RX pins initialization */
	MDIO_Error_State_SetPinDirection(PIN0,MDIO_PORTD,PIN_INPUT);
    94ca:	80 e0       	ldi	r24, 0x00	; 0
    94cc:	63 e0       	ldi	r22, 0x03	; 3
    94ce:	40 e0       	ldi	r20, 0x00	; 0
    94d0:	0e 94 8f 08 	call	0x111e	; 0x111e <MDIO_Error_State_SetPinDirection>
	MDIO_Error_State_SetPinDirection(PIN1,MDIO_PORTD,PIN_OUTPUT);
    94d4:	81 e0       	ldi	r24, 0x01	; 1
    94d6:	63 e0       	ldi	r22, 0x03	; 3
    94d8:	41 e0       	ldi	r20, 0x01	; 1
    94da:	0e 94 8f 08 	call	0x111e	; 0x111e <MDIO_Error_State_SetPinDirection>

	/*UART Initialization*/
	MUSART_VidInit();
    94de:	0e 94 2c 07 	call	0xe58	; 0xe58 <MUSART_VidInit>
	/*Set uart call back function*/
	MUSART_VidSetCallBack(USART_Receive_ISR);
    94e2:	84 ee       	ldi	r24, 0xE4	; 228
    94e4:	9a e4       	ldi	r25, 0x4A	; 74
    94e6:	0e 94 f6 07 	call	0xfec	; 0xfec <MUSART_VidSetCallBack>

	/*UART Interrupt receive enable*/
	MUSART_VidUSART_Receive_Interrupt_Enable();
    94ea:	0e 94 e8 07 	call	0xfd0	; 0xfd0 <MUSART_VidUSART_Receive_Interrupt_Enable>
	/*Enable to GI*/
	MGIE_VidEnable();
    94ee:	0e 94 73 08 	call	0x10e6	; 0x10e6 <MGIE_VidEnable>


	/*Create Semaphors*/

	vSemaphoreCreateBinary(EnabelSem);
    94f2:	81 e0       	ldi	r24, 0x01	; 1
    94f4:	60 e0       	ldi	r22, 0x00	; 0
    94f6:	43 e0       	ldi	r20, 0x03	; 3
    94f8:	0e 94 47 23 	call	0x468e	; 0x468e <xQueueGenericCreate>
    94fc:	90 93 11 08 	sts	0x0811, r25
    9500:	80 93 10 08 	sts	0x0810, r24
    9504:	80 91 10 08 	lds	r24, 0x0810
    9508:	90 91 11 08 	lds	r25, 0x0811
    950c:	00 97       	sbiw	r24, 0x00	; 0
    950e:	59 f0       	breq	.+22     	; 0x9526 <main+0x82>
    9510:	80 91 10 08 	lds	r24, 0x0810
    9514:	90 91 11 08 	lds	r25, 0x0811
    9518:	60 e0       	ldi	r22, 0x00	; 0
    951a:	70 e0       	ldi	r23, 0x00	; 0
    951c:	40 e0       	ldi	r20, 0x00	; 0
    951e:	50 e0       	ldi	r21, 0x00	; 0
    9520:	20 e0       	ldi	r18, 0x00	; 0
    9522:	0e 94 63 24 	call	0x48c6	; 0x48c6 <xQueueGenericSend>
	vSemaphoreCreateBinary(FlagAlarmSem);
    9526:	81 e0       	ldi	r24, 0x01	; 1
    9528:	60 e0       	ldi	r22, 0x00	; 0
    952a:	43 e0       	ldi	r20, 0x03	; 3
    952c:	0e 94 47 23 	call	0x468e	; 0x468e <xQueueGenericCreate>
    9530:	90 93 05 08 	sts	0x0805, r25
    9534:	80 93 04 08 	sts	0x0804, r24
    9538:	80 91 04 08 	lds	r24, 0x0804
    953c:	90 91 05 08 	lds	r25, 0x0805
    9540:	00 97       	sbiw	r24, 0x00	; 0
    9542:	59 f0       	breq	.+22     	; 0x955a <main+0xb6>
    9544:	80 91 04 08 	lds	r24, 0x0804
    9548:	90 91 05 08 	lds	r25, 0x0805
    954c:	60 e0       	ldi	r22, 0x00	; 0
    954e:	70 e0       	ldi	r23, 0x00	; 0
    9550:	40 e0       	ldi	r20, 0x00	; 0
    9552:	50 e0       	ldi	r21, 0x00	; 0
    9554:	20 e0       	ldi	r18, 0x00	; 0
    9556:	0e 94 63 24 	call	0x48c6	; 0x48c6 <xQueueGenericSend>

	/*Create Taskes*/
	xTaskCreate(APP_Disable_System,NULL,100,NULL,0,NULL);
    955a:	82 ee       	ldi	r24, 0xE2	; 226
    955c:	9b e4       	ldi	r25, 0x4B	; 75
    955e:	60 e0       	ldi	r22, 0x00	; 0
    9560:	70 e0       	ldi	r23, 0x00	; 0
    9562:	44 e6       	ldi	r20, 0x64	; 100
    9564:	50 e0       	ldi	r21, 0x00	; 0
    9566:	20 e0       	ldi	r18, 0x00	; 0
    9568:	30 e0       	ldi	r19, 0x00	; 0
    956a:	00 e0       	ldi	r16, 0x00	; 0
    956c:	ee 24       	eor	r14, r14
    956e:	ff 24       	eor	r15, r15
    9570:	0e 94 46 34 	call	0x688c	; 0x688c <xTaskCreate>

	xTaskCreate(APP_ADXL,NULL,100,NULL,1,NULL);
    9574:	8d e4       	ldi	r24, 0x4D	; 77
    9576:	9b e4       	ldi	r25, 0x4B	; 75
    9578:	60 e0       	ldi	r22, 0x00	; 0
    957a:	70 e0       	ldi	r23, 0x00	; 0
    957c:	44 e6       	ldi	r20, 0x64	; 100
    957e:	50 e0       	ldi	r21, 0x00	; 0
    9580:	20 e0       	ldi	r18, 0x00	; 0
    9582:	30 e0       	ldi	r19, 0x00	; 0
    9584:	01 e0       	ldi	r16, 0x01	; 1
    9586:	ee 24       	eor	r14, r14
    9588:	ff 24       	eor	r15, r15
    958a:	0e 94 46 34 	call	0x688c	; 0x688c <xTaskCreate>

	xTaskCreate(APP_Alarm,NULL,100,NULL,2,NULL);
    958e:	80 ec       	ldi	r24, 0xC0	; 192
    9590:	9b e4       	ldi	r25, 0x4B	; 75
    9592:	60 e0       	ldi	r22, 0x00	; 0
    9594:	70 e0       	ldi	r23, 0x00	; 0
    9596:	44 e6       	ldi	r20, 0x64	; 100
    9598:	50 e0       	ldi	r21, 0x00	; 0
    959a:	20 e0       	ldi	r18, 0x00	; 0
    959c:	30 e0       	ldi	r19, 0x00	; 0
    959e:	02 e0       	ldi	r16, 0x02	; 2
    95a0:	ee 24       	eor	r14, r14
    95a2:	ff 24       	eor	r15, r15
    95a4:	0e 94 46 34 	call	0x688c	; 0x688c <xTaskCreate>

	xTaskCreate(APP_Enable_System,NULL,100,NULL,3,NULL);
    95a8:	8a e0       	ldi	r24, 0x0A	; 10
    95aa:	9b e4       	ldi	r25, 0x4B	; 75
    95ac:	60 e0       	ldi	r22, 0x00	; 0
    95ae:	70 e0       	ldi	r23, 0x00	; 0
    95b0:	44 e6       	ldi	r20, 0x64	; 100
    95b2:	50 e0       	ldi	r21, 0x00	; 0
    95b4:	20 e0       	ldi	r18, 0x00	; 0
    95b6:	30 e0       	ldi	r19, 0x00	; 0
    95b8:	03 e0       	ldi	r16, 0x03	; 3
    95ba:	ee 24       	eor	r14, r14
    95bc:	ff 24       	eor	r15, r15
    95be:	0e 94 46 34 	call	0x688c	; 0x688c <xTaskCreate>


	/*Start Scheduler*/

	vTaskStartScheduler();
    95c2:	0e 94 4e 37 	call	0x6e9c	; 0x6e9c <vTaskStartScheduler>
    95c6:	ff cf       	rjmp	.-2      	; 0x95c6 <main+0x122>

000095c8 <USART_Receive_ISR>:




void USART_Receive_ISR(void)
{
    95c8:	df 93       	push	r29
    95ca:	cf 93       	push	r28
    95cc:	cd b7       	in	r28, 0x3d	; 61
    95ce:	de b7       	in	r29, 0x3e	; 62
	MUSART_VidReceiveString(UART_REC_Buffer);
    95d0:	86 e0       	ldi	r24, 0x06	; 6
    95d2:	98 e0       	ldi	r25, 0x08	; 8
    95d4:	0e 94 ba 07 	call	0xf74	; 0xf74 <MUSART_VidReceiveString>

	if(MUSART_u8CompareString(UART_REC_Buffer , "start"))
    95d8:	86 e0       	ldi	r24, 0x06	; 6
    95da:	98 e0       	ldi	r25, 0x08	; 8
    95dc:	25 e6       	ldi	r18, 0x65	; 101
    95de:	30 e0       	ldi	r19, 0x00	; 0
    95e0:	b9 01       	movw	r22, r18
    95e2:	0e 94 35 08 	call	0x106a	; 0x106a <MUSART_u8CompareString>
    95e6:	88 23       	and	r24, r24
    95e8:	31 f0       	breq	.+12     	; 0x95f6 <USART_Receive_ISR+0x2e>
	{
		StartFlag=1;
    95ea:	81 e0       	ldi	r24, 0x01	; 1
    95ec:	80 93 fe 07 	sts	0x07FE, r24
		StopFlag=0;
    95f0:	10 92 ff 07 	sts	0x07FF, r1
    95f4:	0c c0       	rjmp	.+24     	; 0x960e <USART_Receive_ISR+0x46>

	}
	else if(MUSART_u8CompareString(UART_REC_Buffer , "stop"))
    95f6:	86 e0       	ldi	r24, 0x06	; 6
    95f8:	98 e0       	ldi	r25, 0x08	; 8
    95fa:	2b e6       	ldi	r18, 0x6B	; 107
    95fc:	30 e0       	ldi	r19, 0x00	; 0
    95fe:	b9 01       	movw	r22, r18
    9600:	0e 94 35 08 	call	0x106a	; 0x106a <MUSART_u8CompareString>
    9604:	88 23       	and	r24, r24
    9606:	19 f0       	breq	.+6      	; 0x960e <USART_Receive_ISR+0x46>
	{
		StopFlag=1;
    9608:	81 e0       	ldi	r24, 0x01	; 1
    960a:	80 93 ff 07 	sts	0x07FF, r24
	}
}
    960e:	cf 91       	pop	r28
    9610:	df 91       	pop	r29
    9612:	08 95       	ret

00009614 <APP_Enable_System>:

void APP_Enable_System(void *pv)
{
    9614:	df 93       	push	r29
    9616:	cf 93       	push	r28
    9618:	00 d0       	rcall	.+0      	; 0x961a <APP_Enable_System+0x6>
    961a:	00 d0       	rcall	.+0      	; 0x961c <APP_Enable_System+0x8>
    961c:	cd b7       	in	r28, 0x3d	; 61
    961e:	de b7       	in	r29, 0x3e	; 62
    9620:	9c 83       	std	Y+4, r25	; 0x04
    9622:	8b 83       	std	Y+3, r24	; 0x03
	u8 ButtonState;
	u8 Loc_SemStartState;

	while(1)
	{		Loc_SemStartState=xSemaphoreTake(EnabelSem,10);
    9624:	80 91 10 08 	lds	r24, 0x0810
    9628:	90 91 11 08 	lds	r25, 0x0811
    962c:	6a e0       	ldi	r22, 0x0A	; 10
    962e:	70 e0       	ldi	r23, 0x00	; 0
    9630:	0e 94 67 26 	call	0x4cce	; 0x4cce <xQueueSemaphoreTake>
    9634:	89 83       	std	Y+1, r24	; 0x01
	MDIO_Error_State_GetPinValue(PIN1,MDIO_PORTB,&ButtonState);
    9636:	9e 01       	movw	r18, r28
    9638:	2e 5f       	subi	r18, 0xFE	; 254
    963a:	3f 4f       	sbci	r19, 0xFF	; 255
    963c:	81 e0       	ldi	r24, 0x01	; 1
    963e:	61 e0       	ldi	r22, 0x01	; 1
    9640:	a9 01       	movw	r20, r18
    9642:	0e 94 2d 0b 	call	0x165a	; 0x165a <MDIO_Error_State_GetPinValue>

	if(ButtonState==0)
    9646:	8a 81       	ldd	r24, Y+2	; 0x02
    9648:	88 23       	and	r24, r24
    964a:	89 f4       	brne	.+34     	; 0x966e <APP_Enable_System+0x5a>
	{
		xSemaphoreGive(EnabelSem);
    964c:	80 91 10 08 	lds	r24, 0x0810
    9650:	90 91 11 08 	lds	r25, 0x0811
    9654:	60 e0       	ldi	r22, 0x00	; 0
    9656:	70 e0       	ldi	r23, 0x00	; 0
    9658:	40 e0       	ldi	r20, 0x00	; 0
    965a:	50 e0       	ldi	r21, 0x00	; 0
    965c:	20 e0       	ldi	r18, 0x00	; 0
    965e:	0e 94 63 24 	call	0x48c6	; 0x48c6 <xQueueGenericSend>
		StartFlag=1;
    9662:	81 e0       	ldi	r24, 0x01	; 1
    9664:	80 93 fe 07 	sts	0x07FE, r24
		StopFlag=0;
    9668:	10 92 ff 07 	sts	0x07FF, r1
    966c:	11 c0       	rjmp	.+34     	; 0x9690 <APP_Enable_System+0x7c>
	}
	else if(StartFlag==1)
    966e:	80 91 fe 07 	lds	r24, 0x07FE
    9672:	81 30       	cpi	r24, 0x01	; 1
    9674:	69 f4       	brne	.+26     	; 0x9690 <APP_Enable_System+0x7c>
	{
		xSemaphoreGive(EnabelSem);
    9676:	80 91 10 08 	lds	r24, 0x0810
    967a:	90 91 11 08 	lds	r25, 0x0811
    967e:	60 e0       	ldi	r22, 0x00	; 0
    9680:	70 e0       	ldi	r23, 0x00	; 0
    9682:	40 e0       	ldi	r20, 0x00	; 0
    9684:	50 e0       	ldi	r21, 0x00	; 0
    9686:	20 e0       	ldi	r18, 0x00	; 0
    9688:	0e 94 63 24 	call	0x48c6	; 0x48c6 <xQueueGenericSend>
		StopFlag=0;
    968c:	10 92 ff 07 	sts	0x07FF, r1
	}
	vTaskDelay(400);
    9690:	80 e9       	ldi	r24, 0x90	; 144
    9692:	91 e0       	ldi	r25, 0x01	; 1
    9694:	0e 94 2c 37 	call	0x6e58	; 0x6e58 <vTaskDelay>
    9698:	c5 cf       	rjmp	.-118    	; 0x9624 <APP_Enable_System+0x10>

0000969a <APP_ADXL>:
	}
}

void APP_ADXL(void *Pv){
    969a:	df 93       	push	r29
    969c:	cf 93       	push	r28
    969e:	cd b7       	in	r28, 0x3d	; 61
    96a0:	de b7       	in	r29, 0x3e	; 62
    96a2:	6b 97       	sbiw	r28, 0x1b	; 27
    96a4:	0f b6       	in	r0, 0x3f	; 63
    96a6:	f8 94       	cli
    96a8:	de bf       	out	0x3e, r29	; 62
    96aa:	0f be       	out	0x3f, r0	; 63
    96ac:	cd bf       	out	0x3d, r28	; 61
    96ae:	9b 8f       	std	Y+27, r25	; 0x1b
    96b0:	8a 8f       	std	Y+26, r24	; 0x1a
	u8 Loc_SemADXLState;
	float Frist_Read_Acc_Data[3]={0};
    96b2:	8c e0       	ldi	r24, 0x0C	; 12
    96b4:	fe 01       	movw	r30, r28
    96b6:	32 96       	adiw	r30, 0x02	; 2
    96b8:	df 01       	movw	r26, r30
    96ba:	98 2f       	mov	r25, r24
    96bc:	1d 92       	st	X+, r1
    96be:	9a 95       	dec	r25
    96c0:	e9 f7       	brne	.-6      	; 0x96bc <APP_ADXL+0x22>
	float Second_Read_Acc_Data[3]={0};
    96c2:	8c e0       	ldi	r24, 0x0C	; 12
    96c4:	fe 01       	movw	r30, r28
    96c6:	3e 96       	adiw	r30, 0x0e	; 14
    96c8:	df 01       	movw	r26, r30
    96ca:	98 2f       	mov	r25, r24
    96cc:	1d 92       	st	X+, r1
    96ce:	9a 95       	dec	r25
    96d0:	e9 f7       	brne	.-6      	; 0x96cc <APP_ADXL+0x32>

	ADXL_Acc(Frist_Read_Acc_Data);
    96d2:	ce 01       	movw	r24, r28
    96d4:	02 96       	adiw	r24, 0x02	; 2
    96d6:	0e 94 10 17 	call	0x2e20	; 0x2e20 <ADXL_Acc>

	while(1){
		Loc_SemADXLState=xSemaphoreTake(EnabelSem,10);
    96da:	80 91 10 08 	lds	r24, 0x0810
    96de:	90 91 11 08 	lds	r25, 0x0811
    96e2:	6a e0       	ldi	r22, 0x0A	; 10
    96e4:	70 e0       	ldi	r23, 0x00	; 0
    96e6:	0e 94 67 26 	call	0x4cce	; 0x4cce <xQueueSemaphoreTake>
    96ea:	89 83       	std	Y+1, r24	; 0x01
		if(Loc_SemADXLState==pdPASS){
    96ec:	89 81       	ldd	r24, Y+1	; 0x01
    96ee:	81 30       	cpi	r24, 0x01	; 1
    96f0:	09 f0       	breq	.+2      	; 0x96f4 <APP_ADXL+0x5a>
    96f2:	41 c0       	rjmp	.+130    	; 0x9776 <APP_ADXL+0xdc>
			xSemaphoreTake(FlagAlarmSem,10);
    96f4:	80 91 04 08 	lds	r24, 0x0804
    96f8:	90 91 05 08 	lds	r25, 0x0805
    96fc:	6a e0       	ldi	r22, 0x0A	; 10
    96fe:	70 e0       	ldi	r23, 0x00	; 0
    9700:	0e 94 67 26 	call	0x4cce	; 0x4cce <xQueueSemaphoreTake>
			//Check Data from Sensor
			ADXL_Acc(Second_Read_Acc_Data);
    9704:	ce 01       	movw	r24, r28
    9706:	0e 96       	adiw	r24, 0x0e	; 14
    9708:	0e 94 10 17 	call	0x2e20	; 0x2e20 <ADXL_Acc>
			if(Frist_Read_Acc_Data[0]!=Second_Read_Acc_Data[0]
    970c:	8a 81       	ldd	r24, Y+2	; 0x02
    970e:	9b 81       	ldd	r25, Y+3	; 0x03
    9710:	ac 81       	ldd	r26, Y+4	; 0x04
    9712:	bd 81       	ldd	r27, Y+5	; 0x05
    9714:	2e 85       	ldd	r18, Y+14	; 0x0e
    9716:	3f 85       	ldd	r19, Y+15	; 0x0f
    9718:	48 89       	ldd	r20, Y+16	; 0x10
    971a:	59 89       	ldd	r21, Y+17	; 0x11
    971c:	bc 01       	movw	r22, r24
    971e:	cd 01       	movw	r24, r26
    9720:	0e 94 c5 03 	call	0x78a	; 0x78a <__nesf2>
    9724:	88 23       	and	r24, r24
    9726:	e1 f4       	brne	.+56     	; 0x9760 <APP_ADXL+0xc6>
    9728:	8e 81       	ldd	r24, Y+6	; 0x06
    972a:	9f 81       	ldd	r25, Y+7	; 0x07
    972c:	a8 85       	ldd	r26, Y+8	; 0x08
    972e:	b9 85       	ldd	r27, Y+9	; 0x09
    9730:	2a 89       	ldd	r18, Y+18	; 0x12
    9732:	3b 89       	ldd	r19, Y+19	; 0x13
    9734:	4c 89       	ldd	r20, Y+20	; 0x14
    9736:	5d 89       	ldd	r21, Y+21	; 0x15
    9738:	bc 01       	movw	r22, r24
    973a:	cd 01       	movw	r24, r26
    973c:	0e 94 c5 03 	call	0x78a	; 0x78a <__nesf2>
    9740:	88 23       	and	r24, r24
    9742:	71 f4       	brne	.+28     	; 0x9760 <APP_ADXL+0xc6>
    9744:	8a 85       	ldd	r24, Y+10	; 0x0a
    9746:	9b 85       	ldd	r25, Y+11	; 0x0b
    9748:	ac 85       	ldd	r26, Y+12	; 0x0c
    974a:	bd 85       	ldd	r27, Y+13	; 0x0d
    974c:	2e 89       	ldd	r18, Y+22	; 0x16
    974e:	3f 89       	ldd	r19, Y+23	; 0x17
    9750:	48 8d       	ldd	r20, Y+24	; 0x18
    9752:	59 8d       	ldd	r21, Y+25	; 0x19
    9754:	bc 01       	movw	r22, r24
    9756:	cd 01       	movw	r24, r26
    9758:	0e 94 c5 03 	call	0x78a	; 0x78a <__nesf2>
    975c:	88 23       	and	r24, r24
    975e:	59 f0       	breq	.+22     	; 0x9776 <APP_ADXL+0xdc>
				|| Frist_Read_Acc_Data[1]!=Second_Read_Acc_Data[1]
				|| Frist_Read_Acc_Data[2]!=Second_Read_Acc_Data[2])
			{

				xSemaphoreGive(FlagAlarmSem);
    9760:	80 91 04 08 	lds	r24, 0x0804
    9764:	90 91 05 08 	lds	r25, 0x0805
    9768:	60 e0       	ldi	r22, 0x00	; 0
    976a:	70 e0       	ldi	r23, 0x00	; 0
    976c:	40 e0       	ldi	r20, 0x00	; 0
    976e:	50 e0       	ldi	r21, 0x00	; 0
    9770:	20 e0       	ldi	r18, 0x00	; 0
    9772:	0e 94 63 24 	call	0x48c6	; 0x48c6 <xQueueGenericSend>

		}
		else{
			/*Do Nothing*/
		}
		vTaskDelay(1000);
    9776:	88 ee       	ldi	r24, 0xE8	; 232
    9778:	93 e0       	ldi	r25, 0x03	; 3
    977a:	0e 94 2c 37 	call	0x6e58	; 0x6e58 <vTaskDelay>
    977e:	ad cf       	rjmp	.-166    	; 0x96da <APP_ADXL+0x40>

00009780 <APP_Alarm>:

}



void APP_Alarm(void *Pv){
    9780:	df 93       	push	r29
    9782:	cf 93       	push	r28
    9784:	00 d0       	rcall	.+0      	; 0x9786 <APP_Alarm+0x6>
    9786:	0f 92       	push	r0
    9788:	cd b7       	in	r28, 0x3d	; 61
    978a:	de b7       	in	r29, 0x3e	; 62
    978c:	9b 83       	std	Y+3, r25	; 0x03
    978e:	8a 83       	std	Y+2, r24	; 0x02
	u8 Loc_SemUARTSendState;

	while(1){
		Loc_SemUARTSendState=xSemaphoreTake(FlagAlarmSem,10);
    9790:	80 91 04 08 	lds	r24, 0x0804
    9794:	90 91 05 08 	lds	r25, 0x0805
    9798:	6a e0       	ldi	r22, 0x0A	; 10
    979a:	70 e0       	ldi	r23, 0x00	; 0
    979c:	0e 94 67 26 	call	0x4cce	; 0x4cce <xQueueSemaphoreTake>
    97a0:	89 83       	std	Y+1, r24	; 0x01
		if(Loc_SemUARTSendState==pdPASS){
    97a2:	89 81       	ldd	r24, Y+1	; 0x01
    97a4:	81 30       	cpi	r24, 0x01	; 1
    97a6:	49 f4       	brne	.+18     	; 0x97ba <APP_Alarm+0x3a>

			/*Enable Buzzer*/
			MDIO_Error_State_SetPinValue(PIN0,MDIO_PORTB,PIN_HIGH);
    97a8:	80 e0       	ldi	r24, 0x00	; 0
    97aa:	61 e0       	ldi	r22, 0x01	; 1
    97ac:	41 e0       	ldi	r20, 0x01	; 1
    97ae:	0e 94 e2 09 	call	0x13c4	; 0x13c4 <MDIO_Error_State_SetPinValue>

			/*Send Alarm on UART*/
			MUSART_VidSendString("Warning..!!!");
    97b2:	80 e7       	ldi	r24, 0x70	; 112
    97b4:	90 e0       	ldi	r25, 0x00	; 0
    97b6:	0e 94 91 07 	call	0xf22	; 0xf22 <MUSART_VidSendString>

		}
		else{
			/*Do Nothing*/
		}
		vTaskDelay(1000);
    97ba:	88 ee       	ldi	r24, 0xE8	; 232
    97bc:	93 e0       	ldi	r25, 0x03	; 3
    97be:	0e 94 2c 37 	call	0x6e58	; 0x6e58 <vTaskDelay>
    97c2:	e6 cf       	rjmp	.-52     	; 0x9790 <APP_Alarm+0x10>

000097c4 <APP_Disable_System>:
	}

}


void APP_Disable_System(void *Pv){
    97c4:	df 93       	push	r29
    97c6:	cf 93       	push	r28
    97c8:	00 d0       	rcall	.+0      	; 0x97ca <APP_Disable_System+0x6>
    97ca:	cd b7       	in	r28, 0x3d	; 61
    97cc:	de b7       	in	r29, 0x3e	; 62
    97ce:	9a 83       	std	Y+2, r25	; 0x02
    97d0:	89 83       	std	Y+1, r24	; 0x01

	while(1){

		if((StopFlag==1)&&(StartFlag==1))
    97d2:	80 91 ff 07 	lds	r24, 0x07FF
    97d6:	81 30       	cpi	r24, 0x01	; 1
    97d8:	09 f5       	brne	.+66     	; 0x981c <APP_Disable_System+0x58>
    97da:	80 91 fe 07 	lds	r24, 0x07FE
    97de:	81 30       	cpi	r24, 0x01	; 1
    97e0:	e9 f4       	brne	.+58     	; 0x981c <APP_Disable_System+0x58>
		{
			/*Disable Buzzer*/
			MDIO_Error_State_SetPinValue(PIN0,MDIO_PORTB,PIN_LOW);
    97e2:	80 e0       	ldi	r24, 0x00	; 0
    97e4:	61 e0       	ldi	r22, 0x01	; 1
    97e6:	40 e0       	ldi	r20, 0x00	; 0
    97e8:	0e 94 e2 09 	call	0x13c4	; 0x13c4 <MDIO_Error_State_SetPinValue>

			xSemaphoreGive(EnabelSem);
    97ec:	80 91 10 08 	lds	r24, 0x0810
    97f0:	90 91 11 08 	lds	r25, 0x0811
    97f4:	60 e0       	ldi	r22, 0x00	; 0
    97f6:	70 e0       	ldi	r23, 0x00	; 0
    97f8:	40 e0       	ldi	r20, 0x00	; 0
    97fa:	50 e0       	ldi	r21, 0x00	; 0
    97fc:	20 e0       	ldi	r18, 0x00	; 0
    97fe:	0e 94 63 24 	call	0x48c6	; 0x48c6 <xQueueGenericSend>
			xSemaphoreGive(FlagAlarmSem);
    9802:	80 91 04 08 	lds	r24, 0x0804
    9806:	90 91 05 08 	lds	r25, 0x0805
    980a:	60 e0       	ldi	r22, 0x00	; 0
    980c:	70 e0       	ldi	r23, 0x00	; 0
    980e:	40 e0       	ldi	r20, 0x00	; 0
    9810:	50 e0       	ldi	r21, 0x00	; 0
    9812:	20 e0       	ldi	r18, 0x00	; 0
    9814:	0e 94 63 24 	call	0x48c6	; 0x48c6 <xQueueGenericSend>

			StartFlag=0;
    9818:	10 92 fe 07 	sts	0x07FE, r1

		}
		else{
			/*Do Nothing*/
		}
		vTaskDelay(1000);
    981c:	88 ee       	ldi	r24, 0xE8	; 232
    981e:	93 e0       	ldi	r25, 0x03	; 3
    9820:	0e 94 2c 37 	call	0x6e58	; 0x6e58 <vTaskDelay>
    9824:	d6 cf       	rjmp	.-84     	; 0x97d2 <APP_Disable_System+0xe>

00009826 <__udivmodhi4>:
    9826:	aa 1b       	sub	r26, r26
    9828:	bb 1b       	sub	r27, r27
    982a:	51 e1       	ldi	r21, 0x11	; 17
    982c:	07 c0       	rjmp	.+14     	; 0x983c <__udivmodhi4_ep>

0000982e <__udivmodhi4_loop>:
    982e:	aa 1f       	adc	r26, r26
    9830:	bb 1f       	adc	r27, r27
    9832:	a6 17       	cp	r26, r22
    9834:	b7 07       	cpc	r27, r23
    9836:	10 f0       	brcs	.+4      	; 0x983c <__udivmodhi4_ep>
    9838:	a6 1b       	sub	r26, r22
    983a:	b7 0b       	sbc	r27, r23

0000983c <__udivmodhi4_ep>:
    983c:	88 1f       	adc	r24, r24
    983e:	99 1f       	adc	r25, r25
    9840:	5a 95       	dec	r21
    9842:	a9 f7       	brne	.-22     	; 0x982e <__udivmodhi4_loop>
    9844:	80 95       	com	r24
    9846:	90 95       	com	r25
    9848:	bc 01       	movw	r22, r24
    984a:	cd 01       	movw	r24, r26
    984c:	08 95       	ret

0000984e <__udivmodsi4>:
    984e:	a1 e2       	ldi	r26, 0x21	; 33
    9850:	1a 2e       	mov	r1, r26
    9852:	aa 1b       	sub	r26, r26
    9854:	bb 1b       	sub	r27, r27
    9856:	fd 01       	movw	r30, r26
    9858:	0d c0       	rjmp	.+26     	; 0x9874 <__udivmodsi4_ep>

0000985a <__udivmodsi4_loop>:
    985a:	aa 1f       	adc	r26, r26
    985c:	bb 1f       	adc	r27, r27
    985e:	ee 1f       	adc	r30, r30
    9860:	ff 1f       	adc	r31, r31
    9862:	a2 17       	cp	r26, r18
    9864:	b3 07       	cpc	r27, r19
    9866:	e4 07       	cpc	r30, r20
    9868:	f5 07       	cpc	r31, r21
    986a:	20 f0       	brcs	.+8      	; 0x9874 <__udivmodsi4_ep>
    986c:	a2 1b       	sub	r26, r18
    986e:	b3 0b       	sbc	r27, r19
    9870:	e4 0b       	sbc	r30, r20
    9872:	f5 0b       	sbc	r31, r21

00009874 <__udivmodsi4_ep>:
    9874:	66 1f       	adc	r22, r22
    9876:	77 1f       	adc	r23, r23
    9878:	88 1f       	adc	r24, r24
    987a:	99 1f       	adc	r25, r25
    987c:	1a 94       	dec	r1
    987e:	69 f7       	brne	.-38     	; 0x985a <__udivmodsi4_loop>
    9880:	60 95       	com	r22
    9882:	70 95       	com	r23
    9884:	80 95       	com	r24
    9886:	90 95       	com	r25
    9888:	9b 01       	movw	r18, r22
    988a:	ac 01       	movw	r20, r24
    988c:	bd 01       	movw	r22, r26
    988e:	cf 01       	movw	r24, r30
    9890:	08 95       	ret

00009892 <__prologue_saves__>:
    9892:	2f 92       	push	r2
    9894:	3f 92       	push	r3
    9896:	4f 92       	push	r4
    9898:	5f 92       	push	r5
    989a:	6f 92       	push	r6
    989c:	7f 92       	push	r7
    989e:	8f 92       	push	r8
    98a0:	9f 92       	push	r9
    98a2:	af 92       	push	r10
    98a4:	bf 92       	push	r11
    98a6:	cf 92       	push	r12
    98a8:	df 92       	push	r13
    98aa:	ef 92       	push	r14
    98ac:	ff 92       	push	r15
    98ae:	0f 93       	push	r16
    98b0:	1f 93       	push	r17
    98b2:	cf 93       	push	r28
    98b4:	df 93       	push	r29
    98b6:	cd b7       	in	r28, 0x3d	; 61
    98b8:	de b7       	in	r29, 0x3e	; 62
    98ba:	ca 1b       	sub	r28, r26
    98bc:	db 0b       	sbc	r29, r27
    98be:	0f b6       	in	r0, 0x3f	; 63
    98c0:	f8 94       	cli
    98c2:	de bf       	out	0x3e, r29	; 62
    98c4:	0f be       	out	0x3f, r0	; 63
    98c6:	cd bf       	out	0x3d, r28	; 61
    98c8:	09 94       	ijmp

000098ca <__epilogue_restores__>:
    98ca:	2a 88       	ldd	r2, Y+18	; 0x12
    98cc:	39 88       	ldd	r3, Y+17	; 0x11
    98ce:	48 88       	ldd	r4, Y+16	; 0x10
    98d0:	5f 84       	ldd	r5, Y+15	; 0x0f
    98d2:	6e 84       	ldd	r6, Y+14	; 0x0e
    98d4:	7d 84       	ldd	r7, Y+13	; 0x0d
    98d6:	8c 84       	ldd	r8, Y+12	; 0x0c
    98d8:	9b 84       	ldd	r9, Y+11	; 0x0b
    98da:	aa 84       	ldd	r10, Y+10	; 0x0a
    98dc:	b9 84       	ldd	r11, Y+9	; 0x09
    98de:	c8 84       	ldd	r12, Y+8	; 0x08
    98e0:	df 80       	ldd	r13, Y+7	; 0x07
    98e2:	ee 80       	ldd	r14, Y+6	; 0x06
    98e4:	fd 80       	ldd	r15, Y+5	; 0x05
    98e6:	0c 81       	ldd	r16, Y+4	; 0x04
    98e8:	1b 81       	ldd	r17, Y+3	; 0x03
    98ea:	aa 81       	ldd	r26, Y+2	; 0x02
    98ec:	b9 81       	ldd	r27, Y+1	; 0x01
    98ee:	ce 0f       	add	r28, r30
    98f0:	d1 1d       	adc	r29, r1
    98f2:	0f b6       	in	r0, 0x3f	; 63
    98f4:	f8 94       	cli
    98f6:	de bf       	out	0x3e, r29	; 62
    98f8:	0f be       	out	0x3f, r0	; 63
    98fa:	cd bf       	out	0x3d, r28	; 61
    98fc:	ed 01       	movw	r28, r26
    98fe:	08 95       	ret

00009900 <memcpy>:
    9900:	fb 01       	movw	r30, r22
    9902:	dc 01       	movw	r26, r24
    9904:	02 c0       	rjmp	.+4      	; 0x990a <memcpy+0xa>
    9906:	01 90       	ld	r0, Z+
    9908:	0d 92       	st	X+, r0
    990a:	41 50       	subi	r20, 0x01	; 1
    990c:	50 40       	sbci	r21, 0x00	; 0
    990e:	d8 f7       	brcc	.-10     	; 0x9906 <memcpy+0x6>
    9910:	08 95       	ret

00009912 <memset>:
    9912:	dc 01       	movw	r26, r24
    9914:	01 c0       	rjmp	.+2      	; 0x9918 <memset+0x6>
    9916:	6d 93       	st	X+, r22
    9918:	41 50       	subi	r20, 0x01	; 1
    991a:	50 40       	sbci	r21, 0x00	; 0
    991c:	e0 f7       	brcc	.-8      	; 0x9916 <memset+0x4>
    991e:	08 95       	ret

00009920 <_exit>:
    9920:	f8 94       	cli

00009922 <__stop_program>:
    9922:	ff cf       	rjmp	.-2      	; 0x9922 <__stop_program>
